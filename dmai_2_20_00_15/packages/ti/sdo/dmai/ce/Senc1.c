/* --COPYRIGHT--,BSD
 * Copyright (c) 2010, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * --/COPYRIGHT--*/

#include <stdio.h>
#include <stdlib.h>

#include <xdc/std.h>
#include <ti/sdo/ce/Engine.h>
#include <ti/sdo/ce/speech1/sphenc1.h>
#include <ti/xdais/dm/ispeech1_pcm.h>

#include <ti/sdo/dmai/Dmai.h>
#include <ti/sdo/dmai/Buffer.h>
#include <ti/sdo/dmai/ce/Senc1.h>

#define MODULE_NAME     "Senc1"

typedef struct Senc1_Object {
    SPHENC1_Handle      hEncode;
    Int32               minInBufSize;
    Int32               minOutBufSize;
} Senc1_Object;

const SPHENC1_Params Senc1_Params_DEFAULT = {
    sizeof(SPHENC1_Params),
    160, 
    ISPEECH1_PCM_COMPAND_ALAW, 
    0,
    0,
    0,
    0,
    0,
    NULL,
};

const SPHENC1_DynamicParams Senc1_DynamicParams_DEFAULT = {
    sizeof(SPHENC1_DynamicParams),
    0,
    0,
    0,
    ISPEECH1_VADFLAG_DEFAULT,
    0,
    0,
    0,
    0,
    0,
};

/******************************************************************************
 * Senc1_process
 ******************************************************************************/
Int Senc1_process(Senc1_Handle hSe1, Buffer_Handle hInBuf, Buffer_Handle hOutBuf)
{
    XDM1_SingleBufDesc      inBufDesc;
    XDM1_SingleBufDesc      outBufDesc;
    SPHENC1_InArgs          inArgs;
    SPHENC1_OutArgs         outArgs;
    XDAS_Int32              status;
    XDAS_Int8              *inPtr;
    XDAS_Int8              *outPtr;

    assert(hSe1);
    assert(hInBuf);
    assert(hOutBuf);
    assert(Buffer_getUserPtr(hInBuf));
    assert(Buffer_getUserPtr(hOutBuf));
    assert(Buffer_getNumBytesUsed(hInBuf));
    assert(Buffer_getSize(hOutBuf));

    inPtr = Buffer_getUserPtr(hInBuf);
    outPtr = Buffer_getUserPtr(hOutBuf);

    inBufDesc.buf           = inPtr;
    inBufDesc.bufSize       = Buffer_getNumBytesUsed(hInBuf);

    outBufDesc.buf          = outPtr;
    outBufDesc.bufSize      = Buffer_getSize(hOutBuf);

    inArgs.size             = sizeof(SPHENC1_InArgs);
    outArgs.size            = sizeof(SPHENC1_OutArgs);

    /* We never use the inArgs.data fields, so initialize them to NULL. */
    inArgs.data.buf = (XDAS_Int8 *) NULL;
    inArgs.data.bufSize = 0L;

    /* Encode the speech buffer */
    status = SPHENC1_process(hSe1->hEncode, &inBufDesc, &outBufDesc, &inArgs,
                            &outArgs);

    Dmai_dbg1("SPHENC1_process() ret %d \n", status);

    if (status != SPHENC1_EOK) {
        Dmai_err2("SPHENC1_process() failed with error (%d ext: 0x%x)\n",
                  (Int)status, (Uns)outArgs.extendedError);
        return Dmai_EFAIL;
    }

    /* Encoded Bytes Generated: assume output buffer was filled  */

    /* IMPORTANT NOTE:                                           */
    /* This implementation assumes that for every frame the      */
    /* number of bytes generated by the encoder is EQUAL to the  */
    /* size of the output buffer requested by the codec.         */
    Buffer_setNumBytesUsed(hOutBuf, Senc1_getOutBufSize(hSe1));

    return Dmai_EOK;
}

/******************************************************************************
 * Senc1_create
 ******************************************************************************/
Senc1_Handle Senc1_create(Engine_Handle hEngine, Char *codecName,
                        SPHENC1_Params *params, SPHENC1_DynamicParams *dynParams)
{
    Senc1_Handle        hSe1;
    SPHENC1_Status      encStatus;
    XDAS_Int32          status;
    SPHENC1_Handle      hEncode;

    if (hEngine == NULL || codecName == NULL ||
        params == NULL || dynParams == NULL) {
        Dmai_err0("Cannot pass null for engine, codec name, params or "
                  "dynamic params\n");
        return NULL;
    }

    hSe1 = (Senc1_Handle)calloc(1, sizeof(Senc1_Object));

    if (hSe1 == NULL) {
        Dmai_err0("Failed to allocate space for Senc1 Object\n");
        return NULL;
    }

    /* Create speech encoder */
    hEncode = SPHENC1_create(hEngine, codecName, params);

    if (hEncode == NULL) {
        Dmai_err0("Can't open speech encode algorithm\n");
        return NULL;
    }

    Dmai_dbg0("Setting dynParams \n");

    /* Set dynamic parameters */
    encStatus.size = sizeof(SPHENC1_Status);
    encStatus.data.buf = NULL;
    status = SPHENC1_control(hEncode, XDM_SETPARAMS, dynParams, &encStatus);

    if (status != SPHENC1_EOK) {
        Dmai_err1("XDM_SETPARAMS failed, status=%d\n", status);
        SPHENC1_delete(hEncode);
        free(hSe1);
        return NULL;
    }

    Dmai_dbg0("Made XDM_SETPARAMS control call\n");

    /* Get buffer requirements */
    status = SPHENC1_control(hEncode, XDM_GETBUFINFO, dynParams, &encStatus);

    if (status != SPHENC1_EOK) {
        Dmai_err1("XDM_GETBUFINFO failed, status=%d\n", status);
        SPHENC1_delete(hEncode);
        free(hSe1);
        return NULL;
    }

    hSe1->minInBufSize = encStatus.bufInfo.minInBufSize[0];
    hSe1->minOutBufSize = encStatus.bufInfo.minOutBufSize[0];

    Dmai_dbg2("Speech encoder requires min buffer sizes in %u and out %u\n",
              (Uns) encStatus.bufInfo.minInBufSize[0],
              (Uns) encStatus.bufInfo.minOutBufSize[0]);

    hSe1->hEncode = hEncode;

    return hSe1;
}

/******************************************************************************
 * Senc1_delete
 ******************************************************************************/
Int Senc1_delete(Senc1_Handle hSe1)
{
    if (hSe1) {
        if (hSe1->hEncode) {
            SPHENC1_delete(hSe1->hEncode);
        }
        free(hSe1);
    }

    return Dmai_EOK;
}

/******************************************************************************
 * Senc1_getVisaHandle
 ******************************************************************************/
SPHENC1_Handle Senc1_getVisaHandle(Senc1_Handle hSe1)
{
    assert(hSe1);

    return hSe1->hEncode;
}

/******************************************************************************
 * Senc1_getInBufSize
 ******************************************************************************/
Int32 Senc1_getInBufSize(Senc1_Handle hSe1)
{
    assert(hSe1);

    return hSe1->minInBufSize;
}

/******************************************************************************
 * Senc1_getOutBufSize
 ******************************************************************************/
Int32 Senc1_getOutBufSize(Senc1_Handle hSe1)
{
    assert(hSe1);

    return hSe1->minOutBufSize;
}
