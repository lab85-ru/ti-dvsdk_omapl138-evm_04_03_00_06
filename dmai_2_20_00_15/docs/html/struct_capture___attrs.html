<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Davinci Multimedia Application Interface (DMAI): Capture_Attrs Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Capture_Attrs Struct Reference<br/>
<small>
[<a class="el" href="group__ti__sdo__dmai___capture.html">Capture</a>]</small>
</h1><!-- doxytag: class="Capture_Attrs" -->
<p>Attributes used to create a Capture device driver instance.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_capture_8h_source.html">Capture.h</a>&gt;</code></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_capture___attrs.html#a1a90830ea3624512ddf062106b71476a">numBufs</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of buffers the driver is to use, either allocated from the device driver or the supplied <a class="el" href="group__ti__sdo__dmai___buf_tab.html#ga2200af650b24d3ef473a4016c89dccfc" title="Handle through which to reference a BufTab.">BufTab_Handle</a>.  <a href="#a1a90830ea3624512ddf062106b71476a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ti__sdo__dmai___capture.html#ga0396f0332ca661d1894cc2b68a514114">Capture_Input</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_capture___attrs.html#a86073ec71e2dd56b968c7216a0e5e270">videoInput</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Which video input to use.  <a href="#a86073ec71e2dd56b968c7216a0e5e270"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_capture___attrs.html#a71a5350fa3a9f11068f3e789283683e7">cropWidth</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Width of image to crop (if supported by H/W, otherwise ignored). If set to a negative value, no cropping will be used. This value needs to be even.  <a href="#a71a5350fa3a9f11068f3e789283683e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_capture___attrs.html#a5a7131c20f4f455ef0ff8203c5b9bbef">cropHeight</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Height of image to crop (if supported by H/W, otherwise ignored). If set to a negative value, no cropping will be used.  <a href="#a5a7131c20f4f455ef0ff8203c5b9bbef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_capture___attrs.html#a0038333e84fdd6769219b427687b46ae">cropX</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">X pos of image to crop (if supported by H/W, otherwise ignored). If set to a negative value, no cropping will be used.  <a href="#a0038333e84fdd6769219b427687b46ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_capture___attrs.html#a5e5bda0aeda14a5e9b26774ed9117c98">cropY</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Y pos of image to crop (if supported by H/W, otherwise ignored). If set to a negative value, no cropping will be used.  <a href="#a5e5bda0aeda14a5e9b26774ed9117c98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_capture___attrs.html#a261c339bfa8f67e761ff171fbcae2d34">captureDevice</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Name of the Linux v4l2 capture device to use.  <a href="#a261c339bfa8f67e761ff171fbcae2d34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_capture___attrs.html#a536ef60eb3eeb0c059b2da54127d0fa8">smoothPad</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When using the dm6446 resizer to <a class="el" href="group__ti__sdo__dmai___smooth.html">Smooth</a> the captured images, 2 extra rows at the top and 4 extra rows at the bottom needs to be captured (if possible).  <a href="#a536ef60eb3eeb0c059b2da54127d0fa8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ti__sdo__dmai___video_std.html#ga516f1c2c17e3cf9bef416a6bbb8a9289">VideoStd_Type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_capture___attrs.html#a75b44be66cfe05345a9aca3bfc4d076d">videoStd</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To force a certain video standard without auto detection, set this variable to something other than <a class="el" href="group__ti__sdo__dmai___video_std.html#gga516f1c2c17e3cf9bef416a6bbb8a9289a67c7473e7783791683178476d20a24c4">VideoStd_AUTO</a>.  <a href="#a75b44be66cfe05345a9aca3bfc4d076d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_capture___attrs.html#a4eb86cd8b67b2ba4394e99e2f84109de">decoderIdx</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To force a certain decoder on dm6467 instead of auto detecting which decoder supports your <a class="el" href="struct_capture___attrs.html#a86073ec71e2dd56b968c7216a0e5e270" title="Which video input to use.">Capture_Attrs.videoInput</a>, set this to a value &gt; -1. See the VPIF device driver guide on which values apply (VIDIOC_S_STD ioctl). This is useful when auto detection doesn't work, e.g. when two EVM:s are interconnected.  <a href="#a4eb86cd8b67b2ba4394e99e2f84109de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ti__sdo__dmai___color_space.html#ga1b6da3f159b6052d404f11cb010cb398">ColorSpace_Type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_capture___attrs.html#a8889c59f3590235ca8a83c909d2fab8c">colorSpace</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output color format.  <a href="#a8889c59f3590235ca8a83c909d2fab8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_buffer_gfx___dimensions.html">BufferGfx_Dimensions</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_capture___attrs.html#abca75df189e0cdc448c9f89bd02aa74b">captureDimension</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Capture image size.  <a href="#abca75df189e0cdc448c9f89bd02aa74b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_capture___attrs.html#a78b419cc9d5e519b3c2c63af7a79ca14">onTheFly</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the resizer/previewer to "on the fly mode". In this mode the capture device is chained with previewer/resizer to resize and do chroma conversion on the fly.  <a href="#a78b419cc9d5e519b3c2c63af7a79ca14"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Attributes used to create a Capture device driver instance. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__ti__sdo__dmai___capture.html#ga01c49208bc265dec1ae0f725daf7f942" title="Default attributes for video window 0 on dm6446 and dm355.">Capture_Attrs_DM6446_DM355_DEFAULT</a> </dd>
<dd>
<a class="el" href="group__ti__sdo__dmai___capture.html#gaf5d360bc4f62956c39535cba641f83a0" title="Default attributes for video window 0 on dm6467.">Capture_Attrs_DM6467_DEFAULT</a> </dd></dl>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="a1a90830ea3624512ddf062106b71476a"></a><!-- doxytag: member="Capture_Attrs::numBufs" ref="a1a90830ea3624512ddf062106b71476a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int <a class="el" href="struct_capture___attrs.html#a1a90830ea3624512ddf062106b71476a">Capture_Attrs::numBufs</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of buffers the driver is to use, either allocated from the device driver or the supplied <a class="el" href="group__ti__sdo__dmai___buf_tab.html#ga2200af650b24d3ef473a4016c89dccfc" title="Handle through which to reference a BufTab.">BufTab_Handle</a>. </p>

</div>
</div>
<a class="anchor" id="a86073ec71e2dd56b968c7216a0e5e270"></a><!-- doxytag: member="Capture_Attrs::videoInput" ref="a86073ec71e2dd56b968c7216a0e5e270" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ti__sdo__dmai___capture.html#ga0396f0332ca661d1894cc2b68a514114">Capture_Input</a> <a class="el" href="struct_capture___attrs.html#a86073ec71e2dd56b968c7216a0e5e270">Capture_Attrs::videoInput</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Which video input to use. </p>

</div>
</div>
<a class="anchor" id="a71a5350fa3a9f11068f3e789283683e7"></a><!-- doxytag: member="Capture_Attrs::cropWidth" ref="a71a5350fa3a9f11068f3e789283683e7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int32 <a class="el" href="struct_capture___attrs.html#a71a5350fa3a9f11068f3e789283683e7">Capture_Attrs::cropWidth</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Width of image to crop (if supported by H/W, otherwise ignored). If set to a negative value, no cropping will be used. This value needs to be even. </p>

</div>
</div>
<a class="anchor" id="a5a7131c20f4f455ef0ff8203c5b9bbef"></a><!-- doxytag: member="Capture_Attrs::cropHeight" ref="a5a7131c20f4f455ef0ff8203c5b9bbef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int32 <a class="el" href="struct_capture___attrs.html#a5a7131c20f4f455ef0ff8203c5b9bbef">Capture_Attrs::cropHeight</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Height of image to crop (if supported by H/W, otherwise ignored). If set to a negative value, no cropping will be used. </p>

</div>
</div>
<a class="anchor" id="a0038333e84fdd6769219b427687b46ae"></a><!-- doxytag: member="Capture_Attrs::cropX" ref="a0038333e84fdd6769219b427687b46ae" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int32 <a class="el" href="struct_capture___attrs.html#a0038333e84fdd6769219b427687b46ae">Capture_Attrs::cropX</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>X pos of image to crop (if supported by H/W, otherwise ignored). If set to a negative value, no cropping will be used. </p>

</div>
</div>
<a class="anchor" id="a5e5bda0aeda14a5e9b26774ed9117c98"></a><!-- doxytag: member="Capture_Attrs::cropY" ref="a5e5bda0aeda14a5e9b26774ed9117c98" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int32 <a class="el" href="struct_capture___attrs.html#a5e5bda0aeda14a5e9b26774ed9117c98">Capture_Attrs::cropY</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Y pos of image to crop (if supported by H/W, otherwise ignored). If set to a negative value, no cropping will be used. </p>

</div>
</div>
<a class="anchor" id="a261c339bfa8f67e761ff171fbcae2d34"></a><!-- doxytag: member="Capture_Attrs::captureDevice" ref="a261c339bfa8f67e761ff171fbcae2d34" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Char* <a class="el" href="struct_capture___attrs.html#a261c339bfa8f67e761ff171fbcae2d34">Capture_Attrs::captureDevice</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Name of the Linux v4l2 capture device to use. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Only applicable on Linux. </dd></dl>

</div>
</div>
<a class="anchor" id="a536ef60eb3eeb0c059b2da54127d0fa8"></a><!-- doxytag: member="Capture_Attrs::smoothPad" ref="a536ef60eb3eeb0c059b2da54127d0fa8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool <a class="el" href="struct_capture___attrs.html#a536ef60eb3eeb0c059b2da54127d0fa8">Capture_Attrs::smoothPad</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When using the dm6446 resizer to <a class="el" href="group__ti__sdo__dmai___smooth.html">Smooth</a> the captured images, 2 extra rows at the top and 4 extra rows at the bottom needs to be captured (if possible). </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Only applicable for dm6446 / dm357 Linux. </dd></dl>

</div>
</div>
<a class="anchor" id="a75b44be66cfe05345a9aca3bfc4d076d"></a><!-- doxytag: member="Capture_Attrs::videoStd" ref="a75b44be66cfe05345a9aca3bfc4d076d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ti__sdo__dmai___video_std.html#ga516f1c2c17e3cf9bef416a6bbb8a9289">VideoStd_Type</a> <a class="el" href="struct_capture___attrs.html#a75b44be66cfe05345a9aca3bfc4d076d">Capture_Attrs::videoStd</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>To force a certain video standard without auto detection, set this variable to something other than <a class="el" href="group__ti__sdo__dmai___video_std.html#gga516f1c2c17e3cf9bef416a6bbb8a9289a67c7473e7783791683178476d20a24c4">VideoStd_AUTO</a>. </p>

</div>
</div>
<a class="anchor" id="a4eb86cd8b67b2ba4394e99e2f84109de"></a><!-- doxytag: member="Capture_Attrs::decoderIdx" ref="a4eb86cd8b67b2ba4394e99e2f84109de" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int <a class="el" href="struct_capture___attrs.html#a4eb86cd8b67b2ba4394e99e2f84109de">Capture_Attrs::decoderIdx</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>To force a certain decoder on dm6467 instead of auto detecting which decoder supports your <a class="el" href="struct_capture___attrs.html#a86073ec71e2dd56b968c7216a0e5e270" title="Which video input to use.">Capture_Attrs.videoInput</a>, set this to a value &gt; -1. See the VPIF device driver guide on which values apply (VIDIOC_S_STD ioctl). This is useful when auto detection doesn't work, e.g. when two EVM:s are interconnected. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The detected <a class="el" href="group__ti__sdo__dmai___capture.html#ga0396f0332ca661d1894cc2b68a514114" title="Video capture inputs.">Capture_Input</a> on the decoder still needs to correspond to the <a class="el" href="struct_capture___attrs.html#a86073ec71e2dd56b968c7216a0e5e270" title="Which video input to use.">Capture_Attrs.videoInput</a> set, or the function will fail. </dd>
<dd>
Only applicable for dm6467 Linux. </dd></dl>

</div>
</div>
<a class="anchor" id="a8889c59f3590235ca8a83c909d2fab8c"></a><!-- doxytag: member="Capture_Attrs::colorSpace" ref="a8889c59f3590235ca8a83c909d2fab8c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ti__sdo__dmai___color_space.html#ga1b6da3f159b6052d404f11cb010cb398">ColorSpace_Type</a> <a class="el" href="struct_capture___attrs.html#a8889c59f3590235ca8a83c909d2fab8c">Capture_Attrs::colorSpace</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output color format. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Only applicable for dm365 Linux. </dd></dl>

</div>
</div>
<a class="anchor" id="abca75df189e0cdc448c9f89bd02aa74b"></a><!-- doxytag: member="Capture_Attrs::captureDimension" ref="abca75df189e0cdc448c9f89bd02aa74b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_buffer_gfx___dimensions.html">BufferGfx_Dimensions</a>* <a class="el" href="struct_capture___attrs.html#abca75df189e0cdc448c9f89bd02aa74b">Capture_Attrs::captureDimension</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Capture image size. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Only height and width elements are used. </dd>
<dd>
Set it to NULL, if resolution needs to be auto detected. </dd>
<dd>
Only applicable for dm365 Linux. </dd></dl>

</div>
</div>
<a class="anchor" id="a78b419cc9d5e519b3c2c63af7a79ca14"></a><!-- doxytag: member="Capture_Attrs::onTheFly" ref="a78b419cc9d5e519b3c2c63af7a79ca14" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool <a class="el" href="struct_capture___attrs.html#a78b419cc9d5e519b3c2c63af7a79ca14">Capture_Attrs::onTheFly</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the resizer/previewer to "on the fly mode". In this mode the capture device is chained with previewer/resizer to resize and do chroma conversion on the fly. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Only applicable for dm365 Linux. </dd>
<dd>
If this flag is set for composite input, the captured frames will be de-interlaced automatically. </dd>
<dd>
If this flag is enabled the kernel command line parameter dm365_imp.oper_mode should be set to '1', otherwise '0'. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="_capture_8h_source.html">Capture.h</a></li>
</ul>
</div>
<hr size="1"><small>
Copyright  2011, Texas Instruments Incorporated</small>
</body>
</html>
