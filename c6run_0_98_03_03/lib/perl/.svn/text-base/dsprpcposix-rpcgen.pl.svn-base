#!/usr/bin/perl
#
#############################################################################
#                                                                           #
#   Copyright (C) 2010 Texas Instruments Incorporated                       #
#   Copyright (C) 2010 Yaman Umuroglu                                       #
#     http://www.ti.com/                                                    #
#                                                                           #
#############################################################################
#
#############################################################################
#                                                                           #
#  Redistribution and use in source and binary forms, with or without       #
#  modification, are permitted provided that the following conditions       #
#  are met:                                                                 #
#                                                                           #
#    Redistributions of source code must retain the above copyright         #
#    notice, this list of conditions and the following disclaimer.          #
#                                                                           #
#    Redistributions in binary form must reproduce the above copyright      #
#    notice, this list of conditions and the following disclaimer in the    #
#    documentation and/or other materials provided with the                 #
#    distribution.                                                          #
#                                                                           #
#    Neither the name of Texas Instruments Incorporated nor the names of    #
#    its contributors may be used to endorse or promote products derived    #
#    from this software without specific prior written permission.          #
#                                                                           #
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS      #
#  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT        #
#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    #
#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT     #
#  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    #
#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT         #
#  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    #
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    #
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT      #
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    #
#  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     #
#                                                                           #
#############################################################################


use lib "$ENV{C6RUN_INSTALL_DIR}/bin/perl/lib";

use strict;
use GCC::TranslationUnit;

my $tu_file = shift or die "TU filename not specified on the command line.\n";
my $c_file = shift or die "C filename not specified on the command line.\n";
my $out_file_dsp = shift or die "DSP stub output filename not specified on the command line.\n";
my $out_file_gpp = shift or die "ARM stub output filename not specified on the command line.\n";
my $out_file_inc = shift or die "Include output filename not specified on the command line.\n";
#my $list_file = shift or die "Function list filename not specified on the command line.\n";

# Parse the translation unit info
my $node = GCC::TranslationUnit::Parser->parsefile($tu_file)->root;

# Open the output file and input c file for writing
#open(listFile, '>', $list_file) or die $!;
open(outFileDSP, '>', $out_file_dsp) or die $!;
open(outFileGPP, '>', $out_file_gpp) or die $!;
open(outFileTMP, '>', "$out_file_gpp.tmp") or die $!;
open(outFileINC, '>', $out_file_inc) or die $!;
open(cFile, '<',  $c_file) or die $!;

my $c_file_short = $c_file;
$c_file_short=~s/^(.*\/)*(.*)\.c/$2\.c/g;

print outFileDSP "/* Generated by c6runapp-rpcgen from $c_file_short */\n\n";
print outFileGPP "/* Generated by c6runapp-rpcgen from $c_file_short */\n\n";
print outFileINC "/* Generated by c6runapp-rpcgen from $c_file_short */\n\n";


# Find #include statements in the input c file and copy to both stub files
# Then add required stub base headers
while (<cFile>)
{
  if (/^\s*#include/)
  {
    print outFileDSP "$_";
    print outFileGPP "$_";
    print outFileINC "$_";
  }
}

print outFileDSP "\n";
print outFileDSP "#include \"dsp_stubs_base.h\"\n\n";
print outFileDSP "/* DSP-side stub functions */\n\n";


print outFileGPP "\n";
print outFileGPP "#include \"gpp_stubs_base.h\"\n\n";
print outFileGPP "/* External declarations to actual GPP-side target functions */\n\n";

print outFileINC "\n";
print outFileINC "#include \"rpc_stubs_dsp.h\"\n\n";
print outFileINC "/* Declarations for the DSP-side stub functions */\n\n";

# Find all functions from this source file
while($node)
{
  if($node->isa('GCC::Node::function_decl'))
  {
    
    $_=$node->source;
    s/(\w+\.c):\d+/$1/;
    my $sourcefile = $_;
    $_=$node->source;
    s/\w+\.c:(\d+)/$1/;
    my $sourceline = $_;
    
    my $fxnName = $node->name->identifier;
    my $fxnSignature;
    my $fxnMarshalCalls;
    my $fxnGppDecl;

    if($sourcefile eq $c_file_short)
    {
      my $fxnRetType;
      my $fxnGPPCasts;
      my $fxnArgCnt = 0;
      my @argTypes;
      my @setArgFxnType;
      my @argNames;
      my @argSignatures;
      my @argMarshal;
      my @argGPPCast;
    
      # Figure out the return type text
      if($node->type->retn->isa('GCC::Node::enumeral_type'))
      {
        if ($node->type->retn->name->isa('GCC::Node::identifier_node'))
        {
          #my $enumType = $node->type->retn->name->identifier;
          #$fxnRetType = "enum $enumType";
          die "Unsupported return type (enum) in $fxnName.";
        }
        elsif($node->type->retn->name->isa('GCC::Node::type_decl'))
        {
          #$fxnRetType = $node->type->retn->name->name->identifier;
          die "Unsupported return type (type_decl) in $fxnName.";
        }
      }
      elsif($node->type->retn->isa('GCC::Node::pointer_type'))
      {
        # TODO more sophisticated return type processing? 
        #$fxnRetType = $node->type->retn->name->name->identifier;
        $fxnRetType = $node->type->retn->ptd->name->name->identifier;
        $fxnRetType = "$fxnRetType *";
        $fxnSignature = '@';
      }
      elsif($node->type->retn->isa('GCC::Node::real_type'))
      {
        $fxnRetType = $node->type->retn->name->name->identifier;
        if($node->type->retn->precision == 32)
        {
            $fxnSignature = 'f';
        }
        elsif($node->type->retn->precision == 64)
        {
            $fxnSignature = 'd';
        }
      }
      elsif($node->type->retn->isa('GCC::Node::integer_type'))
      {
        $fxnRetType = $node->type->retn->name->name->identifier;
        # Check for char type
        if($fxnRetType =~ /char/)
        {
          $fxnSignature = 'c';
        }
        # Check for int types
        elsif ($fxnRetType =~ /int/)
        {
          # Check for short int types
          if($fxnRetType =~ /short/)
          {
            $fxnSignature = 's';
          }
          # Check for long or long long int types
          elsif($fxnRetType =~ /long/)
          {
            if($fxnRetType =~ /long long/)
            {
              #FIXME need long long type
              $fxnSignature = 'd';
            }
            else
            {
              $fxnSignature = 'i';
            }
          }
          # Assume plain old int
          else
          {
            $fxnSignature = 'i';
          }
        }
      }
      elsif($node->type->retn->isa('GCC::Node::void_type'))
      {
        $fxnRetType = $node->type->retn->name->name->identifier;
        $fxnSignature = 'v';
      }      
      else
      {
        die "Error: Unsupported function return  type, ", ref($node->type->retn), ".\n";
      }
      

      # Print the linker commands so that the cl6x linker will keep the
      # library functions (because they are not directly referenced)
      #print listFile "$fxnName\n";
      
      # All of the following is the actual generation of the stub functions
      # Function definition line for the DSP side stub
      print outFileDSP "$fxnRetType rpc_$fxnName( ";
      # Function definition line for the GPP side stub
      print outFileTMP "void rpc_$fxnName(void **param_buffer, void *result_buffer)\n";
      # Target function's definition line for the GPP side stub
      $fxnGppDecl = "extern $fxnRetType $fxnName( ";
      # Function definition line for the DSP side include file
      print outFileINC "$fxnRetType rpc_$fxnName( ";

      if( defined $node->args )
      {
        my $arg = $node->args;
        my @argTexts;
        while($arg)
        {
          $argNames[$fxnArgCnt] = $arg->name->identifier;
          # Process pointer argument types
          if($arg->type->isa('GCC::Node::pointer_type'))
          {
            $setArgFxnType[$fxnArgCnt] = 'Buffer';
            my $ptrDataType = $arg->type->ptd->name->name->identifier;
            $argTypes[$fxnArgCnt] = "$ptrDataType *";
            #FIXME add more sophisticated pointer type handling?
            $argSignatures[$fxnArgCnt] = '@';
            $argMarshal[$fxnArgCnt] = "    RPC_BUFFER($ptrDataType *, &$argNames[$fxnArgCnt]);";
            $argGPPCast[$fxnArgCnt] = "RPC_CAST_PARAM(param_buffer[$fxnArgCnt], $ptrDataType *)";
          }
          # Process enumerated argument types
          elsif($arg->type->isa('GCC::Node::enumeral_type'))
          {
            #$setArgFxnType[$fxnArgCnt] = 'Enum';
            #if ($arg->type->name->isa('GCC::Node::identifier_node'))
            #{
            #  my $enumType = $arg->type->name->identifier;
            #  $argTypes[$fxnArgCnt] = "enum $enumType";
            #}
            #elsif($arg->type->name->isa('GCC::Node::type_decl'))
            #{
            #  $argTypes[$fxnArgCnt] = $arg->type->name->name->identifier;
            #}
            die "Unsupported argument type (pointer) in $fxnName.";
          }
          # Process integer argument types
          elsif($arg->type->isa('GCC::Node::integer_type'))
          {
            $argTypes[$fxnArgCnt] = $arg->type->name->name->identifier;
            $argGPPCast[$fxnArgCnt] = "RPC_CAST_PARAM(param_buffer[$fxnArgCnt], ${argTypes[$fxnArgCnt]})";
            # Check for char type
            if($argTypes[$fxnArgCnt] =~ /char/)
            {
              $setArgFxnType[$fxnArgCnt] = 'Char';
              $argSignatures[$fxnArgCnt] = 'c';
              $argMarshal[$fxnArgCnt] = "    RPC_PARAM(char, &$argNames[$fxnArgCnt]);";
            }
            # Check for int types
            elsif ($argTypes[$fxnArgCnt] =~ /int/)
            {
              # Check for short int types
              if($argTypes[$fxnArgCnt] =~ /short/)
              {
                $setArgFxnType[$fxnArgCnt] = 'Short';
                $argSignatures[$fxnArgCnt] = 's';
                $argMarshal[$fxnArgCnt] = "    RPC_PARAM(short, &$argNames[$fxnArgCnt]);";
              }
              # Check for long or long long int types
              elsif($argTypes[$fxnArgCnt] =~ /long/)
              {
                if($argTypes[$fxnArgCnt] =~ /long long/)
                {
                  $setArgFxnType[$fxnArgCnt] = 'LongLong';
                  $argSignatures[$fxnArgCnt] = 'd';
                  $argMarshal[$fxnArgCnt] = "    RPC_PARAM(long long, &$argNames[$fxnArgCnt]);";
                }
                else
                {
                  $setArgFxnType[$fxnArgCnt] = 'Long';
                  $argSignatures[$fxnArgCnt] = 'i';
                  $argMarshal[$fxnArgCnt] = "    RPC_PARAM(long, &$argNames[$fxnArgCnt]);";
                }
              }
              # Assume plain old int
              else
              {
                $setArgFxnType[$fxnArgCnt] = 'Integer';
                $argSignatures[$fxnArgCnt] = 'i';
                $argMarshal[$fxnArgCnt] = "    RPC_PARAM(int, &$argNames[$fxnArgCnt]);";
              }
            }
            # If not a char or int, report error
            else
            {
              die "Error: Unrecognized or unsupported integer type, ",$argTypes[$fxnArgCnt],"!\n";
            }
          }
          # Process real (float and double) argument types
          elsif($arg->type->isa('GCC::Node::real_type'))
          {
            $argTypes[$fxnArgCnt] = $arg->type->name->name->identifier;     
            $argGPPCast[$fxnArgCnt] = "RPC_CAST_PARAM(param_buffer[$fxnArgCnt], ${argTypes[$fxnArgCnt]})";     
            if($arg->type->precision == 32)
            {
              $setArgFxnType[$fxnArgCnt] = 'Float';
              $argSignatures[$fxnArgCnt] = 'f';
              $argMarshal[$fxnArgCnt] = "    RPC_PARAM(float, &$argNames[$fxnArgCnt]);";
            }
            elsif($arg->type->precision == 64)
            {
              $setArgFxnType[$fxnArgCnt] = 'Double';
              $argSignatures[$fxnArgCnt] = 'd';
              $argMarshal[$fxnArgCnt] = "    RPC_PARAM(double, &$argNames[$fxnArgCnt]);";
            }
            else
            {
              die "Error: Unrecognized or unsupported real type, ",$argTypes[$fxnArgCnt],"!\n";
            }
          }
          # Report error for any argument type not processed above
          else
          {
            die "Error: Unsupported argument type.", ref($arg->type);
          }
          $argTexts[$fxnArgCnt] = "$argTypes[$fxnArgCnt] $argNames[$fxnArgCnt]";
          $fxnArgCnt += 1;
        } continue {
          $arg = $arg->chain;
        }
        my $paramText = join ', ',@argTexts;
        my $argSignature = join '',@argSignatures;
        $fxnSignature = "$fxnSignature$argSignature";
        $fxnMarshalCalls = join "\n",@argMarshal;
        $fxnGPPCasts = join ",\n      ", @argGPPCast;
        $fxnGppDecl = "$fxnGppDecl$paramText );";
        print outFileDSP "$paramText )\n";
        print outFileINC "$paramText );\n";
      }
      else
      {
        print outFileDSP "void )\n";
        print outFileINC "void );\n";
        $fxnSignature = "${fxnSignature}v";
      }
      
      # DSP-side stub generation for argument marshalling and remote call
      print outFileDSP     "{\n";
      print outFileDSP     "    RPC_INIT(\"rpc_$fxnName\", \"$fxnSignature\");\n";
      print outFileDSP     "$fxnMarshalCalls\n";
      print outFileDSP     "    RPC_PERFORM();\n";
      if($fxnRetType ne 'void')
      {
        print outFileDSP   "    return RPC_GETRESULT($fxnRetType);\n";
      }
      
      print outFileDSP   "}\n";
      print outFileDSP   "\n";
      
      # GPP-side stub generation for actual function call and argument casting
      print outFileTMP      "{\n";
      
      if($fxnRetType ne 'void')
      {
          print outFileTMP      "    $fxnRetType _rpc_result_ = $fxnName(\n";
      }
      else
      {
          print outFileTMP      "    $fxnName(\n";
      }
      
      print outFileTMP      "      $fxnGPPCasts\n";
      print outFileTMP      "    );\n";
      if($fxnRetType ne 'void')
      {
        print outFileTMP      "    RPC_LOAD_RESULT(result_buffer, $fxnRetType, _rpc_result_);\n";
      }
      print outFileTMP      "}\n\n";
      print outFileGPP      "$fxnGppDecl \n";
      
      print outFileINC      "\n";
    }
  }
} continue {
  $node = $node->chain;
}

# Add final newline to generated stubs C files
print outFileDSP "\n";

# Clean up all opened files
close(cFile);
close(outFileDSP);
close(outFileTMP);
close(outFileINC);

# Merge both parts of the GPP stub (add the contents of outFileTMP to outFileGPP)
print outFileGPP "\n/* GPP-side stub functions */\n\n";
open(outFileTMP, '<', "$out_file_gpp.tmp") or die $!;

while (<outFileTMP>)
{
    print outFileGPP "$_";
}
print outFileGPP "\n";

close(outFileTMP);
close(outFileGPP);

# Remove temporary GPP stubs' second part file
unlink("$out_file_gpp.tmp");
