    C6Run - Easy DSP development for TI DSP+ARM devices

Current and up-to-date documentation on the C6Run project can always be found
on the Texas Instrument Embedded Processors wiki:

  http://processors.wiki.ti.com/index.php/C6Run
  
  
Introduction
============

C6Run is a DSP-Ease-Of-Use project to ease development of DSP code on two-core
heterogeneous SoC processors from Texas Instruments, specifically targeting 
DSP+ARM devices. This project is intended to be used in a system running ARM
Linux and containing a C6000 DSP core.

The project consists of two main components:
  1) A build system to create back-end libraries from the various TI software
     technologies and the code of the C6Run project itself
  2) Front-end scripts that wrap the TI C6000 code generation tools in a 
     GCC-like interface and also make use of the back-end build system to create
     ARM-side executables or libraries that transparently make use of the DSP.

There are two uses of the C6Run project, exposed through two different front-end
scripts. They are called C6RunLib and C6RunApp.


C6RunLib
--------
C6RunLib works to build a static ARM library from C source files that can be 
linked with an ARM application and provide access to the DSP when library 
functions are called. This allows the user to keep portions of the application
on the ARM and move other portions to the DSP. 

The C6RunLib front-end consists of two scripts, c6runlib-cc and c6runlib-ar. 
The c6runlib-cc tool is used to compile C code to object files (it does not
support linking).  It actually generates three output files:
 1) a DSP object file from the original source (generated using the cl6x
    compiler)
 2) an ARM object file of remote procedure call stubs
 3) and a text file listing all the functions of the original source that
    are being compiled to the DSP.
Since the compiler step only allows specifying the DSP output object filename
and path, the second and third outputs are implied to be generated at the same
location as the first, but with certain specific file extensions.

The c6runlib-ar tool is a specialized archiver that takes the DSP object files 
produced by the c6runlib-cc tool and generates an ARM side library.  The 
c6runlib-ar tool relies on all three files output from the c6runlib-cc tool to
be in the same path in the filesystem, which is how they are generated by the
c6runlib-cc tool. The archiver tool uses the function list text file to 
generate linker options for the DSP to ensure that the functions in the DSP 
object files are linked into the final DSP executable (otherwise they would be
stripped out since they are not directly referenced in the DSP application 
code). The archiver tool then uses the cl6x tool to link and build the DSP
executable image.  The DSP executable is analyzed and the symbol addresses for
the library functions are extracted and used to generate object files with 
absolute symbol references for the ARM-side application.  The ARM side remote
procedure call stub functions compiled by the c6runlib-cc tool rely on these
absolute symbol references to get the function addresses at link time of the
ARM application.  Next the c6runlib-ar tool will convert the DSP executable
image into a constant array in a C header file which is included in the main
c6runlib task function.  That task function is compiled using the ARM 
cross-compiler to generate an object file. Finally, the c6runlib-ar tool will 
generate a library archive consisting of the remote procedure call stubs, the
function address symbols, the various backend components (DSPLink, CMEM) and
the C6RunLib task function (which has the DSP executable embedded as an array
of const data). 

This output library can then be linked the ARM application to provide mostly
transparent access to the DSP via the unchanged library interfaces.  The 
application can be run from the ARM/Linux command-line as a native ARM 
application.  Underneath the covers, however, the DSP is initiated, loaded with
program code (which consists of the library functions), and runs waiting for
function calls to arrive from the ARM application. As in the C6RunApp tool, 
all C I/O operations (printf, scanf, fopen, etc.) are routed to the ARM 
environment and console. 

C6RunApp
--------
In it's simplest form, this tool acts as a cross-compiler for the DSP, allowing
portable C applications to be rebuilt for the C6000 DSP core of various Texas
Instruments' heterogeneous (ARM+DSP) processors. The C6RunApp front-end 
consists of a single script, called c6runapp-cc.  This use of this script 
matches, as much as possible, the use of GCC.  It can compile C code to C6000
object files and link the C6000 object files into an application. When 
performing linking operations, the tool makes use of a number of steps 
(including linking using the C6000 code generation tools) to create an ARM-side
executable from the DSP object files.

Once built, the application can be run from the ARM/Linux command-line as if
it were a native ARM application.  Underneath the covers, however, the DSP
is initiated, loaded with the program code, and runs the application to 
completion. All C I/O operations (printf, scanf, fopen, etc.) are routed to the
ARM environment and console.  This makes the application appear as another ARM
process, but all of the C code compiled using this tool runs on the DSP core.


Getting Started
===============

Refer the online documentation or the INSTALL file for information on getting
and using the C6Run tools.


Running Code on the Target
==========================

  1. Setup your platform for booting to Linux kernel using a root file system
     you provide (information on how to do this is beyond the scope of this
     project, but typically consists of getting u-boot loaded and running, 
     configuring boot arguments for the Linux kernel under u-boot, and then
     initiating the kernel boot process from u-boot).
  2. IMPORTANT: You need to use the appropriate 'mem=' bootarg for the kernel,
     so that Linux kernel will not use the memory that the C6Run expects to
     use in the memory map. This information is shown when the make 
     <platform>_config step is performed. The physical memory region that 
     C6Run uses can be altered per the instructions in the INSTALL file.
  3. Copy the kernel modules (*.ko) and the module loading and unloading 
     scripts (*.sh) to your target's filesystem from the platforms/<platform> path.
  4. Copy any executables that you have built using the C6Run tools to 
     your target's filesystem.

NOTE: Steps 3 and 4 can be accomplished using the 'make install_programs' 
      target.
      
  5. Boot the system.
  6. Login, locate and run the loadmodules.sh script.
       [target]$ ./loadmodules.sh

  7. Run any one program that you have created with the C6Run tools.
     Only one program can use the DSP at a time.
