/*
 *  Copyright 2010 by Texas Instruments Incorporated.
 *  @(#) DSP/BIOS_Kernel 5,2,5,28 02-10-2010 (cuda-u28)
 */
/*
 *  Do not modify this file; it's generated from c55omap1510.cdb.h
 *  via mkseed!
 */

//# c55omap1510.cdb 5.25.28
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
  
  
object DARAM :: MEM {
    param iAllocHeap :: 1
    param iId :: 0
    param iIsUsed :: 1                   
    param iDelUser :: "USER"
    param base :: 0x000100
    param len ::  0x007F00
    param space :: "code/data"
}
 
object SARAM :: MEM {
    param iAllocHeap :: 0
    param iId :: 0
    param iIsUsed :: 1                   
    param iDelUser :: "USER"
    param base :: 0x008000
    param len ::  0x00C000
    param space :: "code/data"
}
object PDROM :: MEM {
    param iAllocHeap :: 0
    param iId :: 0
    param iIsUsed :: 1                   
    param iDelUser :: "USER"
    param base :: 0x7FC000
    param len ::  0x4000
    param space :: "code/data"
}
object VECT :: MEM {
    param iComment :: .iDelMsg
    param iAllocHeap :: 0
    param iId :: 0
    param iIsUsed :: 1                   
    param iDelUser :: "MEM"
    param iDelMsg :: (
        "This object defines space for the DSP's interrupt vectors and can't be deleted"
    )
    param base :: 0x000080
    param len ::  0x000080
    param space :: "code/data"
}
 
 
 
 
 
 
 
 
 
 
 
 
class Module {
    prop Visible :: 1
    prop Writable :: 1
    prop IsConfMod :: (
	.gNumOf > 0 ? 1 : 0
    )
    prop NoGen	::  0
    prop IsDirty ::  (
	$a = .gDirty,
	.gDirty = 0,
	$a
    )
    
 
    prop dataSize :: 0
    
    
 
    prop error :: #(
	"Error: ", .name,
	$1
    )
    
 
    prop warning :: (
	"Warning ...", .name,
	$1
    )
    
 
    prop minBit	:: (
	$a = 0,
	while (($1 & (1 << $a)) && $a < 32) {
	    ++$a
	},
	$a
    )
    
    
 
    prop name :: (
	"<unnamed module>"
    )
    
 
    prop numBit :: (
	$a = $b = 0,
	while ($a < 32) {
	    if ($1 & (1 << $a)) {
		++$b
	    }
	},
	$b
    )
    
    
 
    global gInit ::= (
	$a = 0,
	$b = 0,
	scan ($i; self) {
	    if ($i.IsConfObj()) {
		$a += 1,
		if (self.isFinite) {
		    $b |= 1 << $i.iId
		}
	    }
	},
	.gNumOf = $a,
	.gSetOf = $b,
	if (.gInitFlag == 0) {
	    .localInit()
	},
	.gInitFlag = 1
    ) {
	prop Visible :: 0    
	prop Writable :: 0
	prop NoGen :: 1	     
    }
    global gInitFlag :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    global  gDirty :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global  gNumOf :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    global  gSetOf :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    global  gUser :: "USER" {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
}
 
class ObjectMgr {
    isa	    Module
    
 
    prop CanCreate :: (
	if (.gNumOf < .maxObjs()) {
	    .localCanCreate()
	}
	else {
	    .warning("Maximum number of objects already created")
	}
    )
    
    
 
    prop CanDelete :: (
	if (.iDelMsg == "ok" || (.iDelUser == .gUser)) {
	    if (.iId >= 0 && .iIsUsed) {
		.localCanDelete()
	    }
	    else {
		.warning("Object already deleted")
	    }
	}
	else {
	    .warning(.iDelMsg)
	}
    )
    
    
 
    prop Create	:: (
	(.gUser = ($0 > 0 ? $1 : "USER")),
	if (($a = .CanCreate()) == "ok") {
	    if (($a = .localCreate()) == "ok") {
		if (.iIsUsed == 0) {
		    .mkId($0 > 1 ? $2 : -1),
		    .iIsUsed = 1,
		    GlobalStatus.gDirty = 1,
		    .gDirty = 1
		}
	    }
	},
	(.gUser = "USER"),
	$a
    )
    
 
    prop Delete :: (
	(.gUser = ($0 > 0 ? $1 : "USER")),
	if (($a = .CanDelete()) == "ok") {
	    if (($a = .localDelete()) == "ok") {
		.rmId(.iId),
		.iIsUsed = 0,
		GlobalStatus.gDirty = 1,
		.gDirty = 1
	    }
	},
	(.gUser = "USER"),
	$a
    )
    
    
 
    prop GetSetOf :: (
	.gSetOf
    )
    
    
 
    prop GetNumOf :: (
	.gNumOf
    )
    
    
 
    prop GetObjId :: (
	.iId
    )
    
 
    prop GetPriority :: (
	.iId
    )
    
    
 
    prop SetPriority :: (
	.iId = $1
    )
    
    
 
    prop IsConfObj ::  (
	.iIsUsed
    )
    
 
    prop localCanCreate :: (
	"ok"
    )
    
 
    prop localCanDelete :: (
	"ok"
    )
    
 
    prop localCreate :: (
	"ok"
    )
    
 
    prop localDelete :: (
	"ok"
    )
    
    
 
    prop localInit :: (
	0
    )
    
    
 
    prop isFinite :: (
	.maxObjs() <= GBL.DSPWORDSIZE ? 1 : 0
    )
    
    
 
    prop mkId ::  (
	if (.isFinite()) {
	    if ($1 < 0) {
		.iId = .minBit(.gSetOf)
	    }
	    else {
		.iId = $1
	    },
	    (.gSetOf |= (1 << .iId))
	}
	else {
	    .iId = 0
	},
	++.gNumOf,
	.iId
    )
    
    
 
    prop rmId :: (
	if (.isFinite()) {
	    .gSetOf &= ~(1 << .iId)
	},
	--.gNumOf
    )
    
    
 
    prop maxObjs :: (
	GBL.DSPWORDSIZE
    )
    
 
    prop isDriver :: (
	0
    )
    
 
    prop SortChildHierView :: (
	1
    )
    inst iDelMsg :: "ok" {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    inst iDelUser :: "USER" {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iId :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst iIsUsed :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
     
    inst iComment :: .iDelUser == "USER" ? "<add comments here>" : .iDelMsg {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "comment"
	prop JSName :: "comment"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER" ? 1 : 0
	prop NoGen :: 1
    }
}
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 	
				 
				 
				 
				 
				 	
				 
				 	
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				
				 
				 
				 
				 
				 	
				  
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 	
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 	
				 
				 
				 
				 
				 
				 
				 
				 
				  
				 
				 
				 
				 	
				 
				 
				 
				  
				 
			         
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
 
type GlobalStatus {
    prop NoGen :: 1
    prop Visible :: 0
    prop Writable :: 0
    prop Label :: "Current Configuration Status"
    prop GlobalIcon :: 101
    prop InstanceIcon :: 101
    prop GlobalHelpTopic :: (
	100
    )
    prop GlobalPropertyPage :: (
	"{9D3AD931-847B-11d0-A621-0000C070F3E9}"
    )
    global GENLIB :: "bioscfg.dll" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Generation Library"
	prop NoGen :: 1
	prop Visible :: 0
	prop Writable :: 1
    }
    
    global DATE :: "" {		 
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global GCONFVERS :: "" {	 
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global SysDataSize ::= (
	$a = 0,
	scan ($i; nil) {		    
	    if ($i.dataSize() != nil) {	    
		$a = $a + $i.dataSize()	    
	    }
	},
	$a
    ) {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "Estimated Data Size: %d"
	prop StatusField :: 1
	prop NoGen :: 1
    }
    global MinStackSize ::= (
	$a = ((2) + (((2) + (4) + (2) + (2)))),	    
	$a = $a + ((1) + (((2) + (4) + (2) + (2)))),	    
	$a = $a + (0),	    
	$b = 0,
	scan ($i; CLK) {	    
	    if ($i.IsConfObj()) {
		$b |= 1
	    }
	},
	$a = $a + (((((5) + (2) + (12) + (14))) + (2) + (((2) + (4) + (2) + (2)))) * $b), 
	$b = 0,
	scan ($i; HWI) {	    
	    if ($i.IsConfObj()) {   
		if ($i != HWI_RESET) {
		    if (($i.function != @HWI_unused) && ($i.function != @RESERVED)) {
			$b++
		    }
		}
	    }
	},
	$a = $a + (((2) + (10) + (6)) * $b),    
	$b = 0,
	scan ($i; SWI) {	    
	    if ($i.IsConfObj()) {   
		if ($i.priority > $b) {
		    $b = $i.priority
		}
	    }
	},
	$a = $a + (((((2) + (10) + (6))) + (((((5) + (2) + (12) + (14))) + (2))) + (((6) + (((2) + (4) + (2) + (2)))))) * $b), 
	$b = 0,
	scan ($i; PRD) {	    
	    if ($i.IsConfObj()) {
		$b |= 1
	    }
	},
	$a = $a + (((2) + (((2) + (4) + (2) + (2)))) * $b), 
	$a
    ) {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "Est. Min. Stack Size (MAUs): %d"
	prop StatusField :: 1
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global ConfigWarnings ::= (
	if (.MinStackSize > MEM.STACKSIZE) {
	    "Application stack size is too small; decrease the number of SWI priorities or increase the stack in MEM."
	}
	else {
	    "None"
	}
    ) {
	prop Label :: "Warnings"
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global SeedVersion ::= "@(#)*** cuda-u28x" {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global gDirty :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    prop Status :: (#.SeedVersion, #.MinStackSize, #.SysDataSize)
}
 
class EModule {
    isa Module
    prop IsXMod :: (
        1
    )
    prop Vendor :: (
	""
    )
    prop Version :: (
	""
    )
}
 
class EObjectMgr {
    isa ObjectMgr
    prop IsXMod :: (
        1
    )
    prop Vendor :: (
        ""
    )
    prop Version :: (
        ""
    )
}
 
class ModuleFolder {
    isa Module
    prop NoGen :: 1
}
 
type SYSTEM {
    isa ModuleFolder
    prop Label :: "System"
    prop GlobalIcon :: 151
    prop GlobalHelpTopic :: (
	500
    )
    prop GlobalPropertyPage :: (
	"{B936FB91-52A5-11d4-947C-0050048381B7}"
    )
}
type INS {
    isa ModuleFolder
    prop Label :: "Instrumentation"
    prop GlobalIcon :: 152
    prop GlobalHelpTopic :: (
	501
    )
    prop GlobalPropertyPage :: (
	"{053C8F90-52A6-11d4-947C-0050048381B7}"
    )
}
type SCH {
    isa ModuleFolder
    prop Label :: "Scheduling"
    prop GlobalIcon :: 153
    prop GlobalHelpTopic :: (
	502
    )
    prop GlobalPropertyPage :: (
	"{053C8F91-52A6-11d4-947C-0050048381B7}"
    )
}
type SYN {
    isa ModuleFolder
    prop Label :: "Synchronization"
    prop GlobalIcon :: 154
    prop GlobalHelpTopic :: (
	503
    )
    prop GlobalPropertyPage :: (
	"{053C8F92-52A6-11d4-947C-0050048381B7}"
    )
}
type IOF {
    isa ModuleFolder
    prop Label :: "Input/Output"
    prop GlobalIcon :: 155
    prop GlobalHelpTopic :: (
	504
    )
    prop GlobalPropertyPage :: (
	"{053C8F93-52A6-11d4-947C-0050048381B7}"
    )
}
type SIODRIVER {
    isa ModuleFolder
    prop Label :: "Device Drivers"
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 127
    prop GlobalHelpTopic :: (
        505
    )
    prop GlobalPropertyPage :: (
        "{A2BCEC70-5365-11d4-947C-0050048381B7}"
    )
}
 
type PROJ {
    isa  ObjectMgr
    prop name :: "PROJ"
    prop maxObjs :: 0	 
    prop Label :: "Project Manager"
    prop GlobalIcon :: 121
    prop InstanceIcon :: 122
    prop InstanceHelpTopic :: (
	201
    )
    
    prop GlobalHelpTopic :: (
	101
    )
    prop InstancePropertyPage :: (
	"{AC3C77D1-890B-11d0-A621-0000C070F3E9}"
    )
    
    prop GlobalPropertyPage :: (
	"{AC3C77D2-890B-11d0-A621-0000C070F3E9}"
    )
    prop NoGen :: 1
    prop Visible :: 0
    
    global ALIASALL :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Generate C Names for All Objects"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global IGNOREWARNING :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Ignore Warnings"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global LIBPATH :: ".;../../lib;$(BIOSROOT)/lib" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Library Search Path"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global INCPATH :: ".;../../include;$(BIOSROOT)/include" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Include File Search Path"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global OBJDIR :: "." {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Object file directory"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global EXTEXE :: "out" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Executable File Extension"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    global EXTLIB :: "lib" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Library File Extension"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    global EXTASM :: "asm" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Assembly Language Source File Extension"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    global EXTOBJ :: "obj" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Object File Extension"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst projType ::  "Executable" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "Executable,Library"
	prop Label :: "Target Type"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst projName :: "$(PROG)" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Target File Name"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst useRpt :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Use RPT Instruction"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst minimizeSpace :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Optimize for Space over Time"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    inst tmx :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Avoid TMX Silicon Bugs"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
}
type PROJ_FILE {
    isa ObjectMgr
    prop Visible :: 0
    
    prop Label :: "Project File Manager"
    
 
    prop InstanceHelpTopic :: (
	BIOSHELP_PROJ_FILE_INSTANCE
    )
    
    prop GlobalHelpTopic :: (
	BIOSHELP_PROJ_FILE_GLOBAL
    )
    prop InstancePropertyPage :: (
	"{AC3C77D3-890B-11d0-A621-0000C070F3E9}"
    )
    
    prop GlobalPropertyPage :: (
	"{AC3C77D4-890B-11d0-A621-0000C070F3E9}"
    )
    prop NoGen :: 1
    
    inst elemType ::  "C Source" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "C Source,ASM Source,Library,Linker Command File"
	prop Label :: "Input File Type"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst elemName :: "$(PROG)" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Input File Name"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst optLevel :: "register+local+global" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "register,register+local,register+local+global,register+local+global+file"
	prop Label :: "Optimization Level"
	prop Visible :: 0
	prop Writable :: .elemType == "C Source" ? 1 : 0
	prop NoGen :: 1
    }
    inst inline :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Inline Expansion"
	prop Visible :: 0
	prop Writable :: .elemType == "C Source" ? 1 : 0
	prop NoGen :: 1
    }
    inst definitions :: "" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Additional Definitions"
	prop Visible :: 0
	prop Writable :: .elemType == "C Source" ? 1 : 0
	prop NoGen :: 1
    }
    inst iParent :: 0 {
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
}
 
type GBL {
    isa Module
    prop name :: "GBL"
    prop Label :: "Global Settings"
    prop IsContainedIn :: SYSTEM
    prop cGen :: 0
    prop GenLinkPrologue :: "%10S\nSECTIONS {%4t\n.vers block(0x20000) (COPY): {} /* version information */%0t\n}\n\n--\"diag_suppress=10286\" /* new linker needs new BIOS (SDSCM00026767) */\n\n-priority\n%1S-l%2S%3S\n%16S%4S%17S%15S%5S%6S%12S%7S%18S\n%19S\n%20S\n\0, _autoInitStr, _board, _librarySuffix, _devLibStr, _biosLibStr, _rtdxLibStr, _rtsLibStr, _librarySuffix, _compilerModel, _lnkCmdStr, _lnkCmdFile, _cslLibStr, _chipType, _librarySuffix, bios55xxLibStr, _chipStr, _sioLibStr, _pwrmLibStr, _pslLibStr1, _pslLibStr2, _dspSubTypeStr, _pslConfigLibStr, _instStr, _rtsNameStr"
    
 
    prop ConfigurationClass :: "{2779A121-92CC-11d1-A63D-0000C070F3E9}"
    prop GlobalIcon :: 105
    prop InstanceIcon :: 106
        
    prop GlobalHelpTopic :: (
        103
    )
    prop InstanceHelpTopic :: (
        103
    )
    prop InstancePropertyPage :: (
        "{B7240DE4-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
        "{B7240DE5-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    prop localInit :: (
        RTA_toHost.Create("HST"),
        RTA_toHost.bufseg = HST.OBJMEMSEG,
        RTA_fromHost.Create("HST"),
        RTA_fromHost.bufseg = HST.OBJMEMSEG,
        RTA_dispatcher.Create("HST"),
        IDL_busyObj.Create("IDL"),
        IDL.USEIDLBUSYOBJ = 1,
        IDL_cpuLoad.Create("IDL")
    )
    
    prop chipcall :: (
        "ok"
    )
    prop IsConfMod :: 1          
    prop ucompare :: (
      $e = "ok",
      $a = ($1 >> 31) & 0x00000001,
      $b = ($2 >> 31) & 0x00000001,
      $c = $1 & 0x7fffffff,
      $d = $2 & 0x7fffffff,
      if($a > $b) {
        $e = "gt"
      }
      else {
        if($a == $b) {
          if($c > $d) {
            $e = "gt"
          }
          else {
            if($c == $d) {
              $e = "eq"
            }
            else {
              $e = "lt"
            }
          }
        }
        else {
          $e = "lt"
        }
      },
      $e
    )
    
    
 
    prop L2Check :: (
        if (.DSPSUBTYPE == 6211 || .DSPSUBTYPE == 6711) {
            .PCC = "mapped",             
            if (.C641XL2CONFIGURE == 1) {
                .C641XL2CONFIGURE = 0,
                .L2CONFIGALLOC = 0
            },
            .L2CacheSizeCheck()
        }
        else {
            if (.DSPSUBTYPE == 6400) {
                .PCC = "mapped",         
                if (.C621XL2CONFIGURE == 1) {
                    .C621XL2CONFIGURE = 0
                },
                .L2CacheSizeCheck()
            }
            else {
                if (.C621XL2CONFIGURE == 1) {
                    .C621XL2CONFIGURE = 0,
                    .L2CacheSizeCheck()
                }
                else {
                    if (.C641XL2CONFIGURE == 1) {
                        .C641XL2CONFIGURE = 0,
                        .L2CONFIGALLOC = 0,
                        .L2CacheSizeCheck()
                    }
                }
            }
        }
    )
    prop C621xL2CacheSizeCheck :: (
        $e = "ok",
        $a = CACHE_L2.base,
        $b = CACHE_L2.len,
        if ( .C621XL2CONFIGURE == 0 ) {
            CACHE_L2.Delete("MEM")
        }
        else {
            if (.L2MODEOPTS == "SRAM" ) {
                CACHE_L2.base = CACHE_L2.base + CACHE_L2.len,
                CACHE_L2.len = 0x0,
                CACHE_L2.Delete("MEM")
            }
            else {
                if (.L2MODEOPTS == "1-way cache" ) {
                    CACHE_L2.Create("MEM"),
                    CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x4000,
                    CACHE_L2.len = 0x4000
                }
                else {
                    if (.L2MODEOPTS == "2-way cache" ) {
                        CACHE_L2.Create("MEM"),
                        CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x8000,
                        CACHE_L2.len = 0x8000
                    }
                    else {
                        if (.L2MODEOPTS == "3-way cache" ) {
                            CACHE_L2.Create("MEM"),
                            CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0xc000,
                            CACHE_L2.len = 0xc000
                        }
                        else {
                            if (.L2MODEOPTS == "4-way cache" ) {
                                CACHE_L2.Create("MEM"),
                                CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x10000,
                                CACHE_L2.len = 0x10000
                            }
                        }
                    }
                }
            }
        },
        $e
    )
    
    prop C641xL2CacheSizeCheck :: (
        $e = "ok",
        $a = CACHE_L2.base,
        $b = CACHE_L2.len,
        if ( .C641XL2CONFIGURE == 0 ) {
            CACHE_L2.Delete("MEM")
        }
        else {
            if (.C641XL2MODEOPTS == "4-way cache (0k)" ) {
                CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x0,
                CACHE_L2.len = 0x0,
                CACHE_L2.Delete("MEM")
            }
            else {
                if (.C641XL2MODEOPTS == "4-way cache (32k)" ) {
                    CACHE_L2.Create("MEM"),
                    CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x8000,
                    CACHE_L2.len = 0x8000
                }
                else {
                    if (.C641XL2MODEOPTS == "4-way cache (64k)" ) {
                        CACHE_L2.Create("MEM"),
                        CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x10000,
                        CACHE_L2.len = 0x10000
                    }
                    else {
                        if (.C641XL2MODEOPTS == "4-way cache (128k)" ) {
                            CACHE_L2.Create("MEM"),
                            CACHE_L2.base = CACHE_L2.base + CACHE_L2.len
                                - 0x20000,
                            CACHE_L2.len = 0x20000
                        }
                        else {
                            if (.C641XL2MODEOPTS == "4-way cache (256k)" ) {
                                CACHE_L2.Create("MEM"),
                                CACHE_L2.base = CACHE_L2.base + CACHE_L2.len
                                    - 0x40000,
                                CACHE_L2.len = 0x40000
                            }
                        }
                    }
                }
            }
        },
        $e
    )
    
    prop C64PL1PCacheSizeCheck :: (
        $e = "ok",
        if (.C64PL2CONFIGURE == 0) {
            .C64PL1PCFG = "32k",
            CACHE_L1P.Create("MEM"),
            CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x8000,
            CACHE_L1P.len = 0x8000
        }
        else {
            if (.C64PL1PCFG == "0k") {
              CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x0,
              CACHE_L1P.len = 0x0,
              CACHE_L1P.Delete("MEM")
            }
            else {
              if (.C64PL1PCFG == "4k") {
                CACHE_L1P.Create("MEM"),
                CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x1000,
                CACHE_L1P.len = 0x1000
              }
              else {
                if (.C64PL1PCFG == "8k") {
                  CACHE_L1P.Create("MEM"),
                  CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x2000,
                  CACHE_L1P.len = 0x2000
                }
                else {
                  if (.C64PL1PCFG == "16k") {
                    CACHE_L1P.Create("MEM"),
                    CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x4000,
                    CACHE_L1P.len = 0x4000
                  }
                  else {
                    if (.C64PL1PCFG == "32k") {
                      CACHE_L1P.Create("MEM"),
                      CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x8000,
                      CACHE_L1P.len = 0x8000
                    }
                    else {
                        $e = .error("Unknown cache size")
                    }
                  }
                }
              }
            }
        },
        $e
    )
    prop C64PL1DCacheSizeCheck :: (
        $e = "ok",
        if (.C64PL2CONFIGURE == 0) {
            .C64PL1DCFG = "32k",
            CACHE_L1D.Create("MEM"),
            CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x8000,
            CACHE_L1D.len = 0x8000
        }
        else {
            if (.C64PL1DCFG == "0k") {
              CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x0,
              CACHE_L1D.len = 0x0,
              CACHE_L1D.Delete("MEM")
            }
            else {
              if (.C64PL1DCFG == "4k") {
                CACHE_L1D.Create("MEM"),
                CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x1000,
                CACHE_L1D.len = 0x1000
              }
              else {
                if (.C64PL1DCFG == "8k") {
                  CACHE_L1D.Create("MEM"),
                  CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x2000,
                  CACHE_L1D.len = 0x2000
                }
                else {
                  if (.C64PL1DCFG == "16k") {
                    CACHE_L1D.Create("MEM"),
                    CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x4000,
                    CACHE_L1D.len = 0x4000
                  }
                  else {
                    if (.C64PL1DCFG == "32k") {
                      CACHE_L1D.Create("MEM"),
                      CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x8000,
                      CACHE_L1D.len = 0x8000
                    }
                    else {
                        $e = .error("Unknown cache size")
                    }
                  }
                }
              }
            }
        },
        $e
    )
    prop C64PL2CacheSizeCheck :: (
        $e = "ok",
        if (.C64PL2CONFIGURE == 0) {
            CACHE_L2.Delete("MEM")
        }
        else {
            if (.C64PL2MODEOPTS == "0k") {
              CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x0,
              CACHE_L2.len = 0x0,
              CACHE_L2.Delete("MEM")
            }
            else {
              if (.C64PL2MODEOPTS == "32k") {
                CACHE_L2.Create("MEM"),
                CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x8000,
                CACHE_L2.len = 0x8000
              }
              else {
                if (.C64PL2MODEOPTS == "64k") {
                  CACHE_L2.Create("MEM"),
                  CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x10000,
                  CACHE_L2.len = 0x10000
                }
                else {
                  if (.C64PL2MODEOPTS == "128k") {
                    CACHE_L2.Create("MEM"),
                    CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x20000,
                    CACHE_L2.len = 0x20000
                  }
                  else {
                    if (.C64PL2MODEOPTS == "256k") {
                      CACHE_L2.Create("MEM"),
                      CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x40000,
                      CACHE_L2.len = 0x40000
                    }
                    else {
		      if (.C64PL2MODEOPTS == "512k") {
                        CACHE_L2.Create("MEM"),
                        CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x80000,
                        CACHE_L2.len = 0x80000
                      }
		      else {
		        if (.C64PL2MODEOPTS == "1024k") {
                          CACHE_L2.Create("MEM"),
                          CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x100000,
                          CACHE_L2.len = 0x100000
                        }
                        else {
                          $e = .error("Unknown cache size")
                        }
                      }
                    }
                  }
                }
              }
            }
        },
        $e
    )
    prop L2CacheSizeCheck :: (
        $e = "ok",
        scan ($i; MEM) {
            if ($i == CACHE_L2) {
                .C621XL2CONFIGURE ?
                    $e = .C621xL2CacheSizeCheck() :
                .C641XL2CONFIGURE ?
                    $e = .C641xL2CacheSizeCheck() :
                .DSPSUBTYPE == 6211 || .DSPSUBTYPE == 6711 ?
                    $e = .C621xL2CacheSizeCheck() :
                .DSPSUBTYPE == 6400 ?
                    $e = .C641xL2CacheSizeCheck() : {
                        CACHE_L2.base = 0x0,
                        CACHE_L2.len = 0x0,
                        CACHE_L2.Delete("MEM")
                    }
            }
        },
        $e
    )
    global PRODUCT :: 0 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 1       
        prop EnvField :: 1
    }
    
 
    global CALLBACKOBJ :: nil {
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CHIPCHAIN :: nil {
        prop Visible ::0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global TRACE :: "CD-01234567" {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Trace Mask"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 0
    }
    global BOARD :: "omap1510" {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Target Board Name"
        prop JSName :: "BOARDNAME"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ROM :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Link to ROM Library"
        prop Visible :: 0
        prop Writable :: 0 
        prop NoGen :: 0
    }
    global CPUCLOCK :: GBL.DSPTYPE == 62 ? .MIPS : .MIPS * 2 {
         
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global PROCID :: = 0  {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style ::  0x01
        prop Label :: "Processor ID (PROCID)"
        prop JSName :: "PROCID"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    
    global CLKIN :: = 20000  {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style ::  0x20
        prop Label :: "Board Clock in KHz (Informational Only)"
        prop JSName :: "CLKIN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global FREQ :: int(round(.MIPS * 1000)) {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style ::  0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    
    global MIPS :: 12.0 {          
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.4f"
        prop Label :: "DSP Speed In MHz (CLKOUT)"
        prop JSName :: "CLKOUT"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (
            $a = .MIPS,
            $b = (GBL.DSPTYPE == 62) ? $1 : $1 * 2,
            $e = "ok",
            .MIPS = $1,
            .FREQ = int(.MIPS * 1000),
            GlobalStatus.gDirty = 1,
            if (($e = .setCPUClock($b)) != "ok") {
                .MIPS = $a
            },
            $e
        )
    }
    prop setCPUClock :: (
        $e = "ok",
        if ($1 != .CPUCLOCK) {
            $a = .CPUCLOCK,
            .CPUCLOCK = $1,
            if (GBL.CALLBACKOBJ != nil) {
                $e = GBL.CALLBACKOBJ.call()
            },
            if ($e != "ok") {
                .CPUCLOCK = $a,
                GBL.CALLBACKOBJ.call()
            }
        },
        if ($e == "ok") {
            "ok"
        }
        else {
            .error($e)
        }
    )
    
    
 
    global OSTYPE :: "BIOS" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "BIOS"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    
 
    global DSPTYPE :: 55 {            
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Major Type"
        prop JSName :: "DSPTYPE"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    
    global SPECIFYRTSLIB :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify RTS library"
        prop JSName :: "SPECIFYRTSLIB"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: 1
    }
    
    global RTSLIB :: "" {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Run-Time Support Library"
        prop JSName :: "RTSLIB"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: .SPECIFYRTSLIB
    }
  
  
        
  
  
  
    global DSPSUBTYPE :: 1510 {      
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "1510,1610,1710,5910,5912,5905"
        prop Label :: "DSP Type"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global CLKTYPE :: 1510 {     
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "CLK Type"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global CHIPTYPE :: "other"  {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "custom,other"
        prop JSName :: "CHIPTYPE"
        prop Label :: "Chip Support Library (CSL)"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 1
        prop Set :: (
            .CHIPTYPE = $1,
            $e = "ok",
            if (GBL.CHIPCHAIN != nil) {
                $e = GBL.CHIPCHAIN.chipcall()
            },
            $e
        )
    }
    global DISPCALLCSLCFGINIT ::= (
            .CHIPTYPE != "other" && .CHIPTYPE != "custom"
        ) {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call CSL_cfgInit Initialization routine"
        prop Visible :: 0
        prop Writable :: .SUPPORTCSL
        prop NoGen :: 1
    }
    global DSPNAME :: "TMS320C55XX" {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global MODIFYCLKMD :: 0 {
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: GBL.DSPSUBTYPE == 5502 ? "Modify PLL Registers" : "Modify CLKMD"
    prop JSName :: "MODIFYCLKMD"
    prop Visible ::  GBL.DSPSUBTYPE == 5561 ? 0 : GBL.DSPSUBTYPE == 1510 ? 0 :
    		     GBL.DSPSUBTYPE == 2420 ? 0 : GBL.DSPSUBTYPE == 2320 ? 0 : 
		     GBL.DSPSUBTYPE == 5505 ? 0 : 1
    prop Writable :: 1
    prop NoGen :: 0
    prop Set :: (
            if ($1 != .MODIFYCLKMD) {    
                .MODIFYCLKMD = $1
            },
            "ok"
        )
     }  
     global CLKMD :: 0x0b50
     {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Label :: GBL.DSPSUBTYPE == 5502 ? "PLLCSR - PLL Control/Status Register" : "CLKMD - (PLL) Clock Mode Register"
        prop JSName :: "CLKMD"
        prop Visible :: GBL.DSPSUBTYPE == 5502 ? 0 : GBL.DSPSUBTYPE == 5561 ? 0 :
            	        GBL.DSPSUBTYPE == 1510 ? 0 : GBL.DSPSUBTYPE == 2420 ? 0 :
                        GBL.DSPSUBTYPE == 2320 ? 0 : GBL.DSPSUBTYPE == 5802 ? 0 :
                        GBL.DSPSUBTYPE == 5505 ? 0 : 1
        prop Writable :: .MODIFYCLKMD
        prop NoGen :: 0
     }   
     global PLLM :: 0x000f
     {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Label :: "PLLM - PLL Multiplier Control Register"
        prop JSName :: "PLLM"
        prop Visible :: GBL.DSPSUBTYPE == 5502 ? 1 : 0
        prop Writable :: .MODIFYCLKMD
        prop NoGen :: 0
     }   
     global PLLDIV0 :: 0x8000
     {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Label :: "PLLDIV0 - PLL Divider 0 Register"
        prop JSName :: "PLLDIV0"
        prop Visible :: GBL.DSPSUBTYPE == 5502 ? 1 : 0
        prop Writable :: .MODIFYCLKMD
        prop NoGen :: 0
     }   
     global PLLDIV1 :: 0x8003
     {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Label :: "PLLDIV1 - PLL Divider 1 Register"
        prop JSName :: "PLLDIV1"
        prop Visible :: GBL.DSPSUBTYPE == 5502 ? 1 : 0
        prop Writable :: .MODIFYCLKMD
        prop NoGen :: 0
        prop Set :: (
            $e = "ok",
            if ($1 != .PLLDIV1) {
            	$a = .PLLDIV1,
                .PLLDIV1 = $1,
            	if (GBL.CALLBACKOBJ != nil) {
                    $e = GBL.CALLBACKOBJ.call()
                },
                if ($e != "ok") {
                    .PLLDIV1 = $a,
                    GBL.CALLBACKOBJ.call()
                }
            },
            if ($e == "ok") {
                "ok"
            }
            else {
                .error($e)
            }
	)
     }   
    global DSPARITHMETIC ::= (
        if (GBL.DSPTYPE == 62 && (GBL.DSPSUBTYPE / 100) == 67) {
            "FLOAT"
        }
        else {
            "FIXED"
        }
    ) {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "FIXED,FLOAT"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPWORDSIZE :: = (
        if (GBL.DSPTYPE == 30 || GBL.DSPTYPE == 40 || GBL.DSPTYPE == 62) {
            32           
        }
        else {
            16           
        }
    ) {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Word Size"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPCHARSIZE :: = (GBL.DSPTYPE == 62 ? 8 :
                             GBL.DSPSUBTYPE == 5599 ? 8 : GBL.DSPWORDSIZE) {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Byte Size"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    
    global DATAPTRSIZE ::= (
        if (GBL.DSPTYPE == 62) {
            32
        }
        else {
            if (GBL.DSPTYPE == 54) {
                16
            }   
            else {
                if (GBL.DSPTYPE == 55) {
                    if (GBL.MEMORYMODEL == "SMALL") {
                        16      
                    }
                    else {
                        23
                    }
                }
                else {
                        if (GBL.DSPTYPE == 28) {
                                22
                        }
                        else {  
                                0
                        }
                }
            }
        })
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop iComment :: "Size of the Data Pointer"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CODEPTRSIZE ::= (
        if (GBL.DSPTYPE == 62) {
            32
        }
        else {
            if (GBL.DSPTYPE == 54) {
                if (GBL.CALLMODEL == "near") {
                    16
                }
                else {
                    24
                }
            }   
            else {
                if (GBL.DSPTYPE == 55) {
                    24
                }
                else {
                    if (GBL.DSPTYPE == 28) {
                        22
                    }
                    else {
                        0
                    }
                }
            }
        })
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop iComment :: "Size of Code Pointer"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global MEMORYMODEL :: "SMALL" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "SMALL,LARGE,HUGE"
        prop Label :: "Memory Model"
        prop JSName :: "MEMORYMODEL"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (
            .MEMORYMODEL = $1,
            "ok"
        )
    }
    global AUTOINIT :: "ROM" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "ROM,RAM"
        prop Label :: "C Autoinitialization Model"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global USERINIT :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call User Init Function"
        prop JSName :: "CALLUSERINITFXN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (
            if ($1 == 0) {       
                .USERINITFXN = @_FXN_F_nop,
                .USERINIT = $1
            }
            else {
                .USERINIT = $1
            },
            "ok"
        )
    }
    global USERINITFXN :: @_FXN_F_nop {
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "User Init Function"
        prop JSName :: "USERINITFXN"
        prop Visible :: 1
        prop Writable :: .USERINIT
        prop NoGen :: 0
    }
    global OLDAUTOCALCULATE :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "previous value for autocalculate"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    
    global ENABLEINST :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Real Time Analysis"
        prop JSName :: "ENABLEINST"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (
            if ($1 != .ENABLEINST) {     
                if ($1) {        
                    RTA_toHost.Create("HST"),
        	    RTA_toHost.bufseg = HST.OBJMEMSEG,
                    RTA_fromHost.Create("HST"),
        	    RTA_fromHost.bufseg = HST.OBJMEMSEG,
                    RTA_dispatcher.Create("HST"),
                    IDL_busyObj.Create("IDL"),
                    IDL.USEIDLBUSYOBJ = 1,
                    IDL_cpuLoad.Create("IDL"),
                    IDL.AUTOCALCULATE = .OLDAUTOCALCULATE
                }
                else {
                    RTA_toHost.Delete("HST"),
        	    RTA_toHost.bufseg = MEM_NULL,
                    RTA_fromHost.Delete("HST"),
        	    RTA_fromHost.bufseg = MEM_NULL,
                    RTA_dispatcher.Delete("HST"),
                    IDL_busyObj.Delete("IDL"),
                    IDL.USEIDLBUSYOBJ = 0,
                    IDL_cpuLoad.Delete("IDL"),
                    .OLDAUTOCALCULATE = IDL.AUTOCALCULATE,
                    IDL.AUTOCALCULATE = 0
                },
                .ENABLEINST = $1
            },
            "ok"
        )
    }
    
    global INSTRUMENTED :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Instrumented BIOS library"
        prop JSName :: "INSTRUMENTED"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global CGENERATE :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Do C Generation"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    
    global ENABLEDLL :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Dynamic Loading"
        prop JSName :: "ENABLEDLL"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global LARGEMODEL ::= .MEMORYMODEL == "LARGE" ? 1 : 
                          .MEMORYMODEL == "HUGE" ? 2 : 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    
   
 
    global ENABLEICACHE :: 0{
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable I-Cache Programming"
        prop JSName :: "ENABLEICACHE"
        prop Visible ::  GBL.DSPSUBTYPE == 5561 ?1:0
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (
            if ($1 != .ENABLEICACHE) {   
                .ENABLEICACHE = $1
            },
            "ok"
        )
    }
    global CACHETYPE :: 2{ 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Nogen :: 0
    }
    global ICACHE :: "2-Way Two RAMset"{
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "2-Way no RAMset,2-Way One RAMset,2-Way Two RAMset" 
        prop Label :: "I-cache configuration"
        prop JSName :: "ICACHE"
        prop Visible ::   GBL.DSPSUBTYPE == 5561 ?1:0
        prop Writable :: .ENABLEICACHE == 1? 1: 0
        prop NoGen :: 1
        prop Set :: (
                .ICACHE = $1,
                if(.ICACHE == "2-Way no RAMset"){
                        .CACHETYPE = 0,
                        "ok"
                }
                else{
                        if(.ICACHE == "2-Way One RAMset"){
                        .CACHETYPE = 1,
                        "ok" 
                        }
                        else{
                        .CACHETYPE = 2,
                        "ok" 
                        }
                }
        )
    }
    global CACHEICRTAG1 :: 0x0f80000{
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x20
        prop Label :: "ICRTAG1 address (24bit address)"
        prop JSName :: "CACHEICRTAG1"
        prop Format :: "0x%06x"
        prop Visible ::  GBL.DSPSUBTYPE == 5561 ?1:0
        prop Writable :: ((.ICACHE != "2-Way no RAMset") && (.ENABLEICACHE == 1))?1:0
        prop NoGen :: 0
    }
    global CACHEICRTAG2 :: 0x0f81000{
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x20
        prop Label :: "ICRTAG2 address (24bit address)"
        prop JSName :: "CACHEICRTAG2"
        prop Format :: "0x%06x"
        prop Visible ::  GBL.DSPSUBTYPE == 5561 ?1:0
        prop Writable :: ((.ICACHE == "2-Way Two RAMset") && (.ENABLEICACHE == 1))?1:0
        prop NoGen :: 0
    }
    
    global SUPPORTCSL :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
    }
    global ENABLEALLTRC :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable All TRC Trace Event Classes"
        prop JSName :: "ENABLEALLTRC"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (
            if ($1) {
                .TRCMASKVALUE = 0xDBEF
            }
            else {
                .TRCMASKVALUE = 0x4000
            },
            .ENABLEALLTRC = $1,
            "ok"
        )
    }
    global TRCMASKVALUE :: 0xDBEF {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
    }
    global CALLCSLCFGINIT ::= .DISPCALLCSLCFGINIT {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
    }
    global BIOS_BOOTFXN :: @_FXN_F_nop {
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "BIOS boot function"
        prop JSName :: "BIOS_BOOTFXN"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    prop setBootFxn :: (
        .CPUREVISION == "1.2" ? @_FXN_F_nop :
          .CPUREVISION == "2.0" ? @_FXN_F_nop :
            @_FXN_F_nop
   )
 
    global DCRPOSTEDWRITE :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DPORT write in posted mode"
        prop JSName :: "DCRPOSTEDWRITE"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (
            if ($1 == 0) {       
                .DCRPOSTEDWRITE = $1
            }
            else {
                .DCRPOSTEDWRITE = $1
            },
            "ok"
        )
    }
    
 
    global CDBPATH :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "CDB search path in COFF file"
        prop JSName :: "CDBRELATIVEPATH"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    prop _cint00Str :: "-u_c_int00 %24t/* link with alternate boot.obj */%0t\n"
    prop _autoInitStr :: ""
    prop _board :: (
        if (HST.RTDX == 1) {
            "lnkrtdx"
        }
        else {
            if (HST.DSM == 1) {
                "lnkdsm"
            }
            else {
                if(HST.EVM54 == 1) {
                    "lnkevm54"
                }
                else {
                    if (HST.BIOSLINK == 1) {
                        "lnkbioslink"
                    }
                    else {
                        "lnknone"
                    }
                }
            }
        }
    )
    prop _dsptype :: GBL.DSPTYPE
    
    prop _instStr :: .INSTRUMENTED ? "" : "_NONINST"
    
    prop _rtsNameStr :: (.RTSLIB)
    prop _biosLibStr :: "-lbios%23S%8S %24t/* DSP/BIOS support */%0t\n"
    prop _compilerModel :: .MEMORYMODEL == "SMALL" ? "" : "x"
    prop _librarySuffix :: .MEMORYMODEL == "SMALL" ? ".a55" :
                           .MEMORYMODEL == "LARGE" ? ".a55L" :
                           .DSPSUBTYPE != 5599 ? ".a55H" : ".a55Pb"
    prop _rtdxLibStr :: (
    	if (RTDX.USERTDX == 0) {
	    ""
	} 
	else {
	    if (RTDX.RTDXTYPE == "JTAG") {
	    	if (.MEMORYMODEL == "SMALL") {
		    "-lrtdx.lib %24t/* RTDX JTAG support */%0t\n"
		} 
		else {
		    if (.MEMORYMODEL == "LARGE") {
		    	"-lrtdxx.lib %24t/* RTDX JTAG support */%0t\n"
		    } 
		    else {
                        if (.MEMORYMODEL == "HUGE") {
                            if (.DSPSUBTYPE != 5599) {
                                "-lrtdxh.lib %24t/* RTDX JTAG support */%0t\n"
                            }
                            else {
                                .error("RTDX not supported for 55+ yet. Disable RTDX.")
                            }
			}
		    }
		}
	    }
	    else {
	    	if (RTDX.RTDXTYPE == "Simulator") {
	    	    if (.MEMORYMODEL == "SMALL") {
		    	"-lrtdxsim.lib %24t/* RTDX SIM support */%0t\n" 
		    } 
		    else {
		    	if (.MEMORYMODEL == "LARGE") {
		    	    "-lrtdxsimx.lib %24t/* RTDX SIM support */%0t\n" 
		    	} 
		    	else {
		    	    if (.MEMORYMODEL == "HUGE") {
		    	    	"-lrtdxsimh.lib %24t/* RTDX SIM support */%0t\n" 
			    }
		    	}
		    }
		}
	    }
	}
    )
    prop _rtsLibStr ::  (
        .SPECIFYRTSLIB ?
        "-l%24S%24t/* C and C++ run-time library support */%0t\n" :
        .MEMORYMODEL == "SMALL" ?
         "-lrts55.lib%24t/* C and C++ run-time library support */%0t\n" :
        .MEMORYMODEL == "LARGE" ?
        "-lrts55x.lib%24t/* C and C++ run-time library support */%0t\n" :
        .DSPSUBTYPE != 5599 ?
        "-lrts55h.lib%24t/* C and C++ run- time library support */%0t\n" :
        "-lrts55phb.lib%24t/* C and C++ run-time library support */%0t\n"
    )
    prop  bios55xxLibStr  ::  (
        if (.DSPSUBTYPE == 1710) {
            "-lbios1710%8S %24t/* 1710 and compatible chips */%0t\n"
        }
        else {
            if (.DSPSUBTYPE == 1510 || .DSPSUBTYPE == 1610 || .DSPSUBTYPE == 5910 || .DSPSUBTYPE == 5912 || .DSPSUBTYPE == 5905) {
                "-lbios1510%8S %24t/* 1510,1610,5910,5912,5905 and compatible chips */%0t\n"
            }
        }
    )
    prop _chipStr :: ""
    prop _pmiLibStr  :: ""
    prop _pmiVoltLibStr  :: ""
    prop _pmiVoltControlLibStr :: ""
    prop _psclLibStr  :: ""
    
    prop _psclCfgLibStr  :: ""
    prop _psclConfigLibStr :: ""
    
    prop _pwrmLibStr  :: PWRM.PWRM_ENABLE == 1
        ? (.MEMORYMODEL == "SMALL"
            ? "-lpwrm.a55"
            : .MEMORYMODEL == "LARGE"
                ? "-lpwrm.a55L"
                : "-lpwrm.a55H")
        : ""
    prop _pslLibStr1  :: PWRM.PWRM_ENABLE == 1
        ? PWRM.PWRM_SCALING == 1
            ? .DSPSUBTYPE == 5509
                ? "-lPSL_c%21da%8S %24t/* PSL library */%0t"
                : "-lPSL_c%21d%8S %24t/* PSL library */%0t"
            : "-lpslnull%8S %24t/* PSL library */%0t"
        : ""
    prop _pslLibStr2  :: PWRM.PWRM_SCALING == 1
        ? "-l%22S %24t/* PSL configuration library */%0t"
        : ""
    prop _dspSubTypeStr :: .DSPSUBTYPE * 1
    prop _pslConfigLibStr :: PWRM.PWRM_CONFIGLIB
    prop _mpcLibStr :: ""
    prop _lnkCmdFile :: MEM.LNKCMDFILE
    prop _lnkCmdStr :: (
        if (MEM.LNKCMDFILE == "") {
            ""
        }
        else {
            "-l%11S %24t/* User Specified Linker cmd file */%0t\n"
        }
    )
    prop _sioLibStr :: SIO.USEISSUERECLAIM == 1 ?
        "-lsioir%8S %24t/* supports SIO Issue/Reclaim model only */%0t\n" :
        "-lsioboth%8S %24t/* supports both SIO models */%0t\n"
    prop _devLibStr :: "-ldrivers%14S %24t/* device drivers support */%0t\n"
    prop _cslLibStr :: ""
    prop _chipType :: ""
    prop AllocType :: (
        if (.SUPPORTCSL) {
            "1\0,    _cslAllocDesc, _cslmemSeg, _placement"
        }
    )
    prop _cslAllocDesc :: (
        "%8t .csldata: block(0x20000) {%12t\n *(.csldata)%8t\n }"
    )
    
 
    prop _cslmemSeg :: MEM.BSSSEG
    prop _placement :: (0x7fffff / 2)
}
 
type MEM {
    isa ObjectMgr
    prop Label :: "MEM - Memory Section Manager"
    prop name :: "MEM"
     
    prop DependsOn :: "SEM"
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 115
    prop InstanceIcon :: 116
    prop GlobalHelpTopic :: (
	108
    )
    prop InstanceHelpTopic :: (
	208
    )
    prop InstancePropertyPage :: (
	    "{3D658E70-05E7-11d0-BD44-0020AFEE33C8}"
    )
    
    prop GlobalPropertyPage :: (
	    "{3D658E71-05E7-11d0-BD44-0020AFEE33C8}"
    )
    
    prop heapLabelStr :: (.iHeapId)
     
    prop _cmd55stksz :: (MEM.STACKSIZE * 2)
    prop _cmd55systksz :: (MEM.SYSSTACKSIZE * 2)
    prop _cmd55origin :: (.base * 2)
    prop _cmd55len :: (.len * 2)
    prop _cmd55heapsize :: (.iHeapSize * 2)
    prop _cmd55heaplen :: (.iHeapSize * 2)
    prop GenLinkPrologue :: (
	if (GBL.DSPTYPE == 55) {
	    "-stack 0x%1x\n-sysstack 0x%2x\n\nMEMORY {%4t\0, _cmd55stksz, _cmd55systksz"
	}
	else {
	    "-stack 0x%1x\nMEMORY {%4t\0, _stackSize"
	}
    )
    prop _stackSize :: MEM.STACKSIZE
    prop _sysstackSize :: MEM.SYSSTACKSIZE
    prop _sysstackSeg :: MEM.SYSSTACKSEG
    prop _sysstackSegPg ::(
                          MEM.SYSSTACKSEG.space() == "code"
                          ? " PAGE 0"
                          : MEM.SYSSTACKSEG.space() == "data"
                            ? " PAGE 1"
                            : MEM.SYSSTACKSEG.space() == "io"
                              ? " PAGE 2"
                              : " PAGE 0"
                          )
    prop AllocType :: (
	if (.REUSE == 0 && .USERCMD == 0) {
	"19\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysinitString,	_initSeg,	_sysinitPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_bssString,	_bssSeg,	_firstPlace, 		_farString,	_farSeg,	_secondPlace, 		_cinitString,	_cinitSeg,	_midPlace, 		_pinitString,	_pinitSeg,	_midPlace, 		_dataString,	_dataSeg,	_midPlace, 		_constString,	_constSeg,	_midPlace, 		_switchString,	_switchSeg,	_midPlace, 		_cioString,	_cioSeg,	_midPlace, 		_textString,	_textSeg,	_midPlace, 		_frtString,	_frtSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"
	}
	else { if (.REUSE == 0 && .USERCMD == 1) {
	"9\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysinitString,	_initSeg,	_sysinitPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"
	}
	else { if (.REUSE == 1 && .USERCMD == 0) {
	 
	"18\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_bssString,	_bssSeg,	_firstPlace, 		_farString,	_farSeg,	_secondPlace, 		_cinitString,	_cinitSeg,	_midPlace, 		_pinitString,	_pinitSeg,	_midPlace, 		_dataString,	_dataSeg,	_midPlace, 		_constString,	_constSeg,	_midPlace, 		_switchString,	_switchSeg,	_midPlace, 		_cioString,	_cioSeg,	_midPlace, 		_textString,	_textSeg,	_midPlace, 		_frtString,	_frtSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"
	}
	else {  
	"8\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"
	}}}
    )
 
    prop _firstPlace  :: 0  
    prop _secondPlace :: 0 + 1
    prop _thirdPlace :: 0 + 2
    prop _midPlace    :: (0x7fffff / 2)
    prop _sysinitPlace :: (0x7fffff / 2)
    prop _argsString    :: ("%8t .args: align = 0x4  fill=0 block(0x20000) {%12t\n *(.args)\n . += 0x%1x;%8t\n }\0, _argsSize")
    prop _bssString     :: ("%8t .bss: block(0x20000)    {}")
    prop _farString     :: ("%8t .far:     {}")
    prop _cinitString   :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.CINITSEG == MEM.LOADCINITSEG) {
		"%8t .cinit: block(0x20000)    {}"
	    }
	    else {
		"%8t .cinit:   {} load > %1s%2s, run\0, _loadcinitSeg, _cinitpg"
	    }
	}
	else {
		"%8t .cinit: block(0x20000)    {}"
	}
    )
    prop _pinitString   :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.PINITSEG == MEM.LOADPINITSEG) {
		"%8t .pinit: block(0x20000)    {}"
	    }
	    else {
		"%8t .pinit:   {} load > %1s%2s, run\0, _loadpinitSeg, _pinitpg"
	    }
	}
	else {
		"%8t .pinit: block(0x20000)    {}"
	}
    )
prop _trcinitString :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.TRCINITSEG == MEM.LOADTRCINITSEG) {
		"%8t .trcdata:   {}"
	    }
	    else {
		"%8t .trcdata:   {} load > %1s%2s, run\0, _loadtrcinitSeg, _trcdatapg"
            }
        }
	else {
	    "%8t .trcdata:    {}"
	}
    )
    prop _gblinitString :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.BIOSINITSEG == MEM.LOADBIOSINITSEG) {
		"%8t .gblinit: block(0x20000)   {}"
    	    }
	    else {
		"%8t .gblinit:   {} load > %1s%2s, run\0, _loadgblinitSeg, _gblinitpg"
   	    }
	}
	else {
		"%8t .gblinit: block(0x20000)   {}"
	}
    )
    prop _dataString    :: ("%8t .data: block(0x20000)  {}")
    prop _constString   :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.CONSTSEG == MEM.LOADCONSTSEG) {
               55 == 28 ?
	         "%8t .const:    {}" :
                 "%8t GROUP {\n %8t .const: {} \n %8t .printf (COPY): {} \n%8t }" 
	    }
	    else {
		 if ((55 == 54) || (55 == 28)) {
                     55 == 28 ?
	                "%8t .const:   {} load > %1s PAGE %2s, run\0, _loadconstSeg, _pg" : 
                        "%8t GROUP {\n %8t .const: {} load > %1s PAGE %2s \n %8t .printf (COPY): {} \n%8t } run\0, _loadconstSeg, _pg" 
                 }
                 else {
                     if (55 == 55)
                     {
                        "%8t GROUP {\n %8t .const: {} load > %1s%2s \n %8t .printf (COPY): {} \n%8t } run\0, _loadconstSeg, _constpg" 
                     }
                     else
                     {
                        "%8t GROUP {\n %8t .const: {} load > %1s \n %8t .printf (COPY): {} \n%8t } run\0, _loadconstSeg" 
                     }
                 }
	    }
	}
	else {
               55 == 28 ?
	         "%8t .const:    {}" :
                 "%8t GROUP {\n %8t .const: {} \n %8t .printf (COPY): {} \n%8t }" 
	}
    )
    prop _switchString  :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.SWITCHSEG == MEM.LOADSWITCHSEG) {
		"%8t .switch:   {}"
	    }
	    else {
		"%8t .switch:   {} load > %1s%2s, run\0, _loadswitchSeg, _switchpg"
	    }
	}
	else {
	    "%8t .switch:    {}"
	}
    )
    prop _sysmemString	:: ("%8t .sysmem:  {}")
    prop _cioString	:: ("%8t .cio:     {}")
    prop _memObjString  :: ("%8t .mem: 	  {}")
    prop _sysdataString :: (
	if((GBL.ROM == 0) && (GBL.DSPTYPE == 54)) {
	    "%8t .sysdata: align = 128 {%12t\n GBL_A_SYSPAGE = .;\n GBL_A_SYSDP = GBL_A_SYSPAGE >> 7;\n %8t }"
	}
	else {
	    "%8t .sysdata: block(0x20000) {}"
	}
    )
    prop _sysinitString :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.INITSEG == MEM.LOADINITSEG) {
		"%8t .sysinit:   {}"
	    }
	    else {
		"%8t .sysinit:   {} load > %1s%2s, run\0, _loadinitSeg, _sysinitpg"
	    }
        }
	else {
	    "%8t .sysinit:    {}"
	}
    )
    prop _sysregsString :: ("%8t .sysregs: {}")
    prop _textString  :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.TEXTSEG == MEM.LOADTEXTSEG) {
		"%8t .text:    {}"
	    }
	    else {
		"%8t .text:    {} load > %1s%2s, run\0, _loadtextSeg, _textpg"
	    }
        }
	else {
	    "%8t .text:    {}"
	}
    )
    prop _frtString	:: ("%8t frt:    {}")
    prop _biosString    :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.BIOSSEG == MEM.LOADBIOSSEG) {
		"%8t .bios:    {}"
	    }
	    else {
		"%8t .bios:    {} load > %1s%2s, run\0, _loadbiosSeg, _biospg"
    	   }
    	}
	else {
	    "%8t .bios:    {}"
	}
    )
    prop _stackString :: (
      if (GBL.DSPTYPE == 62) {
         "%8t .stack: align = 0x8 {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = GBL_stackbeg + 0x%1x - 1;%12t\n _HWI_STKBOTTOM = GBL_stackbeg + 0x%1x - 8;%12t\n _HWI_STKTOP = GBL_stackbeg;%8t\n }\0, _stackSize, _stackSize"
      }
      else {
	if (GBL.DSPTYPE == 54) {
             "%8t .stack: {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = ((GBL_stackbeg + 0x%1x - 1) & 0xfffe) ;%8t\n _HWI_STKBOTTOM = GBL_stackend;%12t\n _HWI_STKTOP = GBL_stackbeg;%8t\n }\0, _stackSize"
        }
        else {
	 if (GBL.DSPTYPE == 55) {
		"%8t GROUP { \n%16t .sysstack :  align = 0x4 {%12t\n %16t GBL_sysstackbeg = .;\n %16t *(.sysstack)\n %16t GBL_sysstackend = GBL_sysstackbeg + 0x%2x -1 ;%12t\n %16t _HWI_SYSSTKTOP = GBL_sysstackbeg; %12t\n %16t_HWI_SYSSTKBOTTOM = (GBL_sysstackend+1);\n%16t} \n%16t .stack: align = 0x4 {%12t\n %16t GBL_stackbeg = .;\n %16t *(.stack)\n GBL_stackend = (GBL_stackbeg + 0x%1x - 1) ;%12t\n %16t _HWI_STKBOTTOM = (GBL_stackend+1);%12t\n %16t _HWI_STKTOP = (GBL_stackbeg);%16t\n }%8t\n } BLOCK(0x20000), run \0, _cmd55stksz, _cmd55systksz"
	}
	  else
	   {  
             "%8t .stack: {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = GBL_stackbeg + 0x%1x - 1;%8t\n _HWI_STKBOTTOM = GBL_stackbeg;%12t\n _HWI_STKTOP = (GBL_stackend + 1);%8t\n }\0, _stackSize"
          }
        }
      }
    )
    prop _memHdrSize :: 8
    prop GenLinkEpilogue :: (
	"%0t}"
    )
    prop _stackSeg :: MEM.STACKSEG
    prop _textSeg :: MEM.TEXTSEG
    prop _frtSeg :: MEM.TEXTSEG
    prop _biosSeg :: MEM.BIOSSEG
    prop _dataSeg :: MEM.DATASEG
    prop _cioSeg :: MEM.CIOSEG
    prop _sysmemSeg :: MEM.SYSMEMSEG
    prop _constSeg :: MEM.CONSTSEG
    prop _initSeg :: MEM.INITSEG
    prop _pinitSeg :: MEM.PINITSEG              
    prop _trcinitSeg :: MEM.TRCINITSEG
    prop _gblinitSeg :: MEM.BIOSINITSEG
    prop _regsSeg :: MEM.SYSDATASEG		 
    prop _sysdataSeg :: MEM.SYSDATASEG
    prop _argsSeg :: MEM.ARGSSEG
    prop _argsSize :: MEM.ARGSSIZE
    prop _bssSeg :: MEM.BSSSEG
    prop _farSeg :: MEM.FARSEG
    prop _cinitSeg :: MEM.CINITSEG
    prop _memObjSeg :: MEM.CFGOBJSEG
    prop _switchSeg :: MEM.SWITCHSEG
    prop _loadtextSeg :: MEM.LOADTEXTSEG
    prop _loadbiosSeg :: MEM.LOADBIOSSEG
    prop _loadconstSeg :: MEM.LOADCONSTSEG
    prop _loadinitSeg :: MEM.LOADINITSEG
    prop _loadpinitSeg :: MEM.LOADPINITSEG      
    prop _loadtrcinitSeg :: MEM.LOADTRCINITSEG
    prop _loadgblinitSeg :: MEM.LOADBIOSINITSEG
    prop _loadcinitSeg :: MEM.LOADCINITSEG
    prop _loadswitchSeg :: MEM.LOADSWITCHSEG
    prop _biospg :: (
        (MEM.LOADBIOSSEG.space() == "code")
           ? " PAGE 0" 
           : (MEM.LOADBIOSSEG.space() == "data")
                ? " PAGE 1"
                : (MEM.LOADBIOSSEG.space() ==  "io")
                     ? " PAGE 2"
                     : " PAGE 0"
    )
    prop _sysinitpg :: (
        (MEM.LOADINITSEG.space() == "code")
           ? " PAGE 0" 
           : (MEM.LOADINITSEG.space() == "data")
                ? " PAGE 1"
                : (MEM.LOADINITSEG.space() ==  "io")
                     ? " PAGE 2"
                     : " PAGE 0"
    )
    prop _gblinitpg :: (
        (MEM.LOADBIOSINITSEG.space() == "code")
           ? " PAGE 0" 
           : (MEM.LOADBIOSINITSEG.space() == "data")
                ? " PAGE 1"
                : (MEM.LOADBIOSINITSEG.space() ==  "io")
                     ? " PAGE 2"
                     : " PAGE 0"
    )
    prop _trcdatapg :: (
        (MEM.LOADTRCINITSEG.space() == "code")
           ? " PAGE 0" 
           : (MEM.LOADTRCINITSEG.space() == "data")
                ? " PAGE 1"
                : (MEM.LOADTRCINITSEG.space() ==  "io")
                     ? " PAGE 2"
                     : " PAGE 0"
    )
    prop _textpg :: (
        (MEM.LOADTEXTSEG.space() == "code")
           ? " PAGE 0" 
           : (MEM.LOADTEXTSEG.space() == "data")
                ? " PAGE 1"
                : (MEM.LOADTEXTSEG.space() ==  "io")
                     ? " PAGE 2"
                     : " PAGE 0"
    )
    prop _switchpg :: (
        (MEM.LOADSWITCHSEG.space() == "code")
           ? " PAGE 0" 
           : (MEM.LOADSWITCHSEG.space() == "data")
                ? " PAGE 1"
                : (MEM.LOADSWITCHSEG.space() ==  "io")
                     ? " PAGE 2"
                     : " PAGE 0"
    )
    prop _cinitpg :: (
        (MEM.LOADCINITSEG.space() == "code")
           ? " PAGE 0" 
           : (MEM.LOADCINITSEG.space() == "data")
                ? " PAGE 1"
                : (MEM.LOADCINITSEG.space() ==  "io")
                     ? " PAGE 2"
                     : " PAGE 0"
    )
    prop _pinitpg :: (
        (MEM.LOADPINITSEG.space() == "code")
           ? " PAGE 0" 
           : (MEM.LOADPINITSEG.space() == "data")
                ? " PAGE 1"
                : (MEM.LOADPINITSEG.space() ==  "io")
                     ? " PAGE 2"
                     : " PAGE 0"
    )
 
    prop _constpg :: (
        (MEM.LOADCONSTSEG.space() == "code")
           ? " PAGE 0" 
           : (MEM.LOADCONSTSEG.space() == "data")
                ? " PAGE 1"
                : (MEM.LOADCONSTSEG.space() ==  "io")
                     ? " PAGE 2"
                     : " PAGE 0"
    )
    prop AllocInst :: (
        if (.iAllocHeap == 1) {
        "1\0, _instAllocDesc, _objMemSeg, _placement"
        }
    )
    
 
    prop _instAllocDesc :: (
	.INITSEG.iAllocHeap && .REUSE && .INITSEG == self
	? "%8t GROUP RUN_START(%0r$Bb), RUN_START(_%0r_baseb), RUN_SIZE(%0r$L), RUN_SIZE(_%0r_length) {%12t\n.sysinitgap {. += 0x%2x;}\n.sysinit: {%16t\n_%0r_base = _%0r_baseb / 2;%16t\n%0r$B = %0r$Bb / 2;%12t\n}%12t\n.%0r$heap: {%16t\n. += 0x%1x;%12t\n}%8t\n }\0, _heapsize, _sysinitgap, _heaplen"
	: "%8t .%0r$heap: RUN_START(%0r$Bb), RUN_START(_%0r_baseb), RUN_SIZE(%0r$L), RUN_SIZE(_%0r_length) {%12t\n . += 0x%1x;%12t\n %0r$B = %0r$Bb / 2;%12t\n _%0r_base = _%0r_baseb / 2;%8t\n } \0, _cmd55heapsize, _cmd55heaplen"
    )
    prop _objMemSeg :: self
    prop _placement :: 0x7fffff - 1
    prop _heapsize :: (.iHeapSize)
    prop _heaplen ::  (.iHeapSize)
    
 
    prop _sysinitgap :: 2 * 1 
    prop GenInstLink :: (GBL.DSPTYPE == 62
	? "%0r %16t: origin = 0x%1x, %40tlen = 0x%2x%4t\0, _origin, _len"
	: GBL.DSPTYPE == 55
	
	? "PAGE %3d: %16t%0r: %26torigin = 0x%1x, %40tlen = 0x%2x%4t\0, _cmd55origin, _cmd55len, _page"
	: "PAGE %3d: %14t%0r: %26torigin = 0x%1x, %50tlen = 0x%2x%4t\0, _origin, _len, _page"
    )
    prop localInit :: (
	$d = "ok",
	scan ($i; MEM) {
	    if ($i.space == "code" && $i.iAllocHeap == 1) {
		$d = .error ("Code memory cannot have a heap")
	    }
	},
	if (.SEGZERO.iAllocHeap == 1) {
	    .SEGZERO.iReqHeapCount++
	}
	else {
	    $d = .error ("Segment for DSP/BIOS objects must be a memory segment with a heap")
	},
	if (.MALLOCSEG.iAllocHeap == 1) {
	    .MALLOCSEG.iReqHeapCount++
	}
	else {
	    $d = .error ("Segment for malloc()/free() must be a memory segment with a heap")
	},
	$d
    )
    prop _page :: (.page)
    prop _origin :: (.base)
    prop _len :: (.len)
    prop maxObjs :: (
	32767				 
    )
    
    prop codeMember :: (
	$1.dynamicLoading == 1
	    ? 0
	    : GBL.DSPTYPE == 62
	    ? (($1.space == "code") || ($1.space == "code/data"))
	    : GBL.DSPTYPE == 54
	        ? ($1.space == "code")
	    : GBL.DSPTYPE == 28
	        ? ($1.space == "code" || ($1.space == "code/data"))
            : GBL.DSPTYPE == 55
	    ? (($1.space == "code") || ($1.space == "code/data"))
	    : ($1.space == "code/data")
    )
    prop dataMember :: (
	$1.dynamicLoading == 1
	    ? 0
	    : GBL.DSPTYPE == 62
	    ? ($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL
	    : GBL.DSPTYPE == 54
	        ? (($1.space != "code") && ($1 != MEM_NULL)) && $1.space != "io"
	    : GBL.DSPTYPE == 28
	        ? ($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL
	    : GBL.DSPTYPE == 55
	    ? ($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL
	        : (($1.space == "code/data") && ($1 != MEM_NULL))
    )
    
    prop dataNullMember :: (
	$1.dynamicLoading == 1
	    ? 0
	    : GBL.DSPTYPE == 62
	    ? $1.space == "data" || $1.space == "code/data"
	    : GBL.DSPTYPE == 54
	        ? $1.space != "code" && $1.space != "io"
	    : GBL.DSPTYPE == 28
	        ? $1.space == "data" || $1.space == "code/data"
	    : GBL.DSPTYPE == 55
	    ? $1.space == "data" || $1.space == "code/data"
	    : $1.space == "code/data"
    )
    prop dataCodeMember :: (		 
	$1.dynamicLoading == 1
	    ? 0
	    : GBL.DSPTYPE == 62
	    ? ($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL
	    : GBL.DSPTYPE == 54
	        ? $1.space == "code" && $1 != MEM_NULL	 
							 
	    : GBL.DSPTYPE == 28
	        ? ($1.space == "code" || $1.space == "code/data")
		  && $1 != MEM_NULL		 
						 
	    : GBL.DSPTYPE == 55
	    ? ($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL
	    : $1.space == "code/data" && $1 != MEM_NULL  
							     
    )
    
 
    prop memWritable :: (.iIsModifiable && .iDelUser != "MEM")
    
 
    global CALLBACKOBJ :: nil {
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumHeap ::= (
	    $a = 0,
	    scan($i; MEM) {
		if ($i != MEM_NULL) {
		    $a += $i.iAllocHeap
		}
	    },
	    $a
	)  {
	prop NoGen :: 0
    }
    global REUSE ::=
	    (.INITSEG.space != "code" && .INITSEG.iAllocHeap == 1 ? .SAVEREUSE : 0) {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Reuse Startup Code Space"
	prop JSName :: "REUSECODESPACE"
	prop Visible :: 1
	prop Writable  :: .INITSEG.space != "code" && .INITSEG.iAllocHeap == 1
	prop NoGen :: 1
	prop Set :: (
	    .SAVEREUSE = $1,
	    "ok"
	)
    }
    global SAVEREUSE :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    
 
    global doCheckOverlap :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
 
    prop validate :: (
        $e = .checkMemOverlap($1),
        if ($e == "ok") {
            $e = .checkHeapSize($1)
        },
        if ($e == "ok") {
            $e = .checkHeapSeg($1)
        },
        $e
    )
    
    
 
    prop checkHeapSeg :: (
        $e = "ok",
        
        if ($1 == MEM_NULL && MEM.NOHEAPS == 0) {
            if (MEM.MALLOCSEG == MEM_NULL) {
                $e = ("Heaps are enabled, but the segment for malloc (MEM.MALLOCSEG) is not set correctly. Please create a heap in one of your data segments and set MEM.MALLOCSEG to it.")
            },
            if (MEM.SEGZERO == MEM_NULL) {
                $e = ("Heaps are enabled, but the segment for DSP/BIOS Objects (MEM.BIOSOBJSEG) is not set correctly. Please create a heap in one of your data segments and set MEM.BIOSOBJSEG to it.")
            }
        },
        $e
    )
    
 
    prop checkHeapSize :: (
        $e = "ok",
        if (MEM.NOHEAPS == 0) {
            if ($1.iAllocHeap && $1 != MEM_NULL) {
                if ($1.iHeapSize > $1.len) {
                    $e = ("MEM segment %s: heap cannot be larger than the length of segment that contains it.")
                }
            }
        },
        $e
    )
    
 
    prop checkMemOverlap :: (
        $e = "ok",
        if ($1 != MEM_NULL && $1.iIsUsed == 1) {
            if ($1.len == 0) {
                $a = $1.base
            }
            else {
                $a = ($1.base + $1.len - 1)
            },
            scan ($j; MEM) {
                if ($1 != $j && $j != MEM_NULL && $j.iIsUsed == 1 &&
                    (GBL.DSPTYPE == 62 ||
                    $1.space == $j.space)) {
                    if (!($j == CACHE_L2 && GBL.L2CONFIGURE == 0)) {
                        $b = $j.base,
                        if ($j.len == 0) {
			    $c = $j.base
			}
			else {
			    $c = ($j.base + $j.len - 1)
			},
                        
 
                        if ($a >= $b && $1.base <= $c) {
                            $e = ("MEM segment %s: overlaps with another segment or cache configuration."),
                            break
                        }
                    }
                }
            }
        },
        $e
    )
     
    global MAPSELECT :: "Map 1" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Map Mode"
	prop JSName :: "MAPMODE"
	prop Enum :: "Map 0,Map 1"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
					  
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
					 
    global ARGSSIZE ::=  GBL.LARGEMODEL == 1 ?  16 :  8 {		
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04x"
	prop Style :: 0x01 | 0x02
	prop Label :: "Argument Buffer Size"
	prop JSName :: "ARGSSIZE"
	prop Visible :: 1	 
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    if ($1 < 4) {
		.error("The 'arguments' section must have at least 4 words.")
	    }
	    else {
		.ARGSSIZE = $1 << 1,
		"ok"
	    }
	)
    }
    global ARGSSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataMember($1)
	prop Label :: "Argument Buffer Section (.args)"
	prop JSName :: "ARGSSEG"
	prop Visible :: 1	 
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
    }
    
    global BIOSSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .codeMember($1)
	prop Label :: "BIOS Code Section (.bios)"
	prop JSName :: "BIOSSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Code"
    }
    global STACKSIZE :: GBL.DSPTYPE == 62 ? 1024 : (GBL.DSPTYPE == 55 && GBL.DSPSUBTYPE == 5599) ? 2560 : (GBL.DSPTYPE == 55 && GBL.DSPSUBTYPE != 5599) ? 1024: (GBL.DSPTYPE == 54)?256:(GBL.DSPTYPE == 28) ? 512 : 256 {  
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04x"
	prop Style :: GBL.DSPTYPE == 54
	    ? 0x01 | 0x02
	    : 0x02
	prop Label :: "Stack Size (MAUs)"
	prop JSName :: "STACKSIZE"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
		if ((GBL.DSPTYPE == 55) && (GBL.DSPSUBTYPE != 5599)) {
		    .STACKSIZE = ($1 & -2)
		}
		else {
		    if ((GBL.DSPTYPE == 55) && (GBL.DSPSUBTYPE == 5599)) {
		        .STACKSIZE = ($1  & -4)
		    }
		    else {
		        .STACKSIZE = $1
		    }
		},
		"ok"
	)
	prop PropSetOkUserMsg :: (MEM.STACKSIZE < GlobalStatus.MinStackSize)?"Warning: You are setting the stack size to a value that is less than the Estimated Minimum Stack Size!":"ok"
    }
    global USERCMD :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "User .cmd File For Compiler Sections"
	prop JSName :: "USERCOMMANDFILE"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global STACKSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataMember($1)
	prop Label :: "Stack Section (.stack)"
	prop JSName :: "STACKSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
	prop Set :: (
	    if (GBL.DSPTYPE == 55) {
	        (MEM.STACKSEG = $1), 
		(MEM.SYSSTACKSEG = $1)
		}
		else {
		(MEM.STACKSEG = $1)
		},
		"ok"
	)
    }
     
    global SYSSTACKSIZE :: GBL.DSPSUBTYPE == 5599 ? 2 : 256 {  
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04x"
	prop Style :: 0x01 | 0x02
	prop Label :: "System Stack Size (MAUs)"
	prop JSName :: "SYSSTACKSIZE"
	prop Visible :: GBL.DSPTYPE == 55 ? 1 : 0
	prop Writable :: 1
	prop NoGen :: 1
    }
     
    global SYSSTACKSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataMember($1)
	prop Label :: "System Stack Section (.sysstack)"
	prop JSName :: "SYSSTACKSEG"
	prop Visible :: GBL.DSPTYPE == 55 ? 1 : 0
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
	prop Set :: (
	    if (GBL.DSPTYPE == 55) {
	        (MEM.STACKSEG = $1), 
		(MEM.SYSSTACKSEG = $1)
		}
		else {
		(MEM.STACKSEG = $1)
		},
		"ok"
	)
	
 
    }
    global ENABLELOADSEG :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify Separate Load Addresses"
	prop JSName :: "ENABLELOADADDR"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global LOADBIOSSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .codeMember($1)
	prop Label :: "Load Address - BIOS Code Section (.bios)"
	prop JSName :: "LOADBIOSSEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global INITSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .codeMember($1)
	prop Label :: "Startup Code Section (.sysinit)"
	prop JSName :: "SYSINITSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Code"
    }
    global LOADINITSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .codeMember($1)
	prop Label :: "Load Address - Startup Code Section (.sysinit)"
	prop JSName :: "LOADSYSINITSEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global BIOSINITSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataCodeMember($1)
	prop Label ::"DSP/BIOS Init Tables (.gblinit)"
	prop JSName :: "GBLINITSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
    }
    global TRCINITSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataCodeMember($1)
	prop Label ::"TRC Initial Value (.trcdata)"
	prop JSName :: "TRCDATASEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
    }
    global LOADBIOSINITSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataCodeMember($1)
	prop Label ::"Load Address - DSP/BIOS Init Tables (.gblinit)"
	prop JSName :: "LOADGBLINITSEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global LOADTRCINITSEG ::= .TRCINITSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataCodeMember($1)
	prop Label ::"Load Address - TRC Initial Value (.trcdata)"
	prop JSName :: "LOADTRCDATASEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global SYSDATASEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataMember($1)
	prop Label :: "DSP/BIOS Kernel State (.sysdata)"
	prop JSName :: "SYSDATASEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
    }
    global CFGOBJSEG :: DARAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
	prop MemberTest :: .dataMember($1)
        prop Label :: "DSP/BIOS Conf Sections (.*obj)"
	prop JSName :: "OBJSEG"
        prop Visible :: 1
        prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
    }
    global NOHEAPS :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "No Dynamic Memory Heaps"
	prop JSName :: "NOMEMORYHEAPS"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    if ($1) {
		 
		.SEGZERO.iReqHeapCount--,
		.SEGZERO = MEM_NULL,
		.MALLOCSEG.iReqHeapCount--,
		.MALLOCSEG = MEM_NULL,
		TSK.STACKSEG.iReqHeapCount--,
		TSK.STACKSEG = MEM_NULL,
		scan ($i; MEM) {
		    if ($i.iAllocHeap && $i != MEM_NULL) {
			$i.iAllocHeap = 0,
			$i.iHeapSize = 0
		    }
		}
	    },
	    .NOHEAPS = $1,
	    "ok"
	)
	prop PropSetOkUserMsg :: (MEM.NOHEAPS == 1)?"Currently specified heaps no longer valid":"Please reconfigure heaps under individual mem segments"
    }
    global SEGZERO :: DARAM { 
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataNullMember($1) && $1.iAllocHeap)
	prop Label :: "Segment For DSP/BIOS Objects"
	prop JSName :: "BIOSOBJSEG"
	prop Visible :: 1
	prop Writable :: MEM.NOHEAPS == 0
	prop NoGen :: 0
        prop Set :: (
            if (.SEGZERO.iReqHeapCount > 0) {
                .SEGZERO.iReqHeapCount--
            },
            .SEGZERO = $1,
            .SEGZERO.iReqHeapCount++,
            "ok"
        )
    }
    global MALLOCSEG :: DARAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
	prop MemberTest :: (.dataNullMember($1) && $1.iAllocHeap)
        prop Label :: "Segment For malloc() / free()"
	prop JSName :: "MALLOCSEG"
        prop Visible :: 1
	prop Writable :: (MEM.NOHEAPS == 0)
	prop NoGen :: 0
        prop Set :: (
            if (.MALLOCSEG.iReqHeapCount > 0) {
                .MALLOCSEG.iReqHeapCount--
            },
            .MALLOCSEG = $1,
            .MALLOCSEG.iReqHeapCount++,
            "ok"
        )
    }
    global LNKCMDFILE :: "" {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify User Linker cmd File"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    
 
    global TEXTSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.codeMember($1))
	prop Label :: "Text Section (.text)"
	prop JSName :: "TEXTSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global LOADTEXTSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.codeMember($1))
	prop Label :: "Load Address - Text Section (.text)"
	prop JSName :: "LOADTEXTSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0 && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global SWITCHSEG :: GBL.DSPTYPE == 62 ? MEM.BSSSEG :(GBL.DSPTYPE == 55 && GBL.DSPSUBTYPE == 5561)? SARAM: MEM.TEXTSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1))
	prop Label :: "Switch Jump Tables (.switch)"
	prop JSName :: "SWITCHSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global LOADSWITCHSEG :: GBL.DSPTYPE == 62 ? MEM.BSSSEG :(GBL.DSPTYPE == 55 && GBL.DSPSUBTYPE == 5561)? SARAM: MEM.TEXTSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1))
	prop Label :: "Load Address - Switch Jump Tables (.switch)"
	prop JSName :: "LOADSWITCHSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0 && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global BSSSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "C Variables Section (.bss)"
	prop JSName :: "BSSSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global FARSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "C Variables Section (.far)"
	prop JSName :: "FARSEG"
	prop Visible :: GBL.DSPTYPE == 62 ? 1 : 0
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global CINITSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1))
	prop Label :: "Data Initialization Section (.cinit)"
	prop JSName :: "CINITSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global LOADCINITSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1))
	prop Label :: "Load Address - Data Initialization Section (.cinit)"
	prop JSName :: "LOADCINITSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0 && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    
    global PINITSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1))
	prop Label :: "C Function Initialization Table (.pinit)"
	prop JSName :: "PINITSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    
    global LOADPINITSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1))
	prop Label :: "Load Address - C Function Initialization Table (.pinit)"
	prop JSName :: "LOADPINITSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0 && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global CONSTSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "Constant Sections (.const, .printf)"
	prop JSName :: "CONSTSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global LOADCONSTSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "Load Address - Constant Sections (.const, .printf)"
	prop JSName :: "LOADCONSTSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0 && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global DATASEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "Data Section (.data)"
	prop JSName :: "DATASEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global CIOSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "Data Section (.cio)"
	prop JSName :: "CIOSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
	prop Set :: (
	    .CIOSEG = $1,
	    .SYSMEMSEG = $1,
	    "ok"
	)
    }
    global SYSMEMSEG ::= DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "Data Section (.sysmem)"
	prop JSName :: "SYSMEMSEG"
	prop Visible :: 0
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global STUBMEMSEG ::= HWI.STUBMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "Function Stub Memory (.hwi)"
	prop JSName :: "HWISEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Code"
	prop Set :: (
	    .STUBMEMSEG = $1,
	    HWI.STUBMEMSEG = $1,
	    "ok"
	)
    }
    
    global LOADSTUBMEMSEG :: HWI.STUBMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "Load Address - Function Stub Memory (.hwi)"
	prop JSName :: "LOADHWISEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
     
    global VECMEMSEG ::= HWI.VECMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "Interrupt Service Table Memory (.hwi_vec)"
	prop JSName :: "HWIVECSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Code"
	prop Set :: (
		.VECMEMSEG = $1,
		HWI.VECMEMSEG = $1,
		"ok"
	)
    }
    global LOADVECMEMSEG :: HWI.VECMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "Load Address -Interrupt Service Table Memory (.hwi_vec)"
	prop JSName :: "LOADHWIVECSEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global RTDXTEXTMEMSEG ::= RTDX.TEXTMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "RTDX Text Segment (.rtdx_text)"
	prop JSName :: "RTDXTEXTSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Code"
	prop Set :: (
	    .RTDXTEXTMEMSEG = $1,
	    RTDX.TEXTMEMSEG = $1,
	    "ok"
	)
    }
    global LOADRTDXTEXTMEMSEG :: RTDX.TEXTMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "Load Address - RTDX Text Segment (.rtdx_text)"
	prop JSName :: "LOADRTDXTEXTSEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    prop _spaceEnum :: (
	.ENUMSPACE
    )    
    global ENUMSPACE ::=
	GBL.DSPTYPE == 62
	    ? "code,data,code/data,reserved"
	    : GBL.DSPTYPE == 54
	        ? "code,data,io,other,reserved"
		: GBL.DSPTYPE == 28
		   ? "code,code/data,data,io,other,reserved"
                   : GBL.DSPTYPE == 55		 
                      ? "code/data,code,data,io,reserved"
	              : "code/data,io,reserved" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "ENUMSPACE"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    inst base :: 0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: GBL.DSPTYPE == 62 ? "0x%08x" : "0x%06x"
	prop Style :: 0x02
	prop Label :: "base"
	prop JSName :: "base"
	prop Visible :: 1
	prop Writable :: (.iIsModifiable)
	prop NoGen :: 1
	prop Set :: (
	    $e = "ok",
	    $a = .base,
	    .base = $1,
	    if (MEM.CALLBACKOBJ != nil) {
		$e = MEM.CALLBACKOBJ.call(self),
		if ($e != "ok") {
		    .base = $a
		}
	    },
	    $e
	)
    }
    inst len :: 0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: GBL.DSPTYPE == 62 ? "0x%08x" : "0x%04x"
	prop Style :: 0x08
	prop Label :: "len"
	prop JSName :: "len"
	prop Visible :: 1
	prop Writable :: (.memWritable)
	prop NoGen :: 0
	prop Set :: (
	    $e = "ok",
	    $a = .len,
	    .len = $1,
	    if (MEM.CALLBACKOBJ != nil) {
		$e = MEM.CALLBACKOBJ.call(self),
		if ($e != "ok") {
		    .len = $a
		}
	    },
	    "ok"
	)
    }
    inst page ::= (
	
 
	GBL.DSPTYPE == 62
	    ? -1
	    : (GBL.DSPTYPE == 55  || GBL.DSPTYPE == 28)
		? (.space == "code"
		    ? 0
		    : .space == "data"
                        ? 1
                        : .space == "io"
                            ? 2
		            : 0 )        
		:.space == "code"
	   	   ? 0
	   	   : .space == "data"
	               ? 1
	       	       : .space == "io"
	      	           ? 2
		           : 3) {	 
	prop Type  :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
	
    
 
    inst iAllocHeap :: MEM.NOHEAPS == 1 ? 0 : 1 {
	prop Type  :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "create a heap in this memory"
	prop JSName :: "createHeap"
	prop Visible :: 1
	prop Writable :: (.space == "data" || .space == "code/data")
		&& (MEM.NOHEAPS == 0) && .memWritable
	prop NoGen :: 0
	prop Set :: (
	    $a = "ok",
	    if ($1 == 0 && .iReqHeapCount > 0) {
	        .error("This heap is used by one or more of: segment for DSP/BIOS objects, segment for malloc()/free(), TSK default stack segment")
	    }
	    else {
		if ($1 == 0) {
		    .iUserHeapId = 0,
		    .iHeapId = @segment_name
		},
		.iAllocHeap = $1,
		MEM.gDirty = 1,
		$a
	    }
	)
    }
    inst iHeapSize :: 0x007F00/2 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: GBL.DSPTYPE == 62 ? "0x%08x" : "0x%04x"
        prop Style :: 0x02
        prop Label :: "heap size"
	prop JSName :: "heapSize"
        prop Visible :: 1
        prop Writable :: (.iAllocHeap) && (.iIsModifiable) && (MEM.NOHEAPS == 0)
        prop Set :: (
            .iHeapSize =  $1,
            "ok"
        )
        prop NoGen :: 1
    }
    inst iSegZero ::= MEM.SEGZERO
    inst iUserHeapId :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "enter a user defined heap identifier label"
	prop JSName :: "enableHeapLabel"
	prop Set :: (
	    if ($1 == 0) {
		.iHeapId = @segment_name
	    },
	    .iUserHeapId = $1,
	    "ok"
	)
	prop Visible :: 1
	prop Writable :: (.iAllocHeap) && (.iIsModifiable) && (.NOHEAPS == 0)
	prop NoGen :: 1
    }
    inst iHeapId :: @segment_name {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "heap identifier label"
	prop JSName :: "heapLabel"
	prop Set :: (
	    $e = .checkHeapId($1),
	    if ($e == "ok") {
		.iHeapId = $1
	    },
	    $e
	)
	prop Writable :: (.iAllocHeap) && (.iIsModifiable) && (.NOHEAPS == 0) &&(.iUserHeapId)
	prop Visible :: 1
	prop NoGen :: 0
    }
    prop checkHeapId :: (
	$e = "ok",
	scan ($i; MEM) {
	    if ($i.iAllocHeap == 1 && $i.iUserHeapId == 1 && $i.iHeapId == $1 && $i.iHeapId != @segment_name) {
		$e = .error ("This identifier label is already in use"),
		break
	    }
	},
	$e
    ) 
    inst iReqHeapCount :: 0 {	 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    inst space :: ( GBL.DSPTYPE == 55 ? "code/data" : "data") {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	
 
	prop Enum :: MEM._spaceEnum()
	prop JSName :: "space"
	prop Visible :: 1
	prop Writable :: (.memWritable)
	prop NoGen :: 1
	prop Set :: (
	    $e = "ok",
	    if ($1 != "data" && $1 != "code/data" && .iAllocHeap == 1) {
		$e =.error("Cannot select this space if a heap will be created")
	    }
	    else {
		$a = .space,
		.space = $1,
		if (MEM.CALLBACKOBJ != nil) {
		    $e = MEM.CALLBACKOBJ.call(self),
		    if ($e != "ok") {
			.space = $a
		    }
		}
	    },
	    $e
	)
    }
    inst dynamicLoading :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Reserved for dynamic loading"
	prop JSName :: "dynamicLoading"
	prop Visible :: GBL.ENABLEDLL
	prop Writable :: GBL.ENABLEDLL
	prop NoGen :: 1
    }
    inst iIsModifiable :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
}
object MEM_NULL :: MEM {
    param iComment :: "Place holder segment which allows user to disable heaps"
    param iAllocHeap :: 1
    param iIsUsed :: 0
}
 
type OBJ {
    isa ObjectMgr
    prop name :: "OBJ"
    prop Visible :: 0
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _objMemDesc, _memSeg, _placement"
	}
    )
    prop _objMemDesc :: ("%8t .obj: block(0x20000) {}")
    prop _memSeg :: MEM.CFGOBJSEG
    prop _placement :: (0x7fffff / 2)
}
 
type BUF {
    isa  ObjectMgr
    prop name :: "BUF"
    prop Label :: "BUF - Buffer Manager"
    prop IsContainedIn :: SYSTEM 
    prop GlobalIcon :: 199
    prop InstanceIcon :: 200
    prop InstanceHelpTopic :: (
	421
    )
    
    prop GlobalHelpTopic :: (
	321
    )
    prop InstancePropertyPage :: (
	"{B7240DE8-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
	"{B7240DE9-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    prop maxObjs :: (32767)
    
     
    prop AllocType :: (
      if (.gNumOf > 0) {
	"1\0,      _globalAllocDesc, _memSeg, _placement"
      }
    )
    prop _globalAllocDesc :: (
       "%8t.buf: block(0x20000){}"
    )
	    
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: .OBJMEMSEG
     
    prop AllocInst :: (
          "1\0, _instAllocDesc, _instMemSeg, _placement"
    )
    prop _instAllocDesc :: (
          "%8t .%0s$data: block(0x20000) align = 0x%1x {%12t\n %0s$databeg = .;\n .+= %2d; %8t\n }\0, _objAlign, _buflength"
    )
    prop _objAlign :: .align * 2   
    prop _instMemSeg :: .bufseg
    prop _buflength :: (.postalignsize *  .bufcount) * 2
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "buf.h" : ""
    
 
    prop cGenHInst :: (
	if (GBL.DSPTYPE == 62) {
	    "extern far BUF_Obj %0r;\n\0"
	}
	else {
	    "extern BUF_Obj %0r;\n\0"
	}
    )
    
    
 
    prop objectSize :: (
        if (GBL.DSPTYPE == 62) {
            $a = ((7 + 3) * 1)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
            $a = ((7 + 4) * 1)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {
            $a = ((7 + 3) * 1)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {
            $a = (12 + 6)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {
            $a = (12 + 6)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
            $a = (7 + 4)
        },
        if (GBL.DSPTYPE == 28) {
            $a = (12 + 6)
        },
        $a
    )
     
    prop dataSize :: (
	$d = 0,
	scan ($i; BUF) {
	    if ($i.IsConfObj()) {
		$d += $i.len 
	    },
	    $d += BUF.objectSize	
	},
	$d
    )
     
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global ENABLED :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Compile in logging"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
     
    inst bufseg :: .OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Memory segment for buffer pool"
	prop JSName :: "bufSeg"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
     
    inst bufcount :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Buffer count"
	prop JSName :: "bufCount"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    .bufcount = $1,
            .postalignsize = (.size + (.align - 1)) & ~(.align - 1),
	    .len = $1 * .postalignsize, 
	    "ok"
	)
    }
     
    inst size :: 4  { 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Buffer size (MADUs)"
	prop JSName :: "size"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
             if($1 < 4) { 
                .error("Size should be atleast 4 words")
             }
             else { 
	        .size = $1,
                .postalignsize = ($1 + (.align - 1)) & ~(.align - 1),
                .len = .postalignsize * .bufcount,
	        "ok"
             }
	)
    }
     
     inst align :: 2 { 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Buffer alignment(Power of 2)"
	prop JSName :: "align"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0 
	prop Set :: (
             if($1 < 2) { 
                .error("Alignment should be atleast 2 ")
             }
             else { 
	         .align = $1,
                 .postalignsize = (.size + ($1 - 1)) & ~($1 - 1),
                 .len = .postalignsize * .bufcount,
	         "ok"
             }
	 )
    }
     
    inst len :: .size {
	prop Label :: "Buffer pool length (MADUs)"
	prop JSName :: "len"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: 0
	prop NoGen :: 1
    }
     
    inst postalignsize :: .size {
	prop Label :: "Buffer size after alignment (MADUs)"
	prop JSName :: "postalignsize"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: 0
	prop NoGen :: 0
    }
    
}
 
type POOL {
    isa Module
    prop Visible :: 1
    prop name :: "POOL"
    prop Label :: "POOL - Allocator Manager"
    prop IsConfMod :: .USEPOOL 
    prop IsContainedIn :: SYSTEM
 
    prop GlobalIcon :: 199
    prop InstanceIcon :: 200
    prop GlobalHelpTopic :: (
	324
    )
    prop InstanceHelpTopic :: (
	424
    )
    prop InstancePropertyPage :: (
	"{473C4A62-B1A8-11d0-9885-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{473C4A63-B1A8-11d0-9885-0020AFEE33C6}"
    )
    prop DependsOn :: "MEM,BUF"
    global USEPOOL :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable Allocator Manager"
	prop JSName :: "ENABLEPOOL"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
}
 
 
type CLK {
    isa ObjectMgr
    prop name :: "CLK"
    prop Label :: "CLK - Clock Manager"
    prop IsContainedIn :: SCH
    prop IsConfMod :: 1 		 
    prop GlobalIcon :: 103
    prop InstanceIcon :: 104
    prop InstanceHelpTopic :: (
	202
    )
    prop GlobalHelpTopic :: (
	102
    )
    prop InstancePropertyPage :: (
	"{EEB2AB41-51E3-11d0-A61D-0000C070F3E9}"
    )
    prop GlobalPropertyPage :: (
	"{EEB2AB40-51E3-11d0-A61D-0000C070F3E9}"
    )
    prop objectSize :: (
	$a = (2 * 1),
	$a
    )
    prop GenLinkPrologue :: (
	"SECTIONS {%4t\n.%1L: block(0x20000), RUN_START(%1U_A_TABBEGb) {\n%8tCLK_F_gethtime = %5s;\n%8t%1U_A_TABBEG = %1U_A_TABBEGb / 2;\n %4S \n%4t} > %3s%6s\0, name, _objSize, _memSeg, _linkString, clkFxn, _memSegPg"
    )
    prop GenLinkEpilogue :: (
	"%0t}\n_CLK_PRD = CLK_PRD;\n_CLK_COUNTSPMS = CLK_COUNTSPMS;\n_CLK_REGS = CLK_REGS;\n_CLK_USETIMER = CLK_USETIMER;\n_CLK_TIMERNUM = CLK_TIMERNUM;\n_CLK_TCR = CLK_TCR;\n_CLK_TDDR = CLK_TDDR;\n\0"
    )
    prop _linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no CLK objs */"
    prop _memSeg :: CLK.OBJMEMSEG
    prop _memSegPg :: (
                        CLK.OBJMEMSEG.space() == "code"
                           ? " PAGE 0"
                           : CLK.OBJMEMSEG.space() == "data"
                                ? " PAGE 1"
                                : CLK.OBJMEMSEG.space() ==  "io"
                                     ? " PAGE 2"
                                     : " PAGE 0"
                      )
     
    prop _objSize :: 2 * .objectSize()
    prop clkFxn :: (.USETIMER == 1) ? .CLKFXN : @FXN_F_zero
    
    prop maxObjs :: (
	32767				 
    )
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    prop localInit :: (
	if (GBL.CALLBACKOBJ != CLK) {
	    CLK.gGBLChain = GBL.CALLBACKOBJ,
	    GBL.CALLBACKOBJ = CLK
	}
    )
    
    prop dataSize :: (
	.objectSize() * (CLK.gNumOf + 1)	 
    )
    prop localCanCreate :: (
	.USETIMER ? "ok" : .error ("The CLK Manager must be enabled before inserting a CLK")
    )
    prop localCreate :: (
	CLK.HOOKFXN = @_CLK_run,
	.seizeHwi(.WHICHHWI),
	"ok"
    )
    prop localDelete :: (
	if (.gNumOf == 1) {	 
	    CLK.HOOKFXN = @_CLK_reti,
	    .seizeHwi(.WHICHHWI)
	},
	"ok"
    )
    global gGBLChain :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
 	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: .USETIMER
	prop NoGen :: 1
    }
    global IMR0TINTMASK  ::  0x0
    {
	prop Visible :: 0
	prop Writable :: .USETIMER
	prop NoGen :: 0
    }
    global IMR1TINTMASK  :: 0x80
    {
	prop Visible :: 0
	prop Writable :: .USETIMER
	prop NoGen :: 0
    }
    global WHICHHWI :: (
	.WHICHTIMER == "Timer 0" ? Timer_0.iHwi :
	.WHICHTIMER == "Timer 1" ? Timer_1.iHwi : Timer_2.iHwi
	)  
	{
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: HWI
	prop Label :: "CPU Interrupt"
	prop Visible :: 1
	prop Writable :: 0
	prop NoGen :: 1
    }
    global INTBIT ::= (
	.WHICHTIMER == "Timer 0" ? 7 :
	.WHICHTIMER == "Timer 1" ? 6 : 8
	)
        {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: .USETIMER 
	prop NoGen :: 0
    }
									
    global TIMERIMRMASK ::= ( 1 << (.WHICHHWI.iId % 16) )
    {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: .USETIMER 
	prop NoGen :: 0
    }
    global WHICHTIMER :: "Timer 0"
    {
	prop Label :: "Timer Selection"
 	prop JSName :: "TIMERSELECT"
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "Timer 0,Timer 1,Timer 2"
	prop Visible :: 1
	prop Writable :: .USETIMER 
	prop NoGen :: 1
	prop Set :: (
	    if (.WHICHTIMER != $1) {
		if (.USETIMER == 0) {
		    $e = "ok"
		}
		else {
		    if ($1 == "Timer 0") {
			$a = Timer_0.iHwi
		    }
		    else  {
		    	  if ($1 == "Timer 1") {
			 	 $a = Timer_1.iHwi
				 }
			  else  {
			 	$a = Timer_2.iHwi
			  	}
			     },
		    	$e = .seizeHwi($a)
		    	  },
		if ($e == "ok") {
		    .releaseHwi(.WHICHHWI),
	            if ($1 == "Timer 0") {
                        .seizeTimer("Timer 0")
		    }
	            else { 
			    if ( $1 ==  "Timer 1") {
                                .seizeTimer("Timer 1")
			 	}
			   else  {
                                 .seizeTimer("Timer 2")
                                 }
			   },
	            .WHICHTIMER = $1,
		    .HOOKFXN = .gNumOf > 0 ? @_CLK_run :  @_CLK_reti,
		    .seizeHwi(.WHICHHWI)
	        },
		$e
	    }
	) 
    }
    global REGS :: 0x02800 {	 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
    }
 
    global TIMERIMR :: 0x45  { 	 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
    }
    global TIMERIFR :: 0x46  {	 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
    }
    global TIMERNUM ::  0
    {	 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	 
	 	
	prop Visible :: 0
	prop NoGen :: 0
    }
    global USETIMER :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable CLK Manager"
 	prop JSName :: "ENABLECLK"
	prop Visible :: 1
	prop Writable :: .gNumOf > 0 ? 0 : 1
	prop NoGen :: 0
	prop Set :: (
	    if ($1 == 1 && .USETIMER == 0) {
                .WHICHHWI = Timer_0.iHwi,
                .WHICHTIMER = "Timer 0",
		if (($e = .seizeHwi(.WHICHHWI)) != "ok") {
                    .WHICHHWI = Timer_1.iHwi,
                    .WHICHTIMER = "Timer 1",
		    if (($e = .seizeHwi(.WHICHHWI)) != "ok") {
                        .WHICHHWI = Timer_2.iHwi,
                        .WHICHTIMER = "Timer 2",
		        if (($e = .seizeHwi(.WHICHHWI)) != "ok") {
                            $e
                        }
                    }
                },
                if ( $e == "ok") {
		    .USETIMER = 1,
	    	    .TIMEFXN = CLK.HIRES ? CLK.clkFxn() : @_CLK_getltime,
    		    .HOOKFXN = .gNumOf > 0 ? @_CLK_run : @_CLK_reti,
		    .seizeHwi(.WHICHHWI),
                    .seizeTimer(".WHICHTIMER"),
		    GlobalStatus.gDirty = 1,
		    if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {
			.releaseHwi(.WHICHHWI),
			.TIMEFXN = @FXN_F_zero,
			.HOOKFXN = @FXN_F_nop,	
			.USETIMER = 0,
			GlobalStatus.gDirty = 1,
			.error("Current stack size inadequate to enable CLK")
			}
		else
		{
		        if (GBL.ENABLEINST == 1) {
		        IDL_busyObj.Create("IDL"),
			IDL.USEIDLBUSYOBJ = 1,
		        IDL_cpuLoad.Create("IDL"),
                        IDL.AUTOCALCULATE = GBL.OLDAUTOCALCULATE
			  },
			  "ok"
			}
	           },
		 $e
		}
	    else {
		if ($1 == 0 && .USETIMER == 1) {
			.releaseHwi(.WHICHHWI),
			.TIMEFXN = @FXN_F_zero,
			
 
			.HOOKFXN = @FXN_F_nop,	
			.USETIMER = 0,
		        if (GBL.ENABLEINST == 1) {
			    IDL_busyObj.Delete("IDL"),
			    IDL.USEIDLBUSYOBJ = 0,
			    IDL_cpuLoad.Delete("IDL"),
                            GBL.OLDAUTOCALCULATE = IDL.AUTOCALCULATE,
                            IDL.AUTOCALCULATE = 0
			},
			"ok"
		}
		else {
		    "ok"
		}
	    }
	)
    }
    
    global HIRES ::= 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Use high resolution time for internal timings"
 	prop JSName :: "HIRESTIME"
	prop Visible :: 1
	prop Writable :: .USETIMER
	prop NoGen :: 1
	prop Set :: (
	    if (CLK.USETIMER) {
		CLK.HIRES = $1,
		if (CLK.USETIMER) {
		        CLK.TIMEFXN = CLK.HIRES ? CLK.clkFxn() : @_CLK_getltime
		},
		"ok"
	    }
	    else {
		.error("CLK Manager must be enabled in order to get high resolution timings.")
	    }
	)
    }
    global INSTRPERCLK :: 1 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
     
    global MICROSECONDS :: (((float((CLK.PRD)) + 1) * ((CLK.PRDMULTFACTOR) ) * 2 / GBL.MIPS)) {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style :: 0x04
	prop Format :: "%.4f"
	prop Label :: "Microseconds/Int"
 	prop JSName :: "MICROSECONDS"
	prop Set :: (
	    .setMicroseconds($1)
	)
	prop Visible :: 1
	prop Writable :: ((CLK.PROGTIMREGS != 0) | (.USETIMER == 0)) ? 0 : 1
	prop NoGen :: 1
    }
    
    global MICROSECS :: int(round(.MICROSECONDS)) {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style ::  0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global PROGTIMREGS ::= 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Directly configure on-chip timer registers"
	prop JSName :: "CONFIGURETIMER"
	prop Visible :: 1
	prop Writable :: .USETIMER
	prop NoGen :: 1
    }
    global TCR :: = 0x20 | CLK.TDDR {	 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global FIXTDDR :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Fix TDDR"
 	prop JSName :: "FIXTDDR"
	prop Visible :: 1
	prop Writable :: CLK.PROGTIMREGS
	prop NoGen :: 1
    }
					 
    global TDDR ::= 0 {
	prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "0,1,2,3,4,5,6,7"	
	prop Label :: "PTV  Register"
 	prop JSName :: "TCRPTV"
	prop Set :: (
	    CLK.TDDR = $1,
	    if ( .TDDR == 0)  { .PRDMULTFACTOR  = 0x2  }, 
	    if ( .TDDR == 1)  { .PRDMULTFACTOR  = 0x4  }, 
	    if ( .TDDR == 2)  { .PRDMULTFACTOR  = 0x8  }, 
	    if ( .TDDR == 3)  { .PRDMULTFACTOR  = 0x10  }, 
	    if ( .TDDR == 4)  { .PRDMULTFACTOR  = 0x20  }, 
	    if ( .TDDR == 5)  { .PRDMULTFACTOR  = 0x40  }, 
	    if ( .TDDR == 6)  { .PRDMULTFACTOR  = 0x80  }, 
	    if ( .TDDR == 7)  { .PRDMULTFACTOR  = 0x100  }, 
	    if (CLK.CALLBACKOBJ != nil) {
		CLK.CALLBACKOBJ.call()
	    },
	    CLK.MICROSECONDS = ((float((CLK . PRD)) + 1) * ((CLK . PRDMULTFACTOR) ) * 2 / GBL . MIPS),
	    "ok"
	)
	prop Visible :: 1 
	prop Writable :: CLK.PROGTIMREGS
	prop NoGen :: 0  
    }
 
    global TDDRHIGH ::= ((.TDDR & 0xffff0000) >> 16) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    
    global PRDMULTFACTOR ::  2  {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible ::  0
	prop Writable ::  0
	prop NoGen :: 1 
	}
    
    global PRD ::= (int(round((1000.0 * (GBL.MIPS/2)/CLK.PRDMULTFACTOR))) - CLK.adjustPrd)  {  
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style ::  0x20
	prop Label :: "LOAD_TIM Register"
 	prop JSName :: "LOAD_TIM"
	prop Set :: (
	    CLK.PRD = $1,
	    CLK.MICROSECONDS = ((float((CLK.PRD)) + 1) * ((CLK.PRDMULTFACTOR) ) * 2 / GBL.MIPS),
     	    .COUNTSPMS = (int(round(GBL.MIPS * 1000 / (CLK.PRDMULTFACTOR) / 2))), 
    	    .COUNTSPMSHIGH =  ((.COUNTSPMS & 0xffff0000) >> 16), 
	    if (CLK.CALLBACKOBJ != nil) {
		CLK.CALLBACKOBJ.call()
	    },
	    "ok"
	)
	prop Visible :: 1
	prop Writable :: ((.PROGTIMREGS) && (.USETIMER)) ? 1 : 0
	prop NoGen :: 0
    }
 
    global PRDHIGH ::= ((.PRD & 0xffff0000) >> 16) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
 
    global COUNTSPMS ::= int(round(GBL.MIPS * 1000.0 / (CLK.PRDMULTFACTOR) / 2)) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
    }
    
    global COUNTSPMSHIGH ::= ((.COUNTSPMS & 0xffff0000) >> 16) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    prop adjustPrd :: 1
      	 
    prop seizeHwi :: (
      if ($1.client == "USER" && $1 == HWI_UNUSED) {
	  .error("Interrupt not mapped for selected timer.")
      }
      else {
	if ($1.client == "USER" && $1.function != @HWI_unused) {
	    .error("Interrupt mapped to selected timer is already in use.")
	}
	else {
	    if( $1.client == "CSL") {
	    .error("Interrupt mapped to selected timer is already in use by CSL.")
	    }
	    else {
	    	$1.function = @CLK_F_isr,
	    	$1.client = "CLK",
	    	$1.iUseDispatcher = (CLK.HOOKFXN == @_CLK_run ? 1 : 0),
	    	$1.iArg = ($1.iUseDispatcher == 1 ? @CLK_A_TABBEG : 0),
	    	HWI.gDirty = 1,
	    	"ok"
	    }
	}
      }
    )
    prop releaseHwi :: (
	$1.function = @HWI_unused,
	$1.client = "USER",
	$1.iUseDispatcher = 0,
	$1.iArg = 0,
	HWI.gDirty = 1,
	"ok"
    )
    prop seizeTimer :: (
        if( $1 == "Timer 0") {
            .WHICHTIMER = "Timer 0",
            .WHICHHWI = Timer_0.iHwi,
            .REGS = 0x02800,
            .TIMERNUM = 0,
            .TIMERIMR = 0x45,
            .TIMERIFR = 0x46,
            .INTBIT = 7,
            .IMR0TINTMASK = 0x0,
            .IMR1TINTMASK = .WHICHHWI.Ier1Mask,
            .setMicroseconds(.MICROSECONDS)
        }
        else {
            if( $1 == "Timer 1") {
                .WHICHTIMER = "Timer 1",
                .WHICHHWI = Timer_1.iHwi,
                .REGS = 0x2c00,
                .TIMERNUM = 1,
                .TIMERIMR = 0x45,
                .TIMERIFR = 0x46,
                .INTBIT = 6,
                .IMR0TINTMASK =  0x0,
                .IMR1TINTMASK =  .WHICHHWI.Ier1Mask,
                .setMicroseconds(.MICROSECONDS)
            }
            else {
                if( $1 == "Timer 2") {
                    .WHICHTIMER = "Timer 2",
                    .WHICHHWI = Timer_2.iHwi,
                    .REGS = 0x3000,
                    .TIMERNUM = 2,
                    .TIMERIMR = 0x0,
                    .TIMERIFR = 0x1,
                    .INTBIT = 8,
                    .IMR0TINTMASK = .WHICHHWI.Ier0Mask,
                    .IMR1TINTMASK = 0x0,
                    .setMicroseconds(.MICROSECONDS)
                }
            }
        },
        .TIMERIMRMASK = 1 << (.WHICHHWI.iId % 16),
            "ok"
    )
    
    prop setMicroseconds :: (
	$e = 0x7fffffff,
	$c =  float((0x100) * (float(float($e) + .adjustPrd + 0.5)) *2 / GBL.MIPS),
	 	
	if ($1 > 0.1) {
	    $d = $1 *GBL.MIPS/2,
	    $d = $d/2,
	    if ($d <= $e ) {
	      .PRD = int($d) - 1,
	       .TDDR = 0,
	       .PRDMULTFACTOR = 2
	     }
	     else
	     {
		$d =  $d /2 ,
		if (  $d <= $e)
		{
	    	  .PRD = int($d) - 1,
		  .TDDR = 1,
	          .PRDMULTFACTOR = 4
		}
		else
		{
		  $d =  $d /2 ,
		  if (  $d <= $e)
		  {
	   	    .PRD = int($d) - 1,
		    .TDDR = 2,
	            .PRDMULTFACTOR = 8
		  }
		  else
		  {
		    $d =  $d/2 ,
		    if (  $d <= $e)
		    {
	   	      .PRD = int($d) - 1,
		      .TDDR = 3,
	              .PRDMULTFACTOR = 0x10
		     }
		     else
		     {
		       $d =  $d /2 ,
		       if (  $d <= $e)
		       {
	   	         .PRD = int($d) -1 ,
		         .TDDR =  4,
	                 .PRDMULTFACTOR = 0x20
		       }
		       else
		       {
		         $d =  $d/2,
		         if (  $d <= $e)
		         {
	   	           .PRD  = int($d) -1,
		           .TDDR = 5,
	                   .PRDMULTFACTOR = 0x40
		         }
		         else
		         {
		           $d =  $d /2 ,
		           if (  $d <= $e)
		           {
	   	             .PRD =  int($d) - 1,
		             .TDDR = 6,
	              	     .PRDMULTFACTOR = 0x80
		           }
			   else
			   {
		              $d =  $d /2 ,
	   	             .PRD = int($d) - 1,
		             .TDDR =  7,
	                     .PRDMULTFACTOR = 0x100
			   }
		         }
		       }
		     }
		   }
		  }
		},
	    .MICROSECONDS = ((float((.PRD)) + 1) * ((.PRDMULTFACTOR) ) * 2 / GBL.MIPS),
	    if (.CALLBACKOBJ != nil) {
		.CALLBACKOBJ.call()
	    },
	    "ok"
	}
	else {
	    .error("The on-chip timer does not have enough range to support this combination of DSP MIPS and Microseconds/Int")
	}
    )
    
 
    prop call :: (
	$a = ((float((CLK.PRD)) + 1) * ((CLK.PRDMULTFACTOR) ) * 2 / GBL.MIPS),
	$b = CLK.MICROSECONDS,
	$e = "ok",
	if (($e = .setMicroseconds(CLK.MICROSECONDS)) == "ok") {
	    if (CLK.gGBLChain != nil) {
		$e = CLK.gGBLChain.call()
	    },
	    if ($e != "ok") {
		.setMicroseconds($b),
		.error($e)
	    }
	    else {
		"ok"
	    }
	}
	else {
	    $e
	}
    )
    global INSTRUCTIONS ::= (
	1.0 * (float(CLK.PRD) + 1) * (CLK.PRDMULTFACTOR) * 1 * 2
    ) {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style :: 0x04
	prop Format :: "%.0f"
	prop Label :: "Instructions/Int"
	prop Visible :: 1
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    global TIMEFXN ::= CLK.clkFxn() {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
 
    global HOOKFXN ::= (.gNumOf > 0 ? @_CLK_run : @_CLK_reti) {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    
    global CLKFXN ::= (CLK.PRD == 0xfffffffff ) ? @_CLK_getfhtime : @_CLK_getshtime
		{
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
 
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
   
 
    global CLKDIV ::=  2
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global CALDIV ::= 1 
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global CALMULT ::= .PRDMULTFACTOR * 2
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global HTIMEDIV ::= 1
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global HTIMEMULT ::= .PRDMULTFACTOR * 2
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global LTIMEDIV ::=  1
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global LTIMEMULT ::= (.PRDMULTFACTOR * .PRD * 2)
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global HTIMEPERLTIME ::=  (.PRD + CLK.adjustPrd)
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst function :: @FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "function"
 	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
     
    inst Order :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
	prop NoGen :: 1
	prop Writable :: 1
    }
     
    inst iPri :: 0 {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}
 
type PRD {
    isa ObjectMgr
    prop name :: "PRD"
    prop Label :: "PRD - Periodic Function Manager"
    prop IsContainedIn :: SCH
    
    prop IsConfMod :: 1
    prop GlobalIcon :: 119
    prop InstanceIcon :: 120
    prop InstanceHelpTopic :: (
	210
    )
    
    prop GlobalHelpTopic :: (
	110
    )
    prop InstancePropertyPage :: (
	"{B7240DE0-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
	"{B7240DE1-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
 
    prop STSGetMaxFmt :: (
	"%g ticks"
    )
    prop STSGetSumFmt :: (
	PRD.STSGetMaxFmt()
    )
    prop STSGetAvgFmt :: (
	"%.2f ticks"
    )
    prop GetPeriod :: .period
    prop IsOneShot :: .mode == "one-shot" ? 1 : 0
    prop objectSize :: (
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
	    $a = (10 * 1)
	},
	if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {
	    $a = (9 * 1)
	},
	if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
	    $a = (12 * 1)
	},
	if (GBL.DSPTYPE == 28 ||
	   (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") ||
	   (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE")) {
	    $a = (12 * 1)
	},
	if (GBL.DSPTYPE == 62) {
	    $a = (8 * 1)
	},
	$a
    )
    prop GenLinkPrologue :: (
        "SECTIONS {%4t\n.prd: block(0x20000) RUN_START(PRD_A_TABBEGb), RUN_END(PRD_A_TABENDb) {%8t\nPRD_A_TABBEG = PRD_A_TABBEGb / 2;%8t\nPRD_A_TABEND = PRD_A_TABENDb / 2;%4t\n} > %1s%2s\0, memSeg, pageString"
    )
    
    prop GenLinkEpilogue :: (
        "%0t}\nPRD_A_TABLEN = %1d;\n\0, numInst"
    )
    prop linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop pageString :: GBL.DSPTYPE == 62
                      ? ""
                      : (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28)
                      ? (
                          PRD.OBJMEMSEG.space() == "code"
                          ? " PAGE 0"
                          : PRD.OBJMEMSEG.space() == "data"
                            ? " PAGE 1"
                            : PRD.OBJMEMSEG.space() == "io"
                              ? " PAGE 2"
                              : " PAGE 0"
                        )
                      : " PAGE 1"
    prop memSeg :: PRD.OBJMEMSEG
    prop objSize :: GBL.DSPTYPE == 55 ? .objectSize() * 2 : .objectSize()
    prop numInst :: (
    	PRD.gNumOf
    )
    prop dataSize :: (
	.objectSize() * PRD.gNumOf
    )
    prop localInit :: (
	if (CLK.CALLBACKOBJ != nil) {
	    .error("PRD initialization failure")
	},
	CLK.CALLBACKOBJ = PRD,
	if (PRD.USECLK && PRD_clock.iIsUsed == 0) {
	    PRD_clock.Create("PRD")
	},
	if (PRD_clock.iIsUsed == 1) {
	  if (.gNumOf == 0) {
            if (TSK.USETSK == 1 && TSK.TSKTICK == "PRD") {
  	      PRD_clock.function = @PRD_F_tick
            }
            else {
  	      PRD_clock.function = @FXN_F_nop
            }
          }
          else {
  	    PRD_clock.function = @PRD_F_tick
          }
        }
    )
    prop localCanCreate :: (
	if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {
	  .error(" System Stack Size too small")
	  }
        else {
	.myCreate("can")
	}
    )
    
    prop localCreate :: (
	STS.gNumEmbed += 1,
	if (($a = .myCreate("do")) == "ok") {
	  if (PRD_clock.iIsUsed == 1) {
	    if (.gNumOf == 0) {
  	      PRD_clock.function = @PRD_F_tick
            }
          }
        },
        $a
    )
    
    prop localCanDelete :: (
	.myDelete("can")
    )
    prop localDelete :: (
	STS.gNumEmbed -= 1,
	if (($a = .myDelete("do")) == "ok") {
	  if (.gNumOf == 1) {
	    if (PRD_clock.iIsUsed == 1) {
              if (TSK.USETSK == 1 && TSK.TSKTICK == "PRD") {
  	        PRD_clock.function = @PRD_F_tick
              }
              else {
  	        PRD_clock.function = @FXN_F_nop
              }
            }
	  }
	},
        $a
    )
    
    prop maxObjs :: (
	32767				 
    )
    prop myCreate :: (
	if (PRD_swi.function != @PRD_F_swi) {
	    PRD_swi.function = @PRD_F_swi
	},
	if (PRD_swi.iIsUsed) {
	    "ok"
	}
	else {
	    if (SWI.CanCreate() == "ok") {
		if ($1 == "do") {
		    if (KNL_swi.iIsUsed == 1 && PRD_swi.pri == 0) {
			PRD_swi.pri = 1
		    },
		    PRD_swi.Create("PRD")
		}
		else {
		    "ok"
		}
	    }
	    else {
		.error("Can't create an SWI for PRD (try deleting a SWI)")
	    }
	}
    )
    
    prop myDelete :: (
	if (PRD_swi.function != @PRD_F_swi) {
	    PRD_swi.function = @PRD_F_swi
	},
	if (.gNumOf == 1) {
	    if ($1 == "do") {
		PRD_swi.Delete("PRD")
	    }
	    else {
		"ok"
	    }
	}
	else {
	    "ok"
	}
    )
    
 
    prop call :: (
	if (CLK.USETIMER != 0) {
	    PRD.MICROSECONDS = CLK.MICROSECONDS
	},
	PRD.CALLBACKOBJ.call()
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "prd.h" : ""
    
 
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far PRD_Obj %0r;\n\0"
	}
	else {
	    "extern PRD_Obj %0r;\n\0"
	}
    )
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global USECLK :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Use CLK Manager to drive PRD"
	prop JSName :: "USECLK"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    if ($1 == 1 && .USECLK == 0) {
		if (CLK.USETIMER == 0) {
		    .error("In order to drive periodic functions, the CLK Manager must be enabled")
		}
		else {
		    .USECLK = 1,
		    .MICROSECONDS = CLK.MICROSECONDS,
		    CLK.CALLBACKOBJ = PRD,
		    PRD_clock.Create("PRD"),
		    GlobalStatus.gDirty = 1,
		    if (GlobalStatus.MinStackSize >= MEM.STACKSIZE){
                      .USECLK = 0,
		      .MICROSECONDS = 0.0,
                      CLK.CALLBACKOBJ = nil,
                      PRD_clock.Delete("PRD"),
                      .error("Current Stack size inadequate to enable this option")
		      }
		    else {
		      "ok"
		    }
		}
	    }
	    else {
		if ($1 == 0 && .USECLK == 1) {
		    .USECLK = 0,
		    .MICROSECONDS = 0.0,
		    CLK.CALLBACKOBJ = nil,
		    PRD_clock.Delete("PRD")
		},
		      "ok"
	    }
	)
	prop NoGen :: 1
    }
   
    
     
    global MICROSECONDS ::= CLK.MICROSECONDS {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style :: 0x04
	prop Format :: "%.1f"
	prop Label :: "Microseconds/Tick"
	prop JSName :: "MICROSECONDS"
	prop Visible :: 1
	prop Writable :: .USECLK == 0
	prop NoGen :: 1
    }
    global SCALAR ::= (		 
	$d = 2,
	$f = 0,
	
 
	while ($d <= 0x4000 && $f == 0) {
	    scan ($i; PRD) {
		if ((($i.period / $d) * $d != $i.period)) ||
		    ($i.mode == "one-shot") {
		    $f = 1
		}
	    },
	    if ($f == 0) {
		$d = 2 * $d
	    }
	},
	$d / 2
    ) {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
     
    prop DEFAULT_THOOKFXN :: @KNL_tick_stub 
    global THOOKFXN :: .DEFAULT_THOOKFXN {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "System Tick Hook Function"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
    }
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst period :: 0x7fff {	 
	prop Label :: "period (ticks)"
	prop JSName :: "period"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    if (($1 > 0) && ($1 < 0x8000)) {
		.period = $1,
		.gDirty = 1,
		"ok"
	    }
	    else {
		.error("Periodic function periods must be greater than 0 and less than 0x8000")
	    }
	)
    }
    inst mode :: "continuous" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "continuous,one-shot"
	prop JSName :: "mode"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst function :: @FXN_F_nop {	 
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst arg0 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg0"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst arg1 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg1"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst milliseconds ::= (
	(.period * PRD.MICROSECONDS) / 1000.0
    ) {
	prop Label :: "period (ms)"
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style :: 0x04
	prop Format :: "%.1f"
	prop Visible :: 1
	prop Writable :: 0
	prop NoGen :: 1
    }
     
    inst Order :: 0 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
        prop NoGen :: 0
        prop Writable :: 1
    }
     
    inst iPri :: 0 {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
    
 
    inst filter :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "filter"
	prop NoGen :: 0
    }
    inst maxformat :: "%g ticks" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "maxformat"
	prop NoGen :: 0
    }
    inst sumformat :: "%g ticks" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "sumformat"
	prop NoGen :: 0
    }
    inst avgformat :: "%.2f ticks" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "avgformat"
	prop NoGen :: 0
    }
    
 
    inst unittype :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "unittype"
	prop NoGen :: 0
    }
}
 
object PRD_swi :: SWI {
    param function :: @PRD_F_swi
    param iComment :: "This Software ISR executes all configured PRD functions"
    param iDelUser :: "PRD"
    param iDelMsg  :: (
	"This object is automatically deleted when all PRD objects are deleted"
    )
}
 
object PRD_clock :: CLK {
    param function :: @PRD_F_tick
    param iComment :: "This clock function calls PRD_tick from within the on-chip timer ISR"
    param iDelUser :: "PRD"
    param iDelMsg  :: (
	"This object is automatically deleted by disabling the 'Use CLK Manager to drive PRD' option of PRD"
    )
}
 
type RTDX {
    isa ObjectMgr
    prop Label :: "RTDX - Real-Time Data Exchange Settings"
    prop name :: "RTDX"
    prop IsConfMod :: .USERTDX		
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 145
    prop InstanceIcon :: 146
    prop GlobalHelpTopic :: (
	113
    )
    prop InstanceHelpTopic :: (
	213	
    )
    prop InstancePropertyPage :: (		
	"{f80273c0-3838-11d2-a32c-006097656921}"
    )
    
    prop GlobalPropertyPage :: (		
	"{050a0600-3839-11d2-a32c-006097656921}"
    )
    prop AllocType :: (.USERTDX ?
	"2\0, _rtdxDataAllocDesc, _rtdxDataSeg, _placement,
	     _rtdxTextAllocDesc, _rtdxTextSeg, _placement"
	:
	""
    )
    prop _rtdxDataAllocDesc :: (
	" .%1L_data: block(0x20000){} \0, name"	
    )
    prop _rtdxTextAllocDesc :: (
	if (MEM.ENABLELOADSEG == 1) {
	    if (MEM.RTDXTEXTMEMSEG == MEM.LOADRTDXTEXTMEMSEG) {
		" .%1L_text: {} \0, name"	
	    }
	    else {
		" .%1L_text: {} load > %2s%3s, run \0, name, _loadRtdxTextMemSeg, _rtdx_textpg"
	    }
	}
	else {
	    " .%1L_text: {} \0, name"
	}
    )
    prop _rtdxDataSeg :: RTDX.DATAMEMSEG
    prop _rtdxTextSeg :: MEM.RTDXTEXTMEMSEG
    prop _loadRtdxTextMemSeg :: MEM.LOADRTDXTEXTMEMSEG
    prop _placement :: (0x7fffff / 2)
    prop _objSize :: RTDX.BUFMEMSIZE
    prop _rtdx_textpg :: (
        (MEM.LOADRTDXTEXTMEMSEG.space() == "code/data")
           ? " PAGE 0"
           : (MEM.LOADRTDXTEXTMEMSEG.space() == "code")
                ? " PAGE 1"
                : (MEM.LOADRTDXTEXTMEMSEG.space() ==  "data")
                     ? " PAGE 2"
                     : " PAGE 3"
    )
    prop GenLinkPrologue :: (.USERTDX ?
         "_RTDX_interrupt_mask = 0x%1x;\n\0, _interruptMask"
	:
	""
    )
    prop _interruptMask :: RTDX.MASK
     
    prop cGen :: 1
    
    
 
    prop noObjectAlias :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "rtdx.h" : ""
    
 
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
            if (.iChannelMode == "output") {
	        "extern far RTDX_outputChannel %0r;\n\0"
	    }
	    else {
	        "extern far RTDX_inputChannel %0r;\n\0"
	    }
	}
        else {
            if (.iChannelMode == "output") {
                "extern RTDX_outputChannel %0r;\n\0"
	    }
	    else {
	        "extern RTDX_inputChannel %0r;\n\0"
	    }
        }
    )
    prop cGenCInst :: (
	if (.iChannelMode == "output") {
	    "RTDX_CreateOutputChannel(%0r);\n\0"
	}
	else {
	    "RTDX_CreateInputChannel(%0r);\n\0"
	}
    )
    prop dataSize :: (
	$d = 0,
	if (.USERTDX) {
	    $d = RTDX.BUFMEMSIZE
	}
	else {
	    $d = 0
	},
	scan ($a; RTDX) {
	    if ($a.iChannelMode == "output") {
		$d += 1
	    }
	    else {
		$d += 3
	    }
	},
	$d
    )
    prop localCanCreate :: (
	$e = "ok",
	if (RTDX.USERTDX != 1) {
	    $e = .error("RTDX manager not enabled")
	},
	$e
    )
    global USERTDX ::= 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable Real-Time Data Exchange (RTDX)"
	prop JSName :: "ENABLERTDX"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
        prop Set :: (
            if($1 == 0) {
                if(HST.LNKTYPE == "RTDX") {
                    .error("RTDX is being used by HST; select a different host link type before attempting to disable RTDX") 
                }
                else {
		    if (.gNumOf > 0) {
			.error("Cannot disable RTDX until all RTDX objects are deleted.")
		    }
		    else {
		        GlobalStatus.gDirty = 1,    
                        .USERTDX = $1,
	                if (RTDX.CALLBACKOBJ != nil) {
		            RTDX.CALLBACKOBJ.call()
                        },
                        "ok"
		    }
                }
            }
	    else {
		GlobalStatus.gDirty = 1,	 
                .USERTDX = $1,
		if (RTDX.CALLBACKOBJ != nil) {
		    RTDX.CALLBACKOBJ.call()
                },
                "ok"
	    }
        )
    }
    global USERTEXECUTION ::= 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable Real-Time Execution Control"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global RTDXTYPE :: "JTAG" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "JTAG,Simulator"
	prop Label :: "RTDX Mode"
	prop JSName :: "MODE"
	prop Visible :: 1
	prop Writable :: .USERTDX
	prop NoGen :: 0
	prop Set :: (
	    .RTDXTYPE = $1,
	    if (RTDX.CALLBACKOBJ != nil) {
		RTDX.CALLBACKOBJ.call()
	    },
	    "ok"
	)
     }
    global DATAMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "RTDX Data Segment (.rtdx_data)"
	prop JSName :: "RTDXDATASEG"
	prop Visible :: 1
	prop Writable :: 1 
	prop NoGen :: 0
    }
    
 
    global BUFMEMSIZE ::= (256 + 2) * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE) {  
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop Label :: "RTDX Buffer Size (MAUs)"
	prop JSName :: "BUFSIZE"
	prop Visible :: 1
	prop Writable :: .USERTDX 
	prop NoGen :: 0
        prop Set :: (
	    if (HST.RTDX == 0) {
                .BUFMEMSIZE = $1,
		GlobalStatus.gDirty = 1,	 
		"ok"
	    }
	    else {
                if ($1 < (HST.MAXFRAMESET + 3) * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) {
                    .error("size (in MAUs) must be at least: (largest configured HST channel framesize in words + 3) * (MAUs per word)")
                }
                else {
                    .BUFMEMSIZE = $1,
		    GlobalStatus.gDirty = 1, 	 
		    if (HST.LNKTYPE == "RTDX") {
			HST.MAXFRAMEALLOWED = (.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 3,
			"ok"
		    }
		    else {
			"ok"
		    }
                }
	    }
        )
    }
    global TEXTMEMSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "RTDX Text Segment (.rtdx_text)"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    global MASK :: 0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%08x"
	prop Style :: 0x02
	prop Label :: "RTDX Interrupt Mask"
	prop JSName :: "INTERRUPTMASK"
	prop Visible :: 1
	prop Writable :: .USERTDX 
	prop NoGen :: 1
	prop Set :: (
	    .MASK = $1,
	    "ok"
	)
    }
    
    inst iChannelMode :: "output" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Channel Mode"
	prop JSName :: "channelMode"
	prop Enum :: "input,output"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    GlobalStatus.gDirty = 1,
	    .iChannelMode = $1,
	    "ok"
	)
    }
    
 
     global CALLBACKOBJ :: nil {
	 prop Visible :: 0
	 prop Writable :: 0
	 prop NoGen :: 1
    }
}
 
 
type HST {
    isa  ObjectMgr
    prop name :: "HST"
    prop Label :: "HST - Host Channel Manager"
    prop IsContainedIn :: IOF
    prop DependsOn :: "HWI,GIO"
    prop FileStream :: 1
    prop GlobalIcon :: 107
    prop InstanceIcon :: 108
    prop GlobalHelpTopic :: (
	104
    )
    prop InstanceHelpTopic :: (
	204
    )
    prop maxObjs :: (
	GBL.DSPWORDSIZE
    )
    prop dataSize :: (
	$b = 0,
	scan ($i; HST) {
	    if ($i.IsConfObj()) {
		$b += ((6) + $i.framesize) * $i.numframes + PIP.OBJSIZE + .objectSize()
	    }
	},
	$b
    )
    prop InstancePropertyPage :: (
	    "{B7240DEA-AA51-11cf-9BFE-0000C0AC14C8}"
    )
    
    prop GlobalPropertyPage :: (
	    "{B7240DEB-AA51-11cf-9BFE-0000C0AC14C8}"
    )
    prop localCreate :: (
	PIP.gNumEmbed += 1,
	if (.gNumOf == 0) {
	    (LNK_dataPump.Create("HST"))
	},
     	"ok"
    )
    prop localDelete :: (
	PIP.gNumEmbed -= 1,
	$b = 0,			 
	scan ($i; HST) {
	    if ($i != self) {
	        if($i.IsConfObj()) {
	            if($i.framesize > $b) {
	                $b = $i.framesize 
	            } 
	        }
	    }
        },
	.MAXFRAMESET = $b,
	if (.gNumOf == 1) {
	    (LNK_dataPump.Delete("HST"))
	},
	"ok"
    )
    prop AllocType :: (
	"2\0, _globalAllocDesc, _memSeg, _placement, 	      _dsmAllocDesc, _dsmMemSeg, _placement"
    )
    
 
    prop _globalAllocDesc :: (
	"%8t .%1L: block(0x20000), RUN_START(%1U_A_TABBEGb), RUN_END(%1U_A_TABENDb) {%12t\n%1U_A_TABBEG = %1U_A_TABBEGb / 2; _%1U_A_TABBEG = %1U_A_TABBEGb / 2;%12t\n%1U_A_TABEND = %1U_A_TABENDb / 2; _%1U_A_TABEND = %1U_A_TABENDb / 2;%8t\n }\0, name"
    )
    prop objectSize :: (
	if (GBL.DSPTYPE == 28) {
	    $a = (14 * 1)
        }, 
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {
	    $a = (12 * 1)
	},
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {
	    $a = (12 * 1)
	},
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
	    $a = (10 * 1)
	},
	if (GBL.DSPTYPE == 54 || GBL.DSPTYPE == 62) {
	    $a = (7 * 1)
	},
	$a
    )
    prop _dsmAllocDesc :: (
	"%8t .dsm: block(0x20000) {}"
    )
    prop _placement :: (0x7fffff / 2)
    prop AllocInst :: (
	"1\0, _instAllocDesc, _objMemSeg, _placement"
    )
    prop _instAllocDesc :: (
	"/* %0s buffer */\n.hst%2d: block(0x20000) %3S\0, name, _objId, _alignString, _objAlign"
    )
    prop _alignString :: .bufalign > 1 ? "align = 0x%4x {}" : ""
    prop _objId :: .iId
    prop _objAlign :: .bufalign
    prop _objMemSeg :: .bufseg
    prop _linkString :: (.gNumOf + .gNumEmbed) > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop _memSeg :: HST.OBJMEMSEG
    prop _dsmMemSeg :: HST.DSMBUFSEG
    prop _objSize :: GBL.DSPTYPE == 55 ? (2 * .objectSize()) : .objectSize()
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "hst.h" : ""
    
 
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far HST_Obj %0r;\n\0"
	}
	else {
	    "extern HST_Obj %0r;\n\0"
        }
    )
    prop modifiable :: (
	(.iDelUser == "USER" ? 1 : 0)
    )
    global gNumEmbed :: 0 {      
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global LNKTYPE :: (
		if (0 == 0) {
		     "RTDX"
		}
		else {
		    if (0 == 1) {
			"Shared Memory"
		    }
		    else {
		        if (0 == 3) {
			    "EVM54"
		        }
		        else {
                            if (0 == 4) {
                                "BIOSLINK"
                            }
                            else {
                                "NONE"
                            }
		        }
		    }
		} ) {
        prop Label :: "Host Link Type"
	prop JSName :: "HOSTLINKTYPE"
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "RTDX,BIOSLINK,NONE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (
	    if ($1 == "RTDX") {
		if (RTDX.USERTDX == 0) {
		    .error("RTDX module must be enabled before it can be used by HST")
		}
		else {
                    if ((RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 2 < .MAXFRAMESET) {
                        .error("RTDX buffer size too small for largest configured HST channel")
                    }
                    else {
			if (.LNKTYPE == "NONE") {
                    	    GlobalStatus.gDirty = 1,
                            .LNKTYPE = $1,
	    		    $b = 0,
	    		    scan ($i; HST) {
	        	        if($i.IsConfObj()) {
	             		    if($i.framesize > $b) {
	                 	        $b = $i.framesize 
	             	    	    } 
	         	        }
            		    },
			    .MAXFRAMESET = $b,
    			    .MAXFRAMEALLOWED = (RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 3, 
                            "ok"
			}
			else {
                            .LNKTYPE = $1,
    			    .MAXFRAMEALLOWED = (RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 3, 
                            "ok"
			}
                    }
		}
	    }
	    else {
		if ($1 == "Shared Memory") {
                    if ((.DSMMEMSIZE/4) < .MAXFRAMESET) {
                        .error("Shared memory buffer too small for largest configured HST channel")
                    }
                    else {
			if (.LNKTYPE == "NONE") {
                    	    GlobalStatus.gDirty = 1,
                            .LNKTYPE = $1,
	    		    $b = 0,
	    		    scan ($i; HST) {
	        	        if ($i.IsConfObj()) {
	             		    if($i.framesize > $b) {
	                 	        $b = $i.framesize 
	             	    	    } 
	         	        }
            		    },
			    .MAXFRAMESET = $b,
    			    .MAXFRAMEALLOWED  = .DSMMEMSIZE/4,
                            "ok"
			}
			else {
                            .LNKTYPE = $1,
    			    .MAXFRAMEALLOWED  = .DSMMEMSIZE/4,
                            "ok"
			}
                    }
		}
		else {
                    if ($1 == "BIOSLINK") {
                        if (GIO.USEGIO == 0) {
                           .error ("GIO must be enabled")
                        }
                        else {
                            .LNKTYPE = $1,
                            "ok"
                        }
                    }
                    else {
                        GlobalStatus.gDirty = 1,
                        .LNKTYPE = $1,
                        "ok"
                    }
		}
            }
        )
    }
    global RTDX ::= .LNKTYPE == "RTDX" ? 1 : 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use RTDX for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global DSM ::= .LNKTYPE == "Shared Memory" ? 1 : 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Shared Memory for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global EVM54 ::= .LNKTYPE == "EVM54" ? 1 : 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use EVM54's I/O ports for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global NONE ::= .LNKTYPE == "NONE" ? 1 : 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "No host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
     
    global BIOSLINK ::= .LNKTYPE == "BIOSLINK" ? 1 : 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use DSP/BIOS LINK for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global MAXFRAMESET ::= (
	    $b = 0,		 
	    scan ($i; HST) {
	        if($i.IsConfObj()) {
	             if($i.framesize > $b) {
	                 $b = $i.framesize 
	             } 
	         }
            }
	) {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAXFRAMESET"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global MAXFRAMEALLOWED ::= .RTDX == 1 ? (RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 3 : .DSMMEMSIZE /4 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAXFRAMEALLOWED"
        prop Visible :: 0 	
        prop Writable :: 1
        prop NoGen :: 0
    }
    global DSMBUFSEG ::= .OBJMEMSEG {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Shared Memory Segment"
        prop Visible :: 0			
        prop Writable :: .DSM 
        prop NoGen :: 0
    }
 
    global DSMMEMSIZE ::= 1024 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop Label :: "Shared Memory Frame Size (MAUs)"
        prop Visible :: 0
        prop Writable :: .DSM
        prop NoGen :: 0
        prop Set :: (
            if ($1 < HST.MAXFRAMESET *4) {
                .error("size (in MAUs) must be at least: 4 * largest configured HST channel framesize (in words)")
            }
            else {
                .DSMMEMSIZE = $1,
                GlobalStatus.gDirty = 1,     
	        if (.LNKTYPE == "Shared Memory") {
	            .MAXFRAMEALLOWED  = .DSMMEMSIZE/4,
                    "ok"
		}
		else {
		    "ok"
		}
            }
        )
    }
     
    global CHNLDRVNAME :: "default" {
        prop Label :: "Host Side Channel Driver Name"
        prop JSName :: "CHNLDRVNAME"
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1  
        prop Writable :: 1  
        prop NoGen :: 0  
    }
   global BIOSLINKDEVICE :: "undefined" {
        prop Label :: "DSP/BIOS LINK Device Name"
        prop JSName :: "BIOSLINKDEVICE"
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Visible :: 1  
        prop Writable :: .BIOSLINK   
        prop NoGen :: 0  
    }
    inst mode :: "output" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "mode"
	prop Enum :: "input,output"
	prop Visible :: 1
	prop Writable :: .modifiable()
	prop NoGen :: 0
    }
    inst bufseg ::= .OBJMEMSEG {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "bufseg"
	prop JSName :: "bufSeg"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataNullMember($1)
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst bufalign :: 4 { 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "bufAlign"
	prop Visible :: 1
	prop Writable :: .modifiable()
	prop NoGen :: 1
	prop Set :: (	         
	    if ($1 < 4) {		 
	        .error("Alignment must be greater than or equal to 4")
	    }
	    else {
		if (($1 % 2) != 0) {  	 
	            .error("Alignment must be a power of 2")
		}
		else {
		    $i = $1,	 
		    while ((($i % 2) == 0) && ($i != 2)) {
		        $i = $i / 2
		    },
		    if(($i % 2) != 0) {	 
	                .error("Alignment must be a power of 2")
		    }
		    else {	     	 
		        .bufalign = $1,
	  	        "ok"
		    }
		}
	    }
	)
    }
    inst buf :: "<NULL>" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst framesize :: 0x80 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "framesize (words)"
	prop JSName :: "frameSize"
	prop Style :: 0x01 | 0x02
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    if ($1 < 1) {
		.error("framesize must be >= 1.")
	    }
	    else {
		if (($1 > .MAXFRAMEALLOWED) && ((.RTDX == 1) || (.DSM == 1)) ) {
		    if (.RTDX == 1) {
		        .error("size (in words) is limited to: (RTDX buffer size in MAUs) / (MAUs per word) - 3")
		    }
		    else {
		            .error("size (in words) is limited to: shared memory frame size (in MAUs)/4")
		    }
		}
		else {
		    .framesize = $1,		 
		    $b = 0,			 
		    scan ($i; HST) {
	        	if($i.IsConfObj()) {
	            	    if($i.framesize > $b) {
	                	$b = $i.framesize 
	            	    } 
	        	}
        	    },
		    .MAXFRAMESET = $b,		 
	  	    GlobalStatus.gDirty = 1,	 
		    "ok"
		}
	    }
	)
    }
    inst numframes :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01
	prop JSName :: "numFrames"
	prop Visible :: 1
	prop Writable :: .modifiable()
	prop NoGen :: 0
	prop Set :: (
	    if ($1 < 1) {
		.error("Channels must contain at least 1 frame.")
	    }
	    else {
		GlobalStatus.gDirty = 1,
		.numframes = $1,
		"ok"
	    }
	)
    }
     
    inst biosLinkChnlNbr :: 0 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP/BIOS LINK channel number[0..15]"
        prop JSName :: "biosLinkChnlNbr"
        prop Visible :: 1  
        prop Writable :: .BIOSLINK 
        prop NoGen :: 0  
        prop Set :: (          
            if ($1 < 0 || $1 > 15) {            
                .error("BiosLink channel number must be [0..15]"),
		"error"
            }
            else {
                $b = 1,
                scan ($i;HST) {
                    if ($i.IsConfObj ()) {
		        if ($i != self && $i.biosLinkChnlNbr == $1) {
                            $b = 0,
                            .error("BiosLink channel number conflict")
                        }
                    }
                },
                if ($b == 1) {
                    GlobalStatus.gDirty = 1,
                    .biosLinkChnlNbr = $1,
                    "ok"
                }
                else {
                    "error"
                }
            }
        )
    }
    inst stsflg :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "statistics"
	prop JSName :: "statistics"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst notify :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyFxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "DHL" || .iDelUser != "USER" ? 0 : 1)
	prop NoGen :: 0
	prop TabName :: "Notify Function"
    }
    inst arg0 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg0"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "DHL" || .iDelUser != "USER" ? 0 : 1)
	prop NoGen :: 0
	prop TabName :: "Notify Function"
    }
    inst arg1 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg1"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "DHL" || .iDelUser != "USER" ? 0 : 1)
	prop NoGen :: 0
	prop TabName :: "Notify Function"
    }
    
 
    inst lnk ::= .RTDX ? "RTDX" : "NOTRTDX" {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "link type"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst iDHLAvailable :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Make this channel available for a new DHL device"
	prop JSName :: "availableForDHL"
        prop Set :: (
	    if (($1 == 0) && (.iDHLAvailable == 1)) {
		DHL.gChannelsAvailable--
	    }
	    else {
		if (($1 == 1) && (.iDHLAvailable == 0)) {
		    DHL.gChannelsAvailable++
		}
	    },
	    .iDHLAvailable = $1,
	    "ok"
	)
	prop Writable :: .modifiable()
        prop Visible :: 1
	prop NoGen :: 1
    }
    
    inst bufFrameAlign ::= .bufalign  { 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
}
object LNK_dataPump :: IDL {
    param function :: @LNK_F_dataPump
    param cycles :: 0			 
    param iDelUser :: "HST"
    param iDelMsg  :: (
	"This object cannot be deleted"
    )
}
object RTA_dispatcher :: IDL {
    param function :: @RTA_F_dispatch
    param cycles :: 0			 
    param iDelUser :: "HST"
    param iDelMsg  :: (
	"This object cannot be deleted"
    )
}
object RTA_fromHost :: HST {
    param iComment  :: (
	"Used to access LOG and STS data"
    )
    param mode :: "input"
    param framesize :: 8 
    param numframes :: 1 
    param iDelUser :: "HST"
    param iDelMsg  :: (
	"This object cannot be deleted"
    )
    param iDHLAvailable :: 0 
     
    param biosLinkChnlNbr :: 12 
} 
object RTA_toHost :: HST {
    param iComment  :: (
	"Used to access LOG and STS data"
    )
    param mode :: "output"
    param framesize :: 64 
    param numframes :: 1 
    param iDelUser :: "HST"
    param iDelMsg  :: (
	"This object cannot be deleted"
    )
    param iDHLAvailable :: 0
     
    param biosLinkChnlNbr :: 13 
}
 
 
  
 
 
 
type HWI {
    isa  ObjectMgr
    prop name :: "HWI"
    prop Label :: "HWI - Hardware Interrupt Service Routine Manager"
    prop IsContainedIn :: SCH
    prop SortChildHierView :: 0
    prop GlobalIcon :: 109
    prop InstanceIcon :: 110
    prop InstanceHelpTopic :: (
        205
    )
    
    prop GlobalHelpTopic :: (
        105
    )
    prop dataSize :: (
         0 * HWI.gNumOf
    )
    prop localCanCreate :: (
        .error("New hardware interrupt objects cannot be created")
    )
    prop InstancePropertyPage :: (
            "{B7240DE6-AA51-11cf-9BFE-0000C0AC14C7}"
    )
   
    prop GlobalPropertyPage :: (
            "{B7240DE7-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    prop DependsOn :: "GBL,OBJ,BUF,CLK,IDL,LCK,LOG,MBX,MEM,PIP,POOL,PRD,QUE,RTDX,SEM,STS,SYS"
    prop AllocType :: (
        "3\0,   _stubsAllocDesc,        _memSeg,        _placement,
                _vectAllocDesc,         _vecSeg,        _minplace,
                _dispAllocDesc,         _dispSeg,       _minplace "
    )
    prop  _dispAllocDesc :: (
        "%8t .hwi_disp_sec:  block(0x20000) {}"
                )
    prop _stubsAllocDesc :: (
        if ((MEM.ENABLELOADSEG) && (MEM.STUBMEMSEG != MEM.LOADSTUBMEMSEG)) {
            "%8t .%1L:  {%8t\n%2S\n%8t} load > %3s%4s, run\0, name, _linkString, _loadstubSeg, _loadstubSegPg"
        }
        else {
            "%8t .%1L:  {%8t\n%2S\n%8t} \0, name, _linkString"
        }
    )
         
         
               
         
         
         
    prop _vectAllocDesc :: (
        if(MEM.ENABLELOADSEG) {
            if(HWI.VECMEMSEG == MEM.LOADVECMEMSEG) {
                 "%8t .%1L_vec: align = 0x100 {%12t\n (.hwi_vec)%8t\n } RUN_START(%1U_A_VECS), \0 , name, name"
            }
            else {
                 "%8t .%1L_vec: align = 0x100 {%12t\n (.hwi_vec)%8t\n } RUN_START(%1U_A_VECS), load > %3s%4s, run\0, name, name, _loadvecSeg, _loadvecSegPg"
            }
        }
        else {
                 "%8t .%1L_vec:  align = 0x100 {%12t\n *(.hwi_vec)%8t\n } RUN_START(%1U_A_VECS), \0 , name, name"
        }
  )
    
    prop _placement :: (0x7fffff / 2)
    prop _minplace  :: 0
    prop localInit :: (
        if (RTDX.CALLBACKOBJ != nil) {
            .error("HWI initialization failure.")
        },
        RTDX.CALLBACKOBJ = HWI
    )
         
         
         
         
         
    prop call :: (
        if ( RTDX.USERTDX == 0 ) {
            HWI_DLOG.function = @HWI_unused,
            HWI_DLOG.iUseDispatcher = 0,
            if (HWI_RTOS.function == @_RTDX_H2TPoll) {
                HWI_RTOS.function = @HWI_unused,
                HWI_RTOS.iUseDispatcher = 0
            }
        }
        else {
            HWI_DLOG.function = @_RTDX_Poll,
            HWI_DLOG.iUseDispatcher = 1,
            HWI_RTOS.function = @_RTDX_H2TPoll,
            HWI_RTOS.iUseDispatcher = 1
        }
    )
    prop _loadstubSegPg   :: (
        (MEM.LOADSTUBMEMSEG.space() == "code")
           ? " PAGE 0"
           : (MEM.LOADSTUBMEMSEG.space() == "data")
                ? " PAGE 1"
                : (MEM.LOADSTUBMEMSEG.space() ==  "io")
                     ? " PAGE 2"
                     : " PAGE 0"
    )
    prop _loadvecSegPg   :: (
        (MEM.LOADVECMEMSEG.space() == "code")
           ? " PAGE 0"
           : (MEM.LOADVECMEMSEG.space() == "data")
                ? " PAGE 1"
                : (MEM.LOADVECMEMSEG.space() ==  "io")
                     ? " PAGE 2"
                     : " PAGE 0"
    )
 
 
 
 
 
 
 
    prop GenLinkPrologue :: ( CLK.TIMERNUM  ==  0
                        ?"HWI_TINT = HWI_INT23;\n_HWI_TINT = HWI_TINT;" 
                        : 1
                        ?"HWI_TINT = HWI_INT22;\n_HWI_TINT = HWI_TINT;" 
                        : 2 
                        ?"HWI_TINT = HWI_INT8;\n_HWI_TINT = HWI_TINT;" 
                        : "HWI_TINT = HWI_INT13;\n _HWI_TINT = HWI_TINT;" 
                         )  
    prop _dispSeg :: MEM.BSSSEG 
    prop _memSeg :: MEM.STUBMEMSEG
    prop _loadstubSeg :: MEM.LOADSTUBMEMSEG
    prop _linkString :: (
        $b = 0,
        scan ($a; HWI) {
            if ($a.monitor != "Nothing") {
                $b = 1
            }
        },
        if ($b == 1) {
            "*(.hwi)"
        }
        else {
            "/* no HWI stubs are necessary */"
        }
    )
    
    prop name2addr :: (
        $i = 0,
        $b = nil,
        scan ($a; { "Nothing","Data Value","xsp", "ac0l", "ac0h", "ac0g", "ac1l", "ac1h", "ac1g", "ac2l", "ac2h", "ac2g", "ac3l", "ac3h", "ac3g", "xar0", "xar1", "xar2", "xar3", "xar4", "xar5", "xar6", "xar7", "t0", "t1", "t2", "t3", "xssp", "tim", "st0_55", "st1_55", "st2_55", "st3_55", "trn0", "bk03", "brc0", "xdp", "xcdp", "dph", "pdp", "bk47", "bkc", "bsa01", "bsa23", "bsa45", "bsa67","bsac", "trn1", "brc1", "csr", "rptc"}) {             
            if ($b == nil) {             
                if ($a == $1) {          
                    $b = { 0, 0, 0x18, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0x24, 0x25, 0x26, 0x28, 0x29, 0x2a, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x20, 0x21, 0x22, 0x23, 0x4c, 0, 0x2, 0x3, 0x4b, 0x4, 0xf, 0x19, 0x1a, 0x2e, 0x27, 0x2b, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x38, 0x39, 0x3b, 0x44 }[$i]     
                },
                $i++
            }
        },
        if ($b == nil) {                 
            $b = 0                       
        },
        $b
    )
    
    prop name2type :: (
        $i = 0,
        $b = nil,
        scan ($a; { "Nothing","Data Value","xsp", "ac0l", "ac0h", "ac0g", "ac1l", "ac1h", "ac1g", "ac2l", "ac2h", "ac2g", "ac3l", "ac3h", "ac3g", "xar0", "xar1", "xar2", "xar3", "xar4", "xar5", "xar6", "xar7", "t0", "t1", "t2", "t3", "xssp", "tim", "st0_55", "st1_55", "st2_55", "st3_55", "trn0", "bk03", "brc0", "xdp", "xcdp", "dph", "pdp", "bk47", "bkc", "bsa01", "bsa23", "bsa45", "bsa67","bsac", "trn1", "brc1", "csr", "rptc"}) {             
            if ($b == nil) {             
                if ($a == $1) {          
                    if ($i < 5) {
                        $b = {"unsigned", "signed", "unsigned", "unsigned", "unsigned"}[$i]  
                    }
                },
                $i++
            }
        },
        if ($b == nil) {                 
            $b = "unsigned"              
        },
        $b
    )
    
    global STUBMEMSEG :: SARAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Function Stub Memory"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    
 
    global ZEROTAB ::= .VECMEMSEG.base == 0xffff00 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Writable :: 0
        prop Visible :: 0
    }
    prop _vecSeg :: MEM.VECMEMSEG
    prop _loadvecSeg :: MEM.LOADVECMEMSEG
    global VECMEMSEG :: VECT {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop Label :: "Interrupt Service Table Memory"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop MemberTest :: GBL.DSPTYPE == 55
                ? ($1.space != "data")
                : ($1.space == "code")
    }
     
    global STACKMODEL :: "USE_RETA" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "C54X_STK,USE_RETA,NO_RETA"
        prop Label :: "Stack mode (See help. Does not automatically take effect without proper reset!)"
        prop JSName :: "STACKMODE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
     
     
 
    inst function :: @HWI_unused {
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: (( .function == @RESERVED ) ||
                ( .client != "USER" )) ? 0 : 1
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
        prop Set :: (
                .function = $1,
                GlobalStatus.gDirty = 1,
                "ok"
        )
    }
    inst iSTSObj :: HWI_RESETSTS {
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    
    inst monitor :: "Nothing" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Nothing,Data Value,xsp,ac0l,ac0h,ac0g,ac1l,ac1h,ac1g,ac2l,ac2h,ac2g,ac3l,ac3h,ac3g,xar0,xar1,xar2,xar3,xar4,xar5,xar6,xar7,t0,t1,t2,t3,xssp,tim,st0_55,st1_55,st2_55,st3_55,trn0,bk03,brc0,xdp,xcdp,dph,pdp,bk47,bkc,bsa01,bsa23,bsa45,bsa67,bsac,trn1,brc1,csr,rptc"
        prop JSName :: "monitor"
        prop Visible :: 1
        prop Writable :: ((.function != @HWI_unused && .function != @RESERVED) && (.iId != 0))
        prop NoGen :: 0
        prop Set :: (
            if ($1 != .monitor) {        
                $e = "ok",
                if ($1 == "Nothing") {
                    if (($e = .iSTSObj.Delete("HWI")) == "ok") {
                        .monitor = "Nothing",
                        .addr = .name2addr(.monitor),
                        .dataType = .name2type(.monitor)
                    }
                }
                else {
                    if (.iSTSObj.iIsUsed || ($e = .iSTSObj.Create("HWI")) == "ok") {
                        .monitor = $1,
                        if (.monitor == "Data Value") {
                            .addr = .saveAddr,
                            .dataType = .saveType
                        }
                        else {
                            .addr = .name2addr(.monitor),
                            .dataType = .name2type(.monitor)
                        }
                    }
                    else {
                        .monitor = "Nothing"
                    }
                },
                $e
            }
            else {
                "ok"
            }
        )
    }
    inst saveAddr :: 0 {
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    
    inst saveType :: "signed" {
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    
    inst addr :: 0 {
        prop JSName :: "addr"
        prop Visible :: 1
        prop Writable :: (.monitor == "Data Value" ? 1 : 0)
        prop NoGen :: 0
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Format :: GBL.DSPTYPE == 62 ? "0x%08x" : "0x%04x"
        prop Set :: (
            .addr = $1,
            .saveAddr = $1,
            "ok"
        )
    }
    inst dataType :: "signed" {
        prop Visible :: 1
        prop Writable :: (.monitor == "Nothing" ? 0 : 1)
        prop NoGen :: 0
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "signed,unsigned"
        prop Label :: "type"
        prop JSName :: "dataType"
        prop Set :: (
            if (.monitor != "Nothing") {
                .dataType = $1,
                .saveType = $1,
                "ok"
            }
            else {
                .error("The monitor field must set to modify this field")
            }
        )
    }
    inst operation :: "STS_add(*addr)" {
        prop Visible :: 1
        prop Writable :: (.monitor == "Nothing" ? 0 : 1)
        prop NoGen :: 0
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "operation"
        prop Enum :: "STS_add(*addr),STS_delta(*addr),STS_add(-*addr),STS_delta(-*addr),STS_add(|*addr|),STS_delta(|*addr|)"
        prop Set :: (
            if (.monitor != "Nothing") {
                .operation = $1,
                "ok"
            }
            else {
                .error("The monitor field must set to modify this field")
            }
        )
    }
    inst client :: "USER" {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
     inst iUseDispatcher :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Dispatcher"
        prop JSName :: "useDispatcher"
        prop Visible :: 1
        prop Writable :: ( .client == "USER" ) ? 1 : 0
        prop NoGen :: 0
        prop TabName :: "Dispatcher"
        prop Set :: (
            if (($1 == 1) && (self == HWI_NMI)){
                .error ("HWI dispatcher can't be used for  NMI")
            }
            else {
                if ( .function == @CLK_F_isr ) {
                    .error("This HWI is being used by the system and cannot be modified")
                }
                else {
                    .iUseDispatcher = $1,
                    "ok"
                }
            }
        )
     }
 
     inst iArg :: 0 {
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Arg"
        prop JSName :: "arg"
        prop Visible :: 1
        prop Writable :: (( .iUseDispatcher == 1 ) && ( .client == "USER" )) ? 1 : 0
        prop NoGen :: 0
        prop TabName :: "Dispatcher"
        prop Set :: (
            .iArg = $1,
            "ok"
        )
     }
 
     inst iIer0Mask :: "self" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Interrupt Mask IER0"
        prop JSName :: "interruptMask0"
        prop Enum :: "all,none,self,bitmask"
        prop Visible :: 1
        prop Writable :: ( .iUseDispatcher == 1 ) ? 1 : 0
        prop NoGen :: 1
        prop TabName :: "Dispatcher"
        prop Set :: (
            if ( $1 == "all" ) {
                .Ier0Mask = 0xffff
            }
            else {
                if ( $1 == "self" ) {
                   if (.iId < 16) {
                        .Ier0Mask = (1 << .iId)
                   }
                   else {
                        .warning("This Interrupt is NOT maskable via IER0")
                        .Ier0Mask = 0
                   }
                }
                else {
                    if ( $1 == "none" ) {
                        .Ier0Mask = 0
                    }
                }
            },
            .iIer0Mask = $1,
            "ok"
        )
     }
        
     inst Ier0Mask :: (.iId < 16) ? (1 << .iId) : 0 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x02
        prop Label :: "Interrupt Bit Mask IER0"
        prop JSName :: "interruptBitMask0"
        prop Visible :: 1
        prop Writable :: ((.iUseDispatcher == 1) && (.iIer0Mask == "bitmask" )) ? 1 : 0
        prop NoGen :: 0
        prop TabName :: "Dispatcher"
        prop Set :: (
            if ( $1 > 0xffff) {
                .error("Invalid Number")
            }
            else {
                .Ier0Mask = $1,
                "ok"
            }
        )
     }
 
     inst iIer1Mask :: "self" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Interrupt Mask IER1"
        prop JSName :: "interruptMask1"
        prop Enum :: "all,none,self,bitmask"
        prop Visible :: 1
        prop Writable :: ( .iUseDispatcher == 1 ) ? 1 : 0
        prop NoGen :: 1
        prop TabName :: "Dispatcher"
        prop Set :: (
            if ( $1 == "all" ) {
                .Ier1Mask = 0xffff
            }
            else {
                if ( $1 == "self" ) {
                   if ( (.iId < 16) || (.iId > 32) ) {
                        .warning("This Interrupt is NOT maskable via IER1")
                        .Ier1Mask = 0
                   }
                   else {
                        .Ier1Mask = (1 << (.iId - 16))
                   }
                }
                else {
                    if ( $1 == "none" ) {
                        .Ier1Mask = 0
                    }
                }
            },
            .iIer1Mask = $1,
            "ok"
        )
     }
        
     inst Ier1Mask :: (.iId > 15) ? (.iId < 32) ? (1 << (.iId - 16)) : 0 : 0 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x02
        prop Label :: "Interrupt Bit Mask IER1"
        prop JSName :: "interruptBitMask1"
        prop Visible :: 1
        prop Writable :: ((.iUseDispatcher == 1) && (.iIer1Mask == "bitmask" )) ? 1 : 0
        prop NoGen :: 0
        prop TabName :: "Dispatcher"
        prop Set :: (
            if ( $1 > 0xffff) {
                .error("Invalid Number")
            }
            else {
                .Ier1Mask = $1,
                "ok"
            }
        )
     }
}
object HWI_RESET_STS :: STS {
    param iComment :: "provides statistics for the RESET ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_RESET :: HWI {
    param iComment :: "defines function for the RESET ISR"
    param iId :: 0                       
    param function :: @_c_int00
    param iIsUsed :: 1
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_RESET_STS
}
object HWI_NMI_STS :: STS {
    param iComment :: "provides statistics for the NMI ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_NMI :: HWI {
    param iComment :: "defines function for the NMI ISR"
    param iId :: 1                       
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_NMI_STS
}
object HWI_INT2_STS :: STS {
    param iComment :: "provides statistics for the INT2 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT2 :: HWI {
    param iComment :: "defines the INT2 Interrupt"
    param iId :: 2                       
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT2_STS
}
object HWI_INT3_STS :: STS {
    param iComment :: "provides statistics for the INT3 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT3 :: HWI {
    param iComment :: "defines the INT3 Interrupt"
    param iId :: 3       
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT3_STS
}
object HWI_INT4_STS :: STS {
    param iComment :: "provides statistics for the INT4 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT4 :: HWI {
    param iComment :: "defines the INT4 Interrupt"
    param iIsUsed :: 1                   
    param iId :: 4                       
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT4_STS
}
object HWI_INT5_STS :: STS {
    param iComment :: "provides statistics for the INT5 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT5 :: HWI {
    param iComment :: "defines the INT5 Interrupt"
    param iId :: 5                       
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT5_STS
}
object HWI_INT6_STS :: STS {
    param iComment :: "provide statistics for  INT6  Interrupt"
    param iId :: 6                       
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT6 :: HWI {
    param iComment :: "defines the INT6 Interrupt"
    param iId :: 6                       
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT6_STS
}
object HWI_INT7_STS :: STS {
    param iComment :: "provides statistics for the INT7 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT7 :: HWI {
    param iComment :: "defines the INT7 Interrupt"
    param iId :: 7                       
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT7_STS
}
object HWI_INT8_STS :: STS {
    param iComment :: "provides statistics for the INT8 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT8 :: HWI {
    param iComment :: "defines the INT8 Interrupt"
    param iId :: 8                       
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param function :: CLK.WHICHHWI == self ? @CLK_F_isr : @HWI_unused
    param client   :: CLK.WHICHHWI == self ? "CLK" : "USER"
    param iUseDispatcher :: (CLK.WHICHHWI == self ) ? 1 : 0
    param iArg :: (.iUseDispatcher && CLK.WHICHHWI == self) ? @CLK_A_TABBEG : 0
    param iSTSObj :: HWI_INT8_STS
}
object HWI_INT9_STS :: STS {
    param iComment :: "provides statistics for the INT 9  ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT9:: HWI {
    param iComment :: "defines the INT9  Interrupt"
    param iId :: 9                       
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT9_STS
    param function :: CLK.WHICHHWI == self ? @CLK_F_isr : @HWI_unused
}
object HWI_INT10_STS :: STS {
    param iComment :: "provides statistics for the INT10 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT10 :: HWI {
    param iComment :: "defines the INT10 Interrupt"
    param iId :: 10                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT10_STS
}
object HWI_INT11_STS :: STS {
    param iComment :: "provides statistics for the INT11 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT11 :: HWI {
    param iComment :: "defines the INT11 Interrupt"
    param iId :: 11                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT11_STS
}
object HWI_INT12_STS :: STS {
    param iComment :: "provides statistics for the INT12 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT12 :: HWI {
    param iComment :: "defines the INT12 Interrupt"
    param iId :: 12                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT12_STS
}
object HWI_INT13_STS :: STS {
    param iComment :: "provides statistics for the INT13 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT13 :: HWI {
    param iComment :: "defines the INT13 Interrupt"
    param iId :: 13                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param function :: CLK.WHICHHWI == self ? @CLK_F_isr : @HWI_unused
    param client   :: CLK.WHICHHWI == self ? "CLK" : "USER"
    param iUseDispatcher :: (CLK.WHICHHWI == self ) ? 1 : 0
    param iArg :: (.iUseDispatcher && CLK.WHICHHWI == self) ? @CLK_A_TABBEG : 0
    param iSTSObj :: HWI_INT13_STS
}
object HWI_INT14_STS :: STS {
    param iComment :: "provides statistics for the INT14 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT14 :: HWI {
    param iComment :: "defines the INT14 Interrupt"
    param iId :: 14                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT14_STS
}
object HWI_INT15_STS :: STS {
    param iComment :: "provides statistics for the INT15 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT15 :: HWI {
    param iComment :: "defines the INT15 Interrupt"
    param iId :: 15                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT15_STS
}
object HWI_INT16_STS :: STS {
    param iComment :: "provides statistics for the INT16 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT16 :: HWI {
    param iComment :: "defines the INT16 Interrupt"
    param iId :: 16                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT16_STS
}
object HWI_INT17_STS :: STS {
    param iComment :: "provides statistics for the INT17 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT17 :: HWI {
    param iComment :: "defines the INT17 Interrupt"
    param iId :: 17                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT17_STS
}
object HWI_INT18_STS :: STS {
    param iComment :: "provides statistics for the INT18 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT18 :: HWI {
    param iComment :: "defines the INT18 Interrupt"
    param iId :: 18                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT18_STS
}
object HWI_INT19_STS :: STS {
    param iComment :: "provides statistics for the INT19 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT19 :: HWI {
    param iComment :: "defines the INT19 Interrupt"
    param iId :: 19                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT19_STS
}
object HWI_INT20_STS :: STS {
    param iComment :: "provides statistics for the INT20 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT20 :: HWI {
    param iComment :: "defines the INT20 Interrupt"
    param iId :: 20                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT20_STS
}
object HWI_INT21_STS :: STS {
    param iComment :: "provides statistics for the INT21 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT21 :: HWI {
    param iComment :: "defines the INT21 Interrupt"
    param iId :: 21                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT21_STS
}
object HWI_INT22_STS :: STS {
    param iComment :: "provides statistics for the INT22 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT22 :: HWI {
    param iComment :: "defines the INT22 Interrupt"
    param iId :: 22                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param function :: CLK.WHICHHWI == self ? @CLK_F_isr : @HWI_unused
    param client   :: CLK.WHICHHWI == self ? "CLK" : "USER"
    param iUseDispatcher :: (CLK.WHICHHWI == self ) ? 1 : 0
    param iArg :: (.iUseDispatcher && CLK.WHICHHWI == self) ? @CLK_A_TABBEG : 0
    param iSTSObj :: HWI_INT22_STS
}
object HWI_INT23_STS :: STS {
    param iComment :: "provides statistics for the INT23 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT23 :: HWI {
    param iComment :: "defines the INT23 Interrupt"
    param iId :: 23                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param function :: CLK.WHICHHWI == self ? @CLK_F_isr : @HWI_unused
    param client   :: CLK.WHICHHWI == self ? "CLK" : "USER"
    param iUseDispatcher :: (CLK.WHICHHWI == self ) ? 1 : 0
    param iArg :: (.iUseDispatcher && CLK.WHICHHWI == self) ? @CLK_A_TABBEG : 0
    param iSTSObj :: HWI_INT23_STS
}
object HWI_BERR_STS :: STS {
    param iComment :: "provides statistics for the BERRINT ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_BERR :: HWI {
    param iComment :: "defines the BERR Interrupt"
    param iId :: 24                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_BERR_STS
}
object HWI_DLOG_STS :: STS {
    param iComment :: "provides statistics for the DLOGINT ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_DLOG :: HWI {
    param iComment :: "RESERVED for RTDX"
    param iId :: 25                      
    param function :: (RTDX.USERTDX ==1) ? @_RTDX_Poll : @HWI_unused
    param client :: "RTDX"
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_DLOG_STS
    param iUseDispatcher :: (RTDX.USERTDX == 1) ? 1 : 0
}
object HWI_RTOS_STS :: STS {
    param iComment :: "provides statistics for the RTOS ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_RTOS :: HWI {
    param iComment :: "defines the RTOS Interrupt"
    param iId :: 26                      
    param function :: (RTDX.USERTDX ==1) ? @_RTDX_H2TPoll : @HWI_unused
    param iUseDispatcher :: (RTDX.USERTDX == 1) ? 1 : 0
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_RTOS_STS
}
object HWI_SINT27_STS :: STS {
    param iComment :: "provides statistics for the SINT27 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_SINT27 :: HWI {
    param iComment :: "defines the SINT27 Interrupt"
    param iId :: 27                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_SINT27_STS
}
object HWI_SINT28_STS :: STS {
    param iComment :: "provides statistics for the SINT28 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_SINT28 :: HWI {
    param iComment :: "defines the SINT28 Interrupt"
    param iId :: 28                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_SINT28_STS
}
object HWI_SINT29_STS :: STS {
    param iComment :: "provides statistics for the SINT29 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_SINT29 :: HWI {
    param iComment :: "defines the SINT29 Interrupt"
    param iId :: 29                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_SINT29_STS
}
object HWI_SINT30_STS :: STS {
    param iComment :: "provides statistics for the SINT30 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_SINT30 :: HWI {
    param iComment :: "defines the SINT30 Interrupt"
    param iId :: 30                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_SINT30_STS
}
object HWI_SINT31_STS :: STS {
    param iComment :: "provides statistics for the SINT31 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_SINT31 :: HWI {
    param iComment :: "defines the SINT31 Interrupt"
    param iId :: 31                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_SINT31_STS
}
object HWI_UNUSED :: HWI {
    param iComment :: "a dummy DSP interrupt for unused sources"
    param iId :: 64                      
    param iIsUsed :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_SINT31_STS
}
 
type SWI {
    isa	ObjectMgr
    prop name :: "SWI"
    prop Label :: "SWI - Software Interrupt Manager"
    prop IsContainedIn :: SCH
    prop DependsOn :: "HWI,SIO,HST,MSGQ,PWRM"
    prop GlobalIcon :: 123
    prop InstanceIcon :: 124
    prop InstanceHelpTopic :: (
	211
    )
    
    prop GlobalHelpTopic :: (
	111
    )
    
 
    prop HighTimeBased :: (
        CLK.HIRES == 1 ? 1 : 0
    )
    prop LowTimeBased :: (
        CLK.HIRES == 1 ? 0 : 1
    )
    
 
    prop uType :: (
        if (.HighTimeBased()) {
	    $a = 0
        }
        else {
	    if (.LowTimeBased()) {
	        $a = 1
	    }
	    else {
	        $a = 2
            }
        },
        $a
    )
    
 
    prop STSGetMaxFmt :: (
	if (SWI.STSUNITS == "raw") {
	    CLK.HIRES ? "%g inst" : "%g ints"
	}
	else {
	    SWI.STSUNITS == "microseconds" ? "%.1f us" : "%.2f ms"
	}
    )
    prop STSGetSumFmt :: (
	SWI.STSGetMaxFmt()
    )
    prop STSGetAvgFmt :: (
	if (SWI.STSUNITS == "raw") {
	    CLK.HIRES ? "%.2f inst" : "%.2f ints"
	}
	else {
	    SWI.STSUNITS == "microseconds" ? "%.1f us" : "%.2f ms"
	}
    )
 
    prop STSFilterMaxMult :: (
	$a = 1
    )
    prop STSFilterSumMult :: (
	SWI.STSFilterMaxMult($1)
    )
    
 
    prop GetPriority :: (
	.pri
    )
    prop objectSize :: (
	if ((GBL.DSPTYPE == 54 && GBL.FARMODE == 0) ||
		(GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL")) {
	    $a = (12 * 1)
	},
	if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
	    $a = (14 * 1)
	},
	if (GBL.DSPTYPE == 28 ||
	   (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") ||
	   (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE")) {
	    $a = (20 * 1)
	},
	if (GBL.DSPTYPE == 62) {
	    $a = (11 * 1)
	},
	$a
    )
    prop GenLinkPrologue :: (
	"SECTIONS {%4t\n.swi: block(0x20000) RUN_START(SWI_A_TABBEGb), RUN_END(SWI_A_TABENDb) {%8t\nSWI_A_TABBEG = SWI_A_TABBEGb / 2;%8t\nSWI_A_TABEND = SWI_A_TABENDb / 2;%4t\n} > %1s%2s\0, memSeg, pageString"
    )
    prop GenLinkEpilogue :: (
    	"%0t}\nSWI_A_TABLEN = %1d;\n\0, numInst"
    )
    prop linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop pageString :: GBL.DSPTYPE == 62
                      ? ""
                      : (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28)
                      ? (
                          SWI.OBJMEMSEG.space() == "code"
                          ? " PAGE 0"
                          : SWI.OBJMEMSEG.space() == "data"
                            ? " PAGE 1"
                            : SWI.OBJMEMSEG.space() == "io"
                              ? " PAGE 2"
                              : " PAGE 0"
                        )
                      :" PAGE 1"
    prop memSeg :: SWI.OBJMEMSEG
     
    prop objSize :: GBL.DSPTYPE == 55 ? (2 * .objectSize()) : .objectSize()
    prop maxObjs :: (
	32767				 
    )
    prop numInst :: (
    	SWI.gNumOf
    )
    prop dataSize :: (
	.objectSize() * SWI.gNumOf
    )
    prop localCanCreate :: (
	if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {
	    .error("System stack size (see MEM) is too small to support a new SWI priority level.")
	}
	else {
	    "ok"
	}
    )
    prop localCreate :: (
	STS.gNumEmbed += 1,
        SWI.EXECFXN = @SWI_F_exec,
	SWI.RUNFXN = @SWI_F_run,
	"ok"
    )
    prop localDelete :: (
	STS.gNumEmbed -= 1,
	if (.gNumOf == 1) {	 
	     
	    SWI.EXECFXN = @FXN_F_nop,
	    SWI.RUNFXN = @FXN_F_nop
	},
	"ok"
    )
    prop SortByField :: "pri"
    prop SortGroups :: 15
    prop InstancePropertyPage :: (
	    "{B7240DEC-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
	    "{B7240DED-AA51-11cf-9BFE-0000C0AC14C7}"
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "swi.h" : ""
    
 
    prop cGenHInst :: (
	if (GBL.DSPTYPE == 62) {
	    "extern far SWI_Obj %0r;\n\0"
	}
	else {
	    "extern SWI_Obj %0r;\n\0"
	}
    )
    global EHOOKFXN :: @GBL_NULL {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Enable Scheduler and Return to Idle Function"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
    }
    global IHOOKFXN :: @GBL_NULL {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Exit Scheduler and Return to Idle Function"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
    }
    global EXECFXN :: @FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Configured SWI executive"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global RUNFXN :: @FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Configured SWI executive body"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global STSUNITS :: "raw" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "raw,milliseconds,microseconds"
	prop Label :: "Statistics Units"
	prop Visible :: 0		 
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst priority :: = (.pri + 1) {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "priority"
	prop JSName :: ""
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst function :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
    inst pri :: 1 {		 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	 
	prop Enum :: "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14"
	prop Label :: "priority"
	prop JSName :: "priority"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
            $a = .pri,
            .pri = $1,
	    if (self == KNL_swi) {
		if ($1 != 0) {
		    .pri = $a,
		    .error("KNL_swi must remain at Priority 0.")
		}
		else {
		    "ok"
		}
	    }
	    else {
		if ($1 == 0 && KNL_swi.iIsUsed == 1) {
		    .pri = $a,
		    .error("Priority 0 reserved for KNL_swi only.")
		}
		else {
		    GlobalStatus.gDirty = 1,
		    if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {
			.pri = $a,
			.error("System stack size (see MEM) is too small to support a new SWI priority level.")
		    }
		    else {
			if ($1 > 14) {
			    .pri = $a,
			    .error("SWI can only support 15 priority levels.")
			}
			else {
			    "ok"
			}
		    }
		}
	    }
	)
    }
    inst mailbox :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "mailbox"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
    inst arg0 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg0"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
    inst arg1 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg1"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
    inst dorta :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
     
    inst Order :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
	prop NoGen :: 0
	prop Writable :: 1
     }
    
 
    inst filter :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "filter"
	prop NoGen :: 0
    }
    inst maxformat :: .STSGetMaxFmt() {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "maxformat"
	prop NoGen :: 0
    }
    inst sumformat :: .STSGetSumFmt() {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "sumformat"
	prop NoGen :: 0
    }
    inst avgformat :: .STSGetAvgFmt() {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "avgformat"
	prop NoGen :: 0
    }
    inst filtmaxmult :: 1  {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "filtmaxmult"
	prop NoGen :: 0
    }
    inst filtsummult :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "filtsummult"
	prop NoGen :: 0
    }
    inst unittype :: .uType() {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "unittype"
	prop NoGen :: 0
    }
}    
 
type TSK {
    isa ObjectMgr
    prop name :: "TSK"
    prop Label :: "TSK - Task Manager"
    prop IsConfMod :: .USETSK
    prop IsContainedIn :: SCH
    
 
    prop DependsOn :: "SWI,HOOK"
    prop GlobalIcon :: 143
    prop InstanceIcon :: 144
    prop GlobalHelpTopic :: (
	314
    )
    prop InstanceHelpTopic :: (
	414
    )
    prop InstancePropertyPage :: (
	"{473C4A64-B1A8-11d0-9885-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{473C4A65-B1A8-11d0-9885-0020AFEE33C6}"
    )
    prop SortByField :: "iPRI"
    prop SortGroups :: 17
    prop objectSize :: (
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
	    $a = (27 * 1)
	},
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {
	    $a = (44 * 1)
	},
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {
	    $a = (44 * 1)
	},
	if (GBL.DSPTYPE == 28) {
	    $a = (40 * 1)
	},
	if (GBL.DSPTYPE == 62 || (GBL.DSPTYPE == 54 && GBL.FARMODE == 0)) {
	    $a = (24 * 1)
	},
	if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
	    $a = (25 * 1)
	},
	$a
    )
    prop GenLinkPrologue :: (
	if (.USETSK != 0) {
	    "SECTIONS {%4t\n.%1L: block(0x20000) {%8t\n %4S %4t\n} > %3s%5s\0, name, objSize, _bssmemSeg, linkString, pageString"
	}
	else {
	    "_KNL_swi = 0;"
	}
    )
    prop linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop pageString :: GBL.DSPTYPE == 62
                      ? ""
                      : (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28)
                      ? (
                          TSK.OBJMEMSEG.space() == "code"
                          ? " PAGE 0"
                          : TSK.OBJMEMSEG.space() == "data"
                            ? " PAGE 1"
                            : TSK.OBJMEMSEG.space() == "io"
                              ? " PAGE 2"
                              : " PAGE 0"
                        )
                      :" PAGE 1"
    prop GenLinkEpilogue :: (
	if (.USETSK != 0) {
	    "%0t}\n\0"
	}
        else {
            ""
        }
    )
    prop _objAllocDesc :: (    
	"%8t .TSK$obj: {}"
    )
    prop _bssmemSeg :: .OBJMEMSEG
    prop _objmemSeg :: MEM.CFGOBJSEG	 
    prop AllocInst :: (
	.iAUTOSTK ? "1\0, _instStackDesc, _instStackSeg, _placement" : "0\0"
    )
    prop _instStackDesc :: (
	"%8t .%0s$stk: block(0x20000){%12t\n *(.%0s$stk)%8t\n }\0"
    )
    prop _self :: self
    prop _instStackSize :: .iSTKSZ * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    prop _instsyStackSize :: .iSYSTKSZ * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    prop _instStackSeg :: .iSTKSEG
    prop _placement :: (0x7fffff / 2)
    prop localInit :: (
	KNL_swi.Create("SWI"),
	if (.STACKSEG.iAllocHeap == 1) {
	    .STACKSEG.iReqHeapCount++,
	    "ok"
	}
	else {
	    .error ("TSK default stack segment must be a memory segment with a heap")
	}
    )
    
 
    prop HighTimeBased :: (
        CLK.HIRES == 1 ? 1 : 0
    )
    prop LowTimeBased :: (
        CLK.HIRES == 1 ? 0 : 1
    )
    
 
    prop uType :: (
        if (.HighTimeBased()) {
	    $a = 0
        }
        else {
	    if (.LowTimeBased()) {
	        $a = 1
	    }
	    else {
	        $a = 2
	    }
        },
        $a
    )
    
 
    prop STSGetMaxFmt :: (
	if (TSK.STSUNITS == "raw") {
	    CLK.HIRES ? "%g inst" : "%g ints"
	}
	else {
	    TSK.STSUNITS == "microseconds" ? "%.1f us" : "%.2f ms"
	}
    )
    prop STSGetSumFmt :: (
	TSK.STSGetMaxFmt()
    )
    prop STSGetAvgFmt :: (
	if (TSK.STSUNITS == "raw") {
	    CLK.HIRES ? "%.2f inst" : "%.2f ints"
	}
	else {
	    TSK.STSUNITS == "microseconds" ? "%.1f us" : "%.2f ms"
	}
    )
     
    prop STSFilterMaxMult :: (
	$a = 1
    )
    prop STSFilterSumMult :: (
	TSK.STSFilterMaxMult($1)
    )
    prop localCreate :: (
	STS.gNumEmbed += 1,
	"ok"
    )
    prop localCanCreate :: (
	$e = "ok",
	if (TSK.USETSK != 1) {
	    $e = .error("TSK manager not enabled")
	},
	$e
    )
    prop localDelete :: (
	STS.gNumEmbed -= 1,
	"ok"
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "tsk.h" : ""
    
 
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far TSK_Obj %0r;\n\0"
        }
	else {
	    "extern TSK_Obj %0r;\n\0"
        }
    )
    prop NOPFXN :: @FXN_F_nop
    global USETSK :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable TSK Manager"
	prop JSName :: "ENABLETSK"
	prop Visible :: 1
	prop Writable :: GBL.DSPSUBTYPE == 0x55DA200 ? 0:1
	prop NoGen :: 1
	prop Set :: (
	    if ($1 == 0) {
		if (.gNumOf > 1) {
		    .error("Cannot disable TSK until all TSK objects are deleted.")
		}
		else {
		    .STACKSEG.iReqHeapCount--,
		    TSK.STACKSEG = MEM_NULL,	 
		    TSK.OBJMEMSEG = MEM_NULL,
		    TSK_idle.iSTKSEG = MEM_NULL,
		    TSK_idle.Delete("TSK"),
		    KNL_swi.Delete("TSK"),
		    PRD.THOOKFXN = .NOPFXN,
                    if (PRD.gNumOf == 0) {
                      if (PRD_clock.iIsUsed == 1) {
                        PRD_clock.function = @FXN_F_nop
                      }
                    },
		    .USETSK = $1,
		    "ok"
		}
	    } else {
		$e = "ok",
	        GlobalStatus.gDirty = 1,
	        if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {
                    $e = .error("Current stack size inadequate to enable TSK"),
		    break
		    },
		scan ($a; SWI) {
		    if ($a != KNL_swi && $a.pri == 0 && $a.iIsUsed == 1) {
			$e = .error("Cannot enable TSK when there are SWI objects at Priority 0."),
			break
		    }
		},
		if ($e == "ok") {
		    TSK.STACKSEG = MEM_NULL,   
		    scan($b; MEM) {
			if ($b.iAllocHeap && $b != MEM_NULL) {
		    	     
		    	    TSK.STACKSEG = $b,
			    break
			}
		    },
		    .STACKSEG.iReqHeapCount++,
		    .USETSK = $1,
		    				 
		    TSK.OBJMEMSEG = SWI.OBJMEMSEG,
		    TSK_idle.iSTKSEG = .OBJMEMSEG,   
		    TSK_idle.Create("TSK"),
		    KNL_swi.Create("TSK"),
		    PRD.THOOKFXN = PRD.DEFAULT_THOOKFXN,
                    if (TSK.TSKTICK == "PRD") {
                      if (PRD_clock.iIsUsed == 1) {
                        PRD_clock.function = @PRD_F_tick
                      }
                    },
		    if ( MEM.NOHEAPS ) {
			.STACKSEG.iReqHeapCount++
		    },
		    $e
		}
		else {
		    $e
		}
	    }
	)
    }
     
    prop _objId :: .iId
    prop objSize :: GBL.DSPTYPE == 55 ? (2 * .objectSize()) : .objectSize()
    prop dataSize :: (
	$d = 0,
	scan ($i; TSK) {
	    
 
	    $d += ($i.iSTKSZ + .objectSize() * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE))
	},
	$d
    )
     
    prop minStackSize :: (
	$a = .STACKSIZE,
	scan ($i; TSK) {
	    if ($i.STACKSIZE < $a) {
		$a = $i.STACKSIZE
	    }
	},
	$a
    )
    prop maxObjs :: (32767)			 
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "OBJMEMSEG"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataNullMember($1)
	prop Label :: "Object Memory"
	prop Visible :: 1
	prop Writable :: .USETSK
	prop NoGen :: 1
    }
    
 
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global STACKSIZE :: GBL.DSPTYPE == 62 ? 1024 : 
			(GBL.DSPTYPE == 55 && GBL.DSPSUBTYPE == 5599) ? 2560 :
			(GBL.DSPTYPE == 55 && GBL.DSPSUBTYPE != 5599) ? 1024 :
			(GBL.DSPTYPE == 28) ? 256 : 256 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: GBL.DSPTYPE == 54 ? 0x01 : 0x02
	prop Label :: "Default stack size (MAUs)"
	prop JSName :: "STACKSIZE"
	prop Visible :: 1
	prop Writable :: .USETSK
    }	
    global SYSTACKSIZE ::   (GBL.DSPSUBTYPE == 5599)? 0 : 256 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Label :: "Default systack size (MAUs)"
	prop JSName :: "SYSSTACKSIZE"
	prop Visible :: 1
	prop Writable :: .USETSK
    }  
    
    global STACKSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataNullMember($1) && $1.iAllocHeap
	prop Label :: "Stack segment for dynamic tasks"
	prop JSName :: "STACKSEG"
	prop Visible :: 1
	prop Writable :: .USETSK && (MEM.NOHEAPS == 0)
	prop Set :: (
	    if (.STACKSEG.iReqHeapCount > 0) {
		.STACKSEG.iReqHeapCount--
	    },
	    .STACKSEG = $1,
	    .STACKSEG.iReqHeapCount++,
	    "ok"
	)
    }	
    global PRIORITY :: 1 {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "PRIORITY"
	prop Enum :: "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
	prop Label :: "Default task priority"
	prop Visible :: 1
	prop Writable :: .USETSK
    }
    global CREATEFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Create function"
	prop JSName :: "CREATEFXN"
	prop Visible :: 1
	prop Writable :: .USETSK
	prop TabName :: "Function Hooks"
	prop Set :: (
	    .CREATEFXN = $1,
	    HOOK_KNL.createFxn = .CREATEFXN,
	    "ok"
	)
	prop NoGen :: 1
    }
    global VCREATEFXN ::= HOOK_KNL.iIsUsed == 1 ? @__HOOK_doCreate : .CREATEFXN {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
    }
    global DELETEFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Delete function"
	prop JSName :: "DELETEFXN"
	prop Visible :: 1
	prop Writable :: .USETSK
	prop TabName :: "Function Hooks"
	prop Set :: (
	    .DELETEFXN = $1,
	    HOOK_KNL.deleteFxn = .DELETEFXN,
	    "ok"
	)
	prop NoGen :: 1
    }
    global VDELETEFXN ::= HOOK_KNL.iIsUsed == 1 ? @__HOOK_doDelete : .DELETEFXN {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
    }
    global EXITFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Exit function"
	prop JSName :: "EXITFXN"
	prop Visible :: 1
	prop Writable :: .USETSK
	prop TabName :: "Function Hooks"
	prop Set :: (
	    .EXITFXN = $1,
	    HOOK_KNL.exitFxn = .EXITFXN,
	    "ok"
	)
	prop NoGen :: 1
    }
    global VEXITFXN ::= HOOK_KNL.iIsUsed == 1 ? @__HOOK_doExit : .EXITFXN {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
    }
    global DOSWITCH :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Call switch function"
	prop JSName :: "CALLSWITCHFXN"
	prop Writable :: .USETSK
	prop Visible :: 1
	prop NoGen :: 1
	prop Set :: (
	    .DOSWITCH = $1,
	    HOOK_KNL.callSwitchFxn = .DOSWITCH,
	    "ok"
	)
	prop TabName :: "Function Hooks"
    }
    global VSWFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Switch function"
	prop JSName :: "SWITCHFXN"
	prop Visible :: 1
	prop NoGen :: 1
	prop Writable :: .DOSWITCH && .USETSK
	prop Set :: (
	    .VSWFXN = $1,
	    HOOK_KNL.switchFxn = .VSWFXN,
	    "ok"
	)
	prop TabName :: "Function Hooks"
    }
    global SWITCHFXN ::= (
	 
	if (HOOK_KNL.iIsUsed) {
	    $i = 0,
	     
	    scan ($a; HOOK) {
		if ($a.callSwitchFxn) {
		    $i = 1
		}
	    },
	     
	    if ($i) {
		@__HOOK_doSwitch
	    }
	    else {
		0
	    }
	}
	else {
	    if (.DOSWITCH) {
		.VSWFXN
	    }
	    else {
		0
	    }
	}
    ) {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: ""
	prop TabName :: "Function Hooks"
    }
    global DOREADY :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Call ready function"
	prop JSName :: "CALLREADYFXN"
	prop Writable :: .USETSK
	prop Visible :: 1
	prop NoGen :: 1
	prop Set :: (
	    .DOREADY = $1,
	    HOOK_KNL.callReadyFxn = .DOREADY,
	    "ok"
	)
	prop TabName :: "Function Hooks"
    }
    global VRDYFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Ready function"
	prop JSName :: "READYFXN"
	prop Visible :: 1
	prop Writable :: .DOREADY && .USETSK
	prop NoGen :: 1
	prop Set :: (
	    .VRDYFXN = $1,
	    HOOK_KNL.readyFxn = .VRDYFXN,
	    "ok"
	)
	prop TabName :: "Function Hooks"
    }
    global READYFXN ::= (
	 
	if (HOOK_KNL.iIsUsed) {
	    $i = 0,
	     
	    scan ($a; HOOK) {
		if ($a.callReadyFxn) {
		    $i = 1
		}
	    },
	     
	    if ($i) {
		@__HOOK_doReady
	    }
	    else {
		0
	    }
	}
	else {
	    if (.DOREADY) {
		.VRDYFXN
	    }
	    else {
		0
	    }
	}
    ) {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: ""
	prop TabName :: "Function Hooks"
    }
    global NUM_HOOKS ::= HOOK.gNumOf {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
    }
    global STSUNITS :: "raw" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "raw,milliseconds,microseconds"
	prop Label :: "Statistics Units"
	prop Visible :: 0
	prop Writable :: .USETSK
	prop NoGen :: 1
    }
    
    global TSKTICK :: "PRD" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "PRD,User"
	prop Label :: "TSK tick driven by"
	prop JSName :: "DRIVETSKTICK"
	prop Visible :: 1
	prop Writable :: .USETSK
	prop NoGen :: 1
	prop Set :: (
	    if ($1 != .TSKTICK) {
		if ($1 == "PRD") {
                    PRD.THOOKFXN = PRD.DEFAULT_THOOKFXN,
                    if (TSK.USETSK == 1) {
                      if (PRD_clock.iIsUsed == 1) {
                        PRD_clock.function = @PRD_F_tick
                      }
                    }
		},
		if ($1 == "User") {
                    PRD.THOOKFXN = .NOPFXN,
                    if (PRD.gNumOf == 0) {
                      if (PRD_clock.iIsUsed == 1) {
                        PRD_clock.function = @FXN_F_nop
                      }
                    }
		},
		if ($1 != "PRD" && $1 != "User") {
		    .error ("Invalid TSK tick driver selection")
		}
	    },
	    .TSKTICK = $1,
	    "ok"
	)
    }
    
    
 
    prop GetPriority :: (
	.iPRI
    )
    
     
    inst iFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Task function"
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG0 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 0"
	prop JSName :: "arg0"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG1 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 1"
	prop JSName :: "arg1"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG2 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 2"
	prop JSName :: "arg2"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG3 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 3"
	prop JSName :: "arg3"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG4 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 4"
	prop JSName :: "arg4"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG5 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 5"
	prop JSName :: "arg5"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG6 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 6"
	prop JSName :: "arg6"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG7 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 7"
	prop JSName :: "arg7"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    
 
    inst iAUTOSTK :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Automatically allocate stack"
	prop JSName :: "autoAllocateStack"
        prop Set :: (
            if (($1 == 1) && (.iAUTOSTK == 0)) {
                .iSTKSZ = TSK.STACKSIZE
            },
            .iAUTOSTK = $1,
            "ok"
        )
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
    }
    
 
    inst iMANSTK :: @null {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Manually allocated stack"
	prop JSName :: "manualStack"
	prop Visible :: 1
	prop Writable :: .iAUTOSTK == 0
    }
 
 
 
 
    inst iSTKSZ :: TSK.STACKSIZE {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Label :: "Stack size (MAUs)"
	prop JSName :: "stackSize"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    $a = $1,
	    .iSTKSZ = ($1 - ($1 - 1) % 2 + 1),
 	    GlobalStatus.gDirty = 1,
	    "ok"
	)
    }
    inst iSYSTKSZ :: TSK.SYSTACKSIZE {
	    prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Style :: 0x02
	    prop Label :: "SyStack size (MAUs)"
	    prop JSName :: "sysStackSize"
	    prop Visible :: 1
	    prop Writable :: 1
	    prop Set :: (
		$a = $1,
                .iSYSTKSZ = ($1 - ($1 - 1) % 2 + 1),
		GlobalStatus.gDirty = 1,
	        "ok"
	    )
	}
   
 
    
    inst iSTKSEG ::= .OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: $1 == MEM_NULL || MEM.dataMember($1)
	prop Label :: "Stack Memory Segment"
	prop JSName :: "stackMemSeg"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iPRI :: TSK.PRIORITY {
	prop Label :: "Priority"
	prop JSName :: "priority"
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    if (self == TSK_idle) {
		if ($1 == 0) {
		    "ok"
		}
		else {
		    .error("Cannot change the priority of the idle task.")
		}
	    }
	    else {
	    if ($1 == 0) {
		.error("Priority 0 is reserved for the system idle task")
	    }
	    else {
		.iPRI = $1,
		"ok"
	    }
	    }
	)
    }
    inst iENV :: 0 {
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Environment pointer"
	prop JSName :: "envPointer"
	prop Visible :: 1
	prop Writable :: .iDelUser != "TSK"
	prop TabName :: "Advanced"
    }
    inst iEXITFLAG :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Don't shut down system while this task is still running"
	prop JSName :: "exitFlag"
	prop Visible :: 1
	prop Writable :: 1
	prop TabName :: "Advanced"
    }
    inst iUSETSKNAME :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Allocate Task Name on Target"
	prop JSName :: "allocateTaskName"
	prop Visible :: 1
	prop Writable :: 1
	prop TabName :: "Advanced"
    }
    inst iSTATREG :: 0x0000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%08x"
	prop Label :: "Initial Status Register value"
	prop Visible :: 0
	prop Writable :: 1
    }
     
    inst Order :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
	prop NoGen :: 0
	prop Writable :: 1
    }
    
 
    inst filter :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "filter"
	prop NoGen :: 0
    }
    inst maxformat :: .STSGetMaxFmt() {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "maxformat"
	prop NoGen :: 0
    }
    inst sumformat :: .STSGetSumFmt() {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "sumformat"
	prop NoGen :: 0
    }
    inst avgformat :: .STSGetAvgFmt() {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "avgformat"
	prop NoGen :: 0
    }
    inst filtmaxmult :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "filtmaxmult"
	prop NoGen :: 0
    }
    inst filtsummult :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "filtsummult"
	prop NoGen :: 0
    }
    inst unittype :: .uType() {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "unittype"
	prop NoGen :: 0
    }
}
object TSK_idle :: TSK {
    param iComment :: "This is the idle task; it only runs when no other task is ready"
    param iDelUser :: "TSK"
    param iDelMsg :: "This task executes all IDL functions and cannot be deleted"
    param iFXN :: GBL.DSPTYPE == 54
		? @_IDL_loop
		: @IDL_F_loop
    param iPRI :: 0
    param iIsUsed :: TSK.USETSK
}
 
object KNL_swi :: SWI {
    param function :: @_KNL_run
    param iComment :: "This Software Interrupt calls the TSK scheduler"
    param iDelUser :: "TSK"
    param iIsUsed :: TSK.USETSK
    param iDelMsg  :: (
        "This object cannot be deleted in DSP/BIOS."
    )
    param pri :: 0
    param dorta :: 1
}
 
type IDL {
    isa ObjectMgr
    prop Label :: "IDL - Idle Function Manager"
    prop name :: "IDL"
    prop IsContainedIn :: SCH
    prop GlobalIcon :: 111
    prop InstanceIcon :: 112
    prop GlobalHelpTopic :: (
	106
    )
    prop InstanceHelpTopic :: (
	206
    )
    prop InstancePropertyPage :: (
	"{586735F1-770B-11d0-A61F-0000C070F3E9}"
    )
    
    prop GlobalPropertyPage :: (
	"{586735F0-770B-11d0-A61F-0000C070F3E9}"
    )
    prop objectSize :: (
	if (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28) {
	     $a = (2 * 1)
	}
	else {
	     $a = (1 * 1)
	},
	$a
    )
    prop GenLinkPrologue :: (
        "SECTIONS {%4t\n.%1L: block(0x20000), RUN_START(%1U_A_TABBEGb) {%8t\n%1U_A_TABBEG = %1U_A_TABBEGb / 2;%4t\n} > %3s%5s\0, name, _objSize, _memSeg, _linkString, _pageString"
    )
    prop GenLinkEpilogue :: (
        "%4t\n.%1Lcal: block(0x20000), RUN_START(%1U_A_CALBEGb) {%8t\n%1U_A_CALBEG = %1U_A_CALBEGb / 2;%4t\n} > %3s%5s %0t\n}\n%6S\n\0, name, _objSize, _memSeg, _linkCalString, _pageString, _nilBusyObj"
    )
    prop _linkString :: "*(.%1L)" 
    prop _linkCalString :: "*(.%1Lcal)"
    prop _pageString :: GBL.DSPTYPE == 62 
                      ? "" 
                      : (GBL.DSPTYPE == 55  || GBL.DSPTYPE == 28)
                      ? ( 
                          IDL.OBJMEMSEG.space() == "code"
                          ? " PAGE 0"
                          : IDL.OBJMEMSEG.space() == "data"
                            ? " PAGE 1"
                            : IDL.OBJMEMSEG.space() == "io"
                              ? " PAGE 2"
                              : " PAGE 0"
                        )       
                      :" PAGE 1"
    prop _nilBusyObj :: ( ((IDL.USEIDLBUSYOBJ == 0) && (GBL.ROM == 1)) ?
         "IDL_busyObj = 0;\n"
        :
         ""
    )
    prop _memSeg :: IDL.OBJMEMSEG
     
    prop _objSize :: GBL.DSPTYPE == 55 ? (2 * .objectSize()) : .objectSize()
    prop dataSize :: (
	.objectSize() * (IDL.gNumOf + 1)	 
    )
    prop maxObjs :: (
	32767				 
    )
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    
 
    prop idlFxnSum :: (
	$a = 0,
	scan ($i; IDL) {
	   $a += $i.cycles
	},
	$a
    )
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    
 
    global AUTOCALCULATE :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Auto calculate idle loop instruction count"
	prop JSName :: "AUTOCALCULATE"
	prop Visible :: 1
	prop Writable :: CLK.USETIMER
	prop Set :: (
	    if ($1 == 1 && CLK.USETIMER == 0) {
		.error("CLK must be enabled to do idle loop intruction count")
	    }
	    else {
		if ($1 == 1 && GBL.ENABLEINST == 0) {
		    .error("Real Time Analysis must be enabled to do idle loop instruction count")
		}
		else {
		    .AUTOCALCULATE = $1,
		    "ok"
		}
	    }
	)
	prop NoGen :: 1
    }
    
 
    global USECLKIDLTIME ::= IDL.AUTOCALCULATE {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    
 
    global USEIDLBUSYOBJ ::= 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
 
 
     global CALIBRFXN :: = (
 	if (IDL.AUTOCALCULATE == 1) {
 	
 	    TSK.USETSK 
 	    ? @_IDL_stub: @_IDL_calibrate
 	}
 	else {
 	    @GBL_NULL
 	}
     ) {
 	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
 	prop Label :: "Idle Loop Auto-Calibrate Function"
 	prop Visible :: 0
 	prop Writable :: 1
 	prop NoGen :: 0
     }
    
 
    global CALIBRERROR :: = (
	if (GBL.DSPTYPE == 62 && IDL.CALIBRFXN == @IDL_F_stub) {
	    6
	}
	else {
	    0
	}
    ) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Idle Loop Auto-Calibrate Error"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
    }
  
 
    global LOOPOVERHEAD :: 0 {
	prop Label :: "Idle Loop Instruction Count"
	prop JSName :: "LOOPINSTCOUNT"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: .AUTOCALCULATE == 0
	prop NoGen :: 1
    }
    inst function :: @_FXN_F_nop {	 
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
    inst cycles :: 0 {
	prop Label :: "CPU cycles"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0		 
	prop Writable :: (.iDelUser == "USER") ? 1 : 0
	prop NoGen :: 1
    }
    inst calibration :: 1 {
	prop Label :: "Include in CPU load calibration"
	prop JSName :: "calibration"
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1		
	prop Writable :: (.iDelUser == "USER") ? 1 : 0
	prop NoGen :: 0
    }
     
    inst Order :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
	prop NoGen :: 1
	prop Writable :: 1
    }
     
    inst iPri :: 0 {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}
object IDL_cpuLoad :: IDL {
    param iComment :: "This object is required by the system to acquire CPU load data"
    param iId :: 0			
    param iIsUsed :: GBL.ENABLEINST
    param cycles :: 0			 
    param iDelUser :: "IDL"
    param iDelMsg :: (
	"This object is required to compute CPU load and can't be deleted"
    )
    param function :: @IDL_F_busy
}
object IDL_busyObj :: STS {
    param iComment :: "This object is required by the system to accumulate CPU load statistics"
    param iIsUsed :: GBL.ENABLEINST
    param iDelUser :: "IDL"
    param iDelMsg :: (
	"This object is required to accumulate CPU load data and can't be deleted"
    )
}
 
type ISRC {
    isa ObjectMgr
    prop name :: "ISRC"
    prop Label :: "ISRC - Interrupt Sources"
    prop IsConfMod :: 1          
    prop Visible :: 0
    inst iHwi :: HWI_UNUSED {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: HWI
        prop MemberTest :: 1
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
}
object Timer_0 :: ISRC {
    param iHwi :: HWI_INT23
}
object Timer_1 :: ISRC {
    param iHwi :: HWI_INT22
}
object Timer_2 :: ISRC {
    param iHwi :: HWI_INT8
}
object Timer_3 :: ISRC {
    param iHwi :: HWI_INT13
}
 
type LOG {
    isa  ObjectMgr
    prop name :: "LOG"
    prop Label :: "LOG - Event Log Manager"
    prop IsContainedIn :: INS
    prop GlobalIcon :: 113
    prop InstanceIcon :: 114
    prop InstanceHelpTopic :: (
	207
    )
    
    prop GlobalHelpTopic :: (
	107
    )
    prop InstancePropertyPage :: (
	"{B7240DE8-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
	"{B7240DE9-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	"1\0, _globalAllocDesc, _memSeg, _placement" 
    )
    prop _globalAllocDesc :: (
	"%8t .%1L: block(0x20000), RUN_START(%1U_A_TABBEGb), RUN_END(%1U_A_TABENDb) {%12t\n%1U_A_TABBEG = %1U_A_TABBEGb / 2; _%1U_A_TABBEG = %1U_A_TABBEGb / 2;%12t\n%1U_A_TABEND = %1U_A_TABENDb / 2; _%1U_A_TABEND = %1U_A_TABENDb / 2;%8t\n }\0, name"
    )
    prop objectSize :: (
	if (GBL.DSPTYPE == 28 ||
	   (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") ||
	   (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE")) {
	    $a = (10 * 1)
	},
	if (GBL.DSPTYPE == 62 || GBL.DSPTYPE == 54 ||
		(GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL")) {
	    $a = (6 * 1)
	},
	$a
    )
    prop _placement :: (0x7fffff / 2)
    prop AllocInst :: (
	"1\0, _instAllocDesc, _objMemSeg, _placement"
    )
    prop GenLinkEpilogue :: (
        "%0tLOG_A_TABLEN = %1d; _LOG_A_TABLEN = %1d;\n\0, numInst"
    )
    prop _instAllocDesc :: (
	"%8t /* %0s buffer */\n .%0s$buf: block(0x20000) align = 0x%1x {}\0, _objAlign"
    )
     
    prop _objSize :: GBL.DSPTYPE == 55 ? (2 * .objectSize()) : .objectSize()
    prop _memSeg :: LOG.OBJMEMSEG
    prop _linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no %1U objects */"
     
    prop _objAlign :: GBL.DSPTYPE == 55 
               ? .buflen * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)*2  
                : .buflen * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)  
    prop _objMemSeg :: .bufseg
    prop LogType :: .iType
    prop LogFormat :: .iFormat
    prop pageString :: (
        GBL.DSPTYPE == 62
	? ""
        : (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28)
	    ? (LOG.OBJMEMSEG.space() == "code"
	        ? " PAGE 0"
		: LOG.OBJMEMSEG.space() == "data"
		    ? " PAGE 1"
		    : LOG.OBJMEMSEG.space() == "io"
			? " PAGE 2"
			: " PAGE 0"
	      )
	    : " PAGE 1"
    )
    prop numInst :: (
    	LOG.gNumOf
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "log.h" : ""
    
 
    prop cGenHInst :: (
	if (GBL.DSPTYPE == 62) {
	    "extern far LOG_Obj %0r;\n\0"
	}
	else {
	    "extern LOG_Obj %0r;\n\0"
	}
    )
    prop dataSize :: (
	$d = 0,
	scan ($i; LOG) {
	    if ($i.IsConfObj()) {
		$d += $i.buflen
	    },
	    $d += .objectSize()	 
	},
	$d
    )
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global ENABLED :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Compile in logging"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst bufseg ::= .OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "bufseg"
	prop JSName :: "bufSeg"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst buflen :: 64 {
	
 
	prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "0,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768"
	prop Label :: "buflen (words)"
	prop JSName :: "bufLen"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    GlobalStatus.gDirty = 1,
	    .buflen = $1,
	    "ok"
	)
    }
    inst logtype :: "circular" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "circular,fixed"
	prop Label :: "logtype"
	prop JSName :: "logType"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst iType :: "printf" {
	prop Label :: "datatype"
	prop JSName :: "dataType"
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "printf,raw data"
	prop Visible :: 1
	prop Writable :: .iType == "system" ? 0 : 1
	prop NoGen :: 0
    }
    inst iFormat :: "0x%x, 0x%x, 0x%x" {
	prop Label :: "format"
	prop JSName :: "format"
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: .iType == "raw data" ? 1 : 0
	prop NoGen :: 0
    }
}
object LOG_system :: LOG {
    param iComment :: "This object is required by the system to accumulate execution trace information"
    param iId :: 0
    param iIsUsed :: 1			 
    param iType :: "system"
    param iDelUser :: "LOG"
    param iDelMsg :: (
	"LOG_system is a system log and cannot be deleted."
    )
}
 
type PIP {
    isa  ObjectMgr
    prop Label :: "PIP - Buffered Pipe Manager"
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 117
    prop InstanceIcon :: 118
    prop GlobalHelpTopic :: (
	109
    )
    prop InstanceHelpTopic :: (
	209
    )
    prop name :: "PIP"
    prop maxObjs :: (
	32767				 
    )
    prop objectSize :: (
	if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {
	    $a = (27 * 1)
	},
	if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
	    $a = (34 * 1)
	},
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
	    $a = (30 * 1)
	},
	if (GBL.DSPTYPE == 28 ||
	   (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") ||
	   (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE")) {
	    $a = (50 * 1)
	},
	if (GBL.DSPTYPE == 62) {
	    $a = (25 * 1)
	},
	$a
    )
    prop dataSize :: (
	$b = 0,
	scan ($i; PIP) {
	    if ($i.IsConfObj()) {
		$b += ((6) + $i.framesize) * $i.numframes + .objectSize()
	    }
	},
	$b
    )
    prop InstancePropertyPage :: (
	    "{B7240DF0-AA51-11cf-9BFE-0000C0AC14C8}"
    )
    
    prop GlobalPropertyPage :: (
	    "{B7240DF1-AA51-11cf-9BFE-0000C0AC14C8}"
    )
    prop localCreate :: (
	"ok"
    )
    prop AllocType :: (
	"1\0, _globalAllocDesc, _memSeg, _placement"
    )
    prop _globalAllocDesc :: (
	"%8t .%1L: block(0x20000), RUN_START(%1U_A_TABBEGb), RUN_END(%1U_A_TABENDb) {%12t\n%1U_A_TABBEG = %1U_A_TABBEGb / 2; _%1U_A_TABBEG = %1U_A_TABBEGb / 2;%12t\n%1U_A_TABEND = %1U_A_TABENDb / 2; _%1U_A_TABEND = %1U_A_TABENDb / 2;%8t\n }\0, name"
    )
    prop AllocInst :: (
	"1\0, _instAllocDesc, _objMemSeg, _placement"
    )
    prop GenLinkEpilogue :: (
        "%0tPIP_A_TABLEN = %1d;\n\0, numInst"
    )
    prop _instAllocDesc :: (
	.bufalign > 0 ? "%8t /* %0s buffer */\n .pip%1d: block(0x20000) align = 0x%2x {}\0, _objId, _objAlign" : "%8t /* %0s buffer */\n .pip%1d: block(0x20000){}\0, _objId"
    )
    prop _placement :: (0x7fffff / 2)
    prop _objId :: .iId
    prop _objAlign :: .bufalign * 2
    prop _objMemSeg :: .bufseg
    prop _linkString :: (.gNumOf + .gNumEmbed) > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop _memSeg :: PIP.OBJMEMSEG
    prop _objSize :: GBL.DSPTYPE == 55 ? (2 * .objectSize()) : .objectSize()
     
    prop numInst :: (
        HST.gNumOf + PIP.gNumOf
    )
    prop mkId :: (
	.iId = .gNextId++,
	.gNumOf++,
	.iId
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "pip.h" : ""
    
 
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far PIP_Obj %0r;\n\0"
	}
	else {
	    "extern PIP_Obj %0r;\n\0"
	}
    )
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global gNumEmbed :: 0 {	 
	prop NoGen :: 0
    }
    global gNextId :: 0
    global OBJSIZE ::= ._objSize
    inst bufseg ::= .OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "bufSeg"
	prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 1
    }
    inst bufalign :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "bufAlign"
	prop Style :: 0x01 | 0x02
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 1
	prop Set :: (
	    $e = "ok",
	    if ($1 == 0) {
		$e = .error("Cannot set align value to 0")
	    }
	    else {
		.bufalign = $1
	    },
	    $e
	)
    }
    inst buf :: "<NULL>" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst framesize :: 8 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "framesize (words)"
	prop JSName :: "frameSize"
	prop Style :: GBL.DSPTYPE == 62 ? 0x02 : 0x01 |0x02
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop Set :: (
	    if ($1 < 1) {
		.error("framesize must be >= 1.")
	    }
	    else {
		GlobalStatus.gDirty = 1,
		.framesize = $1,
		"ok"
	    }
	)
    }
    inst numframes  :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01
	prop JSName :: "numFrames"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop Set :: (
	    if ($1 < 1) {
		.error("Pipes must contain at least 1 frame.")
	    }
	    else {
		GlobalStatus.gDirty = 1,
		.numframes = $1,
		"ok"
	    }
	)
    }
    inst monitor :: "reader" {
    	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "monitor"
	prop Enum :: "reader,writer,none"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst notifyWriter :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyWriterFxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    inst nwarg0 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyWriterArg0"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    inst nwarg1 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyWriterArg1"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    inst notifyReader :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyReaderFxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    inst nrarg0 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyReaderArg0"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    inst nrarg1 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyReaderArg1"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    
    inst bufFrameAlign ::= ._objAlign  {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
}
 
type SEM {
    isa ObjectMgr
    prop name :: "SEM"
    prop Label :: "SEM - Semaphore Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 137
    prop InstanceIcon :: 138
    prop GlobalHelpTopic :: (
	310
    )
    prop InstanceHelpTopic :: (
	410
    )
    prop InstancePropertyPage :: (
	"{D01ACC04-38DD-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{D01ACC05-38DD-11d1-988B-0020AFEE33C6}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: (
	"%8t .sem: block(0x20000){}"
    )
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: .OBJMEMSEG
    
 
    prop objectSize :: (
        if (GBL.DSPTYPE == 62) {
            $a = (8 + 3)
	},
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
            $a = (10 + 4)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {
            $a = (8 + 3)
        },
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {
            $a = (16 + 6)
        },
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {
            $a = (16 + 6)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
            $a = (10 + 4)
        },
	if (GBL.DSPTYPE == 28) {
            $a = (16 + 6)
        },
        $a
   )
    prop dataSize :: (
	SEM.objectSize * SEM.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "sem.h" : ""
    
 
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far SEM_Obj %0r;\n\0"
	}
	else {
	    "extern SEM_Obj %0r;\n\0"
        }
    )
    
 
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst iCount :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Label :: "Initial semaphore count"
	prop JSName :: "count"
	prop Visible :: 1
	prop Writable :: 1
    }
}
 
 
type MBX {
    isa ObjectMgr
    prop name :: "MBX"
    prop Label :: "MBX - Mailbox Manager"
    prop IsContainedIn :: SYN 
    prop GlobalIcon :: 131
    prop InstanceIcon :: 132
    prop GlobalHelpTopic :: (
	307
    )
    prop InstanceHelpTopic :: (
	407
    )
    prop InstancePropertyPage :: (
	"{0EB45D44-38C1-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{0EB45D45-38C1-11d1-988B-0020AFEE33C6}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0,	_bssAllocDesc, _memSeg, _placement"
	    }
    )
    prop _bssAllocDesc :: (
	    "%8t .mbx: block(0x20000){}"
    )
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: .OBJMEMSEG
    prop AllocInst :: (
	"1\0 _instAllocDesc, _instMemSeg, _placement"
    )
 
 
 
 
 
 
 
    prop _instAllocDesc :: (
	"%8t .%0s$que: block(0x20000) align = 0x4 {%12t\n %0s$queElems = .;\n . += %1d;%8t\n }\0, _qElemSize"
    )
    prop _instMemSeg :: .iMbxSeg
    prop _qElemSize :: (
	if ((GBL.DSPTYPE == 55) && (GBL.DSPSUBTYPE != 5599)) {
             
            $a = .iMsgSize,
            if ($a & 0x1) {
                $a += 1
            },
	     
	     (4 + $a) * .iMbxLength  * 2 
	}
	else {
	    if (GBL.DSPTYPE == 28) {
                 
                $a = .iMsgSize,
                if ($a & 0x1) {
                    $a += 1
                },
	        (4 + $a) * .iMbxLength
	    }
	    else {
                 
                $a = .iMsgSize,
		$b = GBL.DSPWORDSIZE / GBL.DSPCHARSIZE,
		$c = $a & ($b - 1),
		if ($c != 0) {
		    $a = $a + ($b - $c)
		},
	        (4 + $a) * .iMbxLength
	    }
	}
    )
    
 
    prop objectSize :: (
        if (GBL.DSPTYPE == 62) {
            $a = (29)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
            $a = (28)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {
            $a = (24)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {
            $a = (46)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {
            $a = (46)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
            $a = (28)
        },
        if (GBL.DSPTYPE == 28) {
            $a = (46)
        },
        $a
    )
    prop dataSize :: (
	$d = 0,
	scan ($i; MBX) {
	    $d += (GBL . DSPWORDSIZE / GBL . DSPCHARSIZE) * (($i.iMsgSize + 2) * $i.iMbxLength + .objectSize())
	},
	$d
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "mbx.h" : ""
    
 
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far MBX_Obj %0r;\n\0"
	}
	else {
	    "extern MBX_Obj %0r;\n\0"
	}
    )
    
 
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst iMsgSize :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Label :: "Message Size"
	prop JSName :: "messageSize"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    if ($1  == 0) {
		.error ("Message size cannot be zero")
	    }
	    else {
	    	GlobalStatus.gDirty = 1,
		.iMsgSize = $1,
		"ok"
	    }
	)
    }
    inst iMbxLength :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Label :: "Mailbox Length"
	prop JSName :: "length"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    if ($1  == 0) {
		.error ("Mailbox length cannot be zero")
	    }
	    else {
	    	GlobalStatus.gDirty = 1,
		.iMbxLength = $1,
		"ok"
	    }
	)
    }
    inst iMbxSeg :: MBX.OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Element memory segment"
	prop JSName :: "elementSeg"
	prop Visible :: 1
	prop Writable :: 1
    }
}
 
type QUE {
    isa ObjectMgr
    prop name :: "QUE"
    prop Label :: "QUE - Atomic Queue Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 133
    prop InstanceIcon :: 134
    prop IsConfMod :: 1		 
    prop GlobalHelpTopic :: (
	309
    )
    prop InstanceHelpTopic :: (
	409
    )
    prop InstancePropertyPage :: (
	"{D01ACC01-38DD-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{D01ACC02-38DD-11d1-988B-0020AFEE33C6}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: (
	"%8t .que: block(0x20000){}"
    )
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: .OBJMEMSEG
    
 
    prop objectSize :: (
        if (GBL.DSPTYPE == 62) {
            $a = (2)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
            $a = (2)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {
            $a = (2)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {
            $a = (4)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {
            $a = (4)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
            $a = (2)
        },
        if (GBL.DSPTYPE == 28) {
            $a = (4)
        },
        $a
    )
    prop dataSize :: (
	QUE.objectSize * QUE.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "que.h" : ""
    
 
    prop cGenHInst :: (
	if (GBL.DSPTYPE == 62) {
	    "extern far QUE_Obj %0r;\n\0"
	}
	else {
	    "extern QUE_Obj %0r;\n\0"
	}
    )
    
 
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
}
 
type LCK {
    isa ObjectMgr
    prop name :: "LCK"
    prop Label :: "LCK - Resource Lock Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 129
    prop InstanceIcon :: 130
    prop IsConfMod :: 1		 
    prop GlobalHelpTopic :: (
	306
    )
    prop InstanceHelpTopic :: (
	406
    )
    prop InstancePropertyPage :: (
	"{0EB45D40-38C1-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{0EB45D41-38C1-11d1-988B-0020AFEE33C6}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _bssAllocDesc, _memSeg, _placement"
	}
    )
    prop _bssAllocDesc :: (
	"%8t .lck: block(0x20000){}"
    )
    prop _objAllocDesc :: (
	"%8t .LCK$obj: block(0x20000){}"
    )
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: .OBJMEMSEG
    
 
    prop objectSize :: (
        if (GBL.DSPTYPE == 62) {
            $a = (10)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
            $a = (12)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {
            $a = (10)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {
            $a = (20)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {
            $a = (20)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
            $a = (12)
        },
        if (GBL.DSPTYPE == 28) {
            $a = (20)
        },
        $a
    )
    prop dataSize :: (
	LCK.objectSize * LCK.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "lck.h" : ""
    
 
    prop cGenHInst :: (
	if (GBL.DSPTYPE == 62) {
	    "extern far LCK_Obj %0r;\n\0"
	}
	else {
	    "extern LCK_Obj %0r;\n\0"
	}
    )
    
 
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
}
 
 
type STS {
    isa  ObjectMgr
    prop name :: "STS"
    prop Label :: "STS - Statistics Object Manager"
    prop IsContainedIn :: INS
    prop GlobalIcon :: 125
    prop InstanceIcon :: 126
    prop InstanceHelpTopic :: (
	212
    )
    
    prop GlobalHelpTopic :: (
	112
    )
    prop AllocType :: (
	"1\0, _globalAllocDesc, _memSeg, _placement"
    )
    prop _globalAllocDesc :: (
	"%8t .%1L: block(0x20000), RUN_START(%1U_A_TABBEGb), RUN_END(%1U_A_TABENDb) {%12t\n%1U_A_TABBEG = %1U_A_TABBEGb / 2; _%1U_A_TABBEG = %1U_A_TABBEGb / 2;%12t\n%1U_A_TABEND = %1U_A_TABENDb / 2; _%1U_A_TABEND = %1U_A_TABENDb / 2;%8t\n }\0, name"
    )
    prop localInit :: (
	if (PRD.CALLBACKOBJ != nil) {
	    .error("STS initialization failure")
	},
	PRD.CALLBACKOBJ = STS
    )
    prop objectSize :: (
	(4 * 2)
    )
    prop _placement :: (0x7fffff / 2)
    prop _linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop _memSeg :: STS.OBJMEMSEG
     
    prop _objSize :: GBL.DSPTYPE == 55 ? (2 * .objectSize()) : .objectSize()
    prop dataSize :: (
	.objectSize() * (STS.gNumOf + STS.gNumEmbed)
    )
    prop maxObjs :: (
	32767			 
    )
    prop InstancePropertyPage :: (
	"{B7240DEE-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
	"{B7240DEF-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
 
    prop STSGetMaxFmt :: (
	.format
    )
    prop STSGetSumFmt :: (
	.format
    )
    prop STSGetAvgFmt :: (
	"%.2f"
    )
    prop STSFilterSum :: (
	(.iA * $1 + .iB * $2) / (1.0 * .iC)
    )
    prop STSFilterMax :: (
	(.iA * $1 + .iB) / (1.0 * .iC)
    )
    prop HighTimeBased :: (
	.unittype == "High resolution time based" ? 1 : 0
    )
    prop LowTimeBased :: (
	.unittype == "Low resolution time based" ? 1 : 0
    )
     
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "sts.h" : ""
    
 
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far STS_Obj %0r;\n\0"
	}
	else {
	    "extern STS_Obj %0r;\n\0"
        }
    )
    prop modifiable :: (
	((.iDelUser == "USER" || .iDelUser == "HWI") ? 1 : 0)
    )
    prop untype :: (
        if (.unittype == "Not time based") {
	    $a = 2
	},
	if (.unittype == "High resolution time based") {
	    $a = 0
        },
	if (.unittype == "Low resolution time based") {
	    $a = 1
        },
	$a
    )
    prop optype :: (
        if (.operation == "Nothing") {
	    $a = 0
	},
	if (.operation == "A * x") {
	    $a = 1
        },
	if (.operation == "A * x + B") {
	    $a = 2
        },
	if (.operation == "(A * x + B) / C") {
	    $a = 3
        },
	$a
    )
    
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global gNumEmbed :: 0 {	 
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst prev :: 0 {		 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: .modifiable()
	prop JSName :: "previousVal"
	prop NoGen :: GBL.DSPTYPE != 40 && GBL.DSPTYPE != 62
	prop Set :: (
	    .prev = $1,
	    .prevlow = $1 & 0xffff,
	    .prevhigh = ($1 >> 16) & 0xffff,
	    "ok"
	)
    }
    
 
    inst format :: "%g" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "format"
	prop NoGen :: 1
    }
    
 
    inst filter :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "filter"
	prop NoGen :: 0
    }
    
 
    inst maxformat :: "%g" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "maxformat"
	prop NoGen :: 0
    }
    inst sumformat :: "%g" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "sumformat"
	prop NoGen :: 0
    }
    inst avgformat :: "%.2f" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "avgformat"
	prop NoGen :: 0
    }
    
 
    inst unittype :: "Not time based" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "Not time based,High resolution time based,Low resolution time based"
	prop Label :: "unit type"
	prop JSName :: "unitType"
	prop Visible :: 1
	prop Writable :: .modifiable()
	prop NoGen :: 1
	prop Set :: (
	    .unittype = $1,
	    if ($1 == "High resolution time based") {
		.iA = 1,
		.iB = 0,
		.iC = 1,
		.operation = "A * x"
	    }
	    else {
		if ($1 == "Low resolution time based") {
		    .iA = 1,
		    .iB = 0,
		    .iC = 1,
		    .operation = "A * x"
		}
		else {
		    .iA = 1,
		    .iB = 0,
		    .iC = 1,
		    .operation = "Nothing"
		}
	    },
	    "ok"
	)
    }
    inst operation :: "Nothing" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "Nothing,A * x,A * x + B,(A * x + B) / C"
	prop Label :: "host operation"
	prop JSName :: "operation"
	prop Visible :: 1
	prop Writable :: (
	    (.unittype != "Low resolution time based") && .modifiable()
	)
	prop NoGen :: 1
	prop Set :: (
	    .operation = $1,
	    if ($1 == "Nothing" && .unittype != "High resolution time based") {
		.iA = 1,
		.iB = 0,
		.iC = 1
	    }
	    else {
		if ($1 == "A * x") {
		    .iB = 0,
		    .iC = 1
		}
		else {
		    if ($1 == "A * x + B") {
			.iC = 1
		    }
		}
	    },
	    "ok"
	)
    }
    inst op ::= .optype() {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
     }
    inst uType ::= .untype() {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
     }
    inst iA :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: (.modifiable() &&
	    !(.unittype != "Not time based" || .operation == "Nothing")
	)
	prop Label :: "A"
	prop JSName :: "numA"
	prop NoGen :: 0
    }
    inst iB :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: (.modifiable() &&
	    !(.unittype == "Low resolution time based" || .operation == "Nothing" || .operation == "A * x")
	)
	prop Label :: "B"
	prop JSName :: "numB"
	prop NoGen :: 0
    }
    inst iC :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: (.modifiable() &&
	    (.unittype == "Not time based" && .operation == "(A * x + B) / C")
	)
	prop Label :: "C"
	prop JSName :: "numC"
	prop NoGen :: 0
    }
    inst prevhigh :: 0 {	 
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: GBL.DSPTYPE == 40 || GBL.DSPTYPE == 62
    }
    
 
    inst prevlow :: 0 {		 
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
}
 
type SYS {
    isa Module
    prop name :: "SYS"
    prop Label :: "SYS - System Settings"
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 141
    prop InstanceIcon :: 142
    prop IsConfMod :: 1		 
    prop GlobalHelpTopic :: (
	313
    )
    prop InstanceHelpTopic :: (
	413
    )
    prop InstancePropertyPage :: (
	"{473C4A62-B1A8-11d0-9885-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{473C4A63-B1A8-11d0-9885-0020AFEE33C6}"
    )
    prop AllocType :: ( .PUTCFXN == @_UTL_doPutc ?
	"2\0, _globalAllocDesc,	_memSeg, _midPlace, 	      _traceString, _traceSeg, _midPlace"
	:
	"1\0, _globalAllocDesc,	_memSeg, _midPlace"
    )
    prop _globalAllocDesc :: (
	"%8t .sys: block(0x20000)    {}"
    )
    prop _traceString   :: (
	"%8t .trace: block(0x20000) fill = 0x0 {%12t\n_SYS_PUTCBEG = .;\n. += 0x%1x;\n_SYS_PUTCEND = . - 1;%8t\n }\0, _traceSize"
    )
    prop _midPlace :: (0x7fffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    prop _traceSeg :: SYS.TRACESEG
    prop _traceSize :: (SYS.TRACESIZE * 2)
    
 
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global TRACESIZE :: 512 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "%d"
	prop Style :: 0x01 | 0x02
	prop Label :: "Trace Buffer Size"
	prop JSName :: "TRACESIZE"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global TRACESEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1) 
	prop Label :: "Trace Buffer Memory"
	prop JSName :: "TRACESEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global ABORTFXN :: @_UTL_doAbort {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Abort Function"
	prop JSName :: "ABORTFXN"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    global ERRORFXN :: @_UTL_doError {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Error Function"
	prop JSName :: "ERRORFXN"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    global EXITFXN :: @_UTL_halt {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Exit Function"
	prop JSName :: "EXITFXN"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    global PUTCFXN :: @_UTL_doPutc {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Putc Function"
	prop JSName :: "PUTCFXN"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
}
 
type SIO {
    isa ObjectMgr
    prop name :: "SIO"
    prop Label :: "SIO - Stream Input and Output Manager"
    prop IsContainedIn :: IOF
    prop DependsOn :: "DIO,DGN,DHL,DPI"
    prop GlobalIcon :: 139
    prop InstanceIcon :: 140
    prop GlobalHelpTopic :: (
	311
    )
    prop InstanceHelpTopic :: (
	411
    )
    prop InstancePropertyPage :: (
	"{7C4C9A60-763E-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{7C4C9A61-763E-11d1-988B-0020AFEE33C6}" 
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "2\0, _bssAllocDesc, _memSeg, _placement,
	          _objAllocDesc, _memSeg, _placement"
	}
    )
    prop _bssAllocDesc :: (
        "%8t .SIO$bss: block(0x20000) {%12t\n *(.SIO$bss)%8t\n }"
    )
    prop _objAllocDesc :: (
        "%8t .SIO$obj: block(0x20000) {%12t\n *(.SIO$obj)%8t\n }"
    )
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: .OBJMEMSEG
    prop AllocInst ::  (
	"1\0, _instBufDesc, _instBufSeg, _placement"
    )
    prop _instBufDesc :: (
	.iAlign > 1? "%8t .%0s$bufs: block(0x20000) align = 0x%1x {}\0, _objAlign" : "%8t .%0s$bufs: block(0x20000) {}"
    )
    prop _objAlign :: .iAlign * 2
    
 
    prop _instBufSeg :: .iBufSegid
    prop defDev :: (
	$h = nil,
	$i = nil,
	$j = nil,
	scan ($h; nil) {
	    if ($h.isDriver == 1) {
		scan ($i; $h) {
	            if ($j == nil
		        && $i.iIsTerminal != 0 && $i.iIsVirtual == 0) {
			
 
			$j = $i,
			break
		    }
		}
	    }
	},
	$j
    )
    prop devList :: (
	$h = nil,
	$i = nil,
	$j = nil,
	scan ($h; nil) {
	    if ($h.isDriver == 1) {
		scan ($i; $h) {
	            if ($j == nil
			&& $i.iIsTerminal != 0 && $i.iIsVirtual == 0) {
			
 
			$j = $i,
			scan ($a; DIO) {
			    if ($a == $i) {
				$i.numTimeUse++
			    }
			},
		        break
	            }
		}
	    }
	},
	$j
    )
     
    prop setDev :: (
	$h = nil,
	$i = nil,
	$j = nil,
	scan ($h; nil) {
	    if ($h.isDriver == 1) {
		scan ($i; $h) {
		    if ($i == $1) {
			$j = $i
		    }
		}
	    }
	},
	$j
    )
    prop localCanCreate :: (
	if (.defDev == nil) {
	    .error ("A driver device must be created before creating a stream.")
	}
	else {
	    "ok"
	}
    )
    prop localDelete :: (
	scan ($a; DIO) {
	    if ($a == .iDevice) {
		.iDevice.numTimeUse--
	    }
	},
	"ok"
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "sio.h" : ""
    
 
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far SIO_Obj %0r;\n\0"
	}
	else {
	    "extern SIO_Obj %0r;\n\0"
        }
    )
    global gNumEmbed :: 0 {   
	prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global USEISSUERECLAIM :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Use Only Issue/Reclaim Model"
	prop JSName :: "USEISSUERECLAIM"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    .USEISSUERECLAIM = $1,
	    if ($1 == 1) {
		scan ($i; SIO) {
		    $i.iModelName = "Issue/Reclaim"
		}
	    },
	    "ok"
	)
    }
    
    inst iDevice :: SIO.devList {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop TypeTest :: $1.isDriver == 1
	prop MemberTest :: $1.driverType != "DEV_IOMTYPE"
	prop Label :: "Device"
	prop JSName :: "deviceName"
	prop Set :: (
	    if (($1.iIsTerminal == 0) && (.iDevCtrlParam == "")) {
		    .error("To select a stacking device, enter first a terminal device in Device Control String")
	    }
	    else {
		if ($1.iIsVirtual == 1) {
		    .error("The device you have selected is a virtual instance, you must select a non-virtual device")
		}
		else {
		    scan($a; DIO) {
			if ($a == .iDevice) {
			    .iDevice.numTimeUse--
			}
		    },
		    scan($b; DIO) {
			if ($b == $1) {
			    $1.numTimeUse++
			}
		    },
		    .iDevice = .setDev($1),
		    "ok"
		}
	    }
	)
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iDevCtrlParam :: "" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Device Control String"
	prop JSName :: "controlParameter"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iDevId ::= .iDevice.iDevId
    inst iFxns  ::= .iDevice.iFxns
    inst iMode :: "input" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "input,output"
	prop Label :: "Mode"
	prop JSName :: "mode"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iBufsize :: 0x80 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Label :: "Buffer size"
	prop JSName :: "bufSize"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iNbufs :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01
	prop Label :: "Number of buffers"
	prop JSName :: "numBufs"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iBufSegid ::= .OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Place buffers in memory segment"
	prop JSName :: "bufSegId"
	prop Visible :: 1
	prop Writable :: .iAllocBuf == 1
    }
    inst iAlign :: 1 {
	prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768"
	prop Label :: "Buffer alignment"
	prop JSName :: "bufAlign"
	prop Visible :: 1
	prop Writable :: .iAllocBuf == 1
    }
    
 
    inst iFlush :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Flush"
	prop JSName :: "flush"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iModelName :: "Standard" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "Standard,Issue/Reclaim"
	prop Label :: "Model"
	prop JSName :: "modelName"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    $e = "ok",
	    if (.USEISSUERECLAIM == 1) {
		if ($1 == "Standard") {
	    	    $e = .error("SIO Issue/Reclaim model support selected")
	        }
	        else {
		    .iModel = $1 == "Standard"
			? "SIO_STANDARD"
			: "SIO_ISSUERECLAIM",
	            .iModelName = $1
	        }
	    }
	    else {
		.iModel = $1 == "Standard"
		    ? "SIO_STANDARD"
		    : "SIO_ISSUERECLAIM",
	        .iModelName = $1
	    },
	    $e
	)
    }
    inst iAllocBuf ::= .iSaveAllocBuf {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Allocate Static Buffer(s)"
	prop JSName :: "allocStaticBuf"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    .iSaveAllocBuf = $1,
	    "ok"
	)
    }
    inst iSaveAllocBuf :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    inst iModel :: "SIO_STANDARD" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "SIO_STANDARD,SIO_ISSUERECLAIM"
	prop Visible :: 0
	prop Writable :: 0
    }
    inst iTimeout ::= .iModel == "SIO_ISSUERECLAIM" ? .iSaveTimeout : -1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Timeout for I/O operation"
	prop JSName :: "timeout"
	prop Visible :: 1
	prop Writable :: .iModel == "SIO_ISSUERECLAIM"
	prop Set :: (
	    .iSaveTimeout = $1,
	    "ok"
	)
    }
    inst iSaveTimeout :: -1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    
    inst useCallBackFxn :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "use callback function"
	prop JSName :: "useCallBackFxn"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop TabName :: "Callback"
    }
    inst callBackFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "callback function"
	prop JSName :: "callBackFxn"
	prop Visible :: 1
	prop Writable :: .useCallBackFxn
	prop NoGen :: 0
	prop TabName :: "Callback"
    }
    inst arg0 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "argument 0"
	prop JSName :: "arg0"
	prop Visible :: 1
	prop Writable :: .useCallBackFxn
	prop NoGen :: 0
	prop TabName :: "Callback"
    }
    inst arg1 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "argument 1"
	prop JSName :: "arg1"
	prop Visible :: 1
	prop Writable :: .useCallBackFxn
	prop NoGen :: 0
	prop TabName :: "Callback"
    }
}
 
type GIO {
    isa Module
    prop Visible :: 1
    prop name :: "GIO"
    prop Label :: "GIO - General Input/Output Manager"
    prop IsConfMod :: .USEGIO 
    prop IsContainedIn :: IOF
    prop DependsOn :: "UDEV"
 
    prop GlobalIcon :: 141
    prop InstanceIcon :: 142
    prop GlobalHelpTopic :: (
	320
    )
    prop InstanceHelpTopic :: (
	420
    )
    prop InstancePropertyPage :: (
	"{473C4A62-B1A8-11d0-9885-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{473C4A63-B1A8-11d0-9885-0020AFEE33C6}"
    )
    prop AllocType :: (
	"1\0, _globalAllocDesc, _memSeg, _midPlace"
    )
    prop _globalAllocDesc :: (
	"%8t .gio: block(0x20000)    {}"
    )
    prop _midPlace :: (0x7fffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    
 
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global USEGIO :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable General Input/Output Manager"
	prop JSName :: "ENABLEGIO"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
 
    global CREATEFXN ::= .USEGIO == 1 ? @_SEM_create : @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Create Function"
	prop JSName :: "CREATEFXN"
	prop Visible :: 1
	prop Writable :: .USEGIO
	prop NoGen :: 0
    }
    global DELETEFXN ::= .USEGIO == 1 ? @_SEM_delete : @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Delete Function"
	prop JSName :: "DELETEFXN"
	prop Visible :: 1
	prop Writable :: .USEGIO
	prop NoGen :: 0
    }
    global PENDFXN ::= .USEGIO == 1 ? @_SEM_pend : @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Pend Function"
	prop JSName :: "PENDFXN"
	prop Visible :: 1
	prop Writable :: .USEGIO
	prop NoGen :: 0
    }
    global POSTFXN ::= .USEGIO == 1 ? @_SEM_post : @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Post Function"
	prop JSName :: "POSTFXN"
	prop Visible :: 1
	prop Writable :: .USEGIO
	prop NoGen :: 0
    }
}
 
type DEV {
    isa ObjectMgr
    prop name :: "DEV"
    prop Visible :: 0
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _bssAllocDesc, _memSeg, _placement"
	},
	
 
	if (.devCount() > 0 ) {
	    "1\0, _devtableDesc, _memSeg, _placement"
	}
    )
    prop _bssAllocDesc :: (
	"%8t .dev: block(0x20000){}"
    )
    prop _devtableDesc :: (
	"%8t .devtable: block(0x20000){}"
    )
    prop _memSeg :: MEM.CFGOBJSEG
    prop _placement :: (0x7fffff / 2)
    prop DependsOn :: "HWI,PWRM"
    prop devCount :: (
	$i = nil,
	$a = 0,
	scan ($i; nil) {
	    if ($i.isDriver == 1) {
		$a = $a + $i.gNumOf
	    }
	},
	$a
    )
}
 
type UDEV {
    isa ObjectMgr
    prop name :: "UDEV"
    prop Label :: "User-Defined Devices"
    prop IsContainedIn :: SIODRIVER
    prop DependsOn :: "DEV"
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop GlobalHelpTopic :: (
	315
    )
    prop InstanceHelpTopic :: (
	415
    )
    prop InstancePropertyPage :: (
	"{7AE86AA0-35C0-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{7AE86AA1-35C0-11d1-988B-0020AFEE33C6}"
    )
    prop maxObjs :: (32767)
    prop isDriver :: (
	1
    )
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: (
        "%8t .udev: block(0x20000){}"
    )
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    prop _driverType :: (
	.fxnTableType == "DEV_Fxns" ? "DEV_SIOTYPE" : "DEV_IOMTYPE"
    )
    inst iInit :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"	
	prop Label :: "init function"
	prop JSName :: "initFxn"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    .iInit = $1,
	    .initFxn = .iInit,
	    "ok"
	)
    }
    inst iFxns :: 0 {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"	
	prop Label    :: "function table ptr"
	prop JSName :: "fxnTable"
	prop Visible  :: 1
	prop Writable :: 1
    }
    
    inst fxnTableType :: "DEV_Fxns" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "DEV_Fxns,IOM_Fxns"
	prop Label :: "function table type"
	prop JSName :: "fxnTableType"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    inst driverType ::= ._driverType {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "DEV_SIOTYPE,DEV_IOMTYPE"
	prop Visible :: 0
    }
    
    inst iDevId :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "device id"
	prop JSName :: "deviceId"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    .iDevId = $1,
	    .deviceId = .iDevId,
	    "ok"
	)
    }
    inst iParams :: 0 {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label    :: "device params ptr"
	prop JSName :: "params"
	prop Visible  :: 1
	prop Writable :: 1
    }
    inst deviceId :: 0 {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName   :: ""
	prop Visible  :: 0
    }
    inst initFxn :: 0 {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"	
	prop JSName   :: ""
	prop Visible  :: 0
    }
    inst iIsStacking ::0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Stacking Device"
	prop JSName :: "stackingDevice"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst deviceGlobalDataPtr :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "device global data ptr"
	prop JSName :: "deviceGlobalDataPtr"
	prop Visible :: 1
	prop Writable :: .fxnTableType == "IOM_Fxns"
    }
    inst iIsTerminal ::= .fxnTableType == "DEV_Fxns" ? 1 : 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    inst iIsVirtual :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
}
 
type DIO {
    isa ObjectMgr
    prop Visible :: 1
    prop Label :: "DIO - Class Driver"
    prop name :: "DIO"
    prop IsContainedIn :: SIODRIVER
    prop DependsOn :: "UDEV"
    prop GlobalIcon :: 127
    prop InstanceIcon :: 127
    prop GlobalHelpTopic :: (
	319
    )
    prop InstanceHelpTopic :: (
	419	
    )
    prop InstancePropertyPage :: (		
	"{f80273c0-3838-11d2-a32c-006097656921}"
    )
    
    prop GlobalPropertyPage :: (		
	"{050a0600-3839-11d2-a32c-006097656921}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: (
	"%8t .dio: {}"
    )
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: .OBJMEMSEG
    prop isDriver :: (
	1
    )
    prop mdObject :: (
	$h = nil,
	$j = nil,
	scan ($h; UDEV) {
	    if ($h.driverType == "DEV_IOMTYPE" ) {
		$j = $h,
                break
	    }
	},
	$j
    )
    prop localCanCreate :: (
	if (.mdObject == nil) {
	    .error ("An IOM type device must be created first.")
	}
	else {
	    "ok"
	}
    )
    prop numTsk :: (
	$a = 0,
	$h = nil,
	scan ($h; DIO) {
	    if ($h.useCallBackFxn == 0) {
		$a = $a + $h.numTimeUse
	    }
	},
	$a
    )
    prop numSwi :: (
	$a = 0,
	$h = nil,
	scan ($h; DIO) {
	    if ($h.useCallBackFxn == 1) {
		$a = $a + $h.numTimeUse
	    }
	},
	$a
    )
	
    prop functionTablePtr :: (
	if (.STATIC) {
	    if (.useCallBackFxn) {
		@_DIO_cbStaticFxns
	    }
	    else {
		@_DIO_tskStaticFxns
	    }
	}
	else {
	    if (.useCallBackFxn) {
		@_DIO_cbDynamicFxns
	    }
	    else {
		@_DIO_tskDynamicFxns
	    }
	}
    )
    global OBJMEMSEG :: DARAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global STATIC :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Create all DIO Objects Statically"
	prop JSName :: "STATICCREATE"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    global NUMTSKBASE ::= .numTsk  {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "TSK based"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global NUMSWIBASE ::= .numSwi  {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "SWI based"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst useCallBackFxn :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "use callback version of DIO function table (for SWI)"
	prop JSName :: "useCallBackFxn"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    inst fxnsTable ::= .functionTablePtr {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible  :: 1
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst initFxn :: @_DIO_init {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible  :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst deviceName :: .mdObject {
        prop Type     :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: UDEV
	prop MemberTest :: $1.driverType == "DEV_IOMTYPE"
        prop Label    :: "device name"
        prop JSName   :: "deviceName"
        prop Visible  :: 1
        prop Writable :: 1
	prop NoGen :: 0
    }
    inst chanParams :: 0 {
        prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label    :: "channel parameters"
        prop JSName   :: "chanParams"
        prop Visible  :: 1
        prop Writable :: 1
	prop NoGen :: 0
    }
    inst numTimeUse :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iDevId :: 0 {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible  :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iFxns ::= .functionTablePtr {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible  :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iIsTerminal :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iIsVirtual :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
}
 
type DGN {
    isa ObjectMgr
    prop name :: "DGN"
    prop Label :: "DGN - Software Generator Driver"
    prop IsContainedIn :: SIODRIVER
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop GlobalHelpTopic :: (
	302
    )
    prop InstanceHelpTopic :: (
	402
    )
    prop InstancePropertyPage :: (
	"{054FE166-B014-11d0-9885-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{054FE167-B014-11d0-9885-0020AFEE33C6}"
    )
    prop DependsOn :: "DEV"
    prop maxObjs :: (32767)
    prop isDriver :: (
	1
    )
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: (
	"%8t .dgn: block(0x20000){}"
    )
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    inst iDevice :: "user" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: GBL.DSPARITHMETIC == "FLOAT" ?
		"user,sine,random,constant,printFloat,printHex,printInt"
		:"user,sine,random,constant,printHex,printInt"
	prop Label :: "Device category"
	prop JSName :: "device"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    $a = $1,
	    if ($a != .iDevice) {
		.iDevice = $a,
		.iUserFxn = @_FXN_F_nop	 
	    },
	    if ($a == "user") {
		.iUserFxn = .iSaveUserFxn
	    },
	    if ($a == "printFloat") {
		.iUserFxn = @_DGN_printFloat
	    },
	    if ($a == "printHex") {
		.iUserFxn = @_DGN_printHex
	    },
	    if ($a == "printInt") {
		.iUserFxn = @_DGN_printInt
	    },
	    "ok"
	)
    }
    inst iUseDefaults :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Use default parameters"
	prop Visible :: 1
	prop JSName :: "useDefaultParam"
	prop Writable :: .iDevice == "sine" || .iDevice == "constant" || .iDevice == "random" || .iDevice == "user"
    }
    inst iDevId ::= .iDevice == "constant" ? @DGN_CONST : .iDevice == "random" ? @DGN_RAND : .iDevice == "sine" ? @DGN_SINE : @DGN_USER {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Device ID"
	prop JSName :: "deviceId"
	prop Visible :: 1
	prop Writable :: 0
    }
    inst iIsTerminal :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    inst iIsVirtual :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    
 
    inst iConstant :: GBL.DSPARITHMETIC == "FIXED" ? 1 : 1.0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label  :: "Constant value"
	prop JSName :: "constant"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "constant" || .iDevice == "user")
    }
    inst iRandSeed :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Seed value"
	prop JSName :: "seedValue"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "random" || .iDevice == "user")
    }
    inst iRandLower :: GBL.DSPARITHMETIC == "FIXED" ? -32767 : 0.0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label :: "Lower limit"
	prop JSName :: "lowerLimit"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "random" || .iDevice == "user")
    }
    inst iRandUpper :: GBL.DSPARITHMETIC == "FIXED" ? 32767 : 1.0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label :: "Upper limit"
	prop JSName :: "upperLimit"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "random" || .iDevice == "user")
    }
    inst iSineGain :: GBL.DSPARITHMETIC == "FIXED" ? 32767 : 1.0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label :: "Gain"
	prop JSName :: "gain"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "sine" || .iDevice == "user")
    }
    inst iSineFreq :: GBL.DSPARITHMETIC == "FIXED" ? 1 : 1000.0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label :: "Frequency (Hz)"
	prop JSName :: "frequency"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "sine" || .iDevice == "user")
    }
    inst iSinePhase :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0.0{
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label :: "Phase (radians)"
	prop JSName :: "phase"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "sine" || .iDevice == "user")
    }
    inst iSineRate :: GBL.DSPARITHMETIC == "FIXED" ? 256 : 44000 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Sample rate (samples/sec)"
	prop JSName :: "rate"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "sine" || .iDevice == "user")
    }
    inst iUserFxn :: .iDevice == "printFloat" ? @_DGN_printFloat : .iDevice == "printHex" ? @_DGN_printHex : .iDevice == "printInt" ? @_DGN_printInt : @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "User function"
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: .iDevice == "user"
	
 
	prop Set :: (
	    .iUserFxn = $1,
	    .iSaveUserFxn = .iUserFxn,
	    "ok"
	)
    }
    inst iSaveUserFxn :: @_FXN_F_nop {
	prop Visible :: 0
	prop Writable ::0
	prop NoGen :: 1
    }
    inst iUserArg ::= 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "User function argument"
	prop JSName :: "arg"
	prop Visible :: 1
	prop Writable :: .iDevice == "user"
    }
    
 
    inst iFxns :: @_DGN_FXNS {
	prop NoGen :: 1
    }
}
 
type DHL {
    isa ObjectMgr
    prop name :: "DHL"
    prop Label :: "DHL - Host Link Driver"
    prop IsContainedIn :: SIODRIVER
    prop GlobalHelpTopic :: (303)
    prop InstanceHelpTopic :: (403)
    prop InstancePropertyPage :: ("{9C29DA20-90F9-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{9C29DA21-90F9-11d1-988B-0020AFEE33C6}")
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop DependsOn :: "DEV"
    prop Visible :: 1
    prop isDriver :: 1
    
 
    prop objectSize :: (
        if (GBL.DSPTYPE == 62) {
            $a = (19)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
            $a = (22)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {
            $a = (19)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {
            $a = (34)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {
            $a = (34)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
            $a = (22)
        },
        if (GBL.DSPTYPE == 28) {
            $a = (34)
        },
        $a
    )
    prop dataSize :: (
	DHL.objectSize * DHL.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    )
    global gChannelsAvailable :: (
        $a = 0,
        scan ($i; HST) {
            if ($i.iDHLAvailable == 1) {
                $a++
            }
        },
        $a
    ) 
    prop localCanCreate :: (
        if (.gChannelsAvailable > 0) {
            "ok"
        }
	else {
	    .warning("No HST channels are available for a new DHL device.")
	}
    )
    prop localCreate :: (
        .gChannelsAvailable--,
	.seizeHSTChannel(.iHSTChannel),
        "ok"
    )
       
    prop seizeHSTChannel :: (
	$1.iDelUser = "DHL",
	$1.iDHLAvailable = 0,
	$1.notify = @_DHL_notify,
	$1.arg0 = $1.iId,
	"ok"
    )
    prop localDelete ::(
        .gChannelsAvailable++,
	.releaseHSTChannel(.iHSTChannel),
        "ok"
    )
    prop releaseHSTChannel :: (
	$1.iDelUser = "USER",
	$1.iDHLAvailable = 1,
	$1.notify = @_FXN_F_nop,
	$1.arg0 = 0,
	"ok"
    )
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: "%8t .dhl: block(0x20000){}"
    prop _memSeg :: .OBJMEMSEG
    prop _placement :: (0x7fffff / 2)
    global OBJMEMSEG :: DARAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iHSTChannel :: (
        scan ($i; HST) {
            if ($i.iDHLAvailable == 1) {
                $a = $i 
            }
        },
        $a
    ) {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Underlying HST Channel"
	prop JSName :: "hstChannel"
        prop MemberType :: HST
	prop MemberTest :: ((($1.iDHLAvailable == 1) || ($1 == .iHSTChannel)) ? 1 : 0)
        prop Set :: (
            if ($1.iDHLAvailable != 1) {
		 
                .error("This channel is already in use.")
            }
            else {
                .releaseHSTChannel(.iHSTChannel),
		.seizeHSTChannel($1),
                .iHSTChannel = $1,
                "ok"
            }
        )
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst iMode ::= .iHSTChannel.mode {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Mode"
	prop JSName :: "mode"
	prop Visible :: 1
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst iDevId ::= (.iHSTChannel.iId) {
	prop NoGen :: 0
    }
    
 
    inst iIsTerminal :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    inst iIsVirtual :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iFxns :: @_DHL_FXNS {
	prop NoGen :: 1
    }
}
 
type DPI {
    isa ObjectMgr
    prop name :: "DPI"
    prop Label :: "DPI - Pipe Driver"
    prop IsContainedIn :: SIODRIVER
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop GlobalHelpTopic :: (
	304
    )
    prop InstanceHelpTopic :: (
	404
    )
    prop InstancePropertyPage :: (
	"{7FE06FA0-2DE9-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{7FE06FA1-2DE9-11d1-988B-0020AFEE33C6}"
    )
    prop DependsOn :: "DEV"
    prop maxObjs :: (32767)
    prop isDriver :: (
	1
    )
    prop localCreate :: (
	.gCurDevId += 1,
	"ok"
    )
    global gCurDevId :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iDevId :: DPI.gCurDevId {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
	prop Set :: (
	    .error("DPI.iDevId parameter no longer settable, it is now handled automatically")
	)
    }
    inst iIsVirtual :: 0 {
        prop Label :: "Allow virtual instances of this device."
	prop JSName :: "allowVirtual"
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
	prop Set :: (
	    if ($1 == 1) {
		$a = "ok",
		$b = 1,
		scan ($i; SIO) {
		    if ($i.iDevice == self) {
			$a = .error("This DPI instance is being used by one or more SIO instances, cannot reconfigure"),
			$b = 0
		    }
		},
		if ($b == 1) {
		    .iIsVirtual = 1
		},
		$a
	    }
	    else {
		.iIsVirtual = 0,
		"ok"
	    }
	)
    }
    inst iIsTerminal :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    
 
    inst iFxns :: @_DPI_FXNS {
	prop NoGen :: 1
    }
}
 
type MSGQ {
    isa Module
    prop Visible :: 1
    prop name :: "MSGQ"
    prop Label :: "MSGQ - Message Queue Manager"
    prop IsConfMod :: .USEMSGQ 
    prop IsContainedIn :: IOF
    prop DependsOn :: "GIO,SIO"
 
    prop GlobalIcon :: 131
    prop InstanceIcon :: 132
    prop GlobalHelpTopic :: (
	323
    )
    prop InstanceHelpTopic :: (
	423
    )
    prop InstancePropertyPage :: (
	"{473C4A62-B1A8-11d0-9885-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{473C4A63-B1A8-11d0-9885-0020AFEE33C6}"
    )
    global USEMSGQ :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable MSGQ Manager"
	prop JSName :: "ENABLEMSGQ"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
}
 
type HOOK {
    isa ObjectMgr
    prop name :: "HOOK"
    prop Label :: "HOOK - Module Hook Manager"
    prop IsContainedIn :: SYSTEM
    prop DependsOn :: "SWI"
    prop InstancePropertyPage :: (
	"{473C4A64-B1A8-11d0-9885-0020AFEE33C6}"
    )
    prop GlobalIcon :: 181
    prop InstanceIcon :: 182
    prop GlobalHelpTopic :: (
	318
    )
    prop InstanceHelpTopic :: (
	418
    )
    prop localCreate :: (
	if (.gNumOf == 0) {
	    HOOK_KNL.iIsUsed = 1,
	    .mkId(0)
	},
	"ok"
    )
    
    prop localDelete :: (
	if (.gNumOf == 2) {
	    HOOK_KNL.iIsUsed = 0,
	    .rmId
	},
	"ok"
    )
    prop maxObjs :: (32767)	 
    
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    global KNLID ::= (HOOK_KNL.Order - 1) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    inst initFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Initialization function"
	prop JSName :: "initFxn"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst createFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Create function"
	prop JSName :: "createFxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER"
    }
    inst deleteFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Delete function"
	prop JSName :: "deleteFxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER"
    }
    inst exitFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Exit function"
	prop JSName :: "exitFxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER"
    }
    inst callSwitchFxn :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Call switch function"
	prop JSName :: "callSwitchFxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER"
    }
    inst switchFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Switch function"
	prop JSName :: "switchFxn"
	prop Visible :: 1
	prop Writable :: .callSwitchFxn
    }
    inst callReadyFxn :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Call ready function"
	prop JSName :: "callReadyFxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER"
    }
    inst readyFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Ready function"
	prop JSName :: "readyFxn"
	prop Visible :: 1
	prop Writable :: .callReadyFxn
    }
     
    inst Order :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
	prop NoGen :: 1
	prop Writable :: 1
    }
     
    inst iPri :: 0 {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}
object HOOK_KNL :: HOOK {
    param Order :: 1
    param iComment :: "Used to support TSK function hooks (cannot be deleted)"
    param iIsUsed :: 0
    param iDelUser :: "HOOK"
    param iDelMsg :: "This hook instance is used by TSK and cannot be deleted"
    param initFxn :: @_FXN_F_nop
    param createFxn :: TSK.CREATEFXN
    param deleteFxn :: TSK.DELETEFXN
    param exitFxn :: TSK.EXITFXN
    param callSwitchFxn :: TSK.DOSWITCH
    param switchFxn :: TSK.VSWFXN
    param callReadyFxn :: TSK.DOREADY
    param readyFxn :: TSK.VRDYFXN
}
 
type PWRM {
    isa Module
    prop name :: "PWRM"
    prop Label :: "PWRM - Power Manager"
    prop IsContainedIn :: SYSTEM
    prop DependsOn :: "HWI"
    prop GlobalIcon :: 185   
    prop InstanceIcon :: 186
    prop GlobalHelpTopic :: (
        322
    )
    prop InstanceHelpTopic :: (
        422
    )
    prop IsConfMod :: 1          
    prop InstancePropertyPage :: (
        "{000FFB50-0419-11d3-B053-0020AFEF4449}"
    )
    
    prop GlobalPropertyPage :: (
        "{43959450-0419-11d3-B053-0020AFEF4449}"
    )
    prop AllocType :: (
      "1\0, _globalAllocDesc, _memSeg, _placement"
    )
    prop _globalAllocDesc :: (
      "%8t .pwrmdb: block(0x20000)   {}"
    )
    prop _memSeg ::  .PWRM_DEVICEDBMEMSEG 
    prop _placement :: (0x7fffff / 2)
    prop pslConfigLibName :: (
        GBL.DSPSUBTYPE == 5503 ? "PSL_cfg_c5503.a55L" :
          GBL.DSPSUBTYPE == 5507 ? "PSL_cfg_c5507.a55L" :
            GBL.DSPSUBTYPE == 5509 ? "PSL_cfg_c5509a.a55L" :
              GBL.DSPSUBTYPE == 5510 ? "PSL_cfg_c5510.a55L" :
                ""
    )
     
    global PWRM_ENABLE :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable PWRM Manager"
        prop JSName :: "ENABLE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: ( 
                      $e="ok",
                      if($1 == 0) {
                          if(.PWRM_IDLEDOMAINS == 1) {
                              $e = .error("Idling of DSP domains (Idling page) must be disabled before disabling the Power Manager")
                          }
                          else {
                              .PWRM_ENABLE = $1
                          }
                      }
                      else {
                          .PWRM_ENABLE = $1 
                      },
                      $e
                    )
    }
     
    global PWRM_BOOTHOOK :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call user hook function at boot time"
        prop JSName :: "BOOTHOOK"
        prop Visible :: 1
        prop Writable :: .PWRM_ENABLE
        prop NoGen :: 1
        prop Set :: ( 
                      $e="ok",
                      if($1 == 0) {
                          .PWRM_BOOTHOOKFXN = @_FXN_F_nop
                      },
                      .PWRM_BOOTHOOK = $1, 
                      .PWRM_CAPSMASK = .PWRM_capsmask_update(),
                      $e
                    )
    }
    global PWRM_BOOTHOOKFXN :: @_FXN_F_nop {
        prop Label :: "Function"
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "BOOTHOOKFXN"
        prop Visible :: 1
        prop Writable :: .PWRM_BOOTHOOK && .PWRM_ENABLE
        prop NoGen :: 0
    }
     
    global PWRM_ADAPTCLK :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Reprogram BIOS clock after frequency scaling"
        prop JSName :: "ADAPTCLK"
        prop Visible :: 1
        prop Writable :: CLK.USETIMER && .PWRM_ENABLE && .PWRM_SCALING
        prop NoGen :: 0
        prop Set :: ( 
                      .PWRM_ADAPTCLK = $1, 
                      .PWRM_CAPSMASK = .PWRM_capsmask_update(),
                      "ok"  
                    )
    }
    global OLDAUTOCALCULATE :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "previous value for autocalculate before PWRM insert "
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
     
    global PWRM_DEVICEINIT :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable device initialization by PWRM"
        prop JSName :: "DEVICEINIT"
        prop Visible :: 1
        prop Writable :: .PWRM_ENABLE && ((GBL.DSPSUBTYPE == 5509) ||
          (GBL.DSPSUBTYPE == 5503) || (GBL.DSPSUBTYPE == 5507) ||
          (GBL.DSPSUBTYPE == 2420) || (GBL.DSPSUBTYPE == 2320))
        prop NoGen :: 1
        prop Set :: ( 
                      .PWRM_DEVICEINIT = $1, 
                      .PWRM_CAPSMASK = .PWRM_capsmask_update(),
                      "ok"  
                    )
    }
     
    global PWRM_RESOURCETRACKING :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable resource tracking by PWRM"
        prop JSName :: "RESOURCETRACKING"
        prop Visible :: 1
        prop Writable :: .PWRM_ENABLE && ((GBL.DSPSUBTYPE == 5509) ||
          (GBL.DSPSUBTYPE == 5503) || (GBL.DSPSUBTYPE == 5507) ||
          (GBL.DSPSUBTYPE == 2420) || (GBL.DSPSUBTYPE == 2320))
        prop NoGen :: 1
        prop Set :: ( 
                      .PWRM_RESOURCETRACKING = $1, 
                      .PWRM_CAPSMASK = .PWRM_capsmask_update(),
                      "ok"  
                    )
    }
     
    global PWRM_DEVICEDBMEMSEG :: DARAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "MEM section for device database"
        prop JSName :: "DEVICEDBMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
     
    global PWRM_IDLEDOMAINS :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Idle DSP domains in the BIOS idle loop"
        prop JSName :: "IDLEDOMAINS"
        prop Visible :: 1
        prop Writable :: .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Idling"
        prop Set :: ( 
                      $e = "ok",
                      if ($1 != .PWRM_IDLEDOMAINS) {  
                          if ($1 == 1) {
                              PWRM_idleDomains.Create("IDL"),
                                PWRM_idleDomains.function = @_PWRM_F_idleDomains,
                              .OLDAUTOCALCULATE = IDL.AUTOCALCULATE,
                              IDL.AUTOCALCULATE = 0 
                          }
                          else {
                              PWRM_idleDomains.Delete("IDL"),
                              IDL.AUTOCALCULATE = .OLDAUTOCALCULATE
                          },
                          .PWRM_IDLEDOMAINS = $1, 
                          .PWRM_CAPSMASK = .PWRM_capsmask_update()
                      },
                     $e
                    )
    }
    global PWRM_EMIF :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    EMIF"
        prop JSName :: "IDLEEMIF"
        prop Visible :: 1
        prop Writable :: .PWRM_IDLEDOMAINS && .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Idling"
        prop Set :: ( 
                      .PWRM_EMIF = $1, 
                      .PWRM_IDLEMASK = .PWRM_idlemask_update(),
                      "ok"  
                    )
    }
    global PWRM_CLKGEN :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    CLKGEN"
        prop JSName :: "IDLECLKGEN"
        prop Visible :: 1
        prop Writable :: .PWRM_IDLEDOMAINS && .PWRM_ENABLE && .PWRM_CPU && .PWRM_CACHE && .PWRM_DMA
        prop NoGen :: 1
        prop TabName :: "Idling"
        prop Set :: ( 
                      $e="ok",
                      if($1 == 1) {
                          if(.PWRM_DMA == 0) {
                              $e = .error("The DMA domain must be idled before idling CLKGEN")
                          }
                          else {
                              if(.PWRM_CPU == 0) {
                                  $e = .error("The CPU domain must be idled before idling CLKGEN")
                              }
                              else {
                                  if(.PWRM_CACHE == 0) {
                                      $e = .error("The CACHE domain must be idled before idling CLKGEN")
                                  }
                                  else {
                                      .PWRM_CLKGEN = $1, 
                                      .PWRM_IDLEMASK = .PWRM_idlemask_update()
                                  }
                              }
                          }
                      }
                      else {
                          .PWRM_CLKGEN = $1,
                          .PWRM_IDLEMASK = .PWRM_idlemask_update()
                      },
                      $e
                    )
    }
    global PWRM_PERIPH :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    PERIPHS"
        prop JSName :: "IDLEPERIPH"
        prop Visible :: 1
        prop Writable :: .PWRM_IDLEDOMAINS && .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Idling"
        prop Set :: ( 
                      .PWRM_PERIPH = $1, 
                      .PWRM_IDLEMASK = .PWRM_idlemask_update(),
                      "ok"  
                    )
    }
    global PWRM_CACHE :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    CACHE"
        prop JSName :: "IDLECACHE"
        prop Visible :: GBL.DSPSUBTYPE != 5509
        prop Writable :: .PWRM_IDLEDOMAINS && .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Idling"
        prop Set :: ( 
                      $e="ok",
                      if($1 == 0) {
                          if(.PWRM_CLKGEN == 1) {
                              $e = .error("The CACHE domain must remain idled while CLKGEN is idled")
                          }
                          else {
                              .PWRM_CACHE = $1, 
                              .PWRM_IDLEMASK = .PWRM_idlemask_update()
                          }
                      }
                      else {
                          .PWRM_CACHE = $1, 
                          .PWRM_IDLEMASK = .PWRM_idlemask_update()
                      },
                      $e
                    )
    }
    global PWRM_DMA :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    DMA"
        prop JSName :: "IDLEDMA"
        prop Visible :: 1
        prop Writable :: .PWRM_IDLEDOMAINS && .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Idling"
        prop Set :: ( 
                      $e="ok",
                      if($1 == 0) {
                          if(.PWRM_CLKGEN == 1) {
                              $e = .error("The DMA domain must remain idled while CLKGEN is idled")
                          }
                          else {
                              .PWRM_DMA = $1, 
                              .PWRM_IDLEMASK = .PWRM_idlemask_update()
                          }
                      }
                      else {
                          .PWRM_DMA = $1, 
                          .PWRM_IDLEMASK = .PWRM_idlemask_update()
                      },
                      $e
                    )
    }
    global PWRM_CPU :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    CPU"
        prop JSName :: "IDLECPU"
        prop Visible :: 1
        prop Writable :: .PWRM_IDLEDOMAINS && .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Idling"
        prop Set :: ( 
                      $e="ok",
                      if($1 == 0) {
                          if(.PWRM_CLKGEN == 1) {
                              $e = .error("The CPU domain must remain idled while CLKGEN is idled")
                          }
                          else {
                              .PWRM_CPU = $1, 
                              .PWRM_IDLEMASK = .PWRM_idlemask_update()
                          }
                      }
                      else {
                          .PWRM_CPU = $1, 
                          .PWRM_IDLEMASK = .PWRM_idlemask_update()
                      },
                      $e
                    )
    }
    global PWRM_IDLEMASK :: ( .PWRMCPUMASK |
                              .PWRMCPUMASK |
                              .PWRMDMAMASK |
                              .PWRMCACHEMASK |
                              .PWRMPERIPHMASK |
                              .PWRMCLKGENMASK |
                              .PWRMEMIFMASK ) {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Clock domain bitmask for IDL loop"
        prop Format :: "0x%04x"
        prop Visible :: 0
        prop Writable :: .PWRM_IDLEDOMAINS 
        prop NoGen :: 0
        prop TabName :: "Idling"
    }
    prop PWRM_idlemask_update :: (
          .PWRMCPUMASK |
          .PWRMDMAMASK |
          .PWRMCACHEMASK |
          .PWRMPERIPHMASK |
          .PWRMCLKGENMASK |
          .PWRMEMIFMASK
    )
    prop PWRMCPUMASK :: ((.PWRM_CPU == 1) ? 0x01 : 0x0)
    prop PWRMDMAMASK :: ((.PWRM_DMA == 1) ? 0x02 : 0x0)
    prop PWRMCACHEMASK :: ((.PWRM_CACHE == 1) ? 0x04 : 0x0)
    prop PWRMPERIPHMASK :: ((.PWRM_PERIPH == 1) ? 0x08 : 0x0)
    prop PWRMCLKGENMASK :: ((.PWRM_CLKGEN == 1) ? 0x10 : 0x0)
    prop PWRMEMIFMASK :: ((.PWRM_EMIF == 1) ? 0x20 : 0x0)
 
     
    global PWRM_CAPSMASK :: (  
                               .PWRMBOOTHOOKF |
                               .PWRMIDLEDOMAINSF |
                               .PWRMVFSCALINGF |
                               .PWRMSCALEVF |
                               .PWRMWAITFORVF |
                               .PWRMDEEPSLEEPF |
                               .PWRMWAITRESTARTF |
                               .PWRMSNOOZEF |
                               .PWRMDEVICEINITF |
                               .PWRMTRACKINGF |
                               .PWRMADAPTCLKF
                                     ) {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "PWRM caps mask"
        prop Format :: "0x%04x"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    prop PWRM_capsmask_update :: (
               .PWRMBOOTHOOKF |
               .PWRMIDLEDOMAINSF |
               .PWRMVFSCALINGF |
               .PWRMSCALEVF |
               .PWRMWAITFORVF |
               .PWRMDEEPSLEEPF |
               .PWRMWAITRESTARTF |
               .PWRMSNOOZEF |
               .PWRMDEVICEINITF |
               .PWRMTRACKINGF |
               .PWRMADAPTCLKF
    )
    prop PWRMBOOTHOOKF :: ((.PWRM_BOOTHOOK == 1) ? 0x100 : 0x0)
    prop PWRMADAPTCLKF :: ((.PWRM_ADAPTCLK == 1) ? 0x80 : 0x0)
    prop PWRMIDLEDOMAINSF :: ((.PWRM_IDLEDOMAINS == 1) ? 0x40 : 0x0)
    prop PWRMVFSCALINGF :: ((.PWRM_SCALING == 1) ? 0x8 : 0x0)
    prop PWRMSCALEVF :: ((.PWRM_SCALEV == 1) ? 0x10 : 0x0)
    prop PWRMWAITFORVF :: ((.PWRM_WAITV == 1) ? 0x20 : 0x0)
    prop PWRMDEEPSLEEPF :: ((.PWRM_ENSLEEP == 1) ? 0x1 : 0x0)
    prop PWRMWAITRESTARTF :: ((.PWRM_ENSLEEPUNTILRESTART == 1) ? 0x2 : 0x0)
    prop PWRMSNOOZEF :: ((.PWRM_ENSNOOZE == 1) ? 0x4: 0x0)
    prop PWRMDEVICEINITF :: ((.PWRM_DEVICEINIT == 1) ? 0x400 : 0x0)
    prop PWRMTRACKINGF :: ((.PWRM_RESOURCETRACKING == 1) ? 0x200 : 0x0)
     
    global PWRM_SCALING :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Voltage and Frequency Scaling"
        prop JSName :: "SCALING"
        prop Visible :: 1
        prop Writable :: (
            .PWRM_ENABLE && (GBL.MEMORYMODEL == "LARGE") &&
            (GBL.DSPSUBTYPE == 5503 || GBL.DSPSUBTYPE == 5507 ||
             GBL.DSPSUBTYPE == 5509 || GBL.DSPSUBTYPE == 5510)
        )
        prop NoGen :: 0
        prop TabName :: "V/F Scaling"
        prop Set :: ( 
            .PWRM_SCALING = $1, 
            if ($1 == 0) {
                .PWRM_ADAPTCLK = 0
            },
            .PWRM_CAPSMASK = .PWRM_capsmask_update(),
            "ok"  
        )
    }
    global PWRM_INITSP :: 15 {
        prop Label :: "Initial frequency (index to frequency table)"
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "INITIALFREQ"
        prop Visible :: 1
        prop Writable :: .PWRM_SCALING && .PWRM_ENABLE
        prop NoGen :: 0
        prop TabName :: "V/F Scaling"
    }
    global PWRM_INITVOLTS :: 1.6 {
        prop Label :: "Initial voltage (volts)"
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.2f"
        prop JSName :: "INITVOLTS"
        prop Visible :: 1
        prop Writable :: .PWRM_SCALING && .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "V/F Scaling"
    }
    global PWRM_INITMILVOLTS ::= int(round(.PWRM_INITVOLTS * 1000)) {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style ::  0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global PWRM_SCALEV :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Scale voltage along with frequency"
        prop JSName :: "SCALEVOLT"
        prop Visible :: 1
        prop Writable :: .PWRM_SCALING && .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "V/F Scaling"
        prop Set :: ( 
                      .PWRM_SCALEV = $1, 
                      .PWRM_CAPSMASK = .PWRM_capsmask_update(),
                      "ok"  
                    )
    }
    global PWRM_WAITV :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Wait while voltage is being scaled down"
        prop JSName :: "WAITVOLT"
        prop Visible :: 1
        prop Writable :: .PWRM_SCALING && .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "V/F Scaling"
        prop Set :: ( 
                      .PWRM_WAITV = $1, 
                      .PWRM_CAPSMASK = .PWRM_capsmask_update(),
                      "ok"  
                    )
    }
    global PWRM_CONFIGLIB ::= .pslConfigLibName() {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "PSL Configuration Library"
        prop JSName :: "PSLCONFIGLIB"
        prop Visible :: 1
        prop Writable :: .PWRM_ENABLE == 1 && .PWRM_SCALING == 1 &&
                         GBL.MEMORYMODEL == "LARGE"
        prop NoGen ::1
        prop TabName :: "V/F Scaling"
        prop Set :: (
            $e = "ok",
            if ($1 == "") {
                $e = "A PSL configuration library name must be entered"
            }
            else {
                .PWRM_CONFIGLIB = $1
            },
            $e
        )
    }
     
    global PWRM_ENSLEEP :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable deep sleep"
        prop JSName :: "ENABLESLEEP"
        prop Visible :: 1
        prop Writable :: .PWRM_ENABLE 
        prop NoGen :: 1
        prop TabName :: "Sleep"
        prop Set :: ( 
                      .PWRM_ENSLEEP = $1, 
                      .PWRM_CAPSMASK = .PWRM_capsmask_update(),
                      "ok"  
                    )
    }
    global PWRM_DS_EMIF :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    EMIF"
        prop JSName :: "SLEEPEMIF"
        prop Visible :: 1
        prop Writable :: .PWRM_ENSLEEP && .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Sleep"
        prop Set :: (
                      .PWRM_DS_EMIF = $1,
                      .PWRM_DS_IDLEMASK = .PWRM_DS_idlemask_update(),
                      "ok"
                    )
    }
    global PWRM_DS_CLKGEN :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    CLKGEN"
        prop JSName :: "SLEEPCLKGEN"
        prop Visible :: 1
        prop Writable :: .PWRM_ENSLEEP && .PWRM_ENABLE && .PWRM_DS_CPU && .PWRM_DS_CACHE && .PWRM_DS_DMA
        prop NoGen :: 1
        prop TabName :: "Sleep"
        prop Set :: (
                      $e="ok",
                      if($1 == 1) {
                          if(.PWRM_DS_DMA == 0) {
                              $e = .error("The DMA domain must be idled before idling CLKGEN")
                          }
                          else {
                              if(.PWRM_DS_CPU == 0) {
                                  $e = .error("The CPU domain must be idled before idling CLKGEN")
                              }
                              else {
                                  if(.PWRM_DS_CACHE == 0) {
                                      $e = .error("The CACHE domain must be idled before idling CLKGEN")
                                  }
                                  else {
                                      .PWRM_DS_CLKGEN = $1,
                                      .PWRM_DS_IDLEMASK = .PWRM_DS_idlemask_update()
                                  }
                              }
                          }
                      }
                      else {
                          .PWRM_DS_CLKGEN = $1,
                          .PWRM_DS_IDLEMASK = .PWRM_DS_idlemask_update()
                      },
                      $e
                    )
    }
    global PWRM_DS_PERIPH :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    PERIPHS"
        prop JSName :: "SLEEPPERIPH"
        prop Visible :: 1
        prop Writable :: .PWRM_ENSLEEP && .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Sleep"
        prop Set :: (
                      .PWRM_DS_PERIPH = $1,
                      .PWRM_DS_IDLEMASK = .PWRM_DS_idlemask_update(),
                      "ok"
                    )
    }
    global PWRM_DS_CACHE :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    CACHE"
        prop JSName :: "SLEEPCACHE"
        prop Visible :: GBL.DSPSUBTYPE != 5509
        prop Writable :: .PWRM_ENSLEEP && .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Sleep"
        prop Set :: (
                      $e="ok",
                      if($1 == 0) {
                          if(.PWRM_DS_CLKGEN == 1) {
                              $e = .error("The CACHE domain must remain idled while CLKGEN is idled")
                          }
                          else {
                              .PWRM_DS_CACHE = $1,
                              .PWRM_DS_IDLEMASK = .PWRM_DS_idlemask_update()
                          }
                      }
                      else {
                          .PWRM_DS_CACHE = $1,
                          .PWRM_DS_IDLEMASK = .PWRM_DS_idlemask_update()
                      },
                      $e
                    )
    }
    global PWRM_DS_DMA :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    DMA"
        prop JSName :: "SLEEPDMA"
        prop Visible :: 1
        prop Writable :: .PWRM_ENSLEEP && .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Sleep"
        prop Set :: (
                      $e="ok",
                      if($1 == 0) {
                          if(.PWRM_DS_CLKGEN == 1) {
                              $e = .error("The DMA domain must remain idled while CLKGEN is idled")
                          }
                          else {
                              .PWRM_DS_DMA = $1,
                              .PWRM_DS_IDLEMASK = .PWRM_DS_idlemask_update()
                          }
                      }
                      else {
                          .PWRM_DS_DMA = $1,
                          .PWRM_DS_IDLEMASK = .PWRM_DS_idlemask_update()
                      },
                      $e
                    )
    }
    global PWRM_DS_CPU :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    CPU"
        prop JSName :: "SLEEPCPU"
        prop Visible :: 1
        prop Writable :: .PWRM_ENSLEEP && .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Sleep"
        prop Set :: (
                      $e="ok",
                      if($1 == 0) {
                          if(.PWRM_DS_CLKGEN == 1) {
                              $e = .error("The CPU domain must remain idled while CLKGEN is idled")
                          }
                          else {
                              .PWRM_DS_CPU = $1,
                              .PWRM_DS_IDLEMASK = .PWRM_DS_idlemask_update()
                          }
                      }
                      else {
                          .PWRM_DS_CPU = $1,
                          .PWRM_DS_IDLEMASK = .PWRM_DS_idlemask_update()
                      },
                      $e
                    )
    }
    
    global PWRM_DS_IDLEMASK :: ( .PWRMDSCPUMASK |
                              .PWRMDSCPUMASK |
                              .PWRMDSDMAMASK |
                              .PWRMDSCACHEMASK |
                              .PWRMDSPERIPHMASK |
                              .PWRMDSCLKGENMASK |
                              .PWRMDSEMIFMASK ) {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Clock domain bitmask for deep sleep"
        prop Format :: "0x%04x"
        prop Visible :: 0
        prop Writable :: .PWRM_ENSLEEP
        prop NoGen :: 0
        prop TabName :: "Sleep"
    }
    prop PWRM_DS_idlemask_update :: (
          .PWRMDSCPUMASK |
          .PWRMDSDMAMASK |
          .PWRMDSCACHEMASK |
          .PWRMDSPERIPHMASK |
          .PWRMDSCLKGENMASK |
          .PWRMDSEMIFMASK
    )
    prop PWRMDSCPUMASK :: ((.PWRM_DS_CPU == 1) ? 0x01 : 0x0)
    prop PWRMDSDMAMASK :: ((.PWRM_DS_DMA == 1) ? 0x02 : 0x0)
    prop PWRMDSCACHEMASK :: ((.PWRM_DS_CACHE == 1) ? 0x04 : 0x0)
    prop PWRMDSPERIPHMASK :: ((.PWRM_DS_PERIPH == 1) ? 0x08 : 0x0)
    prop PWRMDSCLKGENMASK :: ((.PWRM_DS_CLKGEN == 1) ? 0x10 : 0x0)
    prop PWRMDSEMIFMASK :: ((.PWRM_DS_EMIF == 1) ? 0x20 : 0x0)
    global PWRM_IER0 :: 0 {
        prop Label :: "Wakeup interrupt mask, IER0"
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop JSName :: "WKUPIER0"
        prop Visible :: 1
        prop Writable :: .PWRM_ENSLEEP && .PWRM_ENABLE
        prop NoGen :: 0
        prop TabName :: "Sleep"
    }
    global PWRM_IER1 :: 0 {
        prop Label :: "Wakeup interrupt mask, IER1"
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop JSName :: "WKUPIER1"
        prop Visible :: 1
        prop Writable :: .PWRM_ENSLEEP && .PWRM_ENABLE
        prop NoGen :: 0
        prop TabName :: "Sleep"
    }
     
    global PWRM_ENSLEEPUNTILRESTART :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable sleep until restart"
        prop JSName :: "SLEEPUNTILRESTART"
        prop Visible :: 1
        prop Writable :: .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Sleep"
        prop Set :: ( 
                      .PWRM_ENSLEEPUNTILRESTART = $1, 
                      .PWRM_CAPSMASK = .PWRM_capsmask_update(),
                      "ok"  
                    )
    }
     
    global PWRM_ENSNOOZE :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable snooze mode"
        prop JSName :: "ENABLESNOOZE"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "Sleep"
        prop Set :: ( 
                      .PWRM_ENSNOOZE = $1, 
                      .PWRM_CAPSMASK = .PWRM_capsmask_update(),
                      "ok"  
                    )
    }
    global PWRM_WHICHTIMER :: "Timer 1" {
        prop Label :: "Timer to be used for snooze mode:"
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Timer 0,Timer 1"
        prop JSName :: "TIMERFORSNOOZE"
        prop Visible :: 1
        prop Writable :: .PWRM_ENSNOOZE
        prop NoGen :: 1
        prop TabName :: "Sleep"
    }
}
     
object PWRM_idleDomains :: IDL {
    param iComment :: "This object idles select clock domains from the BIOS IDL loop "
    param iIsUsed :: PWRM.PWRM_IDLEDOMAINS
    param cycles :: 0         
    param calibration :: 0         
    param iDelUser :: "IDL"
    param iDelMsg :: (
        "This object is used by PWRM and can't be deleted"
    )
    param function :: @_FXN_F_nop
}
