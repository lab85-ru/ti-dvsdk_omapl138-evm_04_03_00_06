/*
 *  Copyright 2010 by Texas Instruments Incorporated.
 *  @(#) DSP/BIOS_Kernel 5,2,5,28 02-10-2010 (cuda-u28)
 */
/*
 *  Do not modify this file; it's generated from cdra447.cdb.h
 *  via mkseed!
 */

//# cdra447.cdb 5.25.28
 
 
 
 
 
object IRAM :: MEM {
    param iComment :: (
        "This object defines space for the DSP's on-chip memory"
    )
    param iAllocHeap :: 1
    param iId :: 0
    param iIsUsed :: 1                   
    param iDelUser :: "USER"
    param base :: 0x00800000
    param len ::  0x00020000
    param space :: "code/data"
}
object CACHE_L2 :: MEM {
    param iComment :: "Do not delete, in use by cache"
    param iDelUser :: "USER"
    param iIsUsed :: 0           
    param iIsModifiable :: 1
    param base :: 0x00800000
    param len :: 0x00010000
    param iAllocHeap :: 0
    param space :: "Cache"
}
object CACHE_L1P :: MEM {
    param iComment :: "Do not delete, in use by cache"
    param iDelUser :: "USER"
    param iIsUsed :: 1           
    param iIsModifiable :: 1
    param base :: 0x00E08000
    param len ::  0x00008000
    param iAllocHeap :: 0
    param space :: "Cache"
}
object CACHE_L1D :: MEM {
    param iComment :: "Do not delete, in use by cache"
    param iDelUser :: "USER"
    param iIsUsed :: 1           
    param iIsModifiable :: 1
    param base :: 0x00F10000
    param len ::  0x00008000
    param iAllocHeap :: 0
    param space :: "Cache"
}
object L1DSRAM :: MEM {
    param iComment :: "This object defines space for the DSP's on-chip memory"
    param iDelUser :: "USER"
    param iIsUsed :: 1           
    param iIsModifiable :: 1
    param base :: 0x00F04000
    param len ::  0x0000C000
    param iAllocHeap :: 0
    param space :: "code/data"
}
 
 
 
 
 
 
 
 
 
 
 
 
 
class Module {
    prop Visible :: 1
    prop Writable :: 1
    prop IsConfMod :: (
	.gNumOf > 0 ? 1 : 0
    )
    prop NoGen	::  0
    prop IsDirty ::  (
	$a = .gDirty,
	.gDirty = 0,
	$a
    )
    
 
    prop dataSize :: 0
    
    
 
    prop error :: #(
	"Error: ", .name,
	$1
    )
    
 
    prop warning :: (
	"Warning ...", .name,
	$1
    )
    
 
    prop minBit	:: (
	$a = 0,
	while (($1 & (1 << $a)) && $a < 32) {
	    ++$a
	},
	$a
    )
    
    
 
    prop name :: (
	"<unnamed module>"
    )
    
 
    prop numBit :: (
	$a = $b = 0,
	while ($a < 32) {
	    if ($1 & (1 << $a)) {
		++$b
	    }
	},
	$b
    )
    
    
 
    global gInit ::= (
	$a = 0,
	$b = 0,
	scan ($i; self) {
	    if ($i.IsConfObj()) {
		$a += 1,
		if (self.isFinite) {
		    $b |= 1 << $i.iId
		}
	    }
	},
	.gNumOf = $a,
	.gSetOf = $b,
	if (.gInitFlag == 0) {
	    .localInit()
	},
	.gInitFlag = 1
    ) {
	prop Visible :: 0    
	prop Writable :: 0
	prop NoGen :: 1	     
    }
    global gInitFlag :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    global  gDirty :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global  gNumOf :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    global  gSetOf :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    global  gUser :: "USER" {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
}
 
class ObjectMgr {
    isa	    Module
    
 
    prop CanCreate :: (
	if (.gNumOf < .maxObjs()) {
	    .localCanCreate()
	}
	else {
	    .warning("Maximum number of objects already created")
	}
    )
    
    
 
    prop CanDelete :: (
	if (.iDelMsg == "ok" || (.iDelUser == .gUser)) {
	    if (.iId >= 0 && .iIsUsed) {
		.localCanDelete()
	    }
	    else {
		.warning("Object already deleted")
	    }
	}
	else {
	    .warning(.iDelMsg)
	}
    )
    
    
 
    prop Create	:: (
	(.gUser = ($0 > 0 ? $1 : "USER")),
	if (($a = .CanCreate()) == "ok") {
	    if (($a = .localCreate()) == "ok") {
		if (.iIsUsed == 0) {
		    .mkId($0 > 1 ? $2 : -1),
		    .iIsUsed = 1,
		    GlobalStatus.gDirty = 1,
		    .gDirty = 1
		}
	    }
	},
	(.gUser = "USER"),
	$a
    )
    
 
    prop Delete :: (
	(.gUser = ($0 > 0 ? $1 : "USER")),
	if (($a = .CanDelete()) == "ok") {
	    if (($a = .localDelete()) == "ok") {
		.rmId(.iId),
		.iIsUsed = 0,
		GlobalStatus.gDirty = 1,
		.gDirty = 1
	    }
	},
	(.gUser = "USER"),
	$a
    )
    
    
 
    prop GetSetOf :: (
	.gSetOf
    )
    
    
 
    prop GetNumOf :: (
	.gNumOf
    )
    
    
 
    prop GetObjId :: (
	.iId
    )
    
 
    prop GetPriority :: (
	.iId
    )
    
    
 
    prop SetPriority :: (
	.iId = $1
    )
    
    
 
    prop IsConfObj ::  (
	.iIsUsed
    )
    
 
    prop localCanCreate :: (
	"ok"
    )
    
 
    prop localCanDelete :: (
	"ok"
    )
    
 
    prop localCreate :: (
	"ok"
    )
    
 
    prop localDelete :: (
	"ok"
    )
    
    
 
    prop localInit :: (
	0
    )
    
    
 
    prop isFinite :: (
	.maxObjs() <= GBL.DSPWORDSIZE ? 1 : 0
    )
    
    
 
    prop mkId ::  (
	if (.isFinite()) {
	    if ($1 < 0) {
		.iId = .minBit(.gSetOf)
	    }
	    else {
		.iId = $1
	    },
	    (.gSetOf |= (1 << .iId))
	}
	else {
	    .iId = 0
	},
	++.gNumOf,
	.iId
    )
    
    
 
    prop rmId :: (
	if (.isFinite()) {
	    .gSetOf &= ~(1 << .iId)
	},
	--.gNumOf
    )
    
    
 
    prop maxObjs :: (
	GBL.DSPWORDSIZE
    )
    
 
    prop isDriver :: (
	0
    )
    
 
    prop SortChildHierView :: (
	1
    )
    inst iDelMsg :: "ok" {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    inst iDelUser :: "USER" {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iId :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst iIsUsed :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
     
    inst iComment :: .iDelUser == "USER" ? "<add comments here>" : .iDelMsg {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "comment"
	prop JSName :: "comment"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER" ? 1 : 0
	prop NoGen :: 1
    }
}
 
					    
 
 
type GlobalStatus {
    prop NoGen :: 1
    prop Visible :: 0
    prop Writable :: 0
    prop Label :: "Current Configuration Status"
    prop GlobalIcon :: 101
    prop InstanceIcon :: 101
    prop GlobalHelpTopic :: (
	100
    )
    prop GlobalPropertyPage :: (
	"{9D3AD931-847B-11d0-A621-0000C070F3E9}"
    )
    global GENLIB :: "bioscfg.dll" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Generation Library"
	prop NoGen :: 1
	prop Visible :: 0
	prop Writable :: 1
    }
    
    global DATE :: "" {		 
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global GCONFVERS :: "" {	 
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global SysDataSize ::= (
	$a = 0,
	scan ($i; nil) {		    
	    if ($i.dataSize() != nil) {	    
		$a = $a + $i.dataSize()	    
	    }
	},
	$a
    ) {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "Estimated Data Size: %d"
	prop StatusField :: 1
	prop NoGen :: 1
    }
    global MinStackSize ::= (
	$a = ((2 * (2)) * 4),	    
	$a = $a + ((2 * (5)) * 4),	    
	$a = $a + ((0) * 4),	    
	$b = 0,
	scan ($i; CLK) {	    
	    if ($i.IsConfObj()) {
		$b |= 1
	    }
	},
	$a = $a + (((2 * (2)) * 4) * $b), 
	$b = 0,
	scan ($i; HWI) {	    
	    if ($i.IsConfObj()) {   
		if ($i != HWI_NMI && $i != HWI_RESET) {
		    if (($i.function != @HWI_unused) && ($i.function != @RESERVED)) {
			$b++
		    }
		}
	    }
	},
	$a = $a + (((12 + 14 + 2) * 4) * $b),    
	$b = 0,
	scan ($i; SWI) {	    
	    if ($i.IsConfObj()) {   
		if ($i.priority > $b) {
		    $b = $i.priority
		}
	    }
	},
	$a = $a + ((((2 * 2) + 18 + (2 * 4)) * 4) * $b), 
	$b = 0,
	scan ($i; PRD) {	    
	    if ($i.IsConfObj()) {
		$b |= 1
	    }
	},
	$a = $a + (((2 * (3)) * 4) * $b), 
	$a
    ) {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "Est. Min. Stack Size (MAUs): %d"
	prop StatusField :: 1
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global ConfigWarnings ::= (
	if (.MinStackSize > MEM.STACKSIZE) {
	    "Application stack size is too small; decrease the number of SWI priorities or increase the stack in MEM."
	}
	else {
	    "None"
	}
    ) {
	prop Label :: "Warnings"
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global SeedVersion ::= "@(#)*** cuda-u28x" {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global gDirty :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    prop Status :: (#.SeedVersion, #.MinStackSize, #.SysDataSize)
}
 
class EModule {
    isa Module
    prop IsXMod :: (
        1
    )
    prop Vendor :: (
	""
    )
    prop Version :: (
	""
    )
}
 
class EObjectMgr {
    isa ObjectMgr
    prop IsXMod :: (
        1
    )
    prop Vendor :: (
        ""
    )
    prop Version :: (
        ""
    )
}
 
class ModuleFolder {
    isa Module
    prop NoGen :: 1
}
 
type SYSTEM {
    isa ModuleFolder
    prop Label :: "System"
    prop GlobalIcon :: 151
    prop GlobalHelpTopic :: (
	500
    )
    prop GlobalPropertyPage :: (
	"{B936FB91-52A5-11d4-947C-0050048381B7}"
    )
}
type INS {
    isa ModuleFolder
    prop Label :: "Instrumentation"
    prop GlobalIcon :: 152
    prop GlobalHelpTopic :: (
	501
    )
    prop GlobalPropertyPage :: (
	"{053C8F90-52A6-11d4-947C-0050048381B7}"
    )
}
type SCH {
    isa ModuleFolder
    prop Label :: "Scheduling"
    prop GlobalIcon :: 153
    prop GlobalHelpTopic :: (
	502
    )
    prop GlobalPropertyPage :: (
	"{053C8F91-52A6-11d4-947C-0050048381B7}"
    )
}
type SYN {
    isa ModuleFolder
    prop Label :: "Synchronization"
    prop GlobalIcon :: 154
    prop GlobalHelpTopic :: (
	503
    )
    prop GlobalPropertyPage :: (
	"{053C8F92-52A6-11d4-947C-0050048381B7}"
    )
}
type IOF {
    isa ModuleFolder
    prop Label :: "Input/Output"
    prop GlobalIcon :: 155
    prop GlobalHelpTopic :: (
	504
    )
    prop GlobalPropertyPage :: (
	"{053C8F93-52A6-11d4-947C-0050048381B7}"
    )
}
type SIODRIVER {
    isa ModuleFolder
    prop Label :: "Device Drivers"
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 127
    prop GlobalHelpTopic :: (
        505
    )
    prop GlobalPropertyPage :: (
        "{A2BCEC70-5365-11d4-947C-0050048381B7}"
    )
}
 
 
type PROJ {
    isa  ObjectMgr
    prop name :: "PROJ"
    prop maxObjs :: 0	 
    prop Label :: "Project Manager"
    prop GlobalIcon :: 121
    prop InstanceIcon :: 122
    prop InstanceHelpTopic :: (
	201
    )
    
    prop GlobalHelpTopic :: (
	101
    )
    prop InstancePropertyPage :: (
	"{AC3C77D1-890B-11d0-A621-0000C070F3E9}"
    )
    
    prop GlobalPropertyPage :: (
	"{AC3C77D2-890B-11d0-A621-0000C070F3E9}"
    )
    prop NoGen :: 1
    prop Visible :: 0
    
    global ALIASALL :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Generate C Names for All Objects"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global IGNOREWARNING :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Ignore Warnings"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global LIBPATH :: ".;../../lib;$(BIOSROOT)/lib" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Library Search Path"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global INCPATH :: ".;../../include;$(BIOSROOT)/include" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Include File Search Path"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global OBJDIR :: "." {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Object file directory"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global EXTEXE :: "out" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Executable File Extension"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    global EXTLIB :: "lib" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Library File Extension"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    global EXTASM :: "asm" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Assembly Language Source File Extension"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    global EXTOBJ :: "obj" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Object File Extension"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst projType ::  "Executable" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "Executable,Library"
	prop Label :: "Target Type"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst projName :: "$(PROG)" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Target File Name"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst useRpt :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Use RPT Instruction"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst minimizeSpace :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Optimize for Space over Time"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    inst tmx :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Avoid TMX Silicon Bugs"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
}
type PROJ_FILE {
    isa ObjectMgr
    prop Visible :: 0
    
    prop Label :: "Project File Manager"
    
 
    prop InstanceHelpTopic :: (
	BIOSHELP_PROJ_FILE_INSTANCE
    )
    
    prop GlobalHelpTopic :: (
	BIOSHELP_PROJ_FILE_GLOBAL
    )
    prop InstancePropertyPage :: (
	"{AC3C77D3-890B-11d0-A621-0000C070F3E9}"
    )
    
    prop GlobalPropertyPage :: (
	"{AC3C77D4-890B-11d0-A621-0000C070F3E9}"
    )
    prop NoGen :: 1
    
    inst elemType ::  "C Source" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "C Source,ASM Source,Library,Linker Command File"
	prop Label :: "Input File Type"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst elemName :: "$(PROG)" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Input File Name"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst optLevel :: "register+local+global" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "register,register+local,register+local+global,register+local+global+file"
	prop Label :: "Optimization Level"
	prop Visible :: 0
	prop Writable :: .elemType == "C Source" ? 1 : 0
	prop NoGen :: 1
    }
    inst inline :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Inline Expansion"
	prop Visible :: 0
	prop Writable :: .elemType == "C Source" ? 1 : 0
	prop NoGen :: 1
    }
    inst definitions :: "" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Additional Definitions"
	prop Visible :: 0
	prop Writable :: .elemType == "C Source" ? 1 : 0
	prop NoGen :: 1
    }
    inst iParent :: 0 {
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
}
 
type GBL {
    isa Module
    prop name :: "GBL"
    prop Label :: "Global Settings"
    prop IsContainedIn :: SYSTEM
    prop cGen :: 0
    prop GenLinkPrologue :: (
                "%10S\nSECTIONS {%4t\n.vers (COPY): {} /* version information */%0t\n}\n\n-priority\n--trampolines\n%25S%1S%22S-l%2S%23S%3S\n%24S%15S%4S%16S%18S%5S%6S%12S%7S%17S\0, _autoInitStr, _board, _librarySuffix, _devLibStr, _biosLibStr, _rtdxLibStr, _rtsLibStr, _librarySuffix, _compilerModel, _lnkCmdStr, _lnkCmdFile, _cslLibStr, _chipType, _librarySuffix, _chipStr, _sioLibStr, _mpcLibStr, _bios6xLibStr, _bios6xClkType, _instStr, _rtsNameStr, _romStr, _biosRomStr, _logLibStr, _SKLibStr"
    )
    prop poolStr :: (
        (.LINKWITHROM == 0) ? "" : POOL.USEPOOL ? "" : "_POOL_config=0;\n"
    )
    
    prop msgqStr :: (
        (.LINKWITHROM == 0) ? "" :  MSGQ.USEMSGQ ? "" : "_MSGQ_config=0;\n"
    )
    
    prop bcacheBootStr :: (
        if (.C64PL2CONFIGURE) {
            if (.C64PL1PCFG != "32k" || .C64PL1DCFG != "32k" || 
                .C64PL2MODEOPTS != "0k") {
                "_BCACHE_bootInit=_BCACHE_setCacheToSram;\n"
            }
            else {
                "_BCACHE_bootInit=_FXN_F_nop;\n"
            }
        }
        else {
            "_BCACHE_bootInit=_FXN_F_nop;\n"
        }
    )
    prop GenLinkEpilogue :: (
        "%0t_GBL_CACHE = GBL_CACHE;\n%1S%2S%3S\0, poolStr, msgqStr, bcacheBootStr"
    )
    
 
    prop ConfigurationClass :: "{2779A121-92CC-11d1-A63D-0000C070F3E9}"
    prop GlobalIcon :: 105
    prop InstanceIcon :: 106
        
    prop GlobalHelpTopic :: (
        103
    )
    prop InstanceHelpTopic :: (
        103
    )
    prop InstancePropertyPage :: (
        "{B7240DE4-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
        "{B7240DE5-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    prop localInit :: (
        RTA_toHost.Create("HST"),
        RTA_toHost.bufseg = HST.OBJMEMSEG,
        RTA_fromHost.Create("HST"),
        RTA_fromHost.bufseg = HST.OBJMEMSEG,
        RTA_dispatcher.Create("HST"),
        IDL_busyObj.Create("IDL"),
        IDL.USEIDLBUSYOBJ = 1,
        IDL_cpuLoad.Create("IDL")
    )
    
    prop chipcall :: (
        "ok"
    )
    prop IsConfMod :: 1          
    prop ucompare :: (
      $e = "ok",
      $a = ($1 >> 31) & 0x00000001,
      $b = ($2 >> 31) & 0x00000001,
      $c = $1 & 0x7fffffff,
      $d = $2 & 0x7fffffff,
      if($a > $b) {
        $e = "gt"
      }
      else {
        if($a == $b) {
          if($c > $d) {
            $e = "gt"
          }
          else {
            if($c == $d) {
              $e = "eq"
            }
            else {
              $e = "lt"
            }
          }
        }
        else {
          $e = "lt"
        }
      },
      $e
    )
    
    
 
    prop L2Check :: (
        if (.DSPSUBTYPE == 6211 || .DSPSUBTYPE == 6711) {
            .PCC = "mapped",             
            if (.C641XL2CONFIGURE == 1) {
                .C641XL2CONFIGURE = 0,
                .L2CONFIGALLOC = 0
            },
            .L2CacheSizeCheck()
        }
        else {
            if (.DSPSUBTYPE == 6400) {
                .PCC = "mapped",         
                if (.C621XL2CONFIGURE == 1) {
                    .C621XL2CONFIGURE = 0
                },
                .L2CacheSizeCheck()
            }
            else {
                if (.C621XL2CONFIGURE == 1) {
                    .C621XL2CONFIGURE = 0,
                    .L2CacheSizeCheck()
                }
                else {
                    if (.C641XL2CONFIGURE == 1) {
                        .C641XL2CONFIGURE = 0,
                        .L2CONFIGALLOC = 0,
                        .L2CacheSizeCheck()
                    }
                }
            }
        }
    )
    prop C621xL2CacheSizeCheck :: (
        $e = "ok",
        $a = CACHE_L2.base,
        $b = CACHE_L2.len,
        if ( .C621XL2CONFIGURE == 0 ) {
            CACHE_L2.Delete("MEM")
        }
        else {
            if (.L2MODEOPTS == "SRAM" ) {
                CACHE_L2.base = CACHE_L2.base + CACHE_L2.len,
                CACHE_L2.len = 0x0,
                CACHE_L2.Delete("MEM")
            }
            else {
                if (.L2MODEOPTS == "1-way cache" ) {
                    CACHE_L2.Create("MEM"),
                    CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x4000,
                    CACHE_L2.len = 0x4000
                }
                else {
                    if (.L2MODEOPTS == "2-way cache" ) {
                        CACHE_L2.Create("MEM"),
                        CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x8000,
                        CACHE_L2.len = 0x8000
                    }
                    else {
                        if (.L2MODEOPTS == "3-way cache" ) {
                            CACHE_L2.Create("MEM"),
                            CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0xc000,
                            CACHE_L2.len = 0xc000
                        }
                        else {
                            if (.L2MODEOPTS == "4-way cache" ) {
                                CACHE_L2.Create("MEM"),
                                CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x10000,
                                CACHE_L2.len = 0x10000
                            }
                        }
                    }
                }
            }
        },
        $e
    )
    
    prop C641xL2CacheSizeCheck :: (
        $e = "ok",
        $a = CACHE_L2.base,
        $b = CACHE_L2.len,
        if ( .C641XL2CONFIGURE == 0 ) {
            CACHE_L2.Delete("MEM")
        }
        else {
            if (.C641XL2MODEOPTS == "4-way cache (0k)" ) {
                CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x0,
                CACHE_L2.len = 0x0,
                CACHE_L2.Delete("MEM")
            }
            else {
                if (.C641XL2MODEOPTS == "4-way cache (32k)" ) {
                    CACHE_L2.Create("MEM"),
                    CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x8000,
                    CACHE_L2.len = 0x8000
                }
                else {
                    if (.C641XL2MODEOPTS == "4-way cache (64k)" ) {
                        CACHE_L2.Create("MEM"),
                        CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x10000,
                        CACHE_L2.len = 0x10000
                    }
                    else {
                        if (.C641XL2MODEOPTS == "4-way cache (128k)" ) {
                            CACHE_L2.Create("MEM"),
                            CACHE_L2.base = CACHE_L2.base + CACHE_L2.len
                                - 0x20000,
                            CACHE_L2.len = 0x20000
                        }
                        else {
                            if (.C641XL2MODEOPTS == "4-way cache (256k)" ) {
                                CACHE_L2.Create("MEM"),
                                CACHE_L2.base = CACHE_L2.base + CACHE_L2.len
                                    - 0x40000,
                                CACHE_L2.len = 0x40000
                            }
                        }
                    }
                }
            }
        },
        $e
    )
    
    prop C64PL1PCacheSizeCheck :: (
        $e = "ok",
        if (.C64PL2CONFIGURE == 0) {
            .C64PL1PCFG = "32k",
            CACHE_L1P.Create("MEM"),
            CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x8000,
            CACHE_L1P.len = 0x8000
        }
        else {
            if (.C64PL1PCFG == "0k") {
              CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x0,
              CACHE_L1P.len = 0x0,
              CACHE_L1P.Delete("MEM")
            }
            else {
              if (.C64PL1PCFG == "4k") {
                CACHE_L1P.Create("MEM"),
                CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x1000,
                CACHE_L1P.len = 0x1000
              }
              else {
                if (.C64PL1PCFG == "8k") {
                  CACHE_L1P.Create("MEM"),
                  CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x2000,
                  CACHE_L1P.len = 0x2000
                }
                else {
                  if (.C64PL1PCFG == "16k") {
                    CACHE_L1P.Create("MEM"),
                    CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x4000,
                    CACHE_L1P.len = 0x4000
                  }
                  else {
                    if (.C64PL1PCFG == "32k") {
                      CACHE_L1P.Create("MEM"),
                      CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x8000,
                      CACHE_L1P.len = 0x8000
                    }
                    else {
                        $e = .error("Unknown cache size")
                    }
                  }
                }
              }
            }
        },
        $e
    )
    prop C64PL1DCacheSizeCheck :: (
        $e = "ok",
        if (.C64PL2CONFIGURE == 0) {
            .C64PL1DCFG = "32k",
            CACHE_L1D.Create("MEM"),
            CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x8000,
            CACHE_L1D.len = 0x8000
        }
        else {
            if (.C64PL1DCFG == "0k") {
              CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x0,
              CACHE_L1D.len = 0x0,
              CACHE_L1D.Delete("MEM")
            }
            else {
              if (.C64PL1DCFG == "4k") {
                CACHE_L1D.Create("MEM"),
                CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x1000,
                CACHE_L1D.len = 0x1000
              }
              else {
                if (.C64PL1DCFG == "8k") {
                  CACHE_L1D.Create("MEM"),
                  CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x2000,
                  CACHE_L1D.len = 0x2000
                }
                else {
                  if (.C64PL1DCFG == "16k") {
                    CACHE_L1D.Create("MEM"),
                    CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x4000,
                    CACHE_L1D.len = 0x4000
                  }
                  else {
                    if (.C64PL1DCFG == "32k") {
                      CACHE_L1D.Create("MEM"),
                      CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x8000,
                      CACHE_L1D.len = 0x8000
                    }
                    else {
                        $e = .error("Unknown cache size")
                    }
                  }
                }
              }
            }
        },
        $e
    )
    prop C64PL2CacheSizeCheck :: (
        $e = "ok",
        if (.C64PL2CONFIGURE == 0) {
            CACHE_L2.Delete("MEM")
        }
        else {
            if (.C64PL2MODEOPTS == "0k") {
              CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x0,
              CACHE_L2.len = 0x0,
              CACHE_L2.Delete("MEM")
            }
            else {
              if (.C64PL2MODEOPTS == "32k") {
                CACHE_L2.Create("MEM"),
                CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x8000,
                CACHE_L2.len = 0x8000
              }
              else {
                if (.C64PL2MODEOPTS == "64k") {
                  CACHE_L2.Create("MEM"),
                  CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x10000,
                  CACHE_L2.len = 0x10000
                }
                else {
                  if (.C64PL2MODEOPTS == "128k") {
                    CACHE_L2.Create("MEM"),
                    CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x20000,
                    CACHE_L2.len = 0x20000
                  }
                  else {
                    if (.C64PL2MODEOPTS == "256k") {
                      CACHE_L2.Create("MEM"),
                      CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x40000,
                      CACHE_L2.len = 0x40000
                    }
                    else {
		      if (.C64PL2MODEOPTS == "512k") {
                        CACHE_L2.Create("MEM"),
                        CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x80000,
                        CACHE_L2.len = 0x80000
                      }
		      else {
		        if (.C64PL2MODEOPTS == "1024k") {
                          CACHE_L2.Create("MEM"),
                          CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x100000,
                          CACHE_L2.len = 0x100000
                        }
                        else {
                          $e = .error("Unknown cache size")
                        }
                      }
                    }
                  }
                }
              }
            }
        },
        $e
    )
    prop L2CacheSizeCheck :: (
        $e = "ok",
        scan ($i; MEM) {
            if ($i == CACHE_L2) {
                .C621XL2CONFIGURE ?
                    $e = .C621xL2CacheSizeCheck() :
                .C641XL2CONFIGURE ?
                    $e = .C641xL2CacheSizeCheck() :
                .DSPSUBTYPE == 6211 || .DSPSUBTYPE == 6711 ?
                    $e = .C621xL2CacheSizeCheck() :
                .DSPSUBTYPE == 6400 ?
                    $e = .C641xL2CacheSizeCheck() : {
                        CACHE_L2.base = 0x0,
                        CACHE_L2.len = 0x0,
                        CACHE_L2.Delete("MEM")
                    }
            }
        },
        $e
    )
    global PRODUCT :: 0 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 1       
        prop EnvField :: 1
    }
    
 
    global CALLBACKOBJ :: nil {
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CHIPCHAIN :: nil {
        prop Visible ::0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global TRACE :: "CD-01234567" {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Trace Mask"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 0
    }
    global BOARD :: "c64x+" {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Target Board Name"
        prop JSName :: "BOARDNAME"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ROM :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Link to ROM Library"
        prop Visible :: 0
        prop Writable :: 0 
        prop NoGen :: 0
    }
    global CPUCLOCK :: GBL.DSPTYPE == 62 ? .MIPS : .MIPS * 2 {
         
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global PROCID :: = 0  {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style ::  0x01
        prop Label :: "Processor ID (PROCID)"
        prop JSName :: "PROCID"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    
    global CLKIN :: = 20000  {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style ::  0x20
        prop Label :: "Board Clock in KHz (Informational Only)"
        prop JSName :: "CLKIN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global FREQ :: int(round(.MIPS * 1000)) {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style ::  0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    
    global MIPS :: 552.0 {          
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.4f"
        prop Label :: "DSP Speed In MHz (CLKOUT)"
        prop JSName :: "CLKOUT"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (
            $a = .MIPS,
            $b = (GBL.DSPTYPE == 62) ? $1 : $1 * 2,
            $e = "ok",
            .MIPS = $1,
            .FREQ = int(.MIPS * 1000),
            if (($e = .setCPUClock($b)) != "ok") {
                .MIPS = $a
            },
            $e
        )
    }
    prop setCPUClock :: (
        $e = "ok",
        if ($1 != .CPUCLOCK) {
            $a = .CPUCLOCK,
            .CPUCLOCK = $1,
            if (GBL.CALLBACKOBJ != nil) {
                $e = GBL.CALLBACKOBJ.call()
            },
            if ($e != "ok") {
                .CPUCLOCK = $a,
                GBL.CALLBACKOBJ.call()
            }
        },
        if ($e == "ok") {
            "ok"
        }
        else {
            .error($e)
        }
    )
    
    
 
    global OSTYPE :: "BIOS" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "BIOS"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    
 
    global DSPTYPE :: 62 {            
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Major Type"
        prop JSName :: "DSPTYPE"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    
    global SPECIFYRTSLIB :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify RTS library"
        prop JSName :: "SPECIFYRTSLIB"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: 1
    }
    
    global RTSLIB :: "" {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Run-Time Support Library"
        prop JSName :: "RTSLIB"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: .SPECIFYRTSLIB
    }
    global DSPSUBTYPE :: 6499 {      
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "6499"
        prop Label :: "DSP Type"
        prop Visible :: 0
        prop Writable :: 1
        prop Set :: (.DSPSUBTYPE = $1,
                     .L2Check(),
                     "ok"
        )
        prop NoGen :: 0
    }
    global CLKTYPE :: 442 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "CLK Type"
        prop JSName :: "CLKTYPE"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global CHIPTYPE :: "other" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "custom,other"
        prop Label :: "Chip Support Library (CSL)"
        prop JSName :: "CHIPTYPE"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 1
        prop Set :: (
            if ( $1 == "6201" || $1 == "6202" || $1 == "6203" ||
                 $1 == "6204" || $1 == "6205" ) {
                 .DSPSUBTYPE = 6200
            }
            else {
                if ($1 == "6701") {
                    .DSPSUBTYPE = 6700
                }
                else {
                    if ($1 == "6211") {
                        .DSPSUBTYPE = 6211
                    }
                    else {
                        if ($1 == "6711" || $1 == "6712" || $1 == "6713" || $1 == "DA610") {
                          if ($1 == "6711") {
                            .DSPSUBTYPE = 6711
                          },
                          if ($1 == "6712") {
                            .DSPSUBTYPE = 6712
                          },
                          if ($1 == "6713") {
                            .DSPSUBTYPE = 6713
                          }
                        }
                        else {
                            if ($1 == "DM642" || $1 == "6412" || $1 == "6414" ||
                                $1 == "6415" || $1 == "6416" || $1 == "6410" ||
                                $1 == "6413") {
                                .DSPSUBTYPE = 6400
                            }   
                        }
                    }
                }
            },
            .CHIPTYPE = $1,
            .L2Check(),
            $e = "ok",
            if (GBL.CHIPCHAIN != nil) {
                $e = GBL.CHIPCHAIN.chipcall()
            },
            $e
        )
    }
    
    global DISPCALLCSLCFGINIT ::= (
            .CHIPTYPE != "other" && .CHIPTYPE != "custom"
        ) {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call CSL_cfgInit Initialization routine"
        prop Visible :: 0
        prop Writable :: .SUPPORTCSL
        prop NoGen :: 1
    }
    global DSPNAME :: "TMS320C62XX" {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPARITHMETIC ::= (
        if (GBL.DSPTYPE == 62 && (GBL.DSPSUBTYPE / 100) == 67) {
            "FLOAT"
        }
        else {
            "FIXED"
        }
    ) {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "FIXED,FLOAT"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPWORDSIZE :: = (
        if (GBL.DSPTYPE == 30 || GBL.DSPTYPE == 40 || GBL.DSPTYPE == 62) {
            32           
        }
        else {
            16           
        }
    ) {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Word Size"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPCHARSIZE :: = (GBL.DSPTYPE == 62 ? 8 :
                             GBL.DSPSUBTYPE == 5599 ? 8 : GBL.DSPWORDSIZE) {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Byte Size"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    
    global DATAPTRSIZE ::= (
        if (GBL.DSPTYPE == 62) {
            32
        }
        else {
            if (GBL.DSPTYPE == 54) {
                16
            }   
            else {
                if (GBL.DSPTYPE == 55) {
                    if (GBL.MEMORYMODEL == "SMALL") {
                        16      
                    }
                    else {
                        23
                    }
                }
                else {
                        if (GBL.DSPTYPE == 28) {
                                22
                        }
                        else {  
                                0
                        }
                }
            }
        })
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop iComment :: "Size of the Data Pointer"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CODEPTRSIZE ::= (
        if (GBL.DSPTYPE == 62) {
            32
        }
        else {
            if (GBL.DSPTYPE == 54) {
                if (GBL.CALLMODEL == "near") {
                    16
                }
                else {
                    24
                }
            }   
            else {
                if (GBL.DSPTYPE == 55) {
                    24
                }
                else {
                    if (GBL.DSPTYPE == 28) {
                        22
                    }
                    else {
                        0
                    }
                }
            }
        })
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop iComment :: "Size of Code Pointer"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ENDIAN :: "little" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "little,big"
        prop Label :: "DSP Endian Mode"
        prop JSName :: "ENDIANMODE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (
            .ENDIAN = $1,
            "ok"
        )
    }
    
    global BIGENDIAN ::= .ENDIAN == "little" ? 0 : 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global AUTOINIT :: "ROM" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "ROM,RAM"
        prop Label :: "C Autoinitialization Model"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global USERINIT :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call User Init Function"
        prop JSName :: "CALLUSERINITFXN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (
            if ($1 == 0) {       
                .USERINITFXN = @_FXN_F_nop,
                .USERINIT = $1
            }
            else {
                .USERINIT = $1
            },
            "ok"
        )
    }
    global USERINITFXN :: @_FXN_F_nop {
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "User Init Function"
        prop JSName :: "USERINITFXN"
        prop Visible :: 1
        prop Writable :: .USERINIT
        prop NoGen :: 0
    }
    global OLDAUTOCALCULATE :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "previous value for autocalculate"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    
    global ENABLEINST :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Real Time Analysis"
        prop JSName :: "ENABLEINST"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (
            if ($1 != .ENABLEINST) {     
                if ($1) {        
                    RTA_toHost.Create("HST"),
        	    RTA_toHost.bufseg = HST.OBJMEMSEG,
                    RTA_fromHost.Create("HST"),
        	    RTA_fromHost.bufseg = HST.OBJMEMSEG,
                    RTA_dispatcher.Create("HST"),
                    IDL_busyObj.Create("IDL"),
                    IDL.USEIDLBUSYOBJ = 1,
                    IDL_cpuLoad.Create("IDL"),
                    IDL.AUTOCALCULATE = .OLDAUTOCALCULATE
                }
                else {
                    if (.LINKWITHROM) {
                        .LINKWITHROM = 0
                    },
                    RTA_toHost.Delete("HST"),
        	    RTA_toHost.bufseg = MEM_NULL,
                    RTA_fromHost.Delete("HST"),
        	    RTA_fromHost.bufseg = MEM_NULL,
                    RTA_dispatcher.Delete("HST"),
                    IDL_busyObj.Delete("IDL"),
                    IDL.USEIDLBUSYOBJ = 0,
                    IDL_cpuLoad.Delete("IDL"),
                    .OLDAUTOCALCULATE = IDL.AUTOCALCULATE,
                    IDL.AUTOCALCULATE = 0
                },
                .ENABLEINST = $1
            },
            "ok"
        )
    }
    
    global INSTRUMENTED :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Instrumented BIOS library"
        prop JSName :: "INSTRUMENTED"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global CGENERATE :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Do C Generation"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    
    global ENABLEDLL :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Dynamic Loading"
        prop JSName :: "ENABLEDLL"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    
    global SUPPORTCSL :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
    }
    global ENABLEALLTRC :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable All TRC Trace Event Classes"
        prop JSName :: "ENABLEALLTRC"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (
            if ($1) {
                .TRCMASKVALUE = 0xDBEF
            }
            else {
                .TRCMASKVALUE = 0x4000
            },
            .ENABLEALLTRC = $1,
            "ok"
        )
    }
    global TRCMASKVALUE :: 0xDBEF {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
    }
    global CALLCSLCFGINIT ::= .DISPCALLCSLCFGINIT {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
    }
    
 
    global CDBPATH :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "CDB search path in COFF file"
        prop JSName :: "CDBRELATIVEPATH"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global LINKWITHROM :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Link with ROM"
        prop JSName :: "LINKWITHROM"
        prop Visible :: 0
        prop Writable :: (.DSPSUBTYPE == 6799 && .ENABLEINST) ? 1 : 0
        prop NoGen :: 1
        prop Set :: (
            $e = "ok",
            if ($1) {
                $e = .error("This BIOS version does not support linking with ROM.")
            },
            $e
        )
    }
    
    global CACHE :: 0 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    } 
    global C64PL2CONFIGURE :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "64P - Configure Memory Cache Settings"
        prop JSName :: "C64PLUSCONFIGURE"
        prop Visible :: 1
        prop Writable :: 1
        prop TabName :: "64PLUS"
        prop Set :: (
            $e = "ok",
            .C64PL2CONFIGURE = $1,
            $e = .C64PL1PCacheSizeCheck(),
            if ($e ==  "ok") {
                $e = .C64PL1DCacheSizeCheck(),
                if ($e == "ok") {
                    $e = .C64PL2CacheSizeCheck()
                }
            },
            $e
        )
        prop NoGen :: 1
    }
    
    global L2CONFIGURE ::= (.C64PL2CONFIGURE) {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0    
        prop NoGen :: 0
    }
    global C64PL1PCFG :: "32k" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "64P L1PCFG Mode"
        prop Enum :: "0k,4k,8k,16k,32k"
        prop JSName :: "C64PLUSL1PCFG"
        prop Visible :: 1
        prop Writable :: (GBL.C64PL2CONFIGURE ==1) ? 1 : 0
        prop NoGen :: 1
        prop TabName :: "64PLUS"
        prop Set :: (
            $i = .C64PL1PCFG,
            .C64PL1PCFG = $1,
            $e = .C64PL1PCacheSizeCheck(),
            if ($e != "ok") {
                .C64PL1PCFG = $i
            },
            $e
        )
    }
    global C64PL1DCFG :: "32k" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "64P L1DCFG Mode"
        prop Enum :: "0k,4k,8k,16k,32k"
        prop JSName :: "C64PLUSL1DCFG"
        prop Visible :: 1
        prop Writable :: (GBL.C64PL2CONFIGURE ==1) ? 1 : 0
        prop NoGen :: 1
        prop TabName :: "64PLUS"
        prop Set :: (
            $i = .C64PL1DCFG,
            .C64PL1DCFG = $1,
            $e = .C64PL1DCacheSizeCheck(),
            if ($e != "ok") {
                .C64PL1DCFG = $i
            },
            $e
        )
    }
    global C64PL2MODEOPTS :: "0k" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "64P L2CFG Mode"
        prop Enum :: "0k,32k,64k,128k"
        prop JSName :: "C64PLUSL2CFG"
        prop Visible :: 1
        prop Writable :: (GBL.C64PL2CONFIGURE ==1) ? 1 : 0
        prop NoGen :: 1
        prop TabName :: "64PLUS"
        prop Set :: (
            $i = .C64PL2MODEOPTS,
            .C64PL2MODEOPTS = $1,
            $e = .C64PL2CacheSizeCheck(),
            if ($e != "ok") {
                .C64PL2MODEOPTS = $i
            },
            $e
        )
    }
    
    global L1PMODE ::= (.setL1PMODE()) {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0,1,2,3,7"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global L1DMODE ::= (.setL1DMODE()) {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0,1,2,3,7"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global L2MODE ::= (.setL2MODE()) {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0,1,2,3,7"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global L2MAR0_31 :: 0x0 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR 0-31 - bitmask"
        prop JSName :: "C64PLUSMAR0to31"
        prop Format :: "0x%08x"
        prop Style :: 0x02
        prop Visible :: 1
        prop Writable :: (GBL.C64PL2CONFIGURE == 1) ? 1 : 0
        prop NoGen :: 0
        prop TabName :: "64PLUS"
    }
    global L2MAR32_63 :: 0x0 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR 32-63 - bitmask"
        prop JSName :: "C64PLUSMAR32to63"
        prop Format :: "0x%08x"
        prop Style :: 0x02
        prop Visible :: 1
        prop Writable :: (GBL.C64PL2CONFIGURE == 1) ? 1 : 0
        prop NoGen :: 0
        prop TabName :: "64PLUS"
    }
    
    global L2MAR64_95 :: 0x0 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR 64-95 - bitmask"
        prop JSName :: "C64PLUSMAR64to95"
        prop Format :: "0x%08x"
        prop Style :: 0x02
        prop Visible :: 1
        prop Writable :: (GBL.C64PL2CONFIGURE == 1) ? 1 : 0
        prop NoGen :: 0
        prop TabName :: "64PLUS"
    }
    
    global L2MAR96_127 :: 0x0 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR 96-127 - bitmask"
        prop JSName :: "C64PLUSMAR96to127"
        prop Format :: "0x%08x"
        prop Style :: 0x02
        prop Visible :: 1
        prop Writable :: (GBL.C64PL2CONFIGURE == 1) ? 1 : 0
        prop NoGen :: 0
        prop TabName :: "64PLUS"
    }
    
    global L2MAR128_159 :: 0x0 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR 128-159 - bitmask"
        prop JSName :: "C64PLUSMAR128to159"
        prop Format :: "0x%08x"
        prop Style :: 0x02
        prop Visible :: 1
        prop Writable :: (GBL.C64PL2CONFIGURE == 1) ? 1 : 0
        prop NoGen :: 0
        prop TabName :: "64PLUS"
    }
    
    global L2MAR160_191 :: 0x0 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR 160-191 - bitmask"
        prop JSName :: "C64PLUSMAR160to191"
        prop Format :: "0x%08x"
        prop Style :: 0x02
        prop Visible :: 1
        prop Writable :: (GBL.C64PL2CONFIGURE == 1) ? 1 : 0
        prop NoGen :: 0
        prop TabName :: "64PLUS"
    }
    
    global L2MAR192_223 :: 0x0 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR 192-223 - bitmask"
        prop JSName :: "C64PLUSMAR192to223"
        prop Format :: "0x%08x"
        prop Style :: 0x02
        prop Visible :: 1
        prop Writable :: (GBL.C64PL2CONFIGURE == 1) ? 1 : 0
        prop NoGen :: 0
        prop TabName :: "64PLUS"
    }
    
    global L2MAR224_255 :: 0x0 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR 224-255 - bitmask"
        prop JSName :: "C64PLUSMAR224to255"
        prop Format :: "0x%08x"
        prop Style :: 0x02
        prop Visible :: 1
        prop Writable :: (GBL.C64PL2CONFIGURE == 1) ? 1 : 0
        prop NoGen :: 0
        prop TabName :: "64PLUS"
    }
    global ENABLE_SK :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: ""
        prop JSName :: "ENABLE_SK"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
        prop TabName :: "64PLUS"
    }
    
    global USEIDMA0DISPATCHER ::= 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "USEIDMA0DISPATCHER"
        prop Writable :: 1
        prop Visible :: 0
        prop NoGen :: 1
    }
    global GEMTRUECOMPEN :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "GEM True Completion Bit"
	prop JSName :: "GEMTRUECOMPEN"
	prop Visible :: (GBL.CLKTYPE == 2430 ||
			GBL.CLKTYPE == 3430)
	prop Writable :: (GBL.CLKTYPE == 2430 ||
			GBL.CLKTYPE == 3430)
	prop NoGen :: 0
	prop TabName :: "64PLUS"
    }
    global BCACHEREADADDR0 :: 0x0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Label :: "BCACHE Read Address 0"
	prop JSName :: "BCACHEREADADDR0"
	prop Format :: "0x%08x"
	prop Style :: 0x02
	prop Visible :: (GBL.CLKTYPE == 2430 ||
			GBL.CLKTYPE == 3430)
	prop Writable :: (GBL.GEMTRUECOMPEN) ? 1 : 0
	prop NoGen :: 0
	prop TabName :: "64PLUS"
    }
    global BCACHEREADADDR1 :: 0x0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Label :: "BCACHE Read Address 1"
	prop JSName :: "BCACHEREADADDR1"
	prop Format :: "0x%08x"
	prop Style :: 0x02
	prop Visible :: (GBL.CLKTYPE == 2430 ||
			GBL.CLKTYPE == 3430)
	prop Writable :: (GBL.GEMTRUECOMPEN) ? 1 : 0
	prop NoGen :: 0
	prop TabName :: "64PLUS"
    }
    global BCACHEREADADDR2 :: 0x0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Label :: "BCACHE Read Address 2"
	prop JSName :: "BCACHEREADADDR2"
	prop Format :: "0x%08x"
	prop Style :: 0x02
	prop Visible :: (GBL.CLKTYPE == 2430 ||
			GBL.CLKTYPE == 3430)
	prop Writable :: (GBL.GEMTRUECOMPEN) ? 1 : 0
	prop NoGen :: 0
	prop TabName :: "64PLUS"
    }
    prop setL1PMODE :: (
        .C64PL1PCFG == "0k" ?
            0x0 :
        .C64PL1PCFG == "4k" ?
            0x1 :
        .C64PL1PCFG == "8k" ?
            0x2 :
        .C64PL1PCFG == "16k" ?
            0x3 :
            0x7
    )
    prop setL1DMODE :: (
        .C64PL1DCFG == "0k" ?
            0x0 :
        .C64PL1DCFG == "4k" ?
            0x1 :
        .C64PL1DCFG == "8k" ?
            0x2 :
        .C64PL1DCFG == "16k" ?
            0x3 :
            0x7
    )
    prop setL2MODE :: (
        .C64PL2MODEOPTS == "0k" ?
            0x0 :
        .C64PL2MODEOPTS == "32k" ?
            0x1 :
        .C64PL2MODEOPTS == "64k" ?
            0x2 :
        .C64PL2MODEOPTS == "128k" ?
            0x3 :
        .C64PL2MODEOPTS == "256k" ?
            0x4 :
        .C64PL2MODEOPTS == "512k" ?
            0x5 :
        .C64PL2MODEOPTS == "1024k" ?
            0x6 :
            0x7
    )
    prop _cint00Str :: "-u_c_int00 %24t/* link with alternate boot.obj */%0t\n"
    prop _autoInitStr :: ""
    prop _board :: (
        if (HST.RTDX == 1) {
            "lnkrtdx"
        }
        else {
            if (HST.DSM == 1) {
                "lnkdsm"
            }
            else {
                if(HST.EVM54 == 1) {
                    "lnkevm54"
                }
                else {
                    if (HST.BIOSLINK == 1) {
                        "lnkbioslink"
                    }
                    else {
                        "lnknone"
                    }
                }
            }
        }
    )
    prop _dsptype :: GBL.DSPTYPE
    
    prop _instStr :: .INSTRUMENTED ? "" : "_NONINST"
    
    prop _rtsNameStr :: (.RTSLIB)
    prop _biosLibStr :: "-lbios%20S%23S%8S %24t/* DSP/BIOS support */%0t\n"
    prop _compilerModel :: .ENDIAN == "big" ? "e" : ""
    prop _librarySuffix :: (
        if ( .DSPSUBTYPE == 6700 || .DSPSUBTYPE == 6711 || .DSPSUBTYPE == 6712 || .DSPSUBTYPE == 6713) {
            if ( .ENDIAN == "big" ) {
                ".a67e"
            }
            else {
                ".a67"
            }
        }
        else {
            if ( .DSPSUBTYPE == 6400 ) {
                if ( .ENDIAN == "big" ) {
                    ".a64e"
                }
                else {
                    ".a64"
                }
            }
            else {
                if (.DSPSUBTYPE == 6499) {
                    if (.ENDIAN == "big") {
                        ".a64Pe"
                    }
                    else {
                        ".a64P"
                    }
                }
                else {
                    if (.DSPSUBTYPE == 6799) {
                        if (.ENDIAN == "big") {
                            ".a67Pe"
                        }
                        else {
                            ".a67P"
                        }
                    }
                    else {
                        if ((.DSPSUBTYPE == 6747) || (.DSPSUBTYPE == 6748)) {
                            if (.ENDIAN == "big") {
                                ".a674e"
                            }
                            else {
                                ".a674"
                            }
                        }
			else {
                            if (.ENDIAN == "big") {
                                ".a62e"
                            }
                            else {
                                ".a62"
                            }
                        }
                    }  
                } 
            } 
        } 
    ) 
    prop _rtdxLibStr :: RTDX.USERTDX == 0 ? "" : RTDX.RTDXTYPE == "JTAG" ?
        "-lrtdx64xplus%9S.lib %24t/* RTDX support */%0t\n" :
        RTDX.RTDXTYPE == "Simulator" ?
            "-lrtdxsim%9S.lib %24t/* RTDX support */%0t\n" :
            "-lrtdx64xplushs%9S.lib %24t/* RTDX support */%0t\n"
    prop _rtsLibStr :: (
        .SPECIFYRTSLIB ?
        "-l%21S%24t/* C and C++ run-time library support */%0t\n" :
        .DSPSUBTYPE == 6700 || .DSPSUBTYPE == 6711 || .DSPSUBTYPE == 6712 || .DSPSUBTYPE == 6713 ?
        "-lrts6700%9S.lib%24t/* C and C++ run-time library support */%0t\n" :
        .DSPSUBTYPE == 6400 ?
        "-lrts6400%9S.lib%24t/* C and C++ run-time library support */%0t\n" :
        .DSPSUBTYPE == 6799 ?
        "-lrts67plus%9S.lib%24t/* C and C++ run-time library support */%0t\n" :
        .DSPSUBTYPE == 6499 ?
        "-lrts64plus%9S.lib%24t/* C and C++ run-time library support */%0t\n" :
        ((.DSPSUBTYPE == 6747) || (.DSPSUBTYPE == 6748)) ?
        "-lrts6740%9S.lib%24t/* C and C++ run-time library support */%0t\n" :
        "-lrts6200%9S.lib%24t/* C and C++ run-time library support */%0t\n"
    )
     
    prop _bios6xClkType :: (
        .CLKTYPE == 6000 ? "C6000" :
          .CLKTYPE == 700 ? "DA700" :
            (.CLKTYPE == 420 || .CLKTYPE == 6424)
              ? .USEIDMA0DISPATCHER ? "DM420IDMA0" : "DM420" :
                .CLKTYPE == 2430 ? "2430" :
                  .CLKTYPE == 6482 ? "TCI6482" :
                    .CLKTYPE == 6486 ? "TCI6486" :
                      .CLKTYPE == 6488 ? "TCI6488" :
                        .CLKTYPE == 442 ? "DRA442" :
                          .CLKTYPE == 3430 ? "3430" :
                            .CLKTYPE == 6467 ? "DM6467" :
                              .CLKTYPE == 761990 ? "F761990" :
                                ""
        )
    prop _bios6xLibStr :: (
        "-lbios%19S%23S%8S%24t/* BIOS clock specific library */%0t\n"
    )
    prop _chipStr :: ""
    prop _pmiLibStr  :: ""
    prop _pmiVoltLibStr  :: ""
    prop _pmiVoltControlLibStr :: ""
    prop _psclLibStr  :: ""
    
    prop _psclCfgLibStr  :: ""
    prop _psclConfigLibStr :: ""
    
    prop _mpcLibStr :: ""
    prop _lnkCmdFile :: MEM.LNKCMDFILE
    prop _lnkCmdStr :: (
        if (MEM.LNKCMDFILE == "") {
            ""
        }
        else {
            "-l%11S %24t/* User Specified Linker cmd file */%0t\n"
        }
    )
    prop _sioLibStr :: SIO.USEISSUERECLAIM == 1 ?
        "-lsioir%23S%8S %24t/* supports SIO Issue/Reclaim model only */%0t\n" :
        "-lsioboth%23S%8S %24t/* supports both SIO models */%0t\n"
    prop _devLibStr :: "-ldrivers%23S%14S %24t/* device drivers support */%0t\n"
    prop _cslLibStr :: ""
    prop _chipType :: ""
    prop _logLibStr :: LOG.TS ? "-llog8%3S\n" : ""
    prop _romStr :: .LINKWITHROM ? "-lromC672x.out\n-lromC672x.cmd\n" : ""
    
    prop _biosRomStr :: .LINKWITHROM ? "_BIOSROM" : ""
    prop _SKLibStr :: .ENABLE_SK ? "-lbiosSK%3S\n" : ""
}
 
type MEM {
    isa ObjectMgr
    prop Label :: "MEM - Memory Section Manager"
    prop name :: "MEM"
     
    prop DependsOn :: "SEM"
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 115
    prop InstanceIcon :: 116
    prop GlobalHelpTopic :: (
	108
    )
    prop InstanceHelpTopic :: (
	208
    )
    prop InstancePropertyPage :: (
	    "{3D658E70-05E7-11d0-BD44-0020AFEE33C8}"
    )
    
    prop GlobalPropertyPage :: (
	    "{3D658E71-05E7-11d0-BD44-0020AFEE33C8}"
    )
    
    prop heapLabelStr :: (.iHeapId)
    prop GenLinkPrologue :: (
	if (GBL.DSPTYPE == 55) {
	    "-stack 0x%1x\n-sysstack 0x%2x\n\nMEMORY {%4t\0, _cmd55stksz, _cmd55systksz"
	}
	else {
	    "-stack 0x%1x\nMEMORY {%4t\0, _stackSize"
	}
    )
    prop _stackSize :: MEM.STACKSIZE
    prop AllocType :: (
	if (.REUSE == 0 && .USERCMD == 0) {
	"19\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysinitString,	_initSeg,	_sysinitPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_bssString,	_bssSeg,	_firstPlace, 		_farString,	_farSeg,	_secondPlace, 		_cinitString,	_cinitSeg,	_midPlace, 		_pinitString,	_pinitSeg,	_midPlace, 		_dataString,	_dataSeg,	_midPlace, 		_constString,	_constSeg,	_midPlace, 		_switchString,	_switchSeg,	_midPlace, 		_cioString,	_cioSeg,	_midPlace, 		_textString,	_textSeg,	_midPlace, 		_frtString,	_frtSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"
	}
	else { if (.REUSE == 0 && .USERCMD == 1) {
	"9\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysinitString,	_initSeg,	_sysinitPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"
	}
	else { if (.REUSE == 1 && .USERCMD == 0) {
	 
	"18\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_bssString,	_bssSeg,	_firstPlace, 		_farString,	_farSeg,	_secondPlace, 		_cinitString,	_cinitSeg,	_midPlace, 		_pinitString,	_pinitSeg,	_midPlace, 		_dataString,	_dataSeg,	_midPlace, 		_constString,	_constSeg,	_midPlace, 		_switchString,	_switchSeg,	_midPlace, 		_cioString,	_cioSeg,	_midPlace, 		_textString,	_textSeg,	_midPlace, 		_frtString,	_frtSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"
	}
	else {  
	"8\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"
	}}}
    )
 
    prop _firstPlace  :: 0  
    prop _secondPlace :: 0 + 1
    prop _thirdPlace :: 0 + 2
    prop _midPlace    :: (0x7fffffff / 2)
    prop _sysinitPlace :: (0x7fffffff / 2)
    prop _argsString    :: ("%8t .args: align=4 fill=0 {%12t\n *(.args)\n . += 0x%1x;%8t\n }\0, _argsSize")
    prop _bssString     :: ("%8t .bss:     {}")
    prop _farString     :: ("%8t .far:     {}")
    prop _cinitString   :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.CINITSEG == MEM.LOADCINITSEG) {
		"%8t .cinit:    {}"
	    }
	    else {
		"%8t .cinit:   {} load > %1s, run\0, _loadcinitSeg"
	    }
	}
	else {
	    "%8t .cinit:    {}"
	}
    )
    prop _pinitString   :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.PINITSEG == MEM.LOADPINITSEG) {
		"%8t .pinit:   {}"
	    }
	    else {
		"%8t .pinit:   {} load > %1s, run\0, _loadpinitSeg"
	    }
	}
	else {
		"%8t .pinit:   {}"
	}
    )
prop _trcinitString :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.TRCINITSEG == MEM.LOADTRCINITSEG) {
		"%8t .trcdata:   {}"
	    }
	    else {
		"%8t .trcdata:   {} load > %1s, run\0, _loadtrcinitSeg"
            }
        }
	else {
	    "%8t .trcdata:    {}"
	}
    )
    prop _gblinitString :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.BIOSINITSEG == MEM.LOADBIOSINITSEG) {
		"%8t .gblinit:   {}"
    	    }
	    else {
		"%8t .gblinit:   {} load > %1s, run\0, _loadgblinitSeg"
   	    }
	}
	else {
	    "%8t .gblinit:    {}"
	}
    )
    prop _dataString    :: ("%8t .data:    {}")
    
 
    
 
    prop _constString   :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.CONSTSEG == MEM.LOADCONSTSEG) {
                "%8t GROUP {\n %8t .const: align = 0x8 {} \n %8t .printf (COPY): {} \n%8t }"
	    }
	    else {
                "%8t .const: align = 0x8 {} load > %1s run\0, _loadconstSeg" 
	    }
	}
	else {
            "%8t GROUP {\n %8t .const: align = 0x8 {} \n %8t .printf (COPY): {} \n%8t }"
	}
    )
    prop _switchString  :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.SWITCHSEG == MEM.LOADSWITCHSEG) {
		"%8t .switch:   {}"
	    }
	    else {
		"%8t .switch:   {} load > %1s, run\0, _loadswitchSeg"
	    }
	}
	else {
	    "%8t .switch:    {}"
	}
    )
    prop _sysmemString	:: ("%8t .sysmem:  {}")
    prop _cioString	:: ("%8t .cio:     {}")
    prop _memObjString  :: ("%8t .mem: 	  {}")
    prop _sysdataString :: (
	if((GBL.ROM == 0) && (GBL.DSPTYPE == 54)) {
	    "%8t .sysdata: align = 128 {%12t\n GBL_A_SYSPAGE = .;\n GBL_A_SYSDP = GBL_A_SYSPAGE >> 7;\n %8t }"
	}
	else {
	    "%8t .sysdata: {}"
	}
    )
    prop _sysinitString :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.INITSEG == MEM.LOADINITSEG) {
		"%8t .sysinit:   {}"
	    }
	    else {
		"%8t .sysinit:   {} load > %1s, run\0, _loadinitSeg"
	    }
        }
	else {
	    "%8t .sysinit:    {}"
	}
    )
    prop _sysregsString :: ("%8t .sysregs: {}")
    prop _textString  :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.TEXTSEG == MEM.LOADTEXTSEG) {
		"%8t .text:    {}"
	    }
	    else {
		"%8t .text:    {} load > %1s, run\0, _loadtextSeg"
	    }
        }
	else {
	    "%8t .text:    {}"
	}
    )
    prop _frtString	:: ("%8t frt:    {}")
    prop _biosString    :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.BIOSSEG == MEM.LOADBIOSSEG) {
		"%8t .bios:    {}"
	    }
	    else {
		"%8t .bios:    {} load > %1s, run\0, _loadbiosSeg"
    	   }
    	}
	else {
	    "%8t .bios:    {}"
	}
    )
    prop _stackString :: (
      if (GBL.DSPTYPE == 62) {
         "%8t .stack: align = 0x8 {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = GBL_stackbeg + 0x%1x - 1;%12t\n _HWI_STKBOTTOM = GBL_stackbeg + 0x%1x - 8;%12t\n _HWI_STKTOP = GBL_stackbeg;%8t\n }\0, _stackSize, _stackSize"
      }
      else {
	if (GBL.DSPTYPE == 54) {
             "%8t .stack: {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = ((GBL_stackbeg + 0x%1x - 1) & 0xfffe) ;%8t\n _HWI_STKBOTTOM = GBL_stackend;%12t\n _HWI_STKTOP = GBL_stackbeg;%8t\n }\0, _stackSize"
        }
        else {
	 if (GBL.DSPTYPE == 55) {
		"%8t GROUP { \n%16t .sysstack :  align = 0x4 {%12t\n %16t GBL_sysstackbeg = .;\n %16t *(.sysstack)\n %16t GBL_sysstackend = GBL_sysstackbeg + 0x%2x -1 ;%12t\n %16t _HWI_SYSSTKTOP = GBL_sysstackbeg; %12t\n %16t_HWI_SYSSTKBOTTOM = (GBL_sysstackend+1);\n%16t} \n%16t .stack: align = 0x4 {%12t\n %16t GBL_stackbeg = .;\n %16t *(.stack)\n GBL_stackend = (GBL_stackbeg + 0x%1x - 1) ;%12t\n %16t _HWI_STKBOTTOM = (GBL_stackend+1);%12t\n %16t _HWI_STKTOP = (GBL_stackbeg);%16t\n }%8t\n } BLOCK(0x20000), run \0, _cmd55stksz, _cmd55systksz"
	}
	  else
	   {  
             "%8t .stack: {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = GBL_stackbeg + 0x%1x - 1;%8t\n _HWI_STKBOTTOM = GBL_stackbeg;%12t\n _HWI_STKTOP = (GBL_stackend + 1);%8t\n }\0, _stackSize"
          }
        }
      }
    )
    prop _memHdrSize :: 8
    prop GenLinkEpilogue :: (
	"%0t}"
    )
    prop _stackSeg :: MEM.STACKSEG
    prop _textSeg :: MEM.TEXTSEG
    prop _frtSeg :: MEM.TEXTSEG
    prop _biosSeg :: MEM.BIOSSEG
    prop _dataSeg :: MEM.DATASEG
    prop _cioSeg :: MEM.CIOSEG
    prop _sysmemSeg :: MEM.SYSMEMSEG
    prop _constSeg :: MEM.CONSTSEG
    prop _initSeg :: MEM.INITSEG
    prop _pinitSeg :: MEM.PINITSEG              
    prop _trcinitSeg :: MEM.TRCINITSEG
    prop _gblinitSeg :: MEM.BIOSINITSEG
    prop _regsSeg :: MEM.SYSDATASEG		 
    prop _sysdataSeg :: MEM.SYSDATASEG
    prop _argsSeg :: MEM.ARGSSEG
    prop _argsSize :: MEM.ARGSSIZE
    prop _bssSeg :: MEM.BSSSEG
    prop _farSeg :: MEM.FARSEG
    prop _cinitSeg :: MEM.CINITSEG
    prop _memObjSeg :: MEM.CFGOBJSEG
    prop _switchSeg :: MEM.SWITCHSEG
    prop _loadtextSeg :: MEM.LOADTEXTSEG
    prop _loadbiosSeg :: MEM.LOADBIOSSEG
    prop _loadconstSeg :: MEM.LOADCONSTSEG
    prop _loadinitSeg :: MEM.LOADINITSEG
    prop _loadpinitSeg :: MEM.LOADPINITSEG      
    prop _loadtrcinitSeg :: MEM.LOADTRCINITSEG
    prop _loadgblinitSeg :: MEM.LOADBIOSINITSEG
    prop _loadcinitSeg :: MEM.LOADCINITSEG
    prop _loadswitchSeg :: MEM.LOADSWITCHSEG
    prop AllocInst :: (
        if (.iAllocHeap == 1) {
        "1\0, _instAllocDesc, _objMemSeg, _placement"
        }
    )
    
 
    prop _instAllocDesc :: (
	.INITSEG.iAllocHeap && .REUSE && .INITSEG == self
	? "%8t GROUP {%12t\n .sysinitgap {. += 0x%2x;}\n .sysinit:\n .%0r$heap: {%16t\n . += 0x%1x;%12t\n }%8t\n } RUN_START(%0r$B), RUN_START(_%0r_base), RUN_SIZE(%0r$L), RUN_SIZE(_%0r_length)\0, _heapsize, _sysinitgap, _heaplen"
	: "%8t .%0r$heap: {%12t\n . += 0x%1x;%8t\n } RUN_START(%0r$B), RUN_START(_%0r_base), RUN_SIZE(%0r$L), RUN_SIZE(_%0r_length)\0, _heapsize, _heaplen"
    )
    prop _objMemSeg :: self
    prop _placement :: 0x7fffffff - 1
    prop _heapsize :: (.iHeapSize)
    prop _heaplen ::  (.iHeapSize)
    
 
    prop _sysinitgap :: 2 * 4 
    prop GenInstLink :: (GBL.DSPTYPE == 62
	? "%0r %16t: origin = 0x%1x, %40tlen = 0x%2x%4t\0, _origin, _len"
	: GBL.DSPTYPE == 55
	
	? "PAGE %3d: %16t%0r: %26torigin = 0x%1x, %40tlen = 0x%2x%4t\0, _cmd55origin, _cmd55len, _page"
	: "PAGE %3d: %14t%0r: %26torigin = 0x%1x, %50tlen = 0x%2x%4t\0, _origin, _len, _page"
    )
    prop localInit :: (
	$d = "ok",
	scan ($i; MEM) {
	    if ($i.space == "code" && $i.iAllocHeap == 1) {
		$d = .error ("Code memory cannot have a heap")
	    }
	},
	if (.SEGZERO.iAllocHeap == 1) {
	    .SEGZERO.iReqHeapCount++
	}
	else {
	    $d = .error ("Segment for DSP/BIOS objects must be a memory segment with a heap")
	},
	if (.MALLOCSEG.iAllocHeap == 1) {
	    .MALLOCSEG.iReqHeapCount++
	}
	else {
	    $d = .error ("Segment for malloc()/free() must be a memory segment with a heap")
	},
	$d
    )
    prop _page :: (.page)
    prop _origin :: (.base)
    prop _len :: (.len)
    prop maxObjs :: (
	32767				 
    )
    
    prop codeMember :: (
	$1.dynamicLoading == 1
	    ? 0
	    : GBL.DSPTYPE == 62
	    ? (($1.space == "code") || ($1.space == "code/data"))
	    : GBL.DSPTYPE == 54
	        ? ($1.space == "code")
	    : GBL.DSPTYPE == 28
	        ? ($1.space == "code" || ($1.space == "code/data"))
            : GBL.DSPTYPE == 55
	    ? (($1.space == "code") || ($1.space == "code/data"))
	    : ($1.space == "code/data")
    )
    prop dataMember :: (
	$1.dynamicLoading == 1
	    ? 0
	    : GBL.DSPTYPE == 62
	    ? ($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL
	    : GBL.DSPTYPE == 54
	        ? (($1.space != "code") && ($1 != MEM_NULL)) && $1.space != "io"
	    : GBL.DSPTYPE == 28
	        ? ($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL
	    : GBL.DSPTYPE == 55
	    ? ($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL
	        : (($1.space == "code/data") && ($1 != MEM_NULL))
    )
    
    prop dataNullMember :: (
	$1.dynamicLoading == 1
	    ? 0
	    : GBL.DSPTYPE == 62
	    ? $1.space == "data" || $1.space == "code/data"
	    : GBL.DSPTYPE == 54
	        ? $1.space != "code" && $1.space != "io"
	    : GBL.DSPTYPE == 28
	        ? $1.space == "data" || $1.space == "code/data"
	    : GBL.DSPTYPE == 55
	    ? $1.space == "data" || $1.space == "code/data"
	    : $1.space == "code/data"
    )
    prop dataCodeMember :: (		 
	$1.dynamicLoading == 1
	    ? 0
	    : GBL.DSPTYPE == 62
	    ? ($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL
	    : GBL.DSPTYPE == 54
	        ? $1.space == "code" && $1 != MEM_NULL	 
							 
	    : GBL.DSPTYPE == 28
	        ? ($1.space == "code" || $1.space == "code/data")
		  && $1 != MEM_NULL		 
						 
	    : GBL.DSPTYPE == 55
	    ? ($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL
	    : $1.space == "code/data" && $1 != MEM_NULL  
							     
    )
    
 
    prop memWritable :: (.iIsModifiable && .iDelUser != "MEM")
    
 
    global CALLBACKOBJ :: nil {
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumHeap ::= (
	    $a = 0,
	    scan($i; MEM) {
		if ($i != MEM_NULL) {
		    $a += $i.iAllocHeap
		}
	    },
	    $a
	)  {
	prop NoGen :: 0
    }
    global REUSE ::=
	    (.INITSEG.space != "code" && .INITSEG.iAllocHeap == 1 ? .SAVEREUSE : 0) {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Reuse Startup Code Space"
	prop JSName :: "REUSECODESPACE"
	prop Visible :: 1
	prop Writable  :: .INITSEG.space != "code" && .INITSEG.iAllocHeap == 1
	prop NoGen :: 1
	prop Set :: (
	    .SAVEREUSE = $1,
	    "ok"
	)
    }
    global SAVEREUSE :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    
 
    global doCheckOverlap :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
 
    prop validate :: (
        $e = .checkMemOverlap($1),
        if ($e == "ok") {
            $e = .checkHeapSize($1)
        },
        if ($e == "ok") {
            $e = .checkHeapSeg($1)
        },
        $e
    )
    
    
 
    prop checkHeapSeg :: (
        $e = "ok",
        
        if ($1 == MEM_NULL && MEM.NOHEAPS == 0) {
            if (MEM.MALLOCSEG == MEM_NULL) {
                $e = ("Heaps are enabled, but the segment for malloc (MEM.MALLOCSEG) is not set correctly. Please create a heap in one of your data segments and set MEM.MALLOCSEG to it.")
            },
            if (MEM.SEGZERO == MEM_NULL) {
                $e = ("Heaps are enabled, but the segment for DSP/BIOS Objects (MEM.BIOSOBJSEG) is not set correctly. Please create a heap in one of your data segments and set MEM.BIOSOBJSEG to it.")
            }
        },
        $e
    )
    
 
    prop checkHeapSize :: (
        $e = "ok",
        if (MEM.NOHEAPS == 0) {
            if ($1.iAllocHeap && $1 != MEM_NULL) {
                if ($1.iHeapSize > $1.len) {
                    $e = ("MEM segment %s: heap cannot be larger than the length of segment that contains it.")
                }
            }
        },
        $e
    )
    
 
    prop checkMemOverlap :: (
        $e = "ok",
        if ($1 != MEM_NULL && $1.iIsUsed == 1) {
            if ($1.len == 0) {
                $a = $1.base
            }
            else {
                $a = ($1.base + $1.len - 1)
            },
            scan ($j; MEM) {
                if ($1 != $j && $j != MEM_NULL && $j.iIsUsed == 1 &&
                    (GBL.DSPTYPE == 62 ||
                    $1.space == $j.space)) {
                    if (!($j == CACHE_L2 && GBL.L2CONFIGURE == 0)) {
                        $b = $j.base,
                        if ($j.len == 0) {
			    $c = $j.base
			}
			else {
			    $c = ($j.base + $j.len - 1)
			},
                        
 
                        if ($a >= $b && $1.base <= $c) {
                            $e = ("MEM segment %s: overlaps with another segment or cache configuration."),
                            break
                        }
                    }
                }
            }
        },
        $e
    )
     
    global MAPSELECT :: "Map 1" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Map Mode"
	prop JSName :: "MAPMODE"
	prop Enum :: "Map 0,Map 1"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global ARGSSIZE :: 4 {		 
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04x"
	prop Style :: 0x01 | 0x02
	prop Label :: "Argument Buffer Size"
	prop JSName :: "ARGSSIZE"
	prop Visible :: 1	 
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    if ($1 < 4) {
		.error("The 'arguments' section must have at least 4 words.")
	    }
	    else {
		.ARGSSIZE = $1,
		"ok"
	    }
	)
    }
    global ARGSSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataMember($1)
	prop Label :: "Argument Buffer Section (.args)"
	prop JSName :: "ARGSSEG"
	prop Visible :: 1	 
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
    }
    
    global BIOSSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .codeMember($1)
	prop Label :: "BIOS Code Section (.bios)"
	prop JSName :: "BIOSSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Code"
    }
    global STACKSIZE :: GBL.DSPTYPE == 62 ? 1024 : (GBL.DSPTYPE == 55 && GBL.DSPSUBTYPE == 5599) ? 2560 : (GBL.DSPTYPE == 55 && GBL.DSPSUBTYPE != 5599) ? 1024: (GBL.DSPTYPE == 54)?256:(GBL.DSPTYPE == 28) ? 512 : 256 {  
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04x"
	prop Style :: GBL.DSPTYPE == 54
	    ? 0x01 | 0x02
	    : 0x02
	prop Label :: "Stack Size (MAUs)"
	prop JSName :: "STACKSIZE"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
		if ((GBL.DSPTYPE == 55) && (GBL.DSPSUBTYPE != 5599)) {
		    .STACKSIZE = ($1 & -2)
		}
		else {
		    if ((GBL.DSPTYPE == 55) && (GBL.DSPSUBTYPE == 5599)) {
		        .STACKSIZE = ($1  & -4)
		    }
		    else {
		        .STACKSIZE = $1
		    }
		},
		"ok"
	)
	prop PropSetOkUserMsg :: (MEM.STACKSIZE < GlobalStatus.MinStackSize)?"Warning: You are setting the stack size to a value that is less than the Estimated Minimum Stack Size!":"ok"
    }
    global USERCMD :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "User .cmd File For Compiler Sections"
	prop JSName :: "USERCOMMANDFILE"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global STACKSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataMember($1)
	prop Label :: "Stack Section (.stack)"
	prop JSName :: "STACKSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
	prop Set :: (
	    if (GBL.DSPTYPE == 55) {
	        (MEM.STACKSEG = $1), 
		(MEM.SYSSTACKSEG = $1)
		}
		else {
		(MEM.STACKSEG = $1)
		},
		"ok"
	)
    }
    global ENABLELOADSEG :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify Separate Load Addresses"
	prop JSName :: "ENABLELOADADDR"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global LOADBIOSSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .codeMember($1)
	prop Label :: "Load Address - BIOS Code Section (.bios)"
	prop JSName :: "LOADBIOSSEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global INITSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .codeMember($1)
	prop Label :: "Startup Code Section (.sysinit)"
	prop JSName :: "SYSINITSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Code"
    }
    global LOADINITSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .codeMember($1)
	prop Label :: "Load Address - Startup Code Section (.sysinit)"
	prop JSName :: "LOADSYSINITSEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global BIOSINITSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataCodeMember($1)
	prop Label ::"DSP/BIOS Init Tables (.gblinit)"
	prop JSName :: "GBLINITSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
    }
    global TRCINITSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataCodeMember($1)
	prop Label ::"TRC Initial Value (.trcdata)"
	prop JSName :: "TRCDATASEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
    }
    global LOADBIOSINITSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataCodeMember($1)
	prop Label ::"Load Address - DSP/BIOS Init Tables (.gblinit)"
	prop JSName :: "LOADGBLINITSEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global LOADTRCINITSEG ::= .TRCINITSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataCodeMember($1)
	prop Label ::"Load Address - TRC Initial Value (.trcdata)"
	prop JSName :: "LOADTRCDATASEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global SYSDATASEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataMember($1)
	prop Label :: "DSP/BIOS Kernel State (.sysdata)"
	prop JSName :: "SYSDATASEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
    }
    global CFGOBJSEG :: IRAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
	prop MemberTest :: .dataMember($1)
        prop Label :: "DSP/BIOS Conf Sections (.*obj)"
	prop JSName :: "OBJSEG"
        prop Visible :: 1
        prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
    }
    global NOHEAPS :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "No Dynamic Memory Heaps"
	prop JSName :: "NOMEMORYHEAPS"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    if ($1) {
		 
		.SEGZERO.iReqHeapCount--,
		.SEGZERO = MEM_NULL,
		.MALLOCSEG.iReqHeapCount--,
		.MALLOCSEG = MEM_NULL,
		TSK.STACKSEG.iReqHeapCount--,
		TSK.STACKSEG = MEM_NULL,
		scan ($i; MEM) {
		    if ($i.iAllocHeap && $i != MEM_NULL) {
			$i.iAllocHeap = 0,
			$i.iHeapSize = 0
		    }
		}
	    },
	    .NOHEAPS = $1,
	    "ok"
	)
	prop PropSetOkUserMsg :: (MEM.NOHEAPS == 1)?"Currently specified heaps no longer valid":"Please reconfigure heaps under individual mem segments"
    }
    global SEGZERO :: IRAM { 
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataNullMember($1) && $1.iAllocHeap)
	prop Label :: "Segment For DSP/BIOS Objects"
	prop JSName :: "BIOSOBJSEG"
	prop Visible :: 1
	prop Writable :: MEM.NOHEAPS == 0
	prop NoGen :: 0
        prop Set :: (
            if (.SEGZERO.iReqHeapCount > 0) {
                .SEGZERO.iReqHeapCount--
            },
            .SEGZERO = $1,
            .SEGZERO.iReqHeapCount++,
            "ok"
        )
    }
    global MALLOCSEG :: IRAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
	prop MemberTest :: (.dataNullMember($1) && $1.iAllocHeap)
        prop Label :: "Segment For malloc() / free()"
	prop JSName :: "MALLOCSEG"
        prop Visible :: 1
	prop Writable :: (MEM.NOHEAPS == 0)
	prop NoGen :: 0
        prop Set :: (
            if (.MALLOCSEG.iReqHeapCount > 0) {
                .MALLOCSEG.iReqHeapCount--
            },
            .MALLOCSEG = $1,
            .MALLOCSEG.iReqHeapCount++,
            "ok"
        )
    }
    global USEMPC :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable Memory Protection Controller module"
	prop JSName :: "USEMPC"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    global LNKCMDFILE :: "" {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify User Linker cmd File"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    
 
    global TEXTSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.codeMember($1))
	prop Label :: "Text Section (.text)"
	prop JSName :: "TEXTSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global LOADTEXTSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.codeMember($1))
	prop Label :: "Load Address - Text Section (.text)"
	prop JSName :: "LOADTEXTSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0 && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global SWITCHSEG :: GBL.DSPTYPE == 62 ? MEM.BSSSEG :(GBL.DSPTYPE == 55 && GBL.DSPSUBTYPE == 5561)? IRAM: MEM.TEXTSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1))
	prop Label :: "Switch Jump Tables (.switch)"
	prop JSName :: "SWITCHSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global LOADSWITCHSEG :: GBL.DSPTYPE == 62 ? MEM.BSSSEG :(GBL.DSPTYPE == 55 && GBL.DSPSUBTYPE == 5561)? IRAM: MEM.TEXTSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1))
	prop Label :: "Load Address - Switch Jump Tables (.switch)"
	prop JSName :: "LOADSWITCHSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0 && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global BSSSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "C Variables Section (.bss)"
	prop JSName :: "BSSSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global FARSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "C Variables Section (.far)"
	prop JSName :: "FARSEG"
	prop Visible :: GBL.DSPTYPE == 62 ? 1 : 0
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global CINITSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1))
	prop Label :: "Data Initialization Section (.cinit)"
	prop JSName :: "CINITSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global LOADCINITSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1))
	prop Label :: "Load Address - Data Initialization Section (.cinit)"
	prop JSName :: "LOADCINITSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0 && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    
    global PINITSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1))
	prop Label :: "C Function Initialization Table (.pinit)"
	prop JSName :: "PINITSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    
    global LOADPINITSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1))
	prop Label :: "Load Address - C Function Initialization Table (.pinit)"
	prop JSName :: "LOADPINITSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0 && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global CONSTSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "Constant Sections (.const, .printf)"
	prop JSName :: "CONSTSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global LOADCONSTSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "Load Address - Constant Sections (.const, .printf)"
	prop JSName :: "LOADCONSTSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0 && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global DATASEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "Data Section (.data)"
	prop JSName :: "DATASEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global CIOSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "Data Section (.cio)"
	prop JSName :: "CIOSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
	prop Set :: (
	    .CIOSEG = $1,
	    .SYSMEMSEG = $1,
	    "ok"
	)
    }
    global SYSMEMSEG ::= IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "Data Section (.sysmem)"
	prop JSName :: "SYSMEMSEG"
	prop Visible :: 0
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global STUBMEMSEG ::= HWI.STUBMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "Function Stub Memory (.hwi)"
	prop JSName :: "HWISEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Code"
	prop Set :: (
	    .STUBMEMSEG = $1,
	    HWI.STUBMEMSEG = $1,
	    "ok"
	)
    }
    
    global LOADSTUBMEMSEG :: HWI.STUBMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "Load Address - Function Stub Memory (.hwi)"
	prop JSName :: "LOADHWISEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global VECMEMSEG ::= HWI.VECMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "Interrupt Service Table Memory (.hwi_vec)"
	prop JSName :: "HWIVECSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Code"
	prop Set :: (
		.VECMEMSEG = $1,
		HWI.VECMEMSEG = $1,
		GlobalStatus.gDirty = 1,
		if ($1.base == 0) {
		    HWI.GENERATE_RESET_VEC = 0
		},
		"ok"
	)
    }
    global LOADVECMEMSEG :: HWI.VECMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "Load Address -Interrupt Service Table Memory (.hwi_vec)"
	prop JSName :: "LOADHWIVECSEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global RTDXTEXTMEMSEG ::= RTDX.TEXTMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "RTDX Text Segment (.rtdx_text)"
	prop JSName :: "RTDXTEXTSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Code"
	prop Set :: (
	    .RTDXTEXTMEMSEG = $1,
	    RTDX.TEXTMEMSEG = $1,
	    "ok"
	)
    }
    global LOADRTDXTEXTMEMSEG :: RTDX.TEXTMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "Load Address - RTDX Text Segment (.rtdx_text)"
	prop JSName :: "LOADRTDXTEXTSEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    prop _spaceEnum :: (
	.ENUMSPACE
    )    
    global ENUMSPACE ::=
	GBL.DSPTYPE == 62
	    ? "code,data,code/data,reserved"
	    : GBL.DSPTYPE == 54
	        ? "code,data,io,other,reserved"
		: GBL.DSPTYPE == 28
		   ? "code,code/data,data,io,other,reserved"
                   : GBL.DSPTYPE == 55		 
                      ? "code/data,code,data,io,reserved"
	              : "code/data,io,reserved" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "ENUMSPACE"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    inst base :: 0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: GBL.DSPTYPE == 62 ? "0x%08x" : "0x%06x"
	prop Style :: 0x02
	prop Label :: "base"
	prop JSName :: "base"
	prop Visible :: 1
	prop Writable :: (.iIsModifiable)
	prop NoGen :: 1
	prop Set :: (
	    $e = "ok",
	    $a = .base,
	    .base = $1,
	    if (MEM.CALLBACKOBJ != nil) {
		$e = MEM.CALLBACKOBJ.call(self),
		if ($e != "ok") {
		    .base = $a
		}
	    },
	    $e
	)
    }
    inst len :: 0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: GBL.DSPTYPE == 62 ? "0x%08x" : "0x%04x"
	prop Style :: 0x08
	prop Label :: "len"
	prop JSName :: "len"
	prop Visible :: 1
	prop Writable :: (.memWritable)
	prop NoGen :: 0
	prop Set :: (
	    $e = "ok",
	    $a = .len,
	    .len = $1,
	    if (MEM.CALLBACKOBJ != nil) {
		$e = MEM.CALLBACKOBJ.call(self),
		if ($e != "ok") {
		    .len = $a
		}
	    },
	    "ok"
	)
    }
    inst page ::= (
	
 
	GBL.DSPTYPE == 62
	    ? -1
	    : (GBL.DSPTYPE == 55  || GBL.DSPTYPE == 28)
		? (.space == "code"
		    ? 0
		    : .space == "data"
                        ? 1
                        : .space == "io"
                            ? 2
		            : 0 )        
		:.space == "code"
	   	   ? 0
	   	   : .space == "data"
	               ? 1
	       	       : .space == "io"
	      	           ? 2
		           : 3) {	 
	prop Type  :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
	
    
 
    inst iAllocHeap :: MEM.NOHEAPS == 1 ? 0 : 1 {
	prop Type  :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "create a heap in this memory"
	prop JSName :: "createHeap"
	prop Visible :: 1
	prop Writable :: (.space == "data" || .space == "code/data")
		&& (MEM.NOHEAPS == 0) && .memWritable
	prop NoGen :: 0
	prop Set :: (
	    $a = "ok",
	    if ($1 == 0 && .iReqHeapCount > 0) {
	        .error("This heap is used by one or more of: segment for DSP/BIOS objects, segment for malloc()/free(), TSK default stack segment")
	    }
	    else {
		if ($1 == 0) {
		    .iUserHeapId = 0,
		    .iHeapId = @segment_name
		},
		.iAllocHeap = $1,
		MEM.gDirty = 1,
		$a
	    }
	)
    }
    inst iHeapSize :: 0x8000 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: GBL.DSPTYPE == 62 ? "0x%08x" : "0x%04x"
        prop Style :: 0x02
        prop Label :: "heap size"
	prop JSName :: "heapSize"
        prop Visible :: 1
        prop Writable :: (.iAllocHeap) && (.iIsModifiable) && (MEM.NOHEAPS == 0)
        prop Set :: (
            .iHeapSize =  $1,
            "ok"
        )
        prop NoGen :: 1
    }
    inst iSegZero ::= MEM.SEGZERO
    inst iUserHeapId :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "enter a user defined heap identifier label"
	prop JSName :: "enableHeapLabel"
	prop Set :: (
	    if ($1 == 0) {
		.iHeapId = @segment_name
	    },
	    .iUserHeapId = $1,
	    "ok"
	)
	prop Visible :: 1
	prop Writable :: (.iAllocHeap) && (.iIsModifiable) && (.NOHEAPS == 0)
	prop NoGen :: 1
    }
    inst iHeapId :: @segment_name {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "heap identifier label"
	prop JSName :: "heapLabel"
	prop Set :: (
	    $e = .checkHeapId($1),
	    if ($e == "ok") {
		.iHeapId = $1
	    },
	    $e
	)
	prop Writable :: (.iAllocHeap) && (.iIsModifiable) && (.NOHEAPS == 0) &&(.iUserHeapId)
	prop Visible :: 1
	prop NoGen :: 0
    }
    prop checkHeapId :: (
	$e = "ok",
	scan ($i; MEM) {
	    if ($i.iAllocHeap == 1 && $i.iUserHeapId == 1 && $i.iHeapId == $1 && $i.iHeapId != @segment_name) {
		$e = .error ("This identifier label is already in use"),
		break
	    }
	},
	$e
    ) 
    inst iReqHeapCount :: 0 {	 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    inst space :: ( GBL.DSPTYPE == 55 ? "code/data" : "data") {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	
 
	prop Enum :: MEM._spaceEnum()
	prop JSName :: "space"
	prop Visible :: 1
	prop Writable :: (.memWritable)
	prop NoGen :: 1
	prop Set :: (
	    $e = "ok",
	    if ($1 != "data" && $1 != "code/data" && .iAllocHeap == 1) {
		$e =.error("Cannot select this space if a heap will be created")
	    }
	    else {
		$a = .space,
		.space = $1,
		if (MEM.CALLBACKOBJ != nil) {
		    $e = MEM.CALLBACKOBJ.call(self),
		    if ($e != "ok") {
			.space = $a
		    }
		}
	    },
	    $e
	)
    }
    inst dynamicLoading :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Reserved for dynamic loading"
	prop JSName :: "dynamicLoading"
	prop Visible :: GBL.ENABLEDLL
	prop Writable :: GBL.ENABLEDLL
	prop NoGen :: 1
    }
    inst iIsModifiable :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
}
object MEM_NULL :: MEM {
    param iComment :: "Place holder segment which allows user to disable heaps"
    param iAllocHeap :: 1
    param iIsUsed :: 0
}
 
type OBJ {
    isa ObjectMgr
    prop name :: "OBJ"
    prop Visible :: 0
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _objMemDesc, _memSeg, _placement"
	}
    )
    prop _objMemDesc :: ("%8t .obj: {}")
    prop _memSeg :: MEM.CFGOBJSEG
    prop _placement :: (0x7fffffff / 2)
}
 
type BUF {
    isa  ObjectMgr
    prop name :: "BUF"
    prop Label :: "BUF - Buffer Manager"
    prop IsContainedIn :: SYSTEM 
    prop GlobalIcon :: 199
    prop InstanceIcon :: 200
    prop InstanceHelpTopic :: (
	421
    )
    
    prop GlobalHelpTopic :: (
	321
    )
    prop InstancePropertyPage :: (
	"{B7240DE8-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
	"{B7240DE9-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    prop maxObjs :: (32767)
    
     
    prop AllocType :: (
      if (.gNumOf > 0) {
	"1\0,      _globalAllocDesc, _memSeg, _placement"
      }
    )
    prop _globalAllocDesc :: (
       "%8t.buf:{}"
    )
	    
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: .OBJMEMSEG
     
    prop AllocInst :: (
          "1\0, _instAllocDesc, _instMemSeg, _placement"
    )
    prop _instAllocDesc :: (
          "%8t .%0s$data: align = 0x%1x {%12t\n %0s$databeg = .;\n .+= %2d; %8t\n }\0, _objAlign, _buflength"
    )
    prop _objAlign :: .align
    prop _instMemSeg :: .bufseg
    prop _buflength :: (.postalignsize *  .bufcount) 
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "buf.h" : ""
    
 
    prop cGenHInst :: (
	if (GBL.DSPTYPE == 62) {
	    "extern far BUF_Obj %0r;\n\0"
	}
	else {
	    "extern BUF_Obj %0r;\n\0"
	}
    )
    
    
 
    prop objectSize :: (
        if (GBL.DSPTYPE == 62) {
            $a = ((7 + 3) * 4)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
            $a = ((7 + 4) * 4)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {
            $a = ((7 + 3) * 4)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {
            $a = (12 + 6)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {
            $a = (12 + 6)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
            $a = (7 + 4)
        },
        if (GBL.DSPTYPE == 28) {
            $a = (12 + 6)
        },
        $a
    )
     
    prop dataSize :: (
	$d = 0,
	scan ($i; BUF) {
	    if ($i.IsConfObj()) {
		$d += $i.len 
	    },
	    $d += BUF.objectSize	
	},
	$d
    )
     
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global ENABLED :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Compile in logging"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
     
    inst bufseg :: .OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Memory segment for buffer pool"
	prop JSName :: "bufSeg"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
     
    inst bufcount :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Buffer count"
	prop JSName :: "bufCount"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    .bufcount = $1,
            .postalignsize = (.size + (.align - 1)) & ~(.align - 1),
	    .len = $1 * .postalignsize, 
	    "ok"
	)
    }
     
    inst size :: 8  { 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Buffer size (MADUs)"
	prop JSName :: "size"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
             if($1 < 8) { 
                .error("Size should be atleast 8 bytes")
             }
             else { 
	        .size = $1,
                .postalignsize = ($1 + (.align - 1)) & ~(.align - 1),
                .len = .postalignsize * .bufcount,
	        "ok"
             }
	)
    }
     
     inst align :: 4 { 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Buffer alignment(Power of 2)"
	prop JSName :: "align"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0 
	prop Set :: (
             if($1 < 4) { 
                .error("Alignment should be atleast 4 ")
             }
             else { 
	         .align = $1,
                 .postalignsize = (.size + ($1 - 1)) & ~($1 - 1),
                 .len = .postalignsize * .bufcount,
	         "ok"
             }
	 )
    }
     
    inst len :: .size {
	prop Label :: "Buffer pool length (MADUs)"
	prop JSName :: "len"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: 0
	prop NoGen :: 1
    }
     
    inst postalignsize :: .size {
	prop Label :: "Buffer size after alignment (MADUs)"
	prop JSName :: "postalignsize"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: 0
	prop NoGen :: 0
    }
    
}
 
type POOL {
    isa Module
    prop Visible :: 1
    prop name :: "POOL"
    prop Label :: "POOL - Allocator Manager"
    prop IsConfMod :: .USEPOOL 
    prop IsContainedIn :: SYSTEM
 
    prop GlobalIcon :: 199
    prop InstanceIcon :: 200
    prop GlobalHelpTopic :: (
	324
    )
    prop InstanceHelpTopic :: (
	424
    )
    prop InstancePropertyPage :: (
	"{473C4A62-B1A8-11d0-9885-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{473C4A63-B1A8-11d0-9885-0020AFEE33C6}"
    )
    prop DependsOn :: "MEM,BUF"
    global USEPOOL :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable Allocator Manager"
	prop JSName :: "ENABLEPOOL"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
}
 
 
 
 
type CLK {
    isa ObjectMgr
    prop name :: "CLK"
    prop Label :: "CLK - Clock Manager"
    prop IsContainedIn :: SCH
    prop IsConfMod :: 1 		 
    prop GlobalIcon :: 103
    prop InstanceIcon :: 104
    prop InstanceHelpTopic :: (
	202
    )
    prop GlobalHelpTopic :: (
	102
    )
    prop InstancePropertyPage :: (
	"{EEB2AB41-51E3-11d0-A61D-0000C070F3E9}"
    )
    prop GlobalPropertyPage :: (
	"{EEB2AB40-51E3-11d0-A61D-0000C070F3E9}"
    )
    prop objectSize :: (
	$a = (1 * 4)
    )
    prop GenLinkPrologue :: (
	"SECTIONS {%4t\n.%1L: {\n%8t \n %4S \n%4t} > %3s, RUN_START(%1U_A_TABBEG) \0, name, _objSize, _memSeg, _linkString, clkFxn, _clkStartFxn"
    )
    prop _clkStartFxn :: (GBL.SUPPORTCSL && .USETIMER) ? @_CLK_start6x : @FXN_F_nop
    prop GenLinkEpilogue :: (
	"%0t}\n_CLK_PRD = CLK_PRD;\n_CLK_COUNTSPMS = CLK_COUNTSPMS;\n_CLK_REGS = CLK_REGS;\n_CLK_USETIMER = CLK_USETIMER;\n_CLK_TIMERNUM = CLK_TIMERNUM;\n_CLK_TDDR = CLK_TDDR;\n\0"
    )
    prop _linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no CLK objs */"
    prop _memSeg :: CLK.OBJMEMSEG
     
    prop _objSize :: .objectSize()
    prop clkFxn :: (.ENABLEHTIME == 1) ? .CLKFXN : @FXN_F_zero
    
    prop maxObjs :: (
	32767				 
    )
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    prop localInit :: (
	if (GBL.CALLBACKOBJ != CLK) {
	    CLK.gGBLChain = GBL.CALLBACKOBJ,
	    GBL.CALLBACKOBJ = CLK
	}
    )
    
    prop dataSize :: (
	.objectSize() * (CLK.gNumOf + 1)	 
    )
    prop localCanCreate :: (
	.USETIMER ? "ok" : .error ("The CLK Manager must be enabled before inserting a CLK")
    )
    prop localCreate :: (
	CLK.HOOKFXN = @HWI_F_dispatch,
	.seizeHwi(.WHICHHWI),
	"ok"
    )
    prop localDelete :: (
	if (.gNumOf == 1) {	 
	    if (GBL.CALLMODEL == "far") {
	        CLK.HOOKFXN = @CLK_F_frete,
		.seizeHwi(.WHICHHWI)
	    }
	    else {
	        CLK.HOOKFXN = @CLK_F_rete,
		.seizeHwi(.WHICHHWI)
	    }
	},
	"ok"
    )
    global gGBLChain :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
 	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: .USETIMER
	prop NoGen :: 1
    }
    prop maskableHWI :: (
	$1 != HWI_RESET && $1 != HWI_UNUSED && $1 != HWI_NMI &&
	$1 != HWI_RESERVED0 && $1 != HWI_RESERVED1 ? 1 : 0
    )
    prop setInterruptNumber :: (
	$a = ($1 == "RTI1 Timer0" ? 26 : 20),
        scan ($b; ISRC) {
	    if ($b.iIntrSelectNum == $a) {
	        .WHICHHWI.iSource = $b
	    }
	}
    )
    prop setTimerNumber :: (
	if (.WHICHTIMER == "RTI1 Timer0") {
	    .TIMERNUM = 0,
	    .TIMER0BASE = 0x01c82800
	}
	else {
	    .TIMERNUM = 1,
	    .TIMER0BASE = 0x01c44800
	}
    )
    global WHICHHWI :: ( HWI_INT14 ) {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: HWI
	prop MemberTest :: .maskableHWI($1)
	prop Label :: "CPU Interrupt"
 	prop JSName :: "HWISELECT"
	prop Visible :: 1
	prop Writable :: .USETIMER
	prop NoGen :: 1
	prop Set :: (
	    $e = "ok",
	    $e = .releaseHwi(.WHICHHWI),
	    if ($e == "ok") {
	        .WHICHHWI = $1,
	        $e = .seizeHwi(.WHICHHWI)
	    },
	    $e
	)
    }
    global INTBIT ::= .WHICHHWI.iIntrEnableMask
    global WHICHTIMER :: "RTI1 Timer0" { 
        prop Label :: "Timer Selection"
 	prop JSName :: "TIMERSELECT"
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "RTI1 Timer0,RTI2 Timer0"
	prop Visible :: 1
	prop Writable :: .USETIMER
	prop NoGen :: 1
	prop Set :: (
	    .WHICHTIMER = $1,
	    .setInterruptNumber(.WHICHTIMER),
	    .setTimerNumber(),
	    .HOOKFXN = .gNumOf > 0 ? @HWI_F_dispatch : @CLK_F_rete,
	    "ok"
	)
    }
    global REGS ::= (			 
	.TIMER0BASE
	) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Writable :: 1
	prop Visible :: 0
    }
    global TIMER0BASE :: 0x01c82800 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Writable :: 1
	prop Visible :: 0
	prop JSName ::  "TIMER0BASE"
	prop NoGen :: 1
    }
    global TIMERNUM :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop NoGen :: 0
    }
    global USETIMER :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable CLK Manager"
 	prop JSName :: "ENABLECLK"
	prop Visible :: 1
	prop Writable :: .gNumOf > 0 ? 0 : 1
	prop NoGen :: 0
	prop Set :: (
	    if ($1 == 1 && .USETIMER == 0) {
		if (($e = .seizeHwi(.WHICHHWI)) == "ok") {
		    .USETIMER = 1,
	    	    
		    .TIMEFXN = CLK.HIRES ? CLK.clkFxn() : @CLK_F_getltime,
    		    .HOOKFXN = GBL.CALLMODEL == "far" ? @CLK_F_frete : @CLK_F_rete,
		    .seizeHwi(.WHICHHWI),
		        
		    GlobalStatus.gDirty = 1,
		    if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {
			.releaseHwi(.WHICHHWI),
			.TIMEFXN = @FXN_F_zero,
			.HOOKFXN = @FXN_F_nop,	
			.USETIMER = 0,
			GlobalStatus.gDirty = 1,
			.error("Current stack size inadequate to enable CLK")
			}
			else 
			{
		        if (GBL.ENABLEINST == 1) {
		        IDL_busyObj.Create("IDL"),
			IDL.USEIDLBUSYOBJ = 1,
		        IDL_cpuLoad.Create("IDL"),
                        IDL.AUTOCALCULATE = GBL.OLDAUTOCALCULATE
		         },
		          $e
	        	 }
		     }
		     else {
		          $e	
			}
	    }
	    else {
		if ($1 == 0 && .USETIMER == 1) {
			.releaseHwi(.WHICHHWI),
			.TIMEFXN = @FXN_F_zero,
			
 
			.HOOKFXN = @FXN_F_nop,	
			.USETIMER = 0,
		        if (GBL.ENABLEINST == 1) {
			    IDL_busyObj.Delete("IDL"),
			    IDL.USEIDLBUSYOBJ = 0,
			    IDL_cpuLoad.Delete("IDL"),
                            GBL.OLDAUTOCALCULATE = IDL.AUTOCALCULATE,
                            IDL.AUTOCALCULATE = 0
			},
			  "ok"
		     }
		     else {
		          "ok"
	        }
	    }
	)
    }
    
    global HIRES ::= 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Use high resolution time for internal timings"
 	prop JSName :: "HIRESTIME"
	prop Visible :: 1
	prop Writable :: .USETIMER
	prop NoGen :: 1
	prop Set :: (
	    if (CLK.USETIMER) {
		CLK.HIRES = $1,
		if (CLK.USETIMER) {
		        CLK.TIMEFXN = CLK.HIRES ? CLK.clkFxn() : @CLK_F_getltime
		},
		"ok"
	    }
	    else {
		.error("CLK Manager must be enabled in order to get high resolution timings.")
	    }
	)
    }
    global ENABLEHTIME :: =1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable high resolution timer"
 	prop JSName :: "ENABLEHTIME"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    global INSTRPERCLK :: 1 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global SPECIFYRATE :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Specify input clock rate"
 	prop JSName :: "SPECIFYRATE"
	prop Visible :: 1
	prop Writable :: .USETIMER
	prop NoGen :: 1
	prop Set :: (
	    $e = "ok",
	    $a = .SPECIFYRATE,
	    .SPECIFYRATE = $1,
	    if !(.SPECIFYRATE) {
	        $e = CLK.call(),
	        if ($e != "ok") {
		    .SPECIFYRATE = $a,
		    CLK.call()
	        }
	    },
	    $e
    	)
    }
    global _INPUTCLK :: 24.0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style :: 0x04
	prop Format :: "%.4f"
	prop Label :: "Input frequency (MHz)"
	prop JSName :: "INPUTCLK"
	prop Visible :: 1
	prop Writable :: .USETIMER && .SPECIFYRATE
	prop NoGen :: 1
	prop Set :: (
	    $e = "ok",
	    $a = ._INPUTCLK,
	    ._INPUTCLK = $1,
	    $e = CLK.call(),
	    if ($e != "ok") {
		._INPUTCLK = $a,
		CLK.call()
	    },
	    $e
	)
    }
    
    global _RESETTIMER :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Reset Timer and TIMMODE"
 	prop JSName :: "RESETTIMER"
	prop Visible :: 0
	prop Writable :: .USETIMER
	prop NoGen :: 1
    }
    global _TIMMODE :: "32-bit unchained" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "32-bit unchained,32-bit chained,externally programmed"
	prop Label :: "Timer Mode"
 	prop JSName :: "TIMMODE"
	prop Visible :: 0
	prop Writable :: .USETIMER
	prop NoGen :: 1
    }	
     
    global MICROSECONDS :: (((float((CLK . PRD)) + CLK . adjustPrd) * ((CLK . TDDR) + 1.0) * 1 / CLK . _INPUTCLK)) {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style :: 0x04
	prop Format :: "%.4f"
	prop Label :: "Microseconds/Int"
 	prop JSName :: "MICROSECONDS"
	prop Set :: (
	    .setMicroseconds($1)
	)
	prop Visible :: 1
	prop Writable :: ((CLK.PROGTIMREGS != 0) | (.USETIMER == 0)) ? 0 : 1
	prop NoGen :: 1
    }
    
    global MICROSECS ::= int(round(.MICROSECONDS)) {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style ::  0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global PROGTIMREGS ::= 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Directly configure on-chip timer registers"
	prop JSName :: "CONFIGURETIMER"
	prop Visible :: 1
	prop Writable :: .USETIMER
	prop NoGen :: 1
    }
    global TCR :: = 0x20 | CLK.TDDR {	 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global FIXTDDR :: (GBL.DSPTYPE == 62) ? 1 : 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Fix TDDR"
 	prop JSName :: "FIXTDDR"
	prop Visible :: (GBL.DSPTYPE != 62)
	prop Writable :: CLK.PROGTIMREGS && (GBL.DSPTYPE != 62)
	prop NoGen :: 1
    }
    
    
 
    global TDDR :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
	prop Label :: "Compare UpCounter Register"
 	prop JSName :: "TCRTDDR"
	prop Set :: (
	    CLK.TDDR = $1,
	    CLK.MICROSECONDS = ((float((CLK . PRD)) + CLK . adjustPrd) * ((CLK . TDDR) + 1.0) * 1 / CLK . _INPUTCLK),
	    if (CLK.CALLBACKOBJ != nil) {
		CLK.CALLBACKOBJ.call()
	    },
	    "ok"
	)
	prop Visible :: 1
	prop Writable :: CLK.PROGTIMREGS
	prop NoGen :: 0  
    }
    
 
    global TDDRHIGH ::= ((.TDDR & 0xffff0000) >> 16) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    global PRD ::= int(round((1000.0 * CLK._INPUTCLK / (CLK.TDDR + 1) / 1) - CLK.adjustPrd))  { 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
	prop Label :: (GBL.CLKTYPE == 700)? "Compare0 Register" : "PRD Register"
 	prop JSName :: "PRD"
	prop Set :: (
	    CLK.PRD = $1,
	    CLK.MICROSECONDS = ((float((CLK . PRD)) + CLK . adjustPrd) * ((CLK . TDDR) + 1.0) * 1 / CLK . _INPUTCLK),
	    if (CLK.CALLBACKOBJ != nil) {
		CLK.CALLBACKOBJ.call()
	    },
	    "ok"
	)
	prop Visible :: 1
	prop Writable :: ((.PROGTIMREGS) && (.USETIMER)) ? 1 : 0
	prop NoGen :: 0
    }
 
    global PRDHIGH ::= ((.PRD & 0xffff0000) >> 16) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    
 
    global COUNTSPMS ::= int(round(GBL.MIPS * 1000.0)) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
    }
 
    global COUNTSPMSHIGH ::= ((.COUNTSPMS & 0xffff0000) >> 16) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    prop adjustPrd :: 0
      	 
    prop seizeHwi :: (
      if ($1.client == "USER" && $1 == HWI_UNUSED) {
	  .error("Interrupt not mapped for selected timer.")
      }
      else {
	if ($1.client == "USER" && $1.function != @HWI_unused) {
	    .error("Interrupt mapped to selected timer is already in use.")
	}
	else {
	    if( $1.client == "CSL") {
	    .error("Interrupt mapped to selected timer is already in use by CSL.")
	    }
	    else {
	    	$1.function = @CLK_F_isr,
	    	$1.client = "CLK",
		.setInterruptNumber(.WHICHTIMER),
	    	$1.iUseDispatcher = (CLK.HOOKFXN == @HWI_F_dispatch ? 1 : 0),
	    	$1.iArg = ($1.iUseDispatcher == 1 ? @CLK_A_TABBEG : 0),
		$1.iReMappable = 0,
	    	HWI.gDirty = 1,
	    	"ok"
	    }
	}
      }
    )
    prop releaseHwi :: (
	$1.function = @HWI_unused,
	$1.client = "USER",
	$1.iUseDispatcher = 0,
	$1.iArg = 0,
	$1.iReMappable = 1,
	HWI.gDirty = 1,
	"ok"
    )
 
    prop setMicroseconds :: (
	$a = FIXTDDR == 1 ? .TDDR : 0xffffffff,
	$b = 0xffffffff,
	$c = (float($a) + 1.0) * ((float($b) + .adjustPrd) /
	    (CLK._INPUTCLK / 1)),
	if ($1 < $c && $1 > 0.1) {
	    if (.FIXTDDR == 0) {
		.TDDR = int((1.0 * $1 * CLK._INPUTCLK / 1) /
		    (float($b) + .adjustPrd))
	    },
	    .PRD = int((1.0 * $1 * CLK._INPUTCLK) /
		(1 * (.TDDR + 1.0))) - .adjustPrd,
	    .MICROSECONDS = ((float((. PRD)) + CLK . adjustPrd) * ((. TDDR) + 1.0) * 1 / CLK . _INPUTCLK),
	    if (.CALLBACKOBJ != nil) {
		.CALLBACKOBJ.call()
	    },
	    "ok"
	}
	else {
	    .error("The on-chip timer does not have enough range to support this combination of DSP MIPS and Microseconds/Int")
	}
    )
    
    prop setInputClockRate :: (
	CLK._INPUTCLK = 24.0,
	"ok"
    ) 
 
    prop call :: (
	if !(.SPECIFYRATE) {
	    .setInputClockRate()
	},
	$a = ((float((CLK . PRD)) + CLK . adjustPrd) * ((CLK . TDDR) + 1.0) * 1 / CLK . _INPUTCLK),
	$b = CLK.MICROSECONDS,
	$e = "ok",
	if (($e = .setMicroseconds(CLK.MICROSECONDS)) == "ok") {
	    if (CLK.gGBLChain != nil) {
		$e = CLK.gGBLChain.call()
	    },
	    if ($e != "ok") {
		.setMicroseconds($b),
		.error($e)
	    }
	    else {
		"ok"
	    }
	}
	else {
	    $e
	}
    )
    global INSTRUCTIONS ::= (
	1.0 * (float(CLK.PRD) + CLK.adjustPrd) * (CLK.TDDR + 1.0) * 1
    ) {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style :: 0x04
	prop Format :: "%.0f"
	prop Label :: "Instructions/Int"
	prop Visible :: 1
	prop Writable :: 0
	prop NoGen :: 1
    }
    
 
    global TIMEFXN ::= CLK.clkFxn() {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    
 
    
 
    global HOOKFXN ::= (GBL.CALLMODEL == "far" ? @CLK_F_frete : @CLK_F_rete) {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    
    global CLKFXN ::= @_CLK_gethtime {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
 
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global CALDIV ::= 1 
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global CALMULT ::= 1
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global HTIMEDIV ::= 1
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global HTIMEMULT ::= 1
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global LTIMEDIV ::= 1
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global LTIMEMULT ::= int((.TDDR + 1) * (.PRD + .adjustPrd) * (GBL.MIPS/CLK._INPUTCLK))	 
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global INPUTCLK ::= int(round(._INPUTCLK * 1000)) {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style ::  0x20
	prop JSName :: ""
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global RESETTIMER ::= (._RESETTIMER) {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
 	prop JSName :: ""
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global TIMMODE ::= (
	._TIMMODE == "32-bit unchained" ? 0x5 :
	._TIMMODE == "32-bit chained" ? 0xF : 0
        ) {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
 	prop JSName :: ""
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global HTIMEPERLTIME ::= int(round(GBL.MIPS * .MICROSECONDS))
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst function :: @FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "function"
 	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
     
    inst Order :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
	prop NoGen :: 1
	prop Writable :: 1
    }
     
    inst iPri :: 0 {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}
 
type PRD {
    isa ObjectMgr
    prop name :: "PRD"
    prop Label :: "PRD - Periodic Function Manager"
    prop IsContainedIn :: SCH
    
    prop IsConfMod :: 1
    prop GlobalIcon :: 119
    prop InstanceIcon :: 120
    prop InstanceHelpTopic :: (
	210
    )
    
    prop GlobalHelpTopic :: (
	110
    )
    prop InstancePropertyPage :: (
	"{B7240DE0-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
	"{B7240DE1-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
 
    prop STSGetMaxFmt :: (
	"%g ticks"
    )
    prop STSGetSumFmt :: (
	PRD.STSGetMaxFmt()
    )
    prop STSGetAvgFmt :: (
	"%.2f ticks"
    )
    prop GetPeriod :: .period
    prop IsOneShot :: .mode == "one-shot" ? 1 : 0
    prop objectSize :: (
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
	    $a = (10 * 4)
	},
	if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {
	    $a = (9 * 4)
	},
	if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
	    $a = (12 * 4)
	},
	if (GBL.DSPTYPE == 28 ||
	   (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") ||
	   (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE")) {
	    $a = (12 * 4)
	},
	if (GBL.DSPTYPE == 62) {
	    $a = (8 * 4)
	},
	$a
    )
    prop GenLinkPrologue :: (
        "SECTIONS {%4t\n.prd: RUN_START(PRD_A_TABBEG), RUN_END(PRD_A_TABEND) {%4t\n} > %1s%2s\0, memSeg, pageString"
    )
    
    prop GenLinkEpilogue :: (
        "%0t}\nPRD_A_TABLEN = %1d;\n\0, numInst"
    )
    prop linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop pageString :: GBL.DSPTYPE == 62
                      ? ""
                      : (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28)
                      ? (
                          PRD.OBJMEMSEG.space() == "code"
                          ? " PAGE 0"
                          : PRD.OBJMEMSEG.space() == "data"
                            ? " PAGE 1"
                            : PRD.OBJMEMSEG.space() == "io"
                              ? " PAGE 2"
                              : " PAGE 0"
                        )
                      : " PAGE 1"
    prop memSeg :: PRD.OBJMEMSEG
    prop objSize :: GBL.DSPTYPE == 55 ? .objectSize() * 2 : .objectSize()
    prop numInst :: (
    	PRD.gNumOf
    )
    prop dataSize :: (
	.objectSize() * PRD.gNumOf
    )
    prop localInit :: (
	if (CLK.CALLBACKOBJ != nil) {
	    .error("PRD initialization failure")
	},
	CLK.CALLBACKOBJ = PRD,
	if (PRD.USECLK && PRD_clock.iIsUsed == 0) {
	    PRD_clock.Create("PRD")
	},
	if (PRD_clock.iIsUsed == 1) {
	  if (.gNumOf == 0) {
            if (TSK.USETSK == 1 && TSK.TSKTICK == "PRD") {
  	      PRD_clock.function = @PRD_F_tick
            }
            else {
  	      PRD_clock.function = @FXN_F_nop
            }
          }
          else {
  	    PRD_clock.function = @PRD_F_tick
          }
        }
    )
    prop localCanCreate :: (
	if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {
	  .error(" System Stack Size too small")
	  }
        else {
	.myCreate("can")
	}
    )
    
    prop localCreate :: (
	STS.gNumEmbed += 1,
	if (($a = .myCreate("do")) == "ok") {
	  if (PRD_clock.iIsUsed == 1) {
	    if (.gNumOf == 0) {
  	      PRD_clock.function = @PRD_F_tick
            }
          }
        },
        $a
    )
    
    prop localCanDelete :: (
	.myDelete("can")
    )
    prop localDelete :: (
	STS.gNumEmbed -= 1,
	if (($a = .myDelete("do")) == "ok") {
	  if (.gNumOf == 1) {
	    if (PRD_clock.iIsUsed == 1) {
              if (TSK.USETSK == 1 && TSK.TSKTICK == "PRD") {
  	        PRD_clock.function = @PRD_F_tick
              }
              else {
  	        PRD_clock.function = @FXN_F_nop
              }
            }
	  }
	},
        $a
    )
    
    prop maxObjs :: (
	32767				 
    )
    prop myCreate :: (
	if (PRD_swi.function != @PRD_F_swi) {
	    PRD_swi.function = @PRD_F_swi
	},
	if (PRD_swi.iIsUsed) {
	    "ok"
	}
	else {
	    if (SWI.CanCreate() == "ok") {
		if ($1 == "do") {
		    if (KNL_swi.iIsUsed == 1 && PRD_swi.pri == 0) {
			PRD_swi.pri = 1
		    },
		    PRD_swi.Create("PRD")
		}
		else {
		    "ok"
		}
	    }
	    else {
		.error("Can't create an SWI for PRD (try deleting a SWI)")
	    }
	}
    )
    
    prop myDelete :: (
	if (PRD_swi.function != @PRD_F_swi) {
	    PRD_swi.function = @PRD_F_swi
	},
	if (.gNumOf == 1) {
	    if ($1 == "do") {
		PRD_swi.Delete("PRD")
	    }
	    else {
		"ok"
	    }
	}
	else {
	    "ok"
	}
    )
    
 
    prop call :: (
	if (CLK.USETIMER != 0) {
	    PRD.MICROSECONDS = CLK.MICROSECONDS
	},
	PRD.CALLBACKOBJ.call()
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "prd.h" : ""
    
 
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far PRD_Obj %0r;\n\0"
	}
	else {
	    "extern PRD_Obj %0r;\n\0"
	}
    )
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global USECLK :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Use CLK Manager to drive PRD"
	prop JSName :: "USECLK"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    if ($1 == 1 && .USECLK == 0) {
		if (CLK.USETIMER == 0) {
		    .error("In order to drive periodic functions, the CLK Manager must be enabled")
		}
		else {
		    .USECLK = 1,
		    .MICROSECONDS = CLK.MICROSECONDS,
		    CLK.CALLBACKOBJ = PRD,
		    PRD_clock.Create("PRD"),
		    GlobalStatus.gDirty = 1,
		    if (GlobalStatus.MinStackSize >= MEM.STACKSIZE){
                      .USECLK = 0,
		      .MICROSECONDS = 0.0,
                      CLK.CALLBACKOBJ = nil,
                      PRD_clock.Delete("PRD"),
                      .error("Current Stack size inadequate to enable this option")
		      }
		    else {
		      "ok"
		    }
		}
	    }
	    else {
		if ($1 == 0 && .USECLK == 1) {
		    .USECLK = 0,
		    .MICROSECONDS = 0.0,
		    CLK.CALLBACKOBJ = nil,
		    PRD_clock.Delete("PRD")
		},
		      "ok"
	    }
	)
	prop NoGen :: 1
    }
   
    
     
    global MICROSECONDS ::= CLK.MICROSECONDS {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style :: 0x04
	prop Format :: "%.1f"
	prop Label :: "Microseconds/Tick"
	prop JSName :: "MICROSECONDS"
	prop Visible :: 1
	prop Writable :: .USECLK == 0
	prop NoGen :: 1
    }
    global SCALAR ::= (		 
	$d = 2,
	$f = 0,
	
 
	while ($d <= 0x4000 && $f == 0) {
	    scan ($i; PRD) {
		if ((($i.period / $d) * $d != $i.period)) ||
		    ($i.mode == "one-shot") {
		    $f = 1
		}
	    },
	    if ($f == 0) {
		$d = 2 * $d
	    }
	},
	$d / 2
    ) {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
     
    prop DEFAULT_THOOKFXN :: @_KNL_tick 
    global THOOKFXN :: .DEFAULT_THOOKFXN {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "System Tick Hook Function"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
    }
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst period :: 0x7fff {	 
	prop Label :: "period (ticks)"
	prop JSName :: "period"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    if (($1 > 0) && ($1 < 0x8000)) {
		.period = $1,
		.gDirty = 1,
		"ok"
	    }
	    else {
		.error("Periodic function periods must be greater than 0 and less than 0x8000")
	    }
	)
    }
    inst mode :: "continuous" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "continuous,one-shot"
	prop JSName :: "mode"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst function :: @FXN_F_nop {	 
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst arg0 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg0"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst arg1 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg1"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst milliseconds ::= (
	(.period * PRD.MICROSECONDS) / 1000.0
    ) {
	prop Label :: "period (ms)"
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style :: 0x04
	prop Format :: "%.1f"
	prop Visible :: 1
	prop Writable :: 0
	prop NoGen :: 1
    }
     
    inst Order :: 0 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
        prop NoGen :: 0
        prop Writable :: 1
    }
     
    inst iPri :: 0 {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
    
 
    inst filter :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "filter"
	prop NoGen :: 0
    }
    inst maxformat :: "%g ticks" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "maxformat"
	prop NoGen :: 0
    }
    inst sumformat :: "%g ticks" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "sumformat"
	prop NoGen :: 0
    }
    inst avgformat :: "%.2f ticks" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "avgformat"
	prop NoGen :: 0
    }
    
 
    inst unittype :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "unittype"
	prop NoGen :: 0
    }
}
 
object PRD_swi :: SWI {
    param function :: @PRD_F_swi
    param iComment :: "This Software ISR executes all configured PRD functions"
    param iDelUser :: "PRD"
    param iDelMsg  :: (
	"This object is automatically deleted when all PRD objects are deleted"
    )
}
 
object PRD_clock :: CLK {
    param function :: @PRD_F_tick
    param iComment :: "This clock function calls PRD_tick from within the on-chip timer ISR"
    param iDelUser :: "PRD"
    param iDelMsg  :: (
	"This object is automatically deleted by disabling the 'Use CLK Manager to drive PRD' option of PRD"
    )
}
 
type RTDX {
    isa ObjectMgr
    prop Label :: "RTDX - Real-Time Data Exchange Settings"
    prop name :: "RTDX"
    prop IsConfMod :: .USERTDX		
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 145
    prop InstanceIcon :: 146
    prop GlobalHelpTopic :: (
	113
    )
    prop InstanceHelpTopic :: (
	213	
    )
    prop InstancePropertyPage :: (		
	"{f80273c0-3838-11d2-a32c-006097656921}"
    )
    
    prop GlobalPropertyPage :: (		
	"{050a0600-3839-11d2-a32c-006097656921}"
    )
    prop AllocType :: (.USERTDX ?
	"2\0, _rtdxDataAllocDesc, _rtdxDataSeg, _placement,
	     _rtdxTextAllocDesc, _rtdxTextSeg, _placement"
	:
	""
    )
    prop _rtdxDataAllocDesc :: (
        " .%1L_data: align = 0x40 { . += 0x80; *(.rtdx_data) }  \0, name"
    )
    prop _rtdxTextAllocDesc :: (
	if (MEM.ENABLELOADSEG == 1) {
	    if (MEM.RTDXTEXTMEMSEG == MEM.LOADRTDXTEXTMEMSEG) {
		" .%1L_text: {} \0, name"	
	    }
	    else {
		" .%1L_text: {} load > %2s, run \0, name, _loadRtdxTextMemSeg"
	    }
	}
	else {
	    " .%1L_text: {} \0, name"
	}
    )
    prop _rtdxDataSeg :: RTDX.DATAMEMSEG
    prop _rtdxTextSeg :: MEM.RTDXTEXTMEMSEG
    prop _loadRtdxTextMemSeg :: MEM.LOADRTDXTEXTMEMSEG
    prop _placement :: (0x7fffffff / 2)
    prop _objSize :: RTDX.BUFMEMSIZE
    prop GenLinkPrologue :: (.USERTDX ?
         "_RTDX_interrupt_mask = 0x%1x;\n\0, _interruptMask"
	:
	""
    )
    prop _interruptMask :: RTDX.MASK
     
    prop cGen :: 1
    
    
 
    prop noObjectAlias :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "rtdx.h" : ""
    
 
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
            if (.iChannelMode == "output") {
	        "extern far RTDX_outputChannel %0r;\n\0"
	    }
	    else {
	        "extern far RTDX_inputChannel %0r;\n\0"
	    }
	}
        else {
            if (.iChannelMode == "output") {
                "extern RTDX_outputChannel %0r;\n\0"
	    }
	    else {
	        "extern RTDX_inputChannel %0r;\n\0"
	    }
        }
    )
    prop cGenCInst :: (
	if (.iChannelMode == "output") {
	    "RTDX_CreateOutputChannel(%0r);\n\0"
	}
	else {
	    "RTDX_CreateInputChannel(%0r);\n\0"
	}
    )
    prop dataSize :: (
	$d = 0,
	if (.USERTDX) {
	    $d = RTDX.BUFMEMSIZE
	}
	else {
	    $d = 0
	},
	scan ($a; RTDX) {
	    if ($a.iChannelMode == "output") {
		$d += 1
	    }
	    else {
		$d += 3
	    }
	},
	$d
    )
    prop localCanCreate :: (
	$e = "ok",
	if (RTDX.USERTDX != 1) {
	    $e = .error("RTDX manager not enabled")
	},
	$e
    )
    global USERTDX ::= 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable Real-Time Data Exchange (RTDX)"
	prop JSName :: "ENABLERTDX"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
        prop Set :: (
            if($1 == 0) {
                if(HST.LNKTYPE == "RTDX") {
                    .error("RTDX is being used by HST; select a different host link type before attempting to disable RTDX") 
                }
                else {
		    if (.gNumOf > 0) {
			.error("Cannot disable RTDX until all RTDX objects are deleted.")
		    }
		    else {
		        GlobalStatus.gDirty = 1,    
                        .USERTDX = $1,
	                if (RTDX.CALLBACKOBJ != nil) {
		            RTDX.CALLBACKOBJ.call()
                        },
                        "ok"
		    }
                }
            }
	    else {
		GlobalStatus.gDirty = 1,	 
                .USERTDX = $1,
		if (RTDX.CALLBACKOBJ != nil) {
		    RTDX.CALLBACKOBJ.call()
                },
                "ok"
	    }
        )
    }
    global USERTEXECUTION ::= 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable Real-Time Execution Control"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global RTDXTYPE :: "JTAG" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "JTAG,HSRTDX,Simulator"
	prop Label :: "RTDX Mode"
	prop JSName :: "MODE"
	prop Visible :: 1
	prop Writable :: .USERTDX
	prop NoGen :: 0
	prop Set :: (
	    .RTDXTYPE = $1,
	    if (RTDX.CALLBACKOBJ != nil) {
		RTDX.CALLBACKOBJ.call()
	    },
	    "ok"
	)
     }
    global DATAMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "RTDX Data Segment (.rtdx_data)"
	prop JSName :: "RTDXDATASEG"
	prop Visible :: 1
	prop Writable :: 1 
	prop NoGen :: 0
    }
    
 
    global BUFMEMSIZE ::= (256 + 2) * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE) {  
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Label :: "RTDX Buffer Size (MAUs)"
	prop JSName :: "BUFSIZE"
	prop Visible :: 1
	prop Writable :: .USERTDX 
	prop NoGen :: 0
        prop Set :: (
	    if (HST.RTDX == 0) {
                .BUFMEMSIZE = $1,
		GlobalStatus.gDirty = 1,	 
		"ok"
	    }
	    else {
                if ($1 < (HST.MAXFRAMESET + 3) * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) {
                    .error("size (in MAUs) must be at least: (largest configured HST channel framesize in words + 3) * (MAUs per word)")
                }
                else {
                    .BUFMEMSIZE = $1,
		    GlobalStatus.gDirty = 1, 	 
		    if (HST.LNKTYPE == "RTDX") {
			HST.MAXFRAMEALLOWED = (.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 3,
			"ok"
		    }
		    else {
			"ok"
		    }
                }
	    }
        )
    }
    global TEXTMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "RTDX Text Segment (.rtdx_text)"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    global MASK :: 0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%08x"
	prop Style :: 0x02
	prop Label :: "RTDX Interrupt Mask"
	prop JSName :: "INTERRUPTMASK"
	prop Visible :: 1
	prop Writable :: .USERTDX 
	prop NoGen :: 1
	prop Set :: (
	    .MASK = $1,
	    "ok"
	)
    }
    
    inst iChannelMode :: "output" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Channel Mode"
	prop JSName :: "channelMode"
	prop Enum :: "input,output"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    GlobalStatus.gDirty = 1,
	    .iChannelMode = $1,
	    "ok"
	)
    }
    
 
     global CALLBACKOBJ :: nil {
	 prop Visible :: 0
	 prop Writable :: 0
	 prop NoGen :: 1
    }
}
 
type HST {
    isa  ObjectMgr
    prop name :: "HST"
    prop Label :: "HST - Host Channel Manager"
    prop IsContainedIn :: IOF
    prop DependsOn :: "HWI"
    prop FileStream :: 1
    prop GlobalIcon :: 107
    prop InstanceIcon :: 108
    prop GlobalHelpTopic :: (
	104
    )
    prop InstanceHelpTopic :: (
	204
    )
    prop maxObjs :: (
	GBL.DSPWORDSIZE
    )
    prop dataSize :: (
	$b = 0,
	scan ($i; HST) {
	    if ($i.IsConfObj()) {
		$b += (12 + $i.framesize) * $i.numframes + PIP.OBJSIZE + .objectSize()
	    }
	},
	$b
    )
    prop InstancePropertyPage :: (
	    "{B7240DEA-AA51-11cf-9BFE-0000C0AC14C8}"
    )
    
    prop GlobalPropertyPage :: (
	    "{B7240DEB-AA51-11cf-9BFE-0000C0AC14C8}"
    )
    prop localCreate :: (
	PIP.gNumEmbed += 1,
	if (.gNumOf == 0) {
	    (LNK_dataPump.Create("HST"))
	},
     	"ok"
    )
    prop localDelete :: (
	PIP.gNumEmbed -= 1,
	$b = 0,			 
	scan ($i; HST) {
	    if ($i != self) {
	        if($i.IsConfObj()) {
	            if($i.framesize > $b) {
	                $b = $i.framesize 
	            } 
	        }
	    }
        },
	.MAXFRAMESET = $b,
	if (.gNumOf == 1) {
	    (LNK_dataPump.Delete("HST"))
	},
	"ok"
    )
    prop GenLinkPrologue :: (
        if (.LNKTYPE == "RTDX") {
            "_LNK_dspFrameReadyMask = LNK_dspFrameReadyMask; \n_LNK_dspFrameRequestMask = LNK_dspFrameRequestMask; \n_LNK_readDone = LNK_readDone; \n_LNK_readFail = LNK_readFail; \n_LNK_readPend = LNK_readPend; \n_LNK_writeFail = LNK_writeFail;"
        }
    )
    prop AllocType :: (
	"2\0, _globalAllocDesc, _memSeg, _placement, 	      _dsmAllocDesc, _dsmMemSeg, _placement"
    )
    
 
    prop _globalAllocDesc :: (
	"%8t .%1L: RUN_START(%1U_A_TABBEG), RUN_START(_%1U_A_TABBEG), RUN_END(%1U_A_TABEND), RUN_END(_%1U_A_TABEND) {%8t\n }\0, name"
    )
    prop objectSize :: (
	if (GBL.DSPTYPE == 28) {
	    $a = (14 * 4)
        }, 
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {
	    $a = (12 * 4)
	},
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {
	    $a = (12 * 4)
	},
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
	    $a = (10 * 4)
	},
	if (GBL.DSPTYPE == 54 || GBL.DSPTYPE == 62) {
	    $a = (7 * 4)
	},
	$a
    )
    prop _dsmAllocDesc :: (
	"%8t .dsm: {}"
    )
    prop _placement :: (0x7fffffff / 2)
    prop AllocInst :: (
	"1\0, _instAllocDesc, _objMemSeg, _placement"
    )
    prop _instAllocDesc :: (RTDX.RTDXTYPE == "Simulator" ?
	"/* %0s buffer */\n.hst%2d: align = 0x40 { . += 0x80; *(.hst%2d) } \0, name, _objId" :
	"/* %0s buffer */\n.hst%2d: %3S\0, name, _objId, _alignString, _objAlign"
    )
    prop _alignString :: .bufalign > 1 ? "align = 0x%4x {}" : ""
    prop _objId :: .iId
    prop _objAlign :: .bufalign
    prop _objMemSeg :: .bufseg
    prop _linkString :: (.gNumOf + .gNumEmbed) > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop _memSeg :: HST.OBJMEMSEG
    prop _dsmMemSeg :: HST.DSMBUFSEG
    prop _objSize :: GBL.DSPTYPE == 55 ? (2 * .objectSize()) : .objectSize()
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "hst.h" : ""
    
 
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far HST_Obj %0r;\n\0"
	}
	else {
	    "extern HST_Obj %0r;\n\0"
        }
    )
    prop modifiable :: (
	(.iDelUser == "USER" ? 1 : 0)
    )
    global gNumEmbed :: 0 {      
        prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global LNKTYPE :: (
		if (2 == 0) {
		     "RTDX"
		}
		else {
		    if (2 == 1) {
			"Shared Memory"
		    }
		    else {
		        if (2 == 3) {
			    "EVM54"
		        }
		        else {
			    "NONE"
		        }
		    }
		} ) {
        prop Label :: "Host Link Type"
	prop JSName :: "HOSTLINKTYPE"
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "RTDX,NONE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (
	    if ($1 == "RTDX") {
		if (RTDX.USERTDX == 0) {
		    .error("RTDX module must be enabled before it can be used by HST")
		}
		else {
                    if ((RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 2 < .MAXFRAMESET) {
                        .error("RTDX buffer size too small for largest configured HST channel")
                    }
                    else {
			if (.LNKTYPE == "NONE") {
                    	    GlobalStatus.gDirty = 1,
                            .LNKTYPE = $1,
	    		    $b = 0,
	    		    scan ($i; HST) {
	        	        if($i.IsConfObj()) {
	             		    if($i.framesize > $b) {
	                 	        $b = $i.framesize 
	             	    	    } 
	         	        }
            		    },
			    .MAXFRAMESET = $b,
    			    .MAXFRAMEALLOWED = (RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 3, 
                            "ok"
			}
			else {
                            .LNKTYPE = $1,
    			    .MAXFRAMEALLOWED = (RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 3, 
                            "ok"
			}
                    }
		}
	    }
	    else {
		if ($1 == "Shared Memory") {
                    if ((.DSMMEMSIZE/4) < .MAXFRAMESET) {
                        .error("Shared memory buffer too small for largest configured HST channel")
                    }
                    else {
			if (.LNKTYPE == "NONE") {
                    	    GlobalStatus.gDirty = 1,
                            .LNKTYPE = $1,
	    		    $b = 0,
	    		    scan ($i; HST) {
	        	        if ($i.IsConfObj()) {
	             		    if($i.framesize > $b) {
	                 	        $b = $i.framesize 
	             	    	    } 
	         	        }
            		    },
			    .MAXFRAMESET = $b,
    			    .MAXFRAMEALLOWED  = .DSMMEMSIZE/4,
                            "ok"
			}
			else {
                            .LNKTYPE = $1,
    			    .MAXFRAMEALLOWED  = .DSMMEMSIZE/4,
                            "ok"
			}
                    }
		}
		else {
                    GlobalStatus.gDirty = 1,
                    .LNKTYPE = $1,
                    "ok"
		}
            }
        )
    }
    global RTDX ::= .LNKTYPE == "RTDX" ? 1 : 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use RTDX for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global DSM ::= .LNKTYPE == "Shared Memory" ? 1 : 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Shared Memory for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global EVM54 ::= .LNKTYPE == "EVM54" ? 1 : 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use EVM54's I/O ports for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global NONE ::= .LNKTYPE == "NONE" ? 1 : 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "No host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global MAXFRAMESET ::= (
	    $b = 0,		 
	    scan ($i; HST) {
	        if($i.IsConfObj()) {
	             if($i.framesize > $b) {
	                 $b = $i.framesize 
	             } 
	         }
            }
	) {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAXFRAMESET"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global MAXFRAMEALLOWED ::= .RTDX == 1 ? (RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 3 : .DSMMEMSIZE /4 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAXFRAMEALLOWED"
        prop Visible :: 0 	
        prop Writable :: 1
        prop NoGen :: 0
    }
    global DSMBUFSEG ::= .OBJMEMSEG {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Shared Memory Segment"
        prop Visible :: 0			
        prop Writable :: .DSM 
        prop NoGen :: 0
    }
 
    global DSMMEMSIZE ::= 1024 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop Label :: "Shared Memory Frame Size (MAUs)"
        prop Visible :: 0
        prop Writable :: .DSM
        prop NoGen :: 0
        prop Set :: (
            if ($1 < HST.MAXFRAMESET *4) {
                .error("size (in MAUs) must be at least: 4 * largest configured HST channel framesize (in words)")
            }
            else {
                .DSMMEMSIZE = $1,
                GlobalStatus.gDirty = 1,     
	        if (.LNKTYPE == "Shared Memory") {
	            .MAXFRAMEALLOWED  = .DSMMEMSIZE/4,
                    "ok"
		}
		else {
		    "ok"
		}
            }
        )
    }
    inst mode :: "output" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "mode"
	prop Enum :: "input,output"
	prop Visible :: 1
	prop Writable :: .modifiable()
	prop NoGen :: 0
    }
    inst bufseg ::= .OBJMEMSEG {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "bufseg"
	prop JSName :: "bufSeg"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataNullMember($1)
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst bufalign :: 4 { 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "bufAlign"
	prop Visible :: 1
	prop Writable :: .modifiable()
	prop NoGen :: 1
	prop Set :: (	         
	    if ($1 < 4) {		 
	        .error("Alignment must be greater than or equal to 4")
	    }
	    else {
		if (($1 % 2) != 0) {  	 
	            .error("Alignment must be a power of 2")
		}
		else {
		    $i = $1,	 
		    while ((($i % 2) == 0) && ($i != 2)) {
		        $i = $i / 2
		    },
		    if(($i % 2) != 0) {	 
	                .error("Alignment must be a power of 2")
		    }
		    else {	     	 
		        .bufalign = $1,
	  	        "ok"
		    }
		}
	    }
	)
    }
    inst buf :: "<NULL>" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst framesize :: 0x80 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "framesize (words)"
	prop JSName :: "frameSize"
	prop Style :: 0x01 | 0x02
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    if ($1 < 1) {
		.error("framesize must be >= 1.")
	    }
	    else {
		if (($1 > .MAXFRAMEALLOWED) && ((.RTDX == 1) || (.DSM == 1)) ) {
		    if (.RTDX == 1) {
		        .error("size (in words) is limited to: (RTDX buffer size in MAUs) / (MAUs per word) - 3")
		    }
		    else {
		            .error("size (in words) is limited to: shared memory frame size (in MAUs)/4")
		    }
		}
		else {
		    .framesize = $1,		 
		    $b = 0,			 
		    scan ($i; HST) {
	        	if($i.IsConfObj()) {
	            	    if($i.framesize > $b) {
	                	$b = $i.framesize 
	            	    } 
	        	}
        	    },
		    .MAXFRAMESET = $b,		 
	  	    GlobalStatus.gDirty = 1,	 
		    "ok"
		}
	    }
	)
    }
    inst numframes :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01
	prop JSName :: "numFrames"
	prop Visible :: 1
	prop Writable :: .modifiable()
	prop NoGen :: 0
	prop Set :: (
	    if ($1 < 1) {
		.error("Channels must contain at least 1 frame.")
	    }
	    else {
		GlobalStatus.gDirty = 1,
		.numframes = $1,
		"ok"
	    }
	)
    }
    inst stsflg :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "statistics"
	prop JSName :: "statistics"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst notify :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyFxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "DHL" || .iDelUser != "USER" ? 0 : 1)
	prop NoGen :: 0
	prop TabName :: "Notify Function"
    }
    inst arg0 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg0"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "DHL" || .iDelUser != "USER" ? 0 : 1)
	prop NoGen :: 0
	prop TabName :: "Notify Function"
    }
    inst arg1 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg1"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "DHL" || .iDelUser != "USER" ? 0 : 1)
	prop NoGen :: 0
	prop TabName :: "Notify Function"
    }
    
 
    inst lnk ::= .RTDX ? "RTDX" : "NOTRTDX" {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "link type"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst iDHLAvailable :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Make this channel available for a new DHL device"
	prop JSName :: "availableForDHL"
        prop Set :: (
	    if (($1 == 0) && (.iDHLAvailable == 1)) {
		DHL.gChannelsAvailable--
	    }
	    else {
		if (($1 == 1) && (.iDHLAvailable == 0)) {
		    DHL.gChannelsAvailable++
		}
	    },
	    .iDHLAvailable = $1,
	    "ok"
	)
	prop Writable :: .modifiable()
        prop Visible :: 1
	prop NoGen :: 1
    }
    
    inst bufFrameAlign ::= .bufalign  { 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
}
object LNK_dataPump :: IDL {
    param function :: @LNK_F_dataPump
    param cycles :: 0			 
    param iDelUser :: "HST"
    param iDelMsg  :: (
	"This object cannot be deleted"
    )
}
object RTA_dispatcher :: IDL {
    param function :: @RTA_F_dispatch
    param cycles :: 0			 
    param iDelUser :: "HST"
    param iDelMsg  :: (
	"This object cannot be deleted"
    )
}
object RTA_fromHost :: HST {
    param iComment  :: (
	"Used to access LOG and STS data"
    )
    param mode :: "input"
    param framesize :: 4 
    param numframes :: 1 
    param iDelUser :: "HST"
    param iDelMsg  :: (
	"This object cannot be deleted"
    )
    param iDHLAvailable :: 0 
} 
object RTA_toHost :: HST {
    param iComment  :: (
	"Used to access LOG and STS data"
    )
    param mode :: "output"
    param framesize :: 64 
    param numframes :: 1 
    param iDelUser :: "HST"
    param iDelMsg  :: (
	"This object cannot be deleted"
    )
    param iDHLAvailable :: 0
}
 
 
type HWI {
    isa  ObjectMgr
    prop name :: "HWI"
    prop Label :: "HWI - Hardware Interrupt Service Routine Manager"
    prop IsContainedIn :: SCH
    prop SortChildHierView :: 0
    prop GlobalIcon :: 109
    prop InstanceIcon :: 110
    prop InstanceHelpTopic :: (
        205
    )
    
    prop GlobalHelpTopic :: (
        105
    )
    prop dataSize :: (
         0 * HWI.gNumOf
    )
    prop localCanCreate :: (
        .error("New hardware interrupt objects cannot be created")
    )
    prop InstancePropertyPage :: (
            "{B7240DE6-AA51-11cf-9BFE-0000C0AC14C7}"
    )
   
    prop GlobalPropertyPage :: (
            "{B7240DE7-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    prop DependsOn :: "GBL,OBJ,BUF,CLK,IDL,LCK,LOG,MBX,MEM,PIP,POOL,PRD,QUE,RTDX,SEM,STS,SYS"
   prop AllocType :: (.ZEROTAB ?
        "1\0,   _stubsAllocDesc,        _memSeg,        _placement"
        :
        if ((MEM.ENABLELOADSEG) && (MEM.VECMEMSEG != MEM.LOADVECMEMSEG)) {
            "2\0,       _stubsAllocDesc,        _memSeg,        _placement,
                        _vectAllocDesc,         _loadvecSeg,    _minplace"
        }
        else {
            "2\0,       _stubsAllocDesc,        _memSeg,        _placement,
                        _vectAllocDesc,         _vecSeg,        _minplace"
        }
    )
    prop _stubsAllocDesc :: (
        if ((MEM.ENABLELOADSEG) && (MEM.STUBMEMSEG != MEM.LOADSTUBMEMSEG)) {
            "%8t .%1L: {} load > %2s, run\0, name, _loadstubSeg"
        }
        else {
            "%8t .%1L: {} \0, name"
        }
    )
    prop _vectAllocDesc :: (
        if ((MEM.ENABLELOADSEG) && (MEM.VECMEMSEG != MEM.LOADVECMEMSEG)) {
            "%8t .%1L_vec: {%12t\n *(.hwi_vec)%8t\n } run > %2s align = 0x400, RUN_START(%1U_A_VECS), load \0, name, _vecSeg"
        }
        else {
            "%8t .%1L_vec: {%12t\n *(.hwi_vec)%8t\n } align = 0x400, RUN_START(%1U_A_VECS)\0, name"
        }
            
    )
    prop _placement :: (0x7fffffff / 2)
    prop _minplace  :: 0
    prop GenLinkPrologue :: (.ZEROTAB ?
        if ((MEM.ENABLELOADSEG) && (MEM.VECMEMSEG != MEM.LOADVECMEMSEG)) {
         "SECTIONS {%4t\n .%1L_vec: {%8t\n %1U_A_VECS = .;\n *(.hwi_vec)%4t\n }  load >  %2s, run = 0x0 %0t\n}\n\0 , name, _loadvecSeg"
        }
        else {
        "SECTIONS {%4t\n .%1L_vec: 0x0 {%8t\n %1U_A_VECS = .;\n *(.hwi_vec)%4t\n }%0t\n}\n\0, name"
        }
         :.GENERATE_RESET_VEC ?
         "SECTIONS {%4t\n .%1L_reset: 0x%2x {}%0t\n}\n\0, name, resetvector" :
         ""
    )
    prop resetvector :: (
	.RESETVECTORADDR
    )
    prop GenLinkEpilogue :: (
        "%0t_HWI_CFGDISPATCHED = HWI_CFGDISPATCHED;\n\0"
    )
    prop localInit :: (
        if (RTDX.CALLBACKOBJ != nil) {
            .error("HWI initialization failure.")
        },
        CLK.setInterruptNumber(CLK.WHICHTIMER),
        CLK.WHICHHWI.iReMappable = 0,
        RTDX.CALLBACKOBJ = HWI
    )
    prop enableLoadStubs :: (
        HWI_INT4.iLoadTrack = 1,
        HWI_INT5.iLoadTrack = 1,
        HWI_INT6.iLoadTrack = 1,
        HWI_INT7.iLoadTrack = 1,
        HWI_INT8.iLoadTrack = 1,
        HWI_INT9.iLoadTrack = 1,
        HWI_INT10.iLoadTrack = 1,
        HWI_INT11.iLoadTrack = 1,
        HWI_INT12.iLoadTrack = 1,
        HWI_INT13.iLoadTrack = 1,
        HWI_INT14.iLoadTrack = 1,
        HWI_INT15.iLoadTrack = 1
    )
    prop disableLoadStubs :: (
        HWI_INT4.iLoadTrack = 0,
        HWI_INT5.iLoadTrack = 0,
        HWI_INT6.iLoadTrack = 0,
        HWI_INT7.iLoadTrack = 0,
        HWI_INT8.iLoadTrack = 0,
        HWI_INT9.iLoadTrack = 0,
        HWI_INT10.iLoadTrack = 0,
        HWI_INT11.iLoadTrack = 0,
        HWI_INT12.iLoadTrack = 0,
        HWI_INT13.iLoadTrack = 0,
        HWI_INT14.iLoadTrack = 0,
        HWI_INT15.iLoadTrack = 0
    )
    prop call :: (
        if ( RTDX.USERTDX == 0 ) {
            HWI_RESERVED1.function = @HWI_unused,
            HWI_RESERVED1.iUseDispatcher = 0,
            HWI_INT11.iReMappable = 1,
            HWI_INT11.function = @HWI_unused,
            HWI_INT11.iUseDispatcher = 0,
            HWI_INT11.iIntrMask = "self",
            HWI_INT11.client = "USER",
            HWI_INT12.iReMappable = 1,
            HWI_INT12.function = @HWI_unused,
            HWI_INT12.iUseDispatcher = 0,
            HWI_INT12.iIntrMask = "self",
            HWI_INT12.client = "USER"
        }
        else {
            HWI_RESERVED1.function = @_RTDX_Poll,
            HWI_RESERVED1.iUseDispatcher = 1,
            if ( RTDX.RTDXTYPE == "HSRTDX" ) {
                HWI_INT11.iEventId = 11,
                HWI_INT11.iReMappable = 0,
                HWI_INT11.function = @_HSRTDX_xmt,
                HWI_INT11.iUseDispatcher = 1,
                HWI_INT11.iIntrMask = "bitmask",
                HWI_INT11.IntrMask = 0x1808,
                HWI_INT11.client = "RTDX",
                HWI_INT12.iEventId = 12,
                HWI_INT12.iReMappable = 0,
                HWI_INT12.function = @_HSRTDX_rec,
                HWI_INT12.iUseDispatcher = 1,
                HWI_INT12.iIntrMask = "bitmask",
                HWI_INT12.IntrMask = 0x1808,
                HWI_INT12.client = "RTDX"
            }
            else {
                if ( RTDX.RTDXTYPE == "JTAG" ) {
                    HWI_INT11.iEventId = 11,
                    HWI_INT11.iReMappable = 0,
                    HWI_INT11.function = @_HSRTDX_xmt,
                    HWI_INT11.iUseDispatcher = 1,
                    HWI_INT11.iIntrMask = "bitmask",
                    HWI_INT11.IntrMask = 0x1808,
                    HWI_INT11.client = "RTDX",
                    HWI_INT12.iEventId = 12,
                    HWI_INT12.iReMappable = 0,
                    HWI_INT12.function = @_HSRTDX_rec,
                    HWI_INT12.iUseDispatcher = 1,
                    HWI_INT12.iIntrMask = "bitmask",
                    HWI_INT12.IntrMask = 0x1808,
                    HWI_INT12.client = "RTDX"
                }
                else {
                    HWI_INT11.iReMappable = 1,
                    HWI_INT11.function = @HWI_unused,
                    HWI_INT11.iUseDispatcher = 0,
                    HWI_INT11.iIntrMask = "self",
                    HWI_INT11.client = "USER",
                    HWI_INT12.iReMappable = 1,
                    HWI_INT12.function = @HWI_unused,
                    HWI_INT12.iUseDispatcher = 0,
                    HWI_INT12.iIntrMask = "self",
                    HWI_INT12.client = "USER"
                }
            }
        }
    )
    prop _memSeg :: MEM.STUBMEMSEG
    prop _loadstubSeg :: MEM.LOADSTUBMEMSEG
    prop _linkString :: (
        $b = 0,
        scan ($a; HWI) {
            if ($a.monitor != "Nothing") {
                $b = 1
            }
        },
        if ($b == 1) {
            "*(.hwi)"
        }
        else {
            "/* no HWI stubs are necessary */"
        }
    )
    
    prop name2addr :: (
        $i = 0,
        $b = nil,
        scan ($a; { "Nothing","Data Value","Stack Pointer","Top of SW Stack", "A0","A1","A2","A3","A4","A5","A6","A7","A8","A9","A10", "A11","A12","A13","A14","A15", "B0","B1","B2","B3","B4","B5","B6","B7","B8","B9","B10", "B11","B12","B13","B14","B15"}) {             
            if ($b == nil) {             
                if ($a == $1) {          
                    $b = {0, 0, 0, @GBL_stackbeg,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}[$i]     
                },
                $i++
            }
        },
        if ($b == nil) {                 
            $b = 0                       
        },
        $b
    )
    
    prop name2type :: (
        $i = 0,
        $b = nil,
        scan ($a; { "Nothing","Data Value","Stack Pointer","Top of SW Stack", "A0","A1","A2","A3","A4","A5","A6","A7","A8","A9","A10", "A11","A12","A13","A14","A15", "B0","B1","B2","B3","B4","B5","B6","B7","B8","B9","B10", "B11","B12","B13","B14","B15"}) {             
            if ($b == nil) {             
                if ($a == $1) {          
                    if ($i < 5) {
                        $b = {"unsigned", "signed", "unsigned", "unsigned", "unsigned"}[$i]  
                    }
                },
                $i++
            }
        },
        if ($b == nil) {                 
            $b = "unsigned"              
        },
        $b
    )
    
    global STUBMEMSEG :: IRAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Function Stub Memory"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    
 
    global ZEROTAB ::= (6499 == 6499 || 6499 == 6747 || 6499 == 6748)
                   	? 0 : .VECMEMSEG.base == .RESETVECTORADDR {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Writable :: 0
        prop Visible :: 0
    }
    prop _vecSeg :: MEM.VECMEMSEG
    prop _loadvecSeg :: MEM.LOADVECMEMSEG
    global VECMEMSEG :: IRAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop Label :: "Interrupt Service Table Memory"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop MemberTest :: MEM.codeMember($1)
        prop Set :: (
                .VECMEMSEG = $1,
                if ($1.base == 0) {
                        .GENERATE_RESET_VEC = 0
                },
                "ok"
        )
    }
    global GENERATE_RESET_VEC :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Generate RESET vector"
        prop JSName :: "RESETVECTOR"
        prop Writable :: .ZEROTAB == 0
        prop Visible :: 1
        prop NoGen :: 0
    }
    global RESETVECTORADDR :: (6499 == 6499 ||
    			       6499 == 6747 ||
                               6499 == 6748) ? 0x00800000 : 0 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "RESET vector address"
        prop JSName :: "RESETVECTORADDR"
        prop Format :: "0x%08x"
        prop Style :: 0x02
        prop Writable :: .GENERATE_RESET_VEC
        prop Visible :: 1
        prop NoGen :: 1
    }
    global EXT4_POLARITY :: "low-to-high" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "low-to-high,high-to-low"
        prop Label :: "External Interrupt Pin 4 Polarity"
        prop JSName :: "EXTPIN4POLARITY"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXT5_POLARITY :: "low-to-high" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "low-to-high,high-to-low"
        prop Label :: "External Interrupt Pin 5 Polarity"
        prop JSName :: "EXTPIN5POLARITY"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXT6_POLARITY :: "low-to-high" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "low-to-high,high-to-low"
        prop Label :: "External Interrupt Pin 6 Polarity"
        prop JSName :: "EXTPIN6POLARITY"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXT7_POLARITY :: "low-to-high" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "low-to-high,high-to-low"
        prop Label :: "External Interrupt Pin 7 Polarity"
        prop JSName :: "EXTPIN7POLARITY"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global POLARITYMASK ::=
        (.EXT4_POLARITY == "high-to-low" ? 1 : 0) | (.EXT5_POLARITY == "high-to-low" ? 1 : 0) << 1 | (.EXT6_POLARITY == "high-to-low" ? 1 : 0) << 2 | (.EXT7_POLARITY == "high-to-low" ? 1 : 0) << 3 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    
    global INTRMUX1 ::=
        (HWI_INT4.iEventId) | (HWI_INT5.iEventId << 8) | (HWI_INT6.iEventId << 16) | (HWI_INT7.iEventId << 24) {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Writable :: 0
        prop Visible :: 0
        prop NoGen :: 0
    }
    global INTRMUX2 ::=
        (HWI_INT8.iEventId) | (HWI_INT9.iEventId << 8) | (HWI_INT10.iEventId << 16) | (HWI_INT11.iEventId << 24) {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Writable :: 0
        prop Visible :: 0
        prop NoGen :: 0
    }
    
    global INTRMUX3 ::=
        (HWI_INT12.iEventId) | (HWI_INT13.iEventId << 8) | (HWI_INT14.iEventId << 16) | (HWI_INT15.iEventId << 24) {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Writable :: 0
        prop Visible :: 0
        prop NoGen :: 0
    }
    global ENABLE_EXC :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable EXC module exception processing"
        prop JSName :: "ENABLEEXC"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (
            if ($1 == 1) {
                .ENABLE_EXC = 1,
                HWI_NMI.function = @_EXC_dispatch
            }
            else {
                .ENABLE_EXC = 0,
                HWI_NMI.function = @HWI_unused
            },
            "ok"
        )
    }
    global CFGDISPATCHED ::= (
                                 .HWIR0_DISP |
                                 .HWIR1_DISP |
                                 .HWI4_DISP |
                                 .HWI5_DISP |
                                 .HWI6_DISP |
                                 .HWI7_DISP |
                                 .HWI8_DISP |
                                 .HWI9_DISP |
                                 .HWI10_DISP |
                                 .HWI11_DISP |
                                 .HWI12_DISP |
                                 .HWI13_DISP |
                                 .HWI14_DISP |
                                 .HWI15_DISP
                             ) {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "dispatched mask"
        prop Style :: 0x02
        prop Writable :: 1
        prop Visible :: 0
        prop NoGen :: 0
    }
    prop HWIR0_DISP :: ((HWI_RESERVED0.iUseDispatcher == 1) ? 0x4 : 0)
    prop HWIR1_DISP :: ((HWI_RESERVED1.iUseDispatcher == 1) ? 0x8 : 0)
    prop HWI4_DISP  :: ((HWI_INT4.iUseDispatcher == 1)      ? 0x10 : 0)
    prop HWI5_DISP  :: ((HWI_INT5.iUseDispatcher == 1)      ? 0x20 : 0)
    prop HWI6_DISP  :: ((HWI_INT6.iUseDispatcher == 1)      ? 0x40 : 0)
    prop HWI7_DISP  :: ((HWI_INT7.iUseDispatcher == 1)      ? 0x80 : 0)
    prop HWI8_DISP  :: ((HWI_INT8.iUseDispatcher == 1)      ? 0x100 : 0)
    prop HWI9_DISP  :: ((HWI_INT9.iUseDispatcher == 1)      ? 0x200 : 0)
    prop HWI10_DISP :: ((HWI_INT10.iUseDispatcher == 1)     ? 0x400 : 0)
    prop HWI11_DISP :: ((HWI_INT11.iUseDispatcher == 1)     ? 0x800 : 0)
    prop HWI12_DISP :: ((HWI_INT12.iUseDispatcher == 1)     ? 0x1000 : 0)
    prop HWI13_DISP :: ((HWI_INT13.iUseDispatcher == 1)     ? 0x2000 : 0)
    prop HWI14_DISP :: ((HWI_INT14.iUseDispatcher == 1)     ? 0x4000 : 0)
    prop HWI15_DISP :: ((HWI_INT15.iUseDispatcher == 1)     ? 0x8000 : 0)
    inst iSource :: Reset {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: ISRC
        prop MemberTest :: 1
        prop Label :: "interrupt source"
        prop JSName :: "interruptSource"
        prop Visible :: (GBL.CLKTYPE == 700) ? 0 :
            (GBL.DSPSUBTYPE == 6499 || GBL.DSPSUBTYPE == 6747 || GBL.DSPSUBTYPE == 6748) ? 0 : 1
        prop Writable :: (GBL.CLKTYPE == 700) ? 0 : .iReMappable
        prop NoGen :: 1
        prop Set :: (
            $a = $1,
            if ($a == Reset) {
                .error ("The Reset interrupt source cannot be remapped")
            }
            else {
                if ($a == Non_Maskable) {
                    .error ("The Non-Maskable interrupt source cannot be remapped")
                }
                else {
                    if ($a == Reserved) {
                        .error ("The Reserved interrupt source cannot be remapped")
                    }
                    else {
                        
 
                        if (CLK.WHICHHWI == self && $a != .iSource && CLK.USETIMER) {
                           .error ("This interrupt is in use by CLK, settings may be changed in the CLK Manager")
                        }
                        else {
                            
 
                            if ($a == CLK.WHICHHWI.iSource && CLK.USETIMER == 1) {
                                .error ("Interrupt source is in use by CLK, settings may be changed in the CLK Manager.")
                            }
                            else {
                                
 
                                $a.iHwi = self,
                                
 
                                .iSource.iHwi = HWI_UNUSED,
                                .iSource = $1,
                                .iEventId = .iSource.iIntrSelectNum,
                                "ok"
                            }
                        }
                    }
                }
            }
        )
    }
    inst iEventId ::= .iSource.iIntrSelectNum {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "interrupt selection number"
        prop JSName :: "interruptSelectNumber"
        prop Style :: 0x02
        prop Visible :: (GBL.CLKTYPE == 700)? 0:1
        prop Writable :: (GBL.CLKTYPE == 700)? 0:.iReMappable
        prop NoGen  :: 1
        prop Set :: (
            if ($1 == 0 || $1 == 1  || $1 == 2 || $1 == 3) {
                .function = @_ECM_dispatch,
                .iUseDispatcher = 1,
                .iArg = $1
            }
            else {
                if (.function == @_ECM_dispatch) {
                    .iArg = 0x0,
                    if (.iUseDispatcher == 1) {
                        .iUseDispatcher = 0
                    },
                    .function = @HWI_unused
                }
            },
            .iEventId = $1,
            "ok"
        )
    }
    inst iReMappable :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iIntrEnableMask :: 0 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen  :: 1
    }
    inst function :: @HWI_unused {
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: (( .function == @RESERVED ) ||
                ( .client != "USER" )) ? 0 : 1
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
        prop Set :: (
                .function = $1,
                GlobalStatus.gDirty = 1,
                "ok"
        )
    }
    inst iSTSObj :: HWI_RESETSTS {
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    
    inst monitor :: "Nothing" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Nothing,Data Value,Stack Pointer,Top of SW Stack,A0,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14,A15,B0,B1,B2,B3,B4,B5,B6,B7,B8,B9,B10,B11,B12,B13,B14,B15"
        prop JSName :: "monitor"
        prop Visible :: 1
        prop Writable :: ((.function != @HWI_unused && .function != @RESERVED) && (.iId != 0))
        prop NoGen :: 0
        prop Set :: (
            if ($1 != .monitor) {        
                $e = "ok",
                if ($1 == "Nothing") {
                    if (($e = .iSTSObj.Delete("HWI")) == "ok") {
                        .monitor = "Nothing",
                        .addr = .name2addr(.monitor),
                        .dataType = .name2type(.monitor)
                    }
                }
                else {
                    if (.iSTSObj.iIsUsed || ($e = .iSTSObj.Create("HWI")) == "ok") {
                        .monitor = $1,
                        if (.monitor == "Data Value") {
                            .addr = .saveAddr,
                            .dataType = .saveType
                        }
                        else {
                            .addr = .name2addr(.monitor),
                            .dataType = .name2type(.monitor)
                        }
                    }
                    else {
                        .monitor = "Nothing"
                    }
                },
                $e
            }
            else {
                "ok"
            }
        )
    }
    inst saveAddr :: 0 {
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    
    inst saveType :: "signed" {
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    
    inst addr :: 0 {
        prop JSName :: "addr"
        prop Visible :: 1
        prop Writable :: (.monitor == "Data Value" ? 1 : 0)
        prop NoGen :: 0
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Format :: GBL.DSPTYPE == 62 ? "0x%08x" : "0x%04x"
        prop Set :: (
            .addr = $1,
            .saveAddr = $1,
            "ok"
        )
    }
    inst dataType :: "signed" {
        prop Visible :: 1
        prop Writable :: (.monitor == "Nothing" ? 0 : 1)
        prop NoGen :: 0
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "signed,unsigned"
        prop Label :: "type"
        prop JSName :: "dataType"
        prop Set :: (
            if (.monitor != "Nothing") {
                .dataType = $1,
                .saveType = $1,
                "ok"
            }
            else {
                .error("The monitor field must set to modify this field")
            }
        )
    }
    inst operation :: "STS_add(*addr)" {
        prop Visible :: 1
        prop Writable :: (.monitor == "Nothing" ? 0 : 1)
        prop NoGen :: 0
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "operation"
        prop Enum :: "STS_add(*addr),STS_delta(*addr),STS_add(-*addr),STS_delta(-*addr),STS_add(|*addr|),STS_delta(|*addr|)"
        prop Set :: (
            if (.monitor != "Nothing") {
                .operation = $1,
                "ok"
            }
            else {
                .error("The monitor field must set to modify this field")
            }
        )
    }
    inst client :: "USER" {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iUseDispatcher :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Dispatcher"
        prop JSName :: "useDispatcher"
        prop Visible :: 1
        prop Writable :: ( .client == "USER" ) ? 1 : 0
        prop NoGen :: 0
        prop TabName :: "Dispatcher"
        prop Set :: (
                if (($1 == 1) && (self == HWI_NMI)){
                    .error ("HWI dispatcher can't be used for  NMI")
                }
                else{
                    .iUseDispatcher = $1,
                    "ok"
                }
        )
    }
    inst iArg :: 0 {
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Arg"
        prop JSName :: "arg"
        prop Visible :: 1
        prop Writable :: (( .iUseDispatcher == 1 ) && ( .client == "USER" )) ? 1 : 0
        prop NoGen :: 0
        prop TabName :: "Dispatcher"
        prop Set :: (
            .iArg = $1,
            "ok"
        )
    }
    inst iIntrMask :: "self" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Interrupt Mask"
        prop JSName :: "interruptMask"
        prop Enum :: "all,none,self,bitmask"
        prop Visible :: 1
        prop Writable :: ( .iUseDispatcher == 1 ) ? 1 : 0
        prop NoGen :: 1
        prop TabName :: "Dispatcher"
        prop Set :: (
            if ( $1 == "all" ) {
                .IntrMask = 0xffff
            }
            else {
                if ( $1 == "self" ) {
                    .IntrMask = 1 << .iId
                }
                else {
                    if ( $1 == "none" ) {
                        .IntrMask = 0
                    }
                }
            },
            .iIntrMask = $1,
            "ok"
        )
    }
        
    inst IntrMask :: ( 1 << .iId)  {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x02
        prop Label :: "Interrupt Bit Mask"
        prop JSName :: "interruptBitMask"
        prop Visible :: 1
        prop Writable :: ((.iUseDispatcher == 1) && (.iIntrMask == "bitmask" )) ? 1 : 0
        prop NoGen :: 0
        prop TabName :: "Dispatcher"
        prop Set :: (
            if ( $1 > 0xffff) {
                .error("Invalid Number")
            }
            else {
                .IntrMask = $1,
                "ok"
            }
        )
    }
    inst iCacheControl :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Don't modify cache control"
        prop JSName :: "cacheControl"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "Dispatcher"
        prop Set :: (
            if ( $1 == 1 ) {
                .iCCBitMask = 0x1
            }
            else {
                .iCCBitMask = ( .iPCCBitMask | .iDCCBitMask | .iL2CCBitMask)
            }
            ,
            .iCacheControl = $1,
            "ok"
        )
    }   
    inst iPCCMask :: "cache enable" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "cache enable,cache freeze"
        prop Label :: "L1 Program Cache Control Mask"
        prop JSName :: "progCacheMask"
        prop Visible :: 0
        prop Writable ::
             ((.iUseDispatcher == 1) && (.iCacheControl == 0)) ? 1 : 0
        prop NoGen :: 1
        prop TabName :: "Dispatcher"
        prop Set :: (
            if ($1 == "cache enable") {
                .iPCCBitMask = 0x0000
            }
            else {
                if ($1 == "cache freeze") {
                    .iPCCBitMask = 0x0010
                }
            },
            .iPCCMask = $1,
            .iCCBitMask = .iPCCBitMask | .iDCCBitMask | .iL2CCBitMask,
            "ok"
        )
    }
    inst iPCCBitMask :: 0x0000 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDCCMask :: "cache enable" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "cache enable,cache freeze"
        prop Label :: "Data Cache Control Mask"
        prop JSName :: "dataCacheMask"
        prop Visible :: 0
        prop Writable ::
            ((.iUseDispatcher == 1) && (.iCacheControl == 0)) ? 1 : 0
        prop NoGen :: 1
        prop TabName :: "Dispatcher"
        prop Set :: (
            if ($1 == "cache enable") {
                .iDCCBitMask = 0x0000
            }
            else {
                if ($1 == "cache freeze") {
                    .iDCCBitMask = 0x0002
                }
            },
            .iDCCMask = $1,
            .iCCBitMask = .iPCCBitMask | .iDCCBitMask | .iL2CCBitMask,
            "ok"
        )
    }
    inst iDCCBitMask :: 0x0000 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iL2CCMask :: "cache enable" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "cache enable,cache freeze,cache bypass"
        prop Label :: "L2 Cache Control Mask"
        prop JSName :: "l2CacheMask"
        prop Visible :: 0
        prop Writable :: 
            ((.iUseDispatcher == 1) && (.iCacheControl == 0)) ? 1 : 0
        prop NoGen :: 1
        prop TabName :: "Dispatcher"
        prop Set :: (
            if ($1 == "cache enable") {
                .iL2CCBitMask = 0x0000
            }
            else {
                if ($1 == "cache freeze") {
                    .iL2CCBitMask = 0x0080
                }
                else {
                    if ($1 == "cache bypass") {
                        .iL2CCBitMask = 0x0100
                    }
                }
            },
            .iL2CCMask = $1,
            .iCCBitMask = .iPCCBitMask | .iDCCBitMask | .iL2CCBitMask,
            "ok"
        )
    }
    inst iL2CCBitMask :: 0x0000 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iCCBitMask :: 1 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iLoadTrack :: 0 {
        prop Label :: "Support CPU load tracking"
        prop JSName :: "loadTrack"
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
}
object HWI_RESET_STS :: STS {
    param iComment :: "provides statistics for the RESET ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_RESET :: HWI {
    param iComment :: "defines function for the RESET ISR"
    param iSource :: Reset
    param iId :: 0                       
    param iReMappable :: 0
    param function :: @_c_int00
    param iIsUsed :: 1
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_RESET_STS
    param iIntrEnableMask :: 1
}
object HWI_NMI_STS :: STS {
    param iComment :: "provides statistics for the NMI ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_NMI :: HWI {
    param iComment :: "defines function for the NMI ISR"
    param iSource :: Non_Maskable
    param iId :: 1                       
    param iReMappable :: 0
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_NMI_STS
    param iIntrEnableMask :: 0x2
    param function :: HWI.ENABLE_EXC == 1 ? @_EXC_dispatch : @HWI_unused
}
object HWI_RESERVED0_STS :: STS {
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_RESERVED0 :: HWI {
    param iComment :: "RESERVED for RTDX"
    param iId :: 2                       
    param iSource :: Reserved
    param iReMappable :: 0
    param function :: @RESERVED
    param client :: "RTDX"
    param iIsUsed :: 1
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_RESERVED0_STS
    param iIntrEnableMask :: 0x4
}
object HWI_RESERVED1_STS :: STS {
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_RESERVED1 :: HWI {
    param iComment :: "RESERVED for RTDX"
    param iId :: 3                       
    param iSource :: Reserved
    param iReMappable :: 0
    param function :: ( RTDX.USERTDX == 1 ) ? @_RTDX_Poll : @HWI_unused
    param client :: "RTDX"
    param iIsUsed :: 1
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_RESERVED1_STS
    param iIntrEnableMask :: 0x8
    param iUseDispatcher :: 1
}
object HWI_INT4_STS :: STS {
    param iComment :: "provides statistics for the INT4 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT4 :: HWI {
    param iComment :: "defines the INT4 Interrupt"
    param iSource :: External_Pin_4
    param function :: CLK.WHICHHWI == self ? @CLK_F_isr : @HWI_unused
    param client   :: CLK.WHICHHWI == self ? "CLK" : "USER"
    param iId :: 4                       
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT4_STS
    param iIntrEnableMask :: 0x10
}
object HWI_INT5_STS :: STS {
    param iComment :: "provides statistics for the INT5 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT5 :: HWI {
    param iComment :: "defines the INT5 Interrupt"
    param iSource :: External_Pin_5
    param function :: CLK.WHICHHWI == self ? @CLK_F_isr : @HWI_unused
    param client   :: CLK.WHICHHWI == self ? "CLK" : "USER"
    param iId :: 5                       
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT5_STS
    param iIntrEnableMask :: 0x20
}
object HWI_INT6_STS :: STS {
    param iComment :: "provides statistics for the INT6 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT6 :: HWI {
    param iComment :: "defines the INT6 Interrupt"
    param iSource :: External_Pin_6
    param function :: CLK.WHICHHWI == self ? @CLK_F_isr : @HWI_unused
    param client   :: CLK.WHICHHWI == self ? "CLK" : "USER"
    param iId :: 6                       
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT6_STS
    param iIntrEnableMask :: 0x40
}
object HWI_INT7_STS :: STS {
    param iComment :: "provides statistics for the INT7 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT7 :: HWI {
    param iComment :: "defines the INT7 Interrupt"
    param iSource :: External_Pin_7
    param function :: CLK.WHICHHWI == self ? @CLK_F_isr : @HWI_unused
    param client   :: CLK.WHICHHWI == self ? "CLK" : "USER"
    param iId :: 7                       
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT7_STS
    param iIntrEnableMask :: 0x80
}
object HWI_INT8_STS :: STS {
    param iComment :: "provides statistics for the INT8 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT8 :: HWI {
    param iComment :: "defines the INT8 Interrupt"
    param iSource :: DMA_Channel_0
    param function :: CLK.WHICHHWI == self ? @CLK_F_isr : @HWI_unused
    param client   :: CLK.WHICHHWI == self ? "CLK" : "USER"
    param iId :: 8                       
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT8_STS
    param iIntrEnableMask :: 0x100
}
object HWI_INT9_STS :: STS {
    param iComment :: "provides statistics for the INT9 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT9 :: HWI {
    param iComment :: "defines the INT9 Interrupt"
    param iSource :: DMA_Channel_1
    param function :: CLK.WHICHHWI == self ? @CLK_F_isr : @HWI_unused
    param client   :: CLK.WHICHHWI == self ? "CLK" : "USER"
    param iId :: 9                       
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT9_STS
    param iIntrEnableMask :: 0x200
}
object HWI_INT10_STS :: STS {
    param iComment :: "provides statistics for the INT10 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT10 :: HWI {
    param iComment :: "defines the INT10 Interrupt"
    param iSource :: INTSEL10
    param function :: CLK.WHICHHWI == self ? @CLK_F_isr : @HWI_unused
    param client   :: CLK.WHICHHWI == self ? "CLK" : "USER"
    param iId :: 10                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT10_STS
    param iIntrEnableMask :: 0x400
}
object HWI_INT11_STS :: STS {
    param iComment :: "provides statistics for the INT11 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT11 :: HWI {
    param iComment :: "defines the INT11 Interrupt"
    param iSource :: DMA_Channel_2
    param function :: CLK.WHICHHWI == self ? @CLK_F_isr : @HWI_unused
    param client   :: CLK.WHICHHWI == self ? "CLK" : "USER"
    param iId :: 11                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT11_STS
    param iIntrEnableMask :: 0x800
}
object HWI_INT12_STS :: STS {
    param iComment :: "provides statistics for the INT12 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT12 :: HWI {
    param iComment :: "defines the INT12 Interrupt"
    param iSource :: DMA_Channel_3
    param function :: CLK.WHICHHWI == self ? @CLK_F_isr : @HWI_unused
    param client   :: CLK.WHICHHWI == self ? "CLK" : "USER"
    param iId :: 12                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT12_STS
    param iIntrEnableMask :: 0x1000
}
object HWI_INT13_STS :: STS {
    param iComment :: "provides statistics for the INT13 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT13 :: HWI {
    param iComment :: "defines the INT13 Interrupt"
    param iSource :: INTSEL13
    param function :: CLK.WHICHHWI == self ? @CLK_F_isr : @HWI_unused
    param client   :: CLK.WHICHHWI == self ? "CLK" : "USER"
    param iId :: 13                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT13_STS
    param iIntrEnableMask :: 0x2000
}
object HWI_INT14_STS :: STS {
    param iComment :: "provides statistics for the INT14 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT14 :: HWI {
    param iComment :: "defines the INT14 Interrupt"
    param function :: CLK.WHICHHWI == self ? @CLK_F_isr : @HWI_unused
    param client   :: CLK.WHICHHWI == self ? "CLK" : "USER"
    param iSource :: Timer_0
    param iId :: 14                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT14_STS
    param iIntrEnableMask :: 0x4000
    param iUseDispatcher :: (CLK.WHICHHWI == self && CLK.HOOKFXN == @HWI_F_dispatch) ? 1 : 0
    param iArg :: (.iUseDispatcher && CLK.WHICHHWI == self) ? @CLK_A_TABBEG : 0
}
object HWI_INT15_STS :: STS {
    param iComment :: "provides statistics for the INT15 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT15 :: HWI {
    param iComment :: "defines the INT15 Interrupt"
    param function :: CLK.WHICHHWI == self ? @CLK_F_isr : @HWI_unused
    param client   :: CLK.WHICHHWI == self ? "CLK" : "USER"
    param iSource :: Timer_1
    param iId :: 15                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT15_STS
    param iIntrEnableMask :: 0x8000
    param iUseDispatcher :: CLK.WHICHHWI == self ? 1 : 0
    param iArg :: (.iUseDispatcher && CLK.WHICHHWI == self) ? @CLK_A_TABBEG : 0
}
object HWI_UNUSED :: HWI {
    param iComment :: "a dummy DSP interrupt for unused sources"
    param iId :: 16                      
    param iIsUsed :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT15_STS
    param iIntrEnableMask :: 0
}
 
type ECM {
    isa	 ObjectMgr
    prop name :: "ECM"
    prop Label :: "ECM - Event Combiner Manager"
    prop IsConfMod :: (
	.ENABLE
    )
    prop IsContainedIn :: HWI
    prop SortChildHierView :: 0
    prop GlobalIcon :: 109
    prop InstanceIcon :: 110
    prop InstanceHelpTopic :: (
	425
    )
    
    prop GlobalHelpTopic :: (
	325
    )
    prop localCanCreate :: (
	.error("Event combiner objects cannot be created")
    )
    prop localCanDelete :: (
	.error("Event combiner objects cannot be deleted")
    )
    prop InstancePropertyPage :: (
	    "{B7240DE6-AA51-11cf-9BFE-0000C0AC14C7}"
    )
   
    prop GlobalPropertyPage :: (
	    "{B7240DE7-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    global ENABLE :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable event combiner manager"
	prop JSName :: "ENABLE"
	prop Writable :: 1
	prop Visible :: 1
	prop NoGen :: 0
    }
    global EVTMASK0 ::= (
	EVENT0.used << 0 | EVENT1.used << 1 |
	EVENT2.used << 2 | EVENT3.used << 3 |
	EVENT4.used << 4 | EVENT5.used << 5 |
	EVENT6.used << 6 | EVENT7.used << 7 |
	EVENT8.used << 8 | EVENT9.used << 9 |
	EVENT10.used << 10 | EVENT11.used << 11 |
	EVENT12.used << 12 | EVENT13.used << 13 |
	EVENT14.used << 14 | EVENT15.used << 15 |
	EVENT16.used << 16 | EVENT17.used << 17 |
	EVENT18.used << 18 | EVENT19.used << 19 |
	EVENT20.used << 20 | EVENT21.used << 21 |
	EVENT22.used << 22 | EVENT23.used << 23 |
	EVENT24.used << 24 | EVENT25.used << 25 |
	EVENT26.used << 26 | EVENT27.used << 27 |
	EVENT28.used << 28 | EVENT29.used << 29 |
	EVENT30.used << 30 | EVENT31.used << 31
    ) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Writable :: 0
	prop Visible :: 0
	prop NoGen :: 0
    }
    global EVTMASK1 ::= (
	EVENT32.used << 0 | EVENT33.used << 1 |
	EVENT34.used << 2 | EVENT35.used << 3 |
	EVENT36.used << 4 | EVENT37.used << 5 |
	EVENT38.used << 6 | EVENT39.used << 7 |
	EVENT40.used << 8 | EVENT41.used << 9 |
	EVENT42.used << 10 | EVENT43.used << 11 |
	EVENT44.used << 12 | EVENT45.used << 13 |
	EVENT46.used << 14 | EVENT47.used << 15 |
	EVENT48.used << 16 | EVENT49.used << 17 |
	EVENT50.used << 18 | EVENT51.used << 19 |
	EVENT52.used << 20 | EVENT53.used << 21 |
	EVENT54.used << 22 | EVENT55.used << 23 |
	EVENT56.used << 24 | EVENT57.used << 25 |
	EVENT58.used << 26 | EVENT59.used << 27 |
	EVENT60.used << 28 | EVENT61.used << 29 |
	EVENT62.used << 30 | EVENT63.used << 31
    ) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Writable :: 0
	prop Visible :: 0
	prop NoGen :: 0
    }
    global EVTMASK2 ::= (
	EVENT64.used << 0 | EVENT65.used << 1 |
	EVENT66.used << 2 | EVENT67.used << 3 |
	EVENT68.used << 4 | EVENT69.used << 5 |
	EVENT70.used << 6 | EVENT71.used << 7 |
	EVENT72.used << 8 | EVENT73.used << 9 |
	EVENT74.used << 10 | EVENT75.used << 11 |
	EVENT76.used << 12 | EVENT77.used << 13 |
	EVENT78.used << 14 | EVENT79.used << 15 |
	EVENT80.used << 16 | EVENT81.used << 17 |
	EVENT82.used << 18 | EVENT83.used << 19 |
	EVENT84.used << 20 | EVENT85.used << 21 |
	EVENT86.used << 22 | EVENT87.used << 23 |
	EVENT88.used << 24 | EVENT89.used << 25 |
	EVENT90.used << 26 | EVENT91.used << 27 |
	EVENT92.used << 28 | EVENT93.used << 29 |
	EVENT94.used << 30 | EVENT95.used << 31
    ) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Writable :: 0
	prop Visible :: 0
	prop NoGen :: 0
    }
    global EVTMASK3 ::= (
	EVENT96.used << 0 | EVENT97.used << 1 |
	EVENT98.used << 2 | EVENT99.used << 3 |
	EVENT100.used << 4 | EVENT101.used << 5 |
	EVENT102.used << 6 | EVENT103.used << 7 |
	EVENT104.used << 8 | EVENT105.used << 9 |
	EVENT106.used << 10 | EVENT107.used << 11 |
	EVENT108.used << 12 | EVENT109.used << 13 |
	EVENT110.used << 14 | EVENT111.used << 15 |
	EVENT112.used << 16 | EVENT113.used << 17 |
	EVENT114.used << 18 | EVENT115.used << 19 |
	EVENT116.used << 20 | EVENT117.used << 21 |
	EVENT118.used << 22 | EVENT119.used << 23 |
	EVENT120.used << 24 | EVENT121.used << 25 |
	EVENT122.used << 26 | EVENT123.used << 27 |
	EVENT124.used << 28 | EVENT125.used << 29 |
	EVENT126.used << 30 | EVENT127.used << 31
    ) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Writable :: 0
	prop Visible :: 0
	prop NoGen :: 0
    }
    inst function :: @_UTL_halt {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "function"
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: .ENABLE
	prop NoGen :: 0
    }
    inst arg :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "arg"
	prop JSName :: "arg"
	prop Visible :: 1
	prop Writable :: .ENABLE
	prop NoGen :: 0
    }
    inst unmask :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "unmask event source"
	prop JSName :: "unmask"
	prop Visible :: 1
	prop Writable :: .ENABLE
	prop NoGen :: 1
    }
    inst used ::= 1 - .unmask {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
}
object EVENT0 :: ECM {
    param iId :: 0
    param function :: @_UTL_halt
    param iIsUsed :: 0
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT1 :: ECM {
    param iId :: 1
    param function :: @_UTL_halt
    param iIsUsed :: 0
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT2 :: ECM {
    param iId :: 2
    param function :: @_UTL_halt
    param iIsUsed :: 0
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT3 :: ECM {
    param iId :: 3
    param function :: @_UTL_halt
    param iIsUsed :: 0
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT4 :: ECM {
    param iId :: 4
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT5 :: ECM {
    param iId :: 5
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT6 :: ECM {
    param iId :: 6
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT7 :: ECM {
    param iId :: 7
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT8 :: ECM {
    param iId :: 8
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT9 :: ECM {
    param iId :: 9
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT10 :: ECM {
    param iId :: 10
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT11 :: ECM {
    param iId :: 11
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT12 :: ECM {
    param iId :: 12
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT13 :: ECM {
    param iId :: 13
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT14 :: ECM {
    param iId :: 14
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT15 :: ECM {
    param iId :: 15
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT16 :: ECM {
    param iId :: 16
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT17 :: ECM {
    param iId :: 17
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT18 :: ECM {
    param iId :: 18
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT19 :: ECM {
    param iId :: 19
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT20 :: ECM {
    param iId :: 20
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT21 :: ECM {
    param iId :: 21
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT22 :: ECM {
    param iId :: 22
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT23 :: ECM {
    param iId :: 23
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT24 :: ECM {
    param iId :: 24
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT25 :: ECM {
    param iId :: 25
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT26 :: ECM {
    param iId :: 26
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT27 :: ECM {
    param iId :: 27
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT28 :: ECM {
    param iId :: 28
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT29 :: ECM {
    param iId :: 29
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT30 :: ECM {
    param iId :: 30
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT31 :: ECM {
    param iId :: 31
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT32 :: ECM {
    param iId :: 32
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT33 :: ECM {
    param iId :: 33
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT34 :: ECM {
    param iId :: 34
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT35 :: ECM {
    param iId :: 35
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT36 :: ECM {
    param iId :: 36
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT37 :: ECM {
    param iId :: 37
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT38 :: ECM {
    param iId :: 38
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT39 :: ECM {
    param iId :: 39
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT40 :: ECM {
    param iId :: 40
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT41 :: ECM {
    param iId :: 41
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT42 :: ECM {
    param iId :: 42
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT43 :: ECM {
    param iId :: 43
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT44 :: ECM {
    param iId :: 44
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT45 :: ECM {
    param iId :: 45
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT46 :: ECM {
    param iId :: 46
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT47 :: ECM {
    param iId :: 47
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT48 :: ECM {
    param iId :: 48
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT49 :: ECM {
    param iId :: 49
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT50 :: ECM {
    param iId :: 50
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT51 :: ECM {
    param iId :: 51
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT52 :: ECM {
    param iId :: 52
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT53 :: ECM {
    param iId :: 53
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT54 :: ECM {
    param iId :: 54
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT55 :: ECM {
    param iId :: 55
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT56 :: ECM {
    param iId :: 56
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT57 :: ECM {
    param iId :: 57
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT58 :: ECM {
    param iId :: 58
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT59 :: ECM {
    param iId :: 59
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT60 :: ECM {
    param iId :: 60
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT61 :: ECM {
    param iId :: 61
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT62 :: ECM {
    param iId :: 62
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT63 :: ECM {
    param iId :: 63
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT64 :: ECM {
    param iId :: 64
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT65 :: ECM {
    param iId :: 65
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT66 :: ECM {
    param iId :: 66
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT67 :: ECM {
    param iId :: 67
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT68 :: ECM {
    param iId :: 68
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT69 :: ECM {
    param iId :: 69
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT70 :: ECM {
    param iId :: 70
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT71 :: ECM {
    param iId :: 71
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT72 :: ECM {
    param iId :: 72
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT73 :: ECM {
    param iId :: 73
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT74 :: ECM {
    param iId :: 74
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT75 :: ECM {
    param iId :: 75
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT76 :: ECM {
    param iId :: 76
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT77 :: ECM {
    param iId :: 77
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT78 :: ECM {
    param iId :: 78
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT79 :: ECM {
    param iId :: 79
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT80 :: ECM {
    param iId :: 80
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT81 :: ECM {
    param iId :: 81
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT82 :: ECM {
    param iId :: 82
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT83 :: ECM {
    param iId :: 83
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT84 :: ECM {
    param iId :: 84
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT85 :: ECM {
    param iId :: 85
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT86 :: ECM {
    param iId :: 86
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT87 :: ECM {
    param iId :: 87
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT88 :: ECM {
    param iId :: 88
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT89 :: ECM {
    param iId :: 89
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT90 :: ECM {
    param iId :: 90
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT91 :: ECM {
    param iId :: 91
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT92 :: ECM {
    param iId :: 92
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT93 :: ECM {
    param iId :: 93
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT94 :: ECM {
    param iId :: 94
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT95 :: ECM {
    param iId :: 95
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT96 :: ECM {
    param iId :: 96
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT97 :: ECM {
    param iId :: 97
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT98 :: ECM {
    param iId :: 98
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT99 :: ECM {
    param iId :: 99
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT100 :: ECM {
    param iId :: 100
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT101 :: ECM {
    param iId :: 101
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT102 :: ECM {
    param iId :: 102
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT103 :: ECM {
    param iId :: 103
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT104 :: ECM {
    param iId :: 104
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT105 :: ECM {
    param iId :: 105
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT106 :: ECM {
    param iId :: 106
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT107 :: ECM {
    param iId :: 107
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT108 :: ECM {
    param iId :: 108
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT109 :: ECM {
    param iId :: 109
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT110 :: ECM {
    param iId :: 110
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT111 :: ECM {
    param iId :: 111
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT112 :: ECM {
    param iId :: 112
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT113 :: ECM {
    param iId :: 113
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT114 :: ECM {
    param iId :: 114
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT115 :: ECM {
    param iId :: 115
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT116 :: ECM {
    param iId :: 116
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT117 :: ECM {
    param iId :: 117
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT118 :: ECM {
    param iId :: 118
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT119 :: ECM {
    param iId :: 119
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT120 :: ECM {
    param iId :: 120
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT121 :: ECM {
    param iId :: 121
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT122 :: ECM {
    param iId :: 122
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT123 :: ECM {
    param iId :: 123
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT124 :: ECM {
    param iId :: 124
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT125 :: ECM {
    param iId :: 125
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT126 :: ECM {
    param iId :: 126
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
object EVENT127 :: ECM {
    param iId :: 127
    param function :: @_UTL_halt
    param iIsUsed :: 1
    param iDelUser :: "ECM"
    param iDelMsg :: ("Event Combiner objects cannot be deleted")
}
 
type SWI {
    isa	ObjectMgr
    prop name :: "SWI"
    prop Label :: "SWI - Software Interrupt Manager"
    prop IsContainedIn :: SCH
    prop DependsOn :: "HWI,SIO,HST,MSGQ"
    prop GlobalIcon :: 123
    prop InstanceIcon :: 124
    prop InstanceHelpTopic :: (
	211
    )
    
    prop GlobalHelpTopic :: (
	111
    )
    
 
    prop HighTimeBased :: (
        CLK.HIRES == 1 ? 1 : 0
    )
    prop LowTimeBased :: (
        CLK.HIRES == 1 ? 0 : 1
    )
    
 
    prop uType :: (
        if (.HighTimeBased()) {
	    $a = 0
        }
        else {
	    if (.LowTimeBased()) {
	        $a = 1
	    }
	    else {
	        $a = 2
            }
        },
        $a
    )
    
 
    prop STSGetMaxFmt :: (
	if (SWI.STSUNITS == "raw") {
	    CLK.HIRES ? "%g inst" : "%g ints"
	}
	else {
	    SWI.STSUNITS == "microseconds" ? "%.1f us" : "%.2f ms"
	}
    )
    prop STSGetSumFmt :: (
	SWI.STSGetMaxFmt()
    )
    prop STSGetAvgFmt :: (
	if (SWI.STSUNITS == "raw") {
	    CLK.HIRES ? "%.2f inst" : "%.2f ints"
	}
	else {
	    SWI.STSUNITS == "microseconds" ? "%.1f us" : "%.2f ms"
	}
    )
 
    prop STSFilterMaxMult :: (
	$a = 1
    )
    prop STSFilterSumMult :: (
	SWI.STSFilterMaxMult($1)
    )
    
 
    prop GetPriority :: (
	.pri
    )
    prop objectSize :: (
	if ((GBL.DSPTYPE == 54 && GBL.FARMODE == 0) ||
		(GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL")) {
	    $a = (12 * 4)
	},
	if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
	    $a = (14 * 4)
	},
	if (GBL.DSPTYPE == 28 ||
	   (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") ||
	   (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE")) {
	    $a = (20 * 4)
	},
	if (GBL.DSPTYPE == 62) {
	    $a = (11 * 4)
	},
	$a
    )
    prop GenLinkPrologue :: (
	"SECTIONS {%4t\n.swi: RUN_START(SWI_A_TABBEG), RUN_END(SWI_A_TABEND) {%4t\n} > %1s%2s\0, memSeg, pageString"
    )
    prop GenLinkEpilogue :: (
    	"%0t}\nSWI_A_TABLEN = %1d;\n\0, numInst"
    )
    prop linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop pageString :: GBL.DSPTYPE == 62
                      ? ""
                      : (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28)
                      ? (
                          SWI.OBJMEMSEG.space() == "code"
                          ? " PAGE 0"
                          : SWI.OBJMEMSEG.space() == "data"
                            ? " PAGE 1"
                            : SWI.OBJMEMSEG.space() == "io"
                              ? " PAGE 2"
                              : " PAGE 0"
                        )
                      :" PAGE 1"
    prop memSeg :: SWI.OBJMEMSEG
     
    prop objSize :: GBL.DSPTYPE == 55 ? (2 * .objectSize()) : .objectSize()
    prop maxObjs :: (
	32767				 
    )
    prop numInst :: (
    	SWI.gNumOf
    )
    prop dataSize :: (
	.objectSize() * SWI.gNumOf
    )
    prop localCanCreate :: (
	if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {
	    .error("System stack size (see MEM) is too small to support a new SWI priority level.")
	}
	else {
	    "ok"
	}
    )
    prop localCreate :: (
	STS.gNumEmbed += 1,
	SWI.EXECFXN = @SWI_F_exec,
	SWI.RUNFXN = @SWI_F_run,
	"ok"
    )
    prop localDelete :: (
	STS.gNumEmbed -= 1,
	if (.gNumOf == 1) {	 
	     
	    SWI.EXECFXN = @FXN_F_nop,
	    SWI.RUNFXN = @FXN_F_nop
	},
	"ok"
    )
    prop SortByField :: "pri"
    prop SortGroups :: 15
    prop InstancePropertyPage :: (
	    "{B7240DEC-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
	    "{B7240DED-AA51-11cf-9BFE-0000C0AC14C7}"
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "swi.h" : ""
    
 
    prop cGenHInst :: (
	if (GBL.DSPTYPE == 62) {
	    "extern far SWI_Obj %0r;\n\0"
	}
	else {
	    "extern SWI_Obj %0r;\n\0"
	}
    )
    global EHOOKFXN :: @GBL_NULL {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Enable Scheduler and Return to Idle Function"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
    }
    global IHOOKFXN :: @GBL_NULL {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Exit Scheduler and Return to Idle Function"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
    }
    global EXECFXN :: @FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Configured SWI executive"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global RUNFXN :: @FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Configured SWI executive body"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global STSUNITS :: "raw" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "raw,milliseconds,microseconds"
	prop Label :: "Statistics Units"
	prop Visible :: 0		 
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst priority :: = (.pri + 1) {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "priority"
	prop JSName :: ""
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst function :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
    inst pri :: 1 {		 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	 
	prop Enum :: "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14"
	prop Label :: "priority"
	prop JSName :: "priority"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
            $a = .pri,
            .pri = $1,
	    if (self == KNL_swi) {
		if ($1 != 0) {
		    .pri = $a,
		    .error("KNL_swi must remain at Priority 0.")
		}
		else {
		    "ok"
		}
	    }
	    else {
		if ($1 == 0 && KNL_swi.iIsUsed == 1) {
		    .pri = $a,
		    .error("Priority 0 reserved for KNL_swi only.")
		}
		else {
		    GlobalStatus.gDirty = 1,
		    if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {
			.pri = $a,
			.error("System stack size (see MEM) is too small to support a new SWI priority level.")
		    }
		    else {
			if ($1 > 14) {
			    .pri = $a,
			    .error("SWI can only support 15 priority levels.")
			}
			else {
			    "ok"
			}
		    }
		}
	    }
	)
    }
    inst mailbox :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "mailbox"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
    inst arg0 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg0"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
    inst arg1 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg1"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
    inst dorta :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
     
    inst Order :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
	prop NoGen :: 0
	prop Writable :: 1
     }
    
 
    inst filter :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "filter"
	prop NoGen :: 0
    }
    inst maxformat :: .STSGetMaxFmt() {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "maxformat"
	prop NoGen :: 0
    }
    inst sumformat :: .STSGetSumFmt() {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "sumformat"
	prop NoGen :: 0
    }
    inst avgformat :: .STSGetAvgFmt() {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "avgformat"
	prop NoGen :: 0
    }
    inst filtmaxmult :: 1  {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "filtmaxmult"
	prop NoGen :: 0
    }
    inst filtsummult :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "filtsummult"
	prop NoGen :: 0
    }
    inst unittype :: .uType() {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "unittype"
	prop NoGen :: 0
    }
}    
 
type TSK {
    isa ObjectMgr
    prop name :: "TSK"
    prop Label :: "TSK - Task Manager"
    prop IsConfMod :: .USETSK
    prop IsContainedIn :: SCH
    
 
    prop DependsOn :: "SWI,HOOK"
    prop GlobalIcon :: 143
    prop InstanceIcon :: 144
    prop GlobalHelpTopic :: (
	314
    )
    prop InstanceHelpTopic :: (
	414
    )
    prop InstancePropertyPage :: (
	"{473C4A64-B1A8-11d0-9885-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{473C4A65-B1A8-11d0-9885-0020AFEE33C6}"
    )
    prop SortByField :: "iPRI"
    prop SortGroups :: 17
    prop objectSize :: (
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
	    $a = (27 * 4)
	},
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {
	    $a = (44 * 4)
	},
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {
	    $a = (44 * 4)
	},
	if (GBL.DSPTYPE == 28) {
	    $a = (40 * 4)
	},
	if (GBL.DSPTYPE == 62 || (GBL.DSPTYPE == 54 && GBL.FARMODE == 0)) {
	    $a = (24 * 4)
	},
	if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
	    $a = (25 * 4)
	},
	$a
    )
    prop GenLinkPrologue :: (
	if (.USETSK != 0) {
	    "SECTIONS {%4t\n.%1L: {%8t\n %4S %4t\n} > %3s%5s\0, name, objSize, _bssmemSeg, linkString, pageString"
	}
	else {
	    "_KNL_swi = 0;"
	}
    )
    prop linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop pageString :: GBL.DSPTYPE == 62
                      ? ""
                      : (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28)
                      ? (
                          TSK.OBJMEMSEG.space() == "code"
                          ? " PAGE 0"
                          : TSK.OBJMEMSEG.space() == "data"
                            ? " PAGE 1"
                            : TSK.OBJMEMSEG.space() == "io"
                              ? " PAGE 2"
                              : " PAGE 0"
                        )
                      :" PAGE 1"
    prop GenLinkEpilogue :: (
	if (.USETSK != 0) {
	    "%0t}\n\0"
	}
        else {
            ""
        }
    )
    prop _objAllocDesc :: (    
	"%8t .TSK$obj: {}"
    )
    prop _bssmemSeg :: .OBJMEMSEG
    prop _objmemSeg :: MEM.CFGOBJSEG	 
    prop AllocInst :: (
	.iAUTOSTK ? "1\0, _instStackDesc, _instStackSeg, _placement" : "0\0"
    )
    prop _instStackDesc :: (
	"%8t .%0s$stk: {%12t\n *(.%0s$stk)%8t\n }\0"
    )
    prop _self :: self
    prop _instStackSize :: .iSTKSZ * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    prop _instStackSeg :: .iSTKSEG
    prop _placement :: (0x7fffffff / 2)
    prop localInit :: (
	KNL_swi.Create("SWI"),
	if (.STACKSEG.iAllocHeap == 1) {
	    .STACKSEG.iReqHeapCount++,
	    "ok"
	}
	else {
	    .error ("TSK default stack segment must be a memory segment with a heap")
	}
    )
    
 
    prop HighTimeBased :: (
        CLK.HIRES == 1 ? 1 : 0
    )
    prop LowTimeBased :: (
        CLK.HIRES == 1 ? 0 : 1
    )
    
 
    prop uType :: (
        if (.HighTimeBased()) {
	    $a = 0
        }
        else {
	    if (.LowTimeBased()) {
	        $a = 1
	    }
	    else {
	        $a = 2
	    }
        },
        $a
    )
    
 
    prop STSGetMaxFmt :: (
	if (TSK.STSUNITS == "raw") {
	    CLK.HIRES ? "%g inst" : "%g ints"
	}
	else {
	    TSK.STSUNITS == "microseconds" ? "%.1f us" : "%.2f ms"
	}
    )
    prop STSGetSumFmt :: (
	TSK.STSGetMaxFmt()
    )
    prop STSGetAvgFmt :: (
	if (TSK.STSUNITS == "raw") {
	    CLK.HIRES ? "%.2f inst" : "%.2f ints"
	}
	else {
	    TSK.STSUNITS == "microseconds" ? "%.1f us" : "%.2f ms"
	}
    )
     
    prop STSFilterMaxMult :: (
	$a = 1
    )
    prop STSFilterSumMult :: (
	TSK.STSFilterMaxMult($1)
    )
    prop localCreate :: (
	STS.gNumEmbed += 1,
	"ok"
    )
    prop localCanCreate :: (
	$e = "ok",
	if (TSK.USETSK != 1) {
	    $e = .error("TSK manager not enabled")
	},
	$e
    )
    prop localDelete :: (
	STS.gNumEmbed -= 1,
	"ok"
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "tsk.h" : ""
    
 
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far TSK_Obj %0r;\n\0"
        }
	else {
	    "extern TSK_Obj %0r;\n\0"
        }
    )
    prop NOPFXN :: @FXN_F_nop
    global USETSK :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable TSK Manager"
	prop JSName :: "ENABLETSK"
	prop Visible :: 1
	prop Writable :: GBL.DSPSUBTYPE == 0x55DA200 ? 0:1
	prop NoGen :: 1
	prop Set :: (
	    if ($1 == 0) {
		if (.gNumOf > 1) {
		    .error("Cannot disable TSK until all TSK objects are deleted.")
		}
		else {
		    .STACKSEG.iReqHeapCount--,
		    TSK.STACKSEG = MEM_NULL,	 
		    TSK.OBJMEMSEG = MEM_NULL,
		    TSK_idle.iSTKSEG = MEM_NULL,
		    TSK_idle.Delete("TSK"),
		    KNL_swi.Delete("TSK"),
		    PRD.THOOKFXN = .NOPFXN,
                    if (PRD.gNumOf == 0) {
                      if (PRD_clock.iIsUsed == 1) {
                        PRD_clock.function = @FXN_F_nop
                      }
                    },
		    .USETSK = $1,
		    "ok"
		}
	    } else {
		$e = "ok",
	        GlobalStatus.gDirty = 1,
	        if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {
                    $e = .error("Current stack size inadequate to enable TSK"),
		    break
		    },
		scan ($a; SWI) {
		    if ($a != KNL_swi && $a.pri == 0 && $a.iIsUsed == 1) {
			$e = .error("Cannot enable TSK when there are SWI objects at Priority 0."),
			break
		    }
		},
		if ($e == "ok") {
		    TSK.STACKSEG = MEM_NULL,   
		    scan($b; MEM) {
			if ($b.iAllocHeap && $b != MEM_NULL) {
		    	     
		    	    TSK.STACKSEG = $b,
			    break
			}
		    },
		    .STACKSEG.iReqHeapCount++,
		    .USETSK = $1,
		    				 
		    TSK.OBJMEMSEG = SWI.OBJMEMSEG,
		    TSK_idle.iSTKSEG = .OBJMEMSEG,   
		    TSK_idle.Create("TSK"),
		    KNL_swi.Create("TSK"),
		    PRD.THOOKFXN = PRD.DEFAULT_THOOKFXN,
                    if (TSK.TSKTICK == "PRD") {
                      if (PRD_clock.iIsUsed == 1) {
                        PRD_clock.function = @PRD_F_tick
                      }
                    },
		    if ( MEM.NOHEAPS ) {
			.STACKSEG.iReqHeapCount++
		    },
		    $e
		}
		else {
		    $e
		}
	    }
	)
    }
     
    prop _objId :: .iId
    prop objSize :: GBL.DSPTYPE == 55 ? (2 * .objectSize()) : .objectSize()
    prop dataSize :: (
	$d = 0,
	scan ($i; TSK) {
	    
 
	    $d += ($i.iSTKSZ + .objectSize() * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE))
	},
	$d
    )
     
    prop minStackSize :: (
	$a = .STACKSIZE,
	scan ($i; TSK) {
	    if ($i.STACKSIZE < $a) {
		$a = $i.STACKSIZE
	    }
	},
	$a
    )
    prop maxObjs :: (32767)			 
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "OBJMEMSEG"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataNullMember($1)
	prop Label :: "Object Memory"
	prop Visible :: 1
	prop Writable :: .USETSK
	prop NoGen :: 1
    }
    
 
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global STACKSIZE :: GBL.DSPTYPE == 62 ? 1024 : 
			(GBL.DSPTYPE == 55 && GBL.DSPSUBTYPE == 5599) ? 2560 :
			(GBL.DSPTYPE == 55 && GBL.DSPSUBTYPE != 5599) ? 1024 :
			(GBL.DSPTYPE == 28) ? 256 : 256 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: GBL.DSPTYPE == 54 ? 0x01 : 0x02
	prop Label :: "Default stack size (MAUs)"
	prop JSName :: "STACKSIZE"
	prop Visible :: 1
	prop Writable :: .USETSK
    }	
    
    global STACKSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataNullMember($1) && $1.iAllocHeap
	prop Label :: "Stack segment for dynamic tasks"
	prop JSName :: "STACKSEG"
	prop Visible :: 1
	prop Writable :: .USETSK && (MEM.NOHEAPS == 0)
	prop Set :: (
	    if (.STACKSEG.iReqHeapCount > 0) {
		.STACKSEG.iReqHeapCount--
	    },
	    .STACKSEG = $1,
	    .STACKSEG.iReqHeapCount++,
	    "ok"
	)
    }	
    global PRIORITY :: 1 {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "PRIORITY"
	prop Enum :: "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
	prop Label :: "Default task priority"
	prop Visible :: 1
	prop Writable :: .USETSK
    }
    global CREATEFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Create function"
	prop JSName :: "CREATEFXN"
	prop Visible :: 1
	prop Writable :: .USETSK
	prop TabName :: "Function Hooks"
	prop Set :: (
	    .CREATEFXN = $1,
	    HOOK_KNL.createFxn = .CREATEFXN,
	    "ok"
	)
	prop NoGen :: 1
    }
    global VCREATEFXN ::= HOOK_KNL.iIsUsed == 1 ? @__HOOK_doCreate : .CREATEFXN {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
    }
    global DELETEFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Delete function"
	prop JSName :: "DELETEFXN"
	prop Visible :: 1
	prop Writable :: .USETSK
	prop TabName :: "Function Hooks"
	prop Set :: (
	    .DELETEFXN = $1,
	    HOOK_KNL.deleteFxn = .DELETEFXN,
	    "ok"
	)
	prop NoGen :: 1
    }
    global VDELETEFXN ::= HOOK_KNL.iIsUsed == 1 ? @__HOOK_doDelete : .DELETEFXN {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
    }
    global EXITFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Exit function"
	prop JSName :: "EXITFXN"
	prop Visible :: 1
	prop Writable :: .USETSK
	prop TabName :: "Function Hooks"
	prop Set :: (
	    .EXITFXN = $1,
	    HOOK_KNL.exitFxn = .EXITFXN,
	    "ok"
	)
	prop NoGen :: 1
    }
    global VEXITFXN ::= HOOK_KNL.iIsUsed == 1 ? @__HOOK_doExit : .EXITFXN {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
    }
    global DOSWITCH :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Call switch function"
	prop JSName :: "CALLSWITCHFXN"
	prop Writable :: .USETSK
	prop Visible :: 1
	prop NoGen :: 1
	prop Set :: (
	    .DOSWITCH = $1,
	    HOOK_KNL.callSwitchFxn = .DOSWITCH,
	    "ok"
	)
	prop TabName :: "Function Hooks"
    }
    global VSWFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Switch function"
	prop JSName :: "SWITCHFXN"
	prop Visible :: 1
	prop NoGen :: 1
	prop Writable :: .DOSWITCH && .USETSK
	prop Set :: (
	    .VSWFXN = $1,
	    HOOK_KNL.switchFxn = .VSWFXN,
	    "ok"
	)
	prop TabName :: "Function Hooks"
    }
    global SWITCHFXN ::= (
	 
	if (HOOK_KNL.iIsUsed) {
	    $i = 0,
	     
	    scan ($a; HOOK) {
		if ($a.callSwitchFxn) {
		    $i = 1
		}
	    },
	     
	    if ($i) {
		@__HOOK_doSwitch
	    }
	    else {
		0
	    }
	}
	else {
	    if (.DOSWITCH) {
		.VSWFXN
	    }
	    else {
		0
	    }
	}
    ) {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: ""
	prop TabName :: "Function Hooks"
    }
    global DOREADY :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Call ready function"
	prop JSName :: "CALLREADYFXN"
	prop Writable :: .USETSK
	prop Visible :: 1
	prop NoGen :: 1
	prop Set :: (
	    .DOREADY = $1,
	    HOOK_KNL.callReadyFxn = .DOREADY,
	    "ok"
	)
	prop TabName :: "Function Hooks"
    }
    global VRDYFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Ready function"
	prop JSName :: "READYFXN"
	prop Visible :: 1
	prop Writable :: .DOREADY && .USETSK
	prop NoGen :: 1
	prop Set :: (
	    .VRDYFXN = $1,
	    HOOK_KNL.readyFxn = .VRDYFXN,
	    "ok"
	)
	prop TabName :: "Function Hooks"
    }
    global READYFXN ::= (
	 
	if (HOOK_KNL.iIsUsed) {
	    $i = 0,
	     
	    scan ($a; HOOK) {
		if ($a.callReadyFxn) {
		    $i = 1
		}
	    },
	     
	    if ($i) {
		@__HOOK_doReady
	    }
	    else {
		0
	    }
	}
	else {
	    if (.DOREADY) {
		.VRDYFXN
	    }
	    else {
		0
	    }
	}
    ) {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: ""
	prop TabName :: "Function Hooks"
    }
    global NUM_HOOKS ::= HOOK.gNumOf {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
    }
    global STSUNITS :: "raw" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "raw,milliseconds,microseconds"
	prop Label :: "Statistics Units"
	prop Visible :: 0
	prop Writable :: .USETSK
	prop NoGen :: 1
    }
    
    global TSKTICK :: "PRD" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "PRD,User"
	prop Label :: "TSK tick driven by"
	prop JSName :: "DRIVETSKTICK"
	prop Visible :: 1
	prop Writable :: .USETSK
	prop NoGen :: 1
	prop Set :: (
	    if ($1 != .TSKTICK) {
		if ($1 == "PRD") {
                    PRD.THOOKFXN = PRD.DEFAULT_THOOKFXN,
                    if (TSK.USETSK == 1) {
                      if (PRD_clock.iIsUsed == 1) {
                        PRD_clock.function = @PRD_F_tick
                      }
                    }
		},
		if ($1 == "User") {
                    PRD.THOOKFXN = .NOPFXN,
                    if (PRD.gNumOf == 0) {
                      if (PRD_clock.iIsUsed == 1) {
                        PRD_clock.function = @FXN_F_nop
                      }
                    }
		},
		if ($1 != "PRD" && $1 != "User") {
		    .error ("Invalid TSK tick driver selection")
		}
	    },
	    .TSKTICK = $1,
	    "ok"
	)
    }
    
    
 
    prop GetPriority :: (
	.iPRI
    )
    
     
    inst iFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Task function"
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG0 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 0"
	prop JSName :: "arg0"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG1 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 1"
	prop JSName :: "arg1"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG2 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 2"
	prop JSName :: "arg2"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG3 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 3"
	prop JSName :: "arg3"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG4 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 4"
	prop JSName :: "arg4"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG5 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 5"
	prop JSName :: "arg5"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG6 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 6"
	prop JSName :: "arg6"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG7 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 7"
	prop JSName :: "arg7"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    
 
    inst iAUTOSTK :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Automatically allocate stack"
	prop JSName :: "autoAllocateStack"
        prop Set :: (
            if (($1 == 1) && (.iAUTOSTK == 0)) {
                .iSTKSZ = TSK.STACKSIZE
            },
            .iAUTOSTK = $1,
            "ok"
        )
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
    }
    
 
    inst iMANSTK :: @null {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Manually allocated stack"
	prop JSName :: "manualStack"
	prop Visible :: 1
	prop Writable :: .iAUTOSTK == 0
    }
    inst iSTKSZ :: TSK.STACKSIZE {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: GBL.DSPTYPE == 54 ? 0x01 : 0x02
	prop Label :: "Stack size (MAUs)"
	prop JSName :: "stackSize"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    $a = $1,
	    if ($a < 32) {
	        if (GBL.DSPSUBTYPE == 62) {
		    .error("Task stack size is too small.")
		}	
		else {
		    if ($a < 32) {
		        .error("Task stack size is too small.")
		    }
		    else {
		        .iSTKSZ = ($1 - ($1 - 1) % 8 + 7),
 	                 GlobalStatus.gDirty = 1,
	                 "ok"
		    }
		}
	    }
	    else {
	        .iSTKSZ = ($1 - ($1 - 1) % 8 + 7),
 	        GlobalStatus.gDirty = 1,
	        "ok"
	    }
	)
    }
   
 
    
    inst iSTKSEG ::= .OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: $1 == MEM_NULL || MEM.dataMember($1)
	prop Label :: "Stack Memory Segment"
	prop JSName :: "stackMemSeg"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iPRI :: TSK.PRIORITY {
	prop Label :: "Priority"
	prop JSName :: "priority"
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    if (self == TSK_idle) {
		if ($1 == 0) {
		    "ok"
		}
		else {
		    .error("Cannot change the priority of the idle task.")
		}
	    }
	    else {
	    if ($1 == 0) {
		.error("Priority 0 is reserved for the system idle task")
	    }
	    else {
		.iPRI = $1,
		"ok"
	    }
	    }
	)
    }
    inst iENV :: 0 {
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Environment pointer"
	prop JSName :: "envPointer"
	prop Visible :: 1
	prop Writable :: .iDelUser != "TSK"
	prop TabName :: "Advanced"
    }
    inst iEXITFLAG :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Don't shut down system while this task is still running"
	prop JSName :: "exitFlag"
	prop Visible :: 1
	prop Writable :: 1
	prop TabName :: "Advanced"
    }
    inst iUSETSKNAME :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Allocate Task Name on Target"
	prop JSName :: "allocateTaskName"
	prop Visible :: 1
	prop Writable :: 1
	prop TabName :: "Advanced"
    }
    inst iSTATREG ::= GBL.CACHE {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%08x"
	prop Label :: "Initial Status Register value"
	prop Visible :: 0
	prop Writable :: 1
    }
     
    inst Order :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
	prop NoGen :: 0
	prop Writable :: 1
    }
    
 
    inst filter :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "filter"
	prop NoGen :: 0
    }
    inst maxformat :: .STSGetMaxFmt() {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "maxformat"
	prop NoGen :: 0
    }
    inst sumformat :: .STSGetSumFmt() {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "sumformat"
	prop NoGen :: 0
    }
    inst avgformat :: .STSGetAvgFmt() {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "avgformat"
	prop NoGen :: 0
    }
    inst filtmaxmult :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "filtmaxmult"
	prop NoGen :: 0
    }
    inst filtsummult :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "filtsummult"
	prop NoGen :: 0
    }
    inst unittype :: .uType() {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "unittype"
	prop NoGen :: 0
    }
}
object TSK_idle :: TSK {
    param iComment :: "This is the idle task; it only runs when no other task is ready"
    param iDelUser :: "TSK"
    param iDelMsg :: "This task executes all IDL functions and cannot be deleted"
    param iFXN :: GBL.DSPTYPE == 54
		? @_IDL_loop
		: @IDL_F_loop
    param iPRI :: 0
    param iIsUsed :: TSK.USETSK
}
 
object KNL_swi :: SWI {
    param function :: @_KNL_run
    param iComment :: "This Software Interrupt calls the TSK scheduler"
    param iDelUser :: "TSK"
    param iIsUsed :: TSK.USETSK
    param iDelMsg  :: (
        "This object cannot be deleted in DSP/BIOS."
    )
    param pri :: 0
    param dorta :: 1
}
 
type IDL {
    isa ObjectMgr
    prop Label :: "IDL - Idle Function Manager"
    prop name :: "IDL"
    prop IsContainedIn :: SCH
    prop GlobalIcon :: 111
    prop InstanceIcon :: 112
    prop GlobalHelpTopic :: (
	106
    )
    prop InstanceHelpTopic :: (
	206
    )
    prop InstancePropertyPage :: (
	"{586735F1-770B-11d0-A61F-0000C070F3E9}"
    )
    
    prop GlobalPropertyPage :: (
	"{586735F0-770B-11d0-A61F-0000C070F3E9}"
    )
    prop objectSize :: (
	if (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28) {
	     $a = (2 * 4)
	}
	else {
	     $a = (1 * 4)
	},
	$a
    )
    prop GenLinkPrologue :: (
        "SECTIONS {%4t\n.%1L: {%8t\n %4S %4t\n} > %3s%5s, RUN_START(%1U_A_TABBEG)\0, name, _objSize, _memSeg, _linkString, _pageString"
    )
    prop GenLinkEpilogue :: (
        "%4t\n.%1Lcal: {%8t\n %4S %4t\n} > %3s%5s, RUN_START(%1U_A_CALBEG) %0t\n}\n%6S\n\0, name, _objSize, _memSeg, _linkCalString, _pageString, _nilBusyObj"
    )
    prop _linkString :: "*(.%1L)" 
    prop _linkCalString :: "*(.%1Lcal)"
    prop _pageString :: GBL.DSPTYPE == 62 
                      ? "" 
                      : (GBL.DSPTYPE == 55  || GBL.DSPTYPE == 28)
                      ? ( 
                          IDL.OBJMEMSEG.space() == "code"
                          ? " PAGE 0"
                          : IDL.OBJMEMSEG.space() == "data"
                            ? " PAGE 1"
                            : IDL.OBJMEMSEG.space() == "io"
                              ? " PAGE 2"
                              : " PAGE 0"
                        )       
                      :" PAGE 1"
    prop _nilBusyObj :: ( ((IDL.USEIDLBUSYOBJ == 0) && (GBL.ROM == 1)) ?
         "IDL_busyObj = 0;\n"
        :
         ""
    )
    prop _memSeg :: IDL.OBJMEMSEG
     
    prop _objSize :: GBL.DSPTYPE == 55 ? (2 * .objectSize()) : .objectSize()
    prop dataSize :: (
	.objectSize() * (IDL.gNumOf + 1)	 
    )
    prop maxObjs :: (
	32767				 
    )
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    
 
    prop idlFxnSum :: (
	$a = 0,
	scan ($i; IDL) {
	   $a += $i.cycles
	},
	$a
    )
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    
 
    global AUTOCALCULATE :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Auto calculate idle loop instruction count"
	prop JSName :: "AUTOCALCULATE"
	prop Visible :: 1
	prop Writable :: CLK.USETIMER
	prop Set :: (
	    if ($1 == 1 && CLK.USETIMER == 0) {
		.error("CLK must be enabled to do idle loop intruction count")
	    }
	    else {
		if ($1 == 1 && GBL.ENABLEINST == 0) {
		    .error("Real Time Analysis must be enabled to do idle loop instruction count")
		}
		else {
		    .AUTOCALCULATE = $1,
		    "ok"
		}
	    }
	)
	prop NoGen :: 1
    }
    
 
    global USECLKIDLTIME ::= IDL.AUTOCALCULATE {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    
 
    global USEIDLBUSYOBJ ::= 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
 
 
    global CALIBRFXN :: = (
	if (IDL.AUTOCALCULATE == 1) {
	    TSK.USETSK ?  @IDL_F_stub : @IDL_F_calibrate
	}
	else {
	    @GBL_NULL
	}
    ) {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Idle Loop Auto-Calibrate Function"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
    }
    
 
    global CALIBRERROR :: = (
	if (GBL.DSPTYPE == 62 && IDL.CALIBRFXN == @IDL_F_stub) {
	    6
	}
	else {
	    0
	}
    ) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Idle Loop Auto-Calibrate Error"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
    }
  
 
    global LOOPOVERHEAD :: 0 {
	prop Label :: "Idle Loop Instruction Count"
	prop JSName :: "LOOPINSTCOUNT"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: .AUTOCALCULATE == 0
	prop NoGen :: 1
    }
    inst function :: @_FXN_F_nop {	 
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
    inst cycles :: 0 {
	prop Label :: "CPU cycles"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0		 
	prop Writable :: (.iDelUser == "USER") ? 1 : 0
	prop NoGen :: 1
    }
    inst calibration :: 1 {
	prop Label :: "Include in CPU load calibration"
	prop JSName :: "calibration"
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1		
	prop Writable :: (.iDelUser == "USER") ? 1 : 0
	prop NoGen :: 0
    }
     
    inst Order :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
	prop NoGen :: 1
	prop Writable :: 1
    }
     
    inst iPri :: 0 {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}
object IDL_cpuLoad :: IDL {
    param iComment :: "This object is required by the system to acquire CPU load data"
    param iId :: 0			
    param iIsUsed :: GBL.ENABLEINST
    param cycles :: 0			 
    param iDelUser :: "IDL"
    param iDelMsg :: (
	"This object is required to compute CPU load and can't be deleted"
    )
    param function :: @IDL_F_busy
}
object IDL_busyObj :: STS {
    param iComment :: "This object is required by the system to accumulate CPU load statistics"
    param iIsUsed :: GBL.ENABLEINST
    param iDelUser :: "IDL"
    param iDelMsg :: (
	"This object is required to accumulate CPU load data and can't be deleted"
    )
}
 
type ISRC {
    isa ObjectMgr
    prop name :: "ISRC"
    prop Label :: "ISRC - Interrupt Sources"
    prop IsConfMod :: 1          
    prop Visible :: 0
    prop InstancePropertyPage :: (
        "{91BA37C0-98C3-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
        "{91BA37C1-98C3-11d1-988B-0020AFEE33C6}"
    )
    inst iHwi :: HWI_UNUSED {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: HWI
        prop MemberTest :: 1
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iIntrSelectNum :: 0 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
}
object Reset :: ISRC {
    param iHwi :: HWI_RESET
    param iIntrSelectNum :: -1
}
object Non_Maskable :: ISRC {
    param iHwi :: HWI_NMI
    param iIntrSelectNum :: -1
}
object Reserved :: ISRC {
    param iHwi :: HWI_RESERVED0
    param iIntrSelectNum :: -1
}
object INTSEL13 :: ISRC {
    param iHwi :: HWI_INT13
    param iIntrSelectNum :: 13
}
object DSPINT :: ISRC {
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 0
}
object Timer_0 :: ISRC {
    param iHwi :: HWI_INT14
    param iIntrSelectNum :: 26
}
object Timer_1 :: ISRC {
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 20
}
object INTSEL10 :: ISRC {
    param iHwi :: HWI_INT10
    param iIntrSelectNum :: 10
}
object External_Pin_4:: ISRC {
    param iHwi :: HWI_INT4
    param iIntrSelectNum :: 4
}
object External_Pin_5 :: ISRC {
    param iHwi :: HWI_INT5
    param iIntrSelectNum :: 5
}
object External_Pin_6 :: ISRC {
    param iHwi :: HWI_INT6
    param iIntrSelectNum :: 6
}
object External_Pin_7 :: ISRC {
    param iHwi :: HWI_INT7
    param iIntrSelectNum :: 7
}
object DMA_Channel_2 :: ISRC {
    param iHwi :: HWI_INT11
    param iIntrSelectNum :: 10
}
object DMA_Channel_3 :: ISRC {
    param iHwi :: HWI_INT12
    param iIntrSelectNum :: 11
}
object DMA_Channel_0 :: ISRC {
    param iHwi :: HWI_INT8
    param iIntrSelectNum :: 8
}
object DMA_Channel_1 :: ISRC {
    param iHwi :: HWI_INT9
    param iIntrSelectNum :: 9
}
object JTAGRTDX9 :: ISRC {
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 9
}
 
object MCSP_2_Transmit :: ISRC {
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 17
}
 
object MCSP_2_Receive :: ISRC { 
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 18
}
 
object PCI_WAKEUP :: ISRC {
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 17
}
 
object AUX_DMA_HALT :: ISRC {
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 18
}
 
object EDMA_Controller :: ISRC {
    param iHwi :: HWI_INT8
    param iIntrSelectNum :: 8
}
object MCSP_0_Transmit :: ISRC {
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 12
}
object MCSP_0_Receive :: ISRC {
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 13
}
object MCSP_1_Transmit :: ISRC {
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 14
}
object MCSP_1_Receive :: ISRC { 
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 15
}
 
 
type LOG {
    isa  ObjectMgr
    prop name :: "LOG"
    prop Label :: "LOG - Event Log Manager"
    prop IsContainedIn :: INS
    prop GlobalIcon :: 113
    prop InstanceIcon :: 114
    prop InstanceHelpTopic :: (
	207
    )
    
    prop GlobalHelpTopic :: (
	107
    )
    prop InstancePropertyPage :: (
	"{B7240DE8-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
	"{B7240DE9-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	"1\0, _globalAllocDesc, _memSeg, _placement" 
    )
    prop _globalAllocDesc :: (
	"%8t .%1L: RUN_START(%1U_A_TABBEG), RUN_START(_%1U_A_TABBEG), RUN_END(%1U_A_TABEND), RUN_END(_%1U_A_TABEND) {%8t\n }\0, name"
    )
    prop objectSize :: (
	if (GBL.DSPTYPE == 28 ||
	   (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") ||
	   (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE")) {
	    $a = (10 * 4)
	},
	if (GBL.DSPTYPE == 62 || GBL.DSPTYPE == 54 ||
		(GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL")) {
	    $a = (6 * 4)
	},
	$a
    )
    prop _placement :: (0x7fffffff / 2)
    prop AllocInst :: (
	"1\0, _instAllocDesc, _objMemSeg, _placement"
    )
    prop GenLinkEpilogue :: (
        "%0tLOG_A_TABLEN = %1d; _LOG_A_TABLEN = %1d;\n\0, numInst"
    )
    prop _instAllocDesc :: (
	"%8t /* %0s buffer */\n .%0s$buf: align = 0x%1x {}\0, _objAlign"
    )
     
    prop _objSize :: GBL.DSPTYPE == 55 ? (2 * .objectSize()) : .objectSize()
    prop _memSeg :: LOG.OBJMEMSEG
    prop _linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no %1U objects */"
     
    prop _objAlign :: GBL.DSPTYPE == 55 
               ? .buflen * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)*2  
                : .buflen * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)  
    prop _objMemSeg :: .bufseg
    prop LogType :: .iType
    prop LogFormat :: .iFormat
    prop pageString :: (
        GBL.DSPTYPE == 62
	? ""
        : (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28)
	    ? (LOG.OBJMEMSEG.space() == "code"
	        ? " PAGE 0"
		: LOG.OBJMEMSEG.space() == "data"
		    ? " PAGE 1"
		    : LOG.OBJMEMSEG.space() == "io"
			? " PAGE 2"
			: " PAGE 0"
	      )
	    : " PAGE 1"
    )
    prop numInst :: (
    	LOG.gNumOf
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "log.h" : ""
    
 
    prop cGenHInst :: (
	if (GBL.DSPTYPE == 62) {
	    "extern far LOG_Obj %0r;\n\0"
	}
	else {
	    "extern LOG_Obj %0r;\n\0"
	}
    )
    prop dataSize :: (
	$d = 0,
	scan ($i; LOG) {
	    if ($i.IsConfObj()) {
		$d += $i.buflen
	    },
	    $d += .objectSize()	 
	},
	$d
    )
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global ENABLED :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Compile in logging"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global TS :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "timestamped LOGs"
        prop JSName :: "TS"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst bufseg ::= .OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "bufseg"
	prop JSName :: "bufSeg"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst buflen :: 64 {
	
 
	prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "0,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,8388608,16777216,33554432"
	prop Label :: "buflen (words)"
	prop JSName :: "bufLen"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    GlobalStatus.gDirty = 1,
	    .buflen = $1,
	    "ok"
	)
    }
    inst logtype :: "circular" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "circular,fixed"
	prop Label :: "logtype"
	prop JSName :: "logType"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst iType :: "printf" {
	prop Label :: "datatype"
	prop JSName :: "dataType"
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "printf,raw data"
	prop Visible :: 1
	prop Writable :: .iType == "system" ? 0 : 1
	prop NoGen :: 0
    }
    inst iFormat :: "0x%x, 0x%x, 0x%x" {
	prop Label :: "format"
	prop JSName :: "format"
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: .iType == "raw data" ? 1 : 0
	prop NoGen :: 0
    }
}
object LOG_system :: LOG {
    param iComment :: "This object is required by the system to accumulate execution trace information"
    param iId :: 0
    param iIsUsed :: 1			 
    param iType :: "system"
    param iDelUser :: "LOG"
    param iDelMsg :: (
	"LOG_system is a system log and cannot be deleted."
    )
}
 
type PIP {
    isa  ObjectMgr
    prop Label :: "PIP - Buffered Pipe Manager"
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 117
    prop InstanceIcon :: 118
    prop GlobalHelpTopic :: (
	109
    )
    prop InstanceHelpTopic :: (
	209
    )
    prop name :: "PIP"
    prop maxObjs :: (
	32767				 
    )
    prop objectSize :: (
	if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {
	    $a = (27 * 4)
	},
	if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
	    $a = (34 * 4)
	},
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
	    $a = (30 * 4)
	},
	if (GBL.DSPTYPE == 28 ||
	   (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") ||
	   (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE")) {
	    $a = (50 * 4)
	},
	if (GBL.DSPTYPE == 62) {
	    $a = (25 * 4)
	},
	$a
    )
    prop dataSize :: (
	$b = 0,
	scan ($i; PIP) {
	    if ($i.IsConfObj()) {
		$b += (12 + $i.framesize) * $i.numframes + .objectSize()
	    }
	},
	$b
    )
    prop InstancePropertyPage :: (
	    "{B7240DF0-AA51-11cf-9BFE-0000C0AC14C8}"
    )
    
    prop GlobalPropertyPage :: (
	    "{B7240DF1-AA51-11cf-9BFE-0000C0AC14C8}"
    )
    prop localCreate :: (
	"ok"
    )
    prop AllocType :: (
	"1\0, _globalAllocDesc, _memSeg, _placement"
    )
    prop _globalAllocDesc :: (
	"%8t .%1L: RUN_START(%1U_A_TABBEG), RUN_START(_%1U_A_TABBEG), RUN_END(%1U_A_TABEND), RUN_END(_%1U_A_TABEND) {%8t\n }\0, name"
    )
    prop AllocInst :: (
	"1\0, _instAllocDesc, _objMemSeg, _placement"
    )
    prop GenLinkEpilogue :: (
        "%0tPIP_A_TABLEN = %1d;\n\0, numInst"
    )
    prop _instAllocDesc :: (
	.bufalign > 0 ? "%8t /* %0s buffer */\n .pip%1d: align = 0x%2x {}\0, _objId, _objAlign" : "%8t /* %0s buffer */\n .pip%1d: {}\0, _objId"
    )
    prop _placement :: (0x7fffffff / 2)
    prop _objId :: .iId
    prop _objAlign :: .bufalign * 4
    prop _objMemSeg :: .bufseg
    prop _linkString :: (.gNumOf + .gNumEmbed) > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop _memSeg :: PIP.OBJMEMSEG
    prop _objSize :: GBL.DSPTYPE == 55 ? (2 * .objectSize()) : .objectSize()
     
    prop numInst :: (
        HST.gNumOf + PIP.gNumOf
    )
    prop mkId :: (
	.iId = .gNextId++,
	.gNumOf++,
	.iId
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "pip.h" : ""
    
 
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far PIP_Obj %0r;\n\0"
	}
	else {
	    "extern PIP_Obj %0r;\n\0"
	}
    )
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global gNumEmbed :: 0 {	 
	prop NoGen :: 0
    }
    global gNextId :: 0
    global OBJSIZE ::= ._objSize
    inst bufseg ::= .OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "bufSeg"
	prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 1
    }
    inst bufalign :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "bufAlign"
	prop Style :: 0x01 | 0x02
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 1
	prop Set :: (
	    $e = "ok",
	    if ($1 == 0) {
		$e = .error("Cannot set align value to 0")
	    }
	    else {
		.bufalign = $1
	    },
	    $e
	)
    }
    inst buf :: "<NULL>" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst framesize :: 8 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "framesize (words)"
	prop JSName :: "frameSize"
	prop Style :: GBL.DSPTYPE == 62 ? 0x02 : 0x01 |0x02
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop Set :: (
	    if ($1 < 1) {
		.error("framesize must be >= 1.")
	    }
	    else {
		GlobalStatus.gDirty = 1,
		.framesize = $1,
		"ok"
	    }
	)
    }
    inst numframes  :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01
	prop JSName :: "numFrames"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop Set :: (
	    if ($1 < 1) {
		.error("Pipes must contain at least 1 frame.")
	    }
	    else {
		GlobalStatus.gDirty = 1,
		.numframes = $1,
		"ok"
	    }
	)
    }
    inst monitor :: "reader" {
    	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "monitor"
	prop Enum :: "reader,writer,none"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst notifyWriter :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyWriterFxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    inst nwarg0 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyWriterArg0"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    inst nwarg1 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyWriterArg1"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    inst notifyReader :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyReaderFxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    inst nrarg0 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyReaderArg0"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    inst nrarg1 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyReaderArg1"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    
    inst bufFrameAlign ::= ._objAlign  {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
}
 
type SEM {
    isa ObjectMgr
    prop name :: "SEM"
    prop Label :: "SEM - Semaphore Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 137
    prop InstanceIcon :: 138
    prop GlobalHelpTopic :: (
	310
    )
    prop InstanceHelpTopic :: (
	410
    )
    prop InstancePropertyPage :: (
	"{D01ACC04-38DD-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{D01ACC05-38DD-11d1-988B-0020AFEE33C6}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: (
        "%8t .sem: {}"
    )
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: .OBJMEMSEG
    
 
    prop objectSize :: (
        if (GBL.DSPTYPE == 62) {
            $a = (8 + 3)
	},
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
            $a = (10 + 4)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {
            $a = (8 + 3)
        },
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {
            $a = (16 + 6)
        },
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {
            $a = (16 + 6)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
            $a = (10 + 4)
        },
	if (GBL.DSPTYPE == 28) {
            $a = (16 + 6)
        },
        $a
   )
    prop dataSize :: (
	SEM.objectSize * SEM.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "sem.h" : ""
    
 
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far SEM_Obj %0r;\n\0"
	}
	else {
	    "extern SEM_Obj %0r;\n\0"
        }
    )
    
 
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst iCount :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Label :: "Initial semaphore count"
	prop JSName :: "count"
	prop Visible :: 1
	prop Writable :: 1
    }
}
 
 
type MBX {
    isa ObjectMgr
    prop name :: "MBX"
    prop Label :: "MBX - Mailbox Manager"
    prop IsContainedIn :: SYN 
    prop GlobalIcon :: 131
    prop InstanceIcon :: 132
    prop GlobalHelpTopic :: (
	307
    )
    prop InstanceHelpTopic :: (
	407
    )
    prop InstancePropertyPage :: (
	"{0EB45D44-38C1-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{0EB45D45-38C1-11d1-988B-0020AFEE33C6}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0,	_bssAllocDesc, _memSeg, _placement"
	    }
    )
    prop _bssAllocDesc :: (
	    "%8t .mbx: {}"
    )
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: .OBJMEMSEG
    prop AllocInst :: (
	"1\0 _instAllocDesc, _instMemSeg, _placement"
    )
    prop _instAllocDesc :: (
	"%8t .%0s$que: align = 0x4 {%12t\n %0s$queElems = .;\n . += %1d;%8t\n }\0, _qElemSize"
    )
    prop _instMemSeg :: .iMbxSeg
    prop _qElemSize :: (
	if ((GBL.DSPTYPE == 55) && (GBL.DSPSUBTYPE != 5599)) {
             
            $a = .iMsgSize,
            if ($a & 0x1) {
                $a += 1
            },
	     
	     (8 + $a) * .iMbxLength  * 2 
	}
	else {
	    if (GBL.DSPTYPE == 28) {
                 
                $a = .iMsgSize,
                if ($a & 0x1) {
                    $a += 1
                },
	        (8 + $a) * .iMbxLength
	    }
	    else {
                 
                $a = .iMsgSize,
		$b = GBL.DSPWORDSIZE / GBL.DSPCHARSIZE,
		$c = $a & ($b - 1),
		if ($c != 0) {
		    $a = $a + ($b - $c)
		},
	        (8 + $a) * .iMbxLength
	    }
	}
    )
    
 
    prop objectSize :: (
        if (GBL.DSPTYPE == 62) {
            $a = (29)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
            $a = (28)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {
            $a = (24)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {
            $a = (46)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {
            $a = (46)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
            $a = (28)
        },
        if (GBL.DSPTYPE == 28) {
            $a = (46)
        },
        $a
    )
    prop dataSize :: (
	$d = 0,
	scan ($i; MBX) {
	    $d += (GBL . DSPWORDSIZE / GBL . DSPCHARSIZE) * (($i.iMsgSize + 2) * $i.iMbxLength + .objectSize())
	},
	$d
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "mbx.h" : ""
    
 
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far MBX_Obj %0r;\n\0"
	}
	else {
	    "extern MBX_Obj %0r;\n\0"
	}
    )
    
 
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst iMsgSize :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Label :: "Message Size"
	prop JSName :: "messageSize"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    if ($1  == 0) {
		.error ("Message size cannot be zero")
	    }
	    else {
	    	GlobalStatus.gDirty = 1,
		.iMsgSize = $1,
		"ok"
	    }
	)
    }
    inst iMbxLength :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Label :: "Mailbox Length"
	prop JSName :: "length"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    if ($1  == 0) {
		.error ("Mailbox length cannot be zero")
	    }
	    else {
	    	GlobalStatus.gDirty = 1,
		.iMbxLength = $1,
		"ok"
	    }
	)
    }
    inst iMbxSeg :: MBX.OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Element memory segment"
	prop JSName :: "elementSeg"
	prop Visible :: 1
	prop Writable :: 1
    }
}
 
type QUE {
    isa ObjectMgr
    prop name :: "QUE"
    prop Label :: "QUE - Atomic Queue Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 133
    prop InstanceIcon :: 134
    prop IsConfMod :: 1		 
    prop GlobalHelpTopic :: (
	309
    )
    prop InstanceHelpTopic :: (
	409
    )
    prop InstancePropertyPage :: (
	"{D01ACC01-38DD-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{D01ACC02-38DD-11d1-988B-0020AFEE33C6}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: (
	"%8t .que: {}"
    )
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: .OBJMEMSEG
    
 
    prop objectSize :: (
        if (GBL.DSPTYPE == 62) {
            $a = (2)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
            $a = (2)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {
            $a = (2)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {
            $a = (4)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {
            $a = (4)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
            $a = (2)
        },
        if (GBL.DSPTYPE == 28) {
            $a = (4)
        },
        $a
    )
    prop dataSize :: (
	QUE.objectSize * QUE.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "que.h" : ""
    
 
    prop cGenHInst :: (
	if (GBL.DSPTYPE == 62) {
	    "extern far QUE_Obj %0r;\n\0"
	}
	else {
	    "extern QUE_Obj %0r;\n\0"
	}
    )
    
 
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
}
 
type LCK {
    isa ObjectMgr
    prop name :: "LCK"
    prop Label :: "LCK - Resource Lock Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 129
    prop InstanceIcon :: 130
    prop IsConfMod :: 1		 
    prop GlobalHelpTopic :: (
	306
    )
    prop InstanceHelpTopic :: (
	406
    )
    prop InstancePropertyPage :: (
	"{0EB45D40-38C1-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{0EB45D41-38C1-11d1-988B-0020AFEE33C6}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _bssAllocDesc, _memSeg, _placement"
	}
    )
    prop _bssAllocDesc :: (
	"%8t .lck: {}"
    )
    prop _objAllocDesc :: (
	"%8t .LCK$obj: {}"
    )
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: .OBJMEMSEG
    
 
    prop objectSize :: (
        if (GBL.DSPTYPE == 62) {
            $a = (10)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
            $a = (12)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {
            $a = (10)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {
            $a = (20)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {
            $a = (20)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
            $a = (12)
        },
        if (GBL.DSPTYPE == 28) {
            $a = (20)
        },
        $a
    )
    prop dataSize :: (
	LCK.objectSize * LCK.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "lck.h" : ""
    
 
    prop cGenHInst :: (
	if (GBL.DSPTYPE == 62) {
	    "extern far LCK_Obj %0r;\n\0"
	}
	else {
	    "extern LCK_Obj %0r;\n\0"
	}
    )
    
 
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
}
 
 
type STS {
    isa  ObjectMgr
    prop name :: "STS"
    prop Label :: "STS - Statistics Object Manager"
    prop IsContainedIn :: INS
    prop GlobalIcon :: 125
    prop InstanceIcon :: 126
    prop InstanceHelpTopic :: (
	212
    )
    
    prop GlobalHelpTopic :: (
	112
    )
    prop AllocType :: (
	"1\0, _globalAllocDesc, _memSeg, _placement"
    )
    prop _globalAllocDesc :: (
	"%8t .%1L: RUN_START(%1U_A_TABBEG), RUN_START(_%1U_A_TABBEG), RUN_END(%1U_A_TABEND), RUN_END(_%1U_A_TABEND) {%8t\n }\0, name"
    )
    prop localInit :: (
	if (PRD.CALLBACKOBJ != nil) {
	    .error("STS initialization failure")
	},
	PRD.CALLBACKOBJ = STS
    )
    prop objectSize :: (
	(4 * 4)
    )
    prop _placement :: (0x7fffffff / 2)
    prop _linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop _memSeg :: STS.OBJMEMSEG
     
    prop _objSize :: GBL.DSPTYPE == 55 ? (2 * .objectSize()) : .objectSize()
    prop dataSize :: (
	.objectSize() * (STS.gNumOf + STS.gNumEmbed)
    )
    prop maxObjs :: (
	32767			 
    )
    prop InstancePropertyPage :: (
	"{B7240DEE-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
	"{B7240DEF-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
 
    prop STSGetMaxFmt :: (
	.format
    )
    prop STSGetSumFmt :: (
	.format
    )
    prop STSGetAvgFmt :: (
	"%.2f"
    )
    prop STSFilterSum :: (
	(.iA * $1 + .iB * $2) / (1.0 * .iC)
    )
    prop STSFilterMax :: (
	(.iA * $1 + .iB) / (1.0 * .iC)
    )
    prop HighTimeBased :: (
	.unittype == "High resolution time based" ? 1 : 0
    )
    prop LowTimeBased :: (
	.unittype == "Low resolution time based" ? 1 : 0
    )
     
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "sts.h" : ""
    
 
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far STS_Obj %0r;\n\0"
	}
	else {
	    "extern STS_Obj %0r;\n\0"
        }
    )
    prop modifiable :: (
	((.iDelUser == "USER" || .iDelUser == "HWI") ? 1 : 0)
    )
    prop untype :: (
        if (.unittype == "Not time based") {
	    $a = 2
	},
	if (.unittype == "High resolution time based") {
	    $a = 0
        },
	if (.unittype == "Low resolution time based") {
	    $a = 1
        },
	$a
    )
    prop optype :: (
        if (.operation == "Nothing") {
	    $a = 0
	},
	if (.operation == "A * x") {
	    $a = 1
        },
	if (.operation == "A * x + B") {
	    $a = 2
        },
	if (.operation == "(A * x + B) / C") {
	    $a = 3
        },
	$a
    )
    
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global gNumEmbed :: 0 {	 
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst prev :: 0 {		 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: .modifiable()
	prop JSName :: "previousVal"
	prop NoGen :: GBL.DSPTYPE != 40 && GBL.DSPTYPE != 62
	prop Set :: (
	    .prev = $1,
	    .prevlow = $1 & 0xffff,
	    .prevhigh = ($1 >> 16) & 0xffff,
	    "ok"
	)
    }
    
 
    inst format :: "%g" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "format"
	prop NoGen :: 1
    }
    
 
    inst filter :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "filter"
	prop NoGen :: 0
    }
    
 
    inst maxformat :: "%g" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "maxformat"
	prop NoGen :: 0
    }
    inst sumformat :: "%g" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "sumformat"
	prop NoGen :: 0
    }
    inst avgformat :: "%.2f" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "avgformat"
	prop NoGen :: 0
    }
    
 
    inst unittype :: "Not time based" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "Not time based,High resolution time based,Low resolution time based"
	prop Label :: "unit type"
	prop JSName :: "unitType"
	prop Visible :: 1
	prop Writable :: .modifiable()
	prop NoGen :: 1
	prop Set :: (
	    .unittype = $1,
	    if ($1 == "High resolution time based") {
		.iA = 1,
		.iB = 0,
		.iC = 1,
		.operation = "A * x"
	    }
	    else {
		if ($1 == "Low resolution time based") {
		    .iA = 1,
		    .iB = 0,
		    .iC = 1,
		    .operation = "A * x"
		}
		else {
		    .iA = 1,
		    .iB = 0,
		    .iC = 1,
		    .operation = "Nothing"
		}
	    },
	    "ok"
	)
    }
    inst operation :: "Nothing" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "Nothing,A * x,A * x + B,(A * x + B) / C"
	prop Label :: "host operation"
	prop JSName :: "operation"
	prop Visible :: 1
	prop Writable :: (
	    (.unittype != "Low resolution time based") && .modifiable()
	)
	prop NoGen :: 1
	prop Set :: (
	    .operation = $1,
	    if ($1 == "Nothing" && .unittype != "High resolution time based") {
		.iA = 1,
		.iB = 0,
		.iC = 1
	    }
	    else {
		if ($1 == "A * x") {
		    .iB = 0,
		    .iC = 1
		}
		else {
		    if ($1 == "A * x + B") {
			.iC = 1
		    }
		}
	    },
	    "ok"
	)
    }
    inst op ::= .optype() {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
     }
    inst uType ::= .untype() {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
     }
    inst iA :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: (.modifiable() &&
	    !(.unittype != "Not time based" || .operation == "Nothing")
	)
	prop Label :: "A"
	prop JSName :: "numA"
	prop NoGen :: 0
    }
    inst iB :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: (.modifiable() &&
	    !(.unittype == "Low resolution time based" || .operation == "Nothing" || .operation == "A * x")
	)
	prop Label :: "B"
	prop JSName :: "numB"
	prop NoGen :: 0
    }
    inst iC :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: (.modifiable() &&
	    (.unittype == "Not time based" && .operation == "(A * x + B) / C")
	)
	prop Label :: "C"
	prop JSName :: "numC"
	prop NoGen :: 0
    }
    inst prevhigh :: 0 {	 
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: GBL.DSPTYPE == 40 || GBL.DSPTYPE == 62
    }
    
 
    inst prevlow :: 0 {		 
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
}
 
type SYS {
    isa Module
    prop name :: "SYS"
    prop Label :: "SYS - System Settings"
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 141
    prop InstanceIcon :: 142
    prop IsConfMod :: 1		 
    prop GlobalHelpTopic :: (
	313
    )
    prop InstanceHelpTopic :: (
	413
    )
    prop InstancePropertyPage :: (
	"{473C4A62-B1A8-11d0-9885-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{473C4A63-B1A8-11d0-9885-0020AFEE33C6}"
    )
    prop AllocType :: ( .PUTCFXN == @_UTL_doPutc ?
	"2\0, _globalAllocDesc,	_memSeg, _midPlace, 	      _traceString, _traceSeg, _midPlace"
	:
	"1\0, _globalAllocDesc,	_memSeg, _midPlace"
    )
    
 
    prop _globalAllocDesc :: (
	"%8t .sys:     {}"
    )
    prop _traceString   :: (
	"%8t .trace: fill = 0x0  align = 0x4 {%12t\n_SYS_PUTCBEG = .;\n. += 0x%1x;\n_SYS_PUTCEND = . - 1;%8t\n }\0, _traceSize"
    )
    prop _midPlace :: (0x7fffffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    prop _traceSeg :: SYS.TRACESEG
    prop _traceSize :: SYS.TRACESIZE
    
 
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global TRACESIZE :: 512 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "%d"
	prop Style :: 0x01 | 0x02
	prop Label :: "Trace Buffer Size"
	prop JSName :: "TRACESIZE"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global TRACESEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1) 
	prop Label :: "Trace Buffer Memory"
	prop JSName :: "TRACESEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global ABORTFXN :: @_UTL_doAbort {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Abort Function"
	prop JSName :: "ABORTFXN"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    global ERRORFXN :: @_UTL_doError {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Error Function"
	prop JSName :: "ERRORFXN"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    global EXITFXN :: @_UTL_halt {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Exit Function"
	prop JSName :: "EXITFXN"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    global PUTCFXN :: @_UTL_doPutc {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Putc Function"
	prop JSName :: "PUTCFXN"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
}
 
type SIO {
    isa ObjectMgr
    prop name :: "SIO"
    prop Label :: "SIO - Stream Input and Output Manager"
    prop IsContainedIn :: IOF
    prop DependsOn :: "DIO,DGN,DHL,DPI"
    prop GlobalIcon :: 139
    prop InstanceIcon :: 140
    prop GlobalHelpTopic :: (
	311
    )
    prop InstanceHelpTopic :: (
	411
    )
    prop InstancePropertyPage :: (
	"{7C4C9A60-763E-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{7C4C9A61-763E-11d1-988B-0020AFEE33C6}" 
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "2\0, _bssAllocDesc, _memSeg, _placement,
	          _objAllocDesc, _memSeg, _placement"
	}
    )
    prop _bssAllocDesc :: (
        "%8t .SIO$bss: {%12t\n *(.SIO$bss)%8t\n }"
    )
    prop _objAllocDesc :: (
        "%8t .SIO$obj: {%12t\n *(.SIO$obj)%8t\n }"
    )
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: .OBJMEMSEG
    prop AllocInst ::  (
	"1\0, _instBufDesc, _instBufSeg, _placement"
    )
    prop _instBufDesc :: (
	.iAlign > 1? "%8t .%0s$bufs: align = 0x%1x {}\0, _objAlign" : "%8t .%0s$bufs: {}"
    )
    prop _objAlign :: .iAlign
    prop _instBufSeg :: .iBufSegid
    prop defDev :: (
	$h = nil,
	$i = nil,
	$j = nil,
	scan ($h; nil) {
	    if ($h.isDriver == 1) {
		scan ($i; $h) {
	            if ($j == nil
		        && $i.iIsTerminal != 0 && $i.iIsVirtual == 0) {
			
 
			$j = $i,
			break
		    }
		}
	    }
	},
	$j
    )
    prop devList :: (
	$h = nil,
	$i = nil,
	$j = nil,
	scan ($h; nil) {
	    if ($h.isDriver == 1) {
		scan ($i; $h) {
	            if ($j == nil
			&& $i.iIsTerminal != 0 && $i.iIsVirtual == 0) {
			
 
			$j = $i,
			scan ($a; DIO) {
			    if ($a == $i) {
				$i.numTimeUse++
			    }
			},
		        break
	            }
		}
	    }
	},
	$j
    )
     
    prop setDev :: (
	$h = nil,
	$i = nil,
	$j = nil,
	scan ($h; nil) {
	    if ($h.isDriver == 1) {
		scan ($i; $h) {
		    if ($i == $1) {
			$j = $i
		    }
		}
	    }
	},
	$j
    )
    prop localCanCreate :: (
	if (.defDev == nil) {
	    .error ("A driver device must be created before creating a stream.")
	}
	else {
	    "ok"
	}
    )
    prop localDelete :: (
	scan ($a; DIO) {
	    if ($a == .iDevice) {
		.iDevice.numTimeUse--
	    }
	},
	"ok"
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "sio.h" : ""
    
 
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far SIO_Obj %0r;\n\0"
	}
	else {
	    "extern SIO_Obj %0r;\n\0"
        }
    )
    global gNumEmbed :: 0 {   
	prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global USEISSUERECLAIM :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Use Only Issue/Reclaim Model"
	prop JSName :: "USEISSUERECLAIM"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    .USEISSUERECLAIM = $1,
	    if ($1 == 1) {
		scan ($i; SIO) {
		    $i.iModelName = "Issue/Reclaim"
		}
	    },
	    "ok"
	)
    }
    
    inst iDevice :: SIO.devList {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop TypeTest :: $1.isDriver == 1
	prop MemberTest :: $1.driverType != "DEV_IOMTYPE"
	prop Label :: "Device"
	prop JSName :: "deviceName"
	prop Set :: (
	    if (($1.iIsTerminal == 0) && (.iDevCtrlParam == "")) {
		    .error("To select a stacking device, enter first a terminal device in Device Control String")
	    }
	    else {
		if ($1.iIsVirtual == 1) {
		    .error("The device you have selected is a virtual instance, you must select a non-virtual device")
		}
		else {
		    scan($a; DIO) {
			if ($a == .iDevice) {
			    .iDevice.numTimeUse--
			}
		    },
		    scan($b; DIO) {
			if ($b == $1) {
			    $1.numTimeUse++
			}
		    },
		    .iDevice = .setDev($1),
		    "ok"
		}
	    }
	)
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iDevCtrlParam :: "" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Device Control String"
	prop JSName :: "controlParameter"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iDevId ::= .iDevice.iDevId
    inst iFxns  ::= .iDevice.iFxns
    inst iMode :: "input" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "input,output"
	prop Label :: "Mode"
	prop JSName :: "mode"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iBufsize :: 0x80 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Label :: "Buffer size"
	prop JSName :: "bufSize"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iNbufs :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01
	prop Label :: "Number of buffers"
	prop JSName :: "numBufs"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iBufSegid ::= .OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Place buffers in memory segment"
	prop JSName :: "bufSegId"
	prop Visible :: 1
	prop Writable :: .iAllocBuf == 1
    }
    inst iAlign :: 1 {
	prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768"
	prop Label :: "Buffer alignment"
	prop JSName :: "bufAlign"
	prop Visible :: 1
	prop Writable :: .iAllocBuf == 1
    }
    
 
    inst iFlush :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Flush"
	prop JSName :: "flush"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iModelName :: "Standard" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "Standard,Issue/Reclaim"
	prop Label :: "Model"
	prop JSName :: "modelName"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    $e = "ok",
	    if (.USEISSUERECLAIM == 1) {
		if ($1 == "Standard") {
	    	    $e = .error("SIO Issue/Reclaim model support selected")
	        }
	        else {
		    .iModel = $1 == "Standard"
			? "SIO_STANDARD"
			: "SIO_ISSUERECLAIM",
	            .iModelName = $1
	        }
	    }
	    else {
		.iModel = $1 == "Standard"
		    ? "SIO_STANDARD"
		    : "SIO_ISSUERECLAIM",
	        .iModelName = $1
	    },
	    $e
	)
    }
    inst iAllocBuf ::= .iSaveAllocBuf {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Allocate Static Buffer(s)"
	prop JSName :: "allocStaticBuf"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    .iSaveAllocBuf = $1,
	    "ok"
	)
    }
    inst iSaveAllocBuf :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    inst iModel :: "SIO_STANDARD" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "SIO_STANDARD,SIO_ISSUERECLAIM"
	prop Visible :: 0
	prop Writable :: 0
    }
    inst iTimeout ::= .iModel == "SIO_ISSUERECLAIM" ? .iSaveTimeout : -1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Timeout for I/O operation"
	prop JSName :: "timeout"
	prop Visible :: 1
	prop Writable :: .iModel == "SIO_ISSUERECLAIM"
	prop Set :: (
	    .iSaveTimeout = $1,
	    "ok"
	)
    }
    inst iSaveTimeout :: -1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    
    inst useCallBackFxn :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "use callback function"
	prop JSName :: "useCallBackFxn"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop TabName :: "Callback"
    }
    inst callBackFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "callback function"
	prop JSName :: "callBackFxn"
	prop Visible :: 1
	prop Writable :: .useCallBackFxn
	prop NoGen :: 0
	prop TabName :: "Callback"
    }
    inst arg0 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "argument 0"
	prop JSName :: "arg0"
	prop Visible :: 1
	prop Writable :: .useCallBackFxn
	prop NoGen :: 0
	prop TabName :: "Callback"
    }
    inst arg1 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "argument 1"
	prop JSName :: "arg1"
	prop Visible :: 1
	prop Writable :: .useCallBackFxn
	prop NoGen :: 0
	prop TabName :: "Callback"
    }
}
 
type GIO {
    isa Module
    prop Visible :: 1
    prop name :: "GIO"
    prop Label :: "GIO - General Input/Output Manager"
    prop IsConfMod :: .USEGIO 
    prop IsContainedIn :: IOF
    prop DependsOn :: "UDEV"
 
    prop GlobalIcon :: 141
    prop InstanceIcon :: 142
    prop GlobalHelpTopic :: (
	320
    )
    prop InstanceHelpTopic :: (
	420
    )
    prop InstancePropertyPage :: (
	"{473C4A62-B1A8-11d0-9885-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{473C4A63-B1A8-11d0-9885-0020AFEE33C6}"
    )
    prop AllocType :: (
	"1\0, _globalAllocDesc, _memSeg, _midPlace"
    )
    prop _globalAllocDesc :: (
	"%8t .gio:     {}"
    )
    prop _midPlace :: (0x7fffffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    
 
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global USEGIO :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable General Input/Output Manager"
	prop JSName :: "ENABLEGIO"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
 
    global CREATEFXN ::= .USEGIO == 1 ? @_SEM_create : @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Create Function"
	prop JSName :: "CREATEFXN"
	prop Visible :: 1
	prop Writable :: .USEGIO
	prop NoGen :: 0
    }
    global DELETEFXN ::= .USEGIO == 1 ? @_SEM_delete : @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Delete Function"
	prop JSName :: "DELETEFXN"
	prop Visible :: 1
	prop Writable :: .USEGIO
	prop NoGen :: 0
    }
    global PENDFXN ::= .USEGIO == 1 ? @_SEM_pend : @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Pend Function"
	prop JSName :: "PENDFXN"
	prop Visible :: 1
	prop Writable :: .USEGIO
	prop NoGen :: 0
    }
    global POSTFXN ::= .USEGIO == 1 ? @_SEM_post : @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Post Function"
	prop JSName :: "POSTFXN"
	prop Visible :: 1
	prop Writable :: .USEGIO
	prop NoGen :: 0
    }
}
 
type DEV {
    isa ObjectMgr
    prop name :: "DEV"
    prop Visible :: 0
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _bssAllocDesc, _memSeg, _placement"
	},
	
 
	if (.devCount() > 0 ) {
	    "1\0, _devtableDesc, _memSeg, _placement"
	}
    )
    prop _bssAllocDesc :: (
	"%8t .dev: {}"
    )
    prop _devtableDesc :: (
	"%8t .devtable: {}"
    )
    prop _memSeg :: MEM.CFGOBJSEG
    prop _placement :: (0x7fffffff / 2)
    prop DependsOn :: "HWI"
    prop devCount :: (
	$i = nil,
	$a = 0,
	scan ($i; nil) {
	    if ($i.isDriver == 1) {
		$a = $a + $i.gNumOf
	    }
	},
	$a
    )
}
 
type UDEV {
    isa ObjectMgr
    prop name :: "UDEV"
    prop Label :: "User-Defined Devices"
    prop IsContainedIn :: SIODRIVER
    prop DependsOn :: "DEV"
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop GlobalHelpTopic :: (
	315
    )
    prop InstanceHelpTopic :: (
	415
    )
    prop InstancePropertyPage :: (
	"{7AE86AA0-35C0-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{7AE86AA1-35C0-11d1-988B-0020AFEE33C6}"
    )
    prop maxObjs :: (32767)
    prop isDriver :: (
	1
    )
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: (
        "%8t .udev: {}"
    )
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    prop _driverType :: (
	.fxnTableType == "DEV_Fxns" ? "DEV_SIOTYPE" : "DEV_IOMTYPE"
    )
    inst iInit :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"	
	prop Label :: "init function"
	prop JSName :: "initFxn"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    .iInit = $1,
	    .initFxn = .iInit,
	    "ok"
	)
    }
    inst iFxns :: 0 {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"	
	prop Label    :: "function table ptr"
	prop JSName :: "fxnTable"
	prop Visible  :: 1
	prop Writable :: 1
    }
    
    inst fxnTableType :: "DEV_Fxns" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "DEV_Fxns,IOM_Fxns"
	prop Label :: "function table type"
	prop JSName :: "fxnTableType"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    inst driverType ::= ._driverType {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "DEV_SIOTYPE,DEV_IOMTYPE"
	prop Visible :: 0
    }
    
    inst iDevId :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "device id"
	prop JSName :: "deviceId"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    .iDevId = $1,
	    .deviceId = .iDevId,
	    "ok"
	)
    }
    inst iParams :: 0 {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label    :: "device params ptr"
	prop JSName :: "params"
	prop Visible  :: 1
	prop Writable :: 1
    }
    inst deviceId :: 0 {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName   :: ""
	prop Visible  :: 0
    }
    inst initFxn :: 0 {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"	
	prop JSName   :: ""
	prop Visible  :: 0
    }
    inst iIsStacking ::0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Stacking Device"
	prop JSName :: "stackingDevice"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst deviceGlobalDataPtr :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "device global data ptr"
	prop JSName :: "deviceGlobalDataPtr"
	prop Visible :: 1
	prop Writable :: .fxnTableType == "IOM_Fxns"
    }
    inst iIsTerminal ::= .fxnTableType == "DEV_Fxns" ? 1 : 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    inst iIsVirtual :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
}
 
type DIO {
    isa ObjectMgr
    prop Visible :: 1
    prop Label :: "DIO - Class Driver"
    prop name :: "DIO"
    prop IsContainedIn :: SIODRIVER
    prop DependsOn :: "UDEV"
    prop GlobalIcon :: 127
    prop InstanceIcon :: 127
    prop GlobalHelpTopic :: (
	319
    )
    prop InstanceHelpTopic :: (
	419	
    )
    prop InstancePropertyPage :: (		
	"{f80273c0-3838-11d2-a32c-006097656921}"
    )
    
    prop GlobalPropertyPage :: (		
	"{050a0600-3839-11d2-a32c-006097656921}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: (
	"%8t .dio: {}"
    )
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: .OBJMEMSEG
    prop isDriver :: (
	1
    )
    prop mdObject :: (
	$h = nil,
	$j = nil,
	scan ($h; UDEV) {
	    if ($h.driverType == "DEV_IOMTYPE" ) {
		$j = $h,
                break
	    }
	},
	$j
    )
    prop localCanCreate :: (
	if (.mdObject == nil) {
	    .error ("An IOM type device must be created first.")
	}
	else {
	    "ok"
	}
    )
    prop numTsk :: (
	$a = 0,
	$h = nil,
	scan ($h; DIO) {
	    if ($h.useCallBackFxn == 0) {
		$a = $a + $h.numTimeUse
	    }
	},
	$a
    )
    prop numSwi :: (
	$a = 0,
	$h = nil,
	scan ($h; DIO) {
	    if ($h.useCallBackFxn == 1) {
		$a = $a + $h.numTimeUse
	    }
	},
	$a
    )
	
    prop functionTablePtr :: (
	if (.STATIC) {
	    if (.useCallBackFxn) {
		@_DIO_cbStaticFxns
	    }
	    else {
		@_DIO_tskStaticFxns
	    }
	}
	else {
	    if (.useCallBackFxn) {
		@_DIO_cbDynamicFxns
	    }
	    else {
		@_DIO_tskDynamicFxns
	    }
	}
    )
    global OBJMEMSEG :: IRAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global STATIC :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Create all DIO Objects Statically"
	prop JSName :: "STATICCREATE"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    global NUMTSKBASE ::= .numTsk  {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "TSK based"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global NUMSWIBASE ::= .numSwi  {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "SWI based"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst useCallBackFxn :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "use callback version of DIO function table (for SWI)"
	prop JSName :: "useCallBackFxn"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    inst fxnsTable ::= .functionTablePtr {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible  :: 1
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst initFxn :: @_DIO_init {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible  :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst deviceName :: .mdObject {
        prop Type     :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: UDEV
	prop MemberTest :: $1.driverType == "DEV_IOMTYPE"
        prop Label    :: "device name"
        prop JSName   :: "deviceName"
        prop Visible  :: 1
        prop Writable :: 1
	prop NoGen :: 0
    }
    inst chanParams :: 0 {
        prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label    :: "channel parameters"
        prop JSName   :: "chanParams"
        prop Visible  :: 1
        prop Writable :: 1
	prop NoGen :: 0
    }
    inst numTimeUse :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iDevId :: 0 {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible  :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iFxns ::= .functionTablePtr {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible  :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iIsTerminal :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iIsVirtual :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
}
 
type DGN {
    isa ObjectMgr
    prop name :: "DGN"
    prop Label :: "DGN - Software Generator Driver"
    prop IsContainedIn :: SIODRIVER
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop GlobalHelpTopic :: (
	302
    )
    prop InstanceHelpTopic :: (
	402
    )
    prop InstancePropertyPage :: (
	"{054FE166-B014-11d0-9885-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{054FE167-B014-11d0-9885-0020AFEE33C6}"
    )
    prop DependsOn :: "DEV"
    prop maxObjs :: (32767)
    prop isDriver :: (
	1
    )
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: (
        "%8t .dgn: {}"
    )
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    inst iDevice :: "user" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: GBL.DSPARITHMETIC == "FLOAT" ?
		"user,sine,random,constant,printFloat,printHex,printInt"
		:"user,sine,random,constant,printHex,printInt"
	prop Label :: "Device category"
	prop JSName :: "device"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    $a = $1,
	    if ($a != .iDevice) {
		.iDevice = $a,
		.iUserFxn = @_FXN_F_nop	 
	    },
	    if ($a == "user") {
		.iUserFxn = .iSaveUserFxn
	    },
	    if ($a == "printFloat") {
		.iUserFxn = @_DGN_printFloat
	    },
	    if ($a == "printHex") {
		.iUserFxn = @_DGN_printHex
	    },
	    if ($a == "printInt") {
		.iUserFxn = @_DGN_printInt
	    },
	    "ok"
	)
    }
    inst iUseDefaults :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Use default parameters"
	prop Visible :: 1
	prop JSName :: "useDefaultParam"
	prop Writable :: .iDevice == "sine" || .iDevice == "constant" || .iDevice == "random" || .iDevice == "user"
    }
    inst iDevId ::= .iDevice == "constant" ? @DGN_CONST : .iDevice == "random" ? @DGN_RAND : .iDevice == "sine" ? @DGN_SINE : @DGN_USER {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Device ID"
	prop JSName :: "deviceId"
	prop Visible :: 1
	prop Writable :: 0
    }
    inst iIsTerminal :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    inst iIsVirtual :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    
 
    inst iConstant :: GBL.DSPARITHMETIC == "FIXED" ? 1 : 1.0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label  :: "Constant value"
	prop JSName :: "constant"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "constant" || .iDevice == "user")
    }
    inst iRandSeed :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Seed value"
	prop JSName :: "seedValue"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "random" || .iDevice == "user")
    }
    inst iRandLower :: GBL.DSPARITHMETIC == "FIXED" ? -32767 : 0.0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label :: "Lower limit"
	prop JSName :: "lowerLimit"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "random" || .iDevice == "user")
    }
    inst iRandUpper :: GBL.DSPARITHMETIC == "FIXED" ? 32767 : 1.0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label :: "Upper limit"
	prop JSName :: "upperLimit"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "random" || .iDevice == "user")
    }
    inst iSineGain :: GBL.DSPARITHMETIC == "FIXED" ? 32767 : 1.0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label :: "Gain"
	prop JSName :: "gain"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "sine" || .iDevice == "user")
    }
    inst iSineFreq :: GBL.DSPARITHMETIC == "FIXED" ? 1 : 1000.0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label :: "Frequency (Hz)"
	prop JSName :: "frequency"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "sine" || .iDevice == "user")
    }
    inst iSinePhase :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0.0{
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label :: "Phase (radians)"
	prop JSName :: "phase"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "sine" || .iDevice == "user")
    }
    inst iSineRate :: GBL.DSPARITHMETIC == "FIXED" ? 256 : 44000 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Sample rate (samples/sec)"
	prop JSName :: "rate"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "sine" || .iDevice == "user")
    }
    inst iUserFxn :: .iDevice == "printFloat" ? @_DGN_printFloat : .iDevice == "printHex" ? @_DGN_printHex : .iDevice == "printInt" ? @_DGN_printInt : @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "User function"
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: .iDevice == "user"
	
 
	prop Set :: (
	    .iUserFxn = $1,
	    .iSaveUserFxn = .iUserFxn,
	    "ok"
	)
    }
    inst iSaveUserFxn :: @_FXN_F_nop {
	prop Visible :: 0
	prop Writable ::0
	prop NoGen :: 1
    }
    inst iUserArg ::= 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "User function argument"
	prop JSName :: "arg"
	prop Visible :: 1
	prop Writable :: .iDevice == "user"
    }
    
 
    inst iFxns :: @_DGN_FXNS {
	prop NoGen :: 1
    }
}
 
type DHL {
    isa ObjectMgr
    prop name :: "DHL"
    prop Label :: "DHL - Host Link Driver"
    prop IsContainedIn :: SIODRIVER
    prop GlobalHelpTopic :: (303)
    prop InstanceHelpTopic :: (403)
    prop InstancePropertyPage :: ("{9C29DA20-90F9-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{9C29DA21-90F9-11d1-988B-0020AFEE33C6}")
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop DependsOn :: "DEV"
    prop Visible :: 1
    prop isDriver :: 1
    
 
    prop objectSize :: (
        if (GBL.DSPTYPE == 62) {
            $a = (19)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
            $a = (22)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {
            $a = (19)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {
            $a = (34)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {
            $a = (34)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
            $a = (22)
        },
        if (GBL.DSPTYPE == 28) {
            $a = (34)
        },
        $a
    )
    prop dataSize :: (
	DHL.objectSize * DHL.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    )
    global gChannelsAvailable :: (
        $a = 0,
        scan ($i; HST) {
            if ($i.iDHLAvailable == 1) {
                $a++
            }
        },
        $a
    ) 
    prop localCanCreate :: (
        if (.gChannelsAvailable > 0) {
            "ok"
        }
	else {
	    .warning("No HST channels are available for a new DHL device.")
	}
    )
    prop localCreate :: (
        .gChannelsAvailable--,
	.seizeHSTChannel(.iHSTChannel),
        "ok"
    )
       
    prop seizeHSTChannel :: (
	$1.iDelUser = "DHL",
	$1.iDHLAvailable = 0,
	$1.notify = @_DHL_notify,
	$1.arg0 = $1.iId,
	"ok"
    )
    prop localDelete ::(
        .gChannelsAvailable++,
	.releaseHSTChannel(.iHSTChannel),
        "ok"
    )
    prop releaseHSTChannel :: (
	$1.iDelUser = "USER",
	$1.iDHLAvailable = 1,
	$1.notify = @_FXN_F_nop,
	$1.arg0 = 0,
	"ok"
    )
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: "%8t .dhl: {}"
    prop _memSeg :: .OBJMEMSEG
    prop _placement :: (0x7fffffff / 2)
    global OBJMEMSEG :: IRAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iHSTChannel :: (
        scan ($i; HST) {
            if ($i.iDHLAvailable == 1) {
                $a = $i 
            }
        },
        $a
    ) {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Underlying HST Channel"
	prop JSName :: "hstChannel"
        prop MemberType :: HST
	prop MemberTest :: ((($1.iDHLAvailable == 1) || ($1 == .iHSTChannel)) ? 1 : 0)
        prop Set :: (
            if ($1.iDHLAvailable != 1) {
		 
                .error("This channel is already in use.")
            }
            else {
                .releaseHSTChannel(.iHSTChannel),
		.seizeHSTChannel($1),
                .iHSTChannel = $1,
                "ok"
            }
        )
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst iMode ::= .iHSTChannel.mode {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Mode"
	prop JSName :: "mode"
	prop Visible :: 1
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst iDevId ::= (.iHSTChannel.iId) {
	prop NoGen :: 0
    }
    
 
    inst iIsTerminal :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    inst iIsVirtual :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iFxns :: @_DHL_FXNS {
	prop NoGen :: 1
    }
}
 
type DPI {
    isa ObjectMgr
    prop name :: "DPI"
    prop Label :: "DPI - Pipe Driver"
    prop IsContainedIn :: SIODRIVER
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop GlobalHelpTopic :: (
	304
    )
    prop InstanceHelpTopic :: (
	404
    )
    prop InstancePropertyPage :: (
	"{7FE06FA0-2DE9-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{7FE06FA1-2DE9-11d1-988B-0020AFEE33C6}"
    )
    prop DependsOn :: "DEV"
    prop maxObjs :: (32767)
    prop isDriver :: (
	1
    )
    prop localCreate :: (
	.gCurDevId += 1,
	"ok"
    )
    global gCurDevId :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iDevId :: DPI.gCurDevId {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
	prop Set :: (
	    .error("DPI.iDevId parameter no longer settable, it is now handled automatically")
	)
    }
    inst iIsVirtual :: 0 {
        prop Label :: "Allow virtual instances of this device."
	prop JSName :: "allowVirtual"
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
	prop Set :: (
	    if ($1 == 1) {
		$a = "ok",
		$b = 1,
		scan ($i; SIO) {
		    if ($i.iDevice == self) {
			$a = .error("This DPI instance is being used by one or more SIO instances, cannot reconfigure"),
			$b = 0
		    }
		},
		if ($b == 1) {
		    .iIsVirtual = 1
		},
		$a
	    }
	    else {
		.iIsVirtual = 0,
		"ok"
	    }
	)
    }
    inst iIsTerminal :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    
 
    inst iFxns :: @_DPI_FXNS {
	prop NoGen :: 1
    }
}
 
type MSGQ {
    isa Module
    prop Visible :: 1
    prop name :: "MSGQ"
    prop Label :: "MSGQ - Message Queue Manager"
    prop IsConfMod :: .USEMSGQ 
    prop IsContainedIn :: IOF
    prop DependsOn :: "GIO,SIO"
 
    prop GlobalIcon :: 131
    prop InstanceIcon :: 132
    prop GlobalHelpTopic :: (
	323
    )
    prop InstanceHelpTopic :: (
	423
    )
    prop InstancePropertyPage :: (
	"{473C4A62-B1A8-11d0-9885-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{473C4A63-B1A8-11d0-9885-0020AFEE33C6}"
    )
    global USEMSGQ :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable MSGQ Manager"
	prop JSName :: "ENABLEMSGQ"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
}
 
type HOOK {
    isa ObjectMgr
    prop name :: "HOOK"
    prop Label :: "HOOK - Module Hook Manager"
    prop IsContainedIn :: SYSTEM
    prop DependsOn :: "SWI"
    prop InstancePropertyPage :: (
	"{473C4A64-B1A8-11d0-9885-0020AFEE33C6}"
    )
    prop GlobalIcon :: 181
    prop InstanceIcon :: 182
    prop GlobalHelpTopic :: (
	318
    )
    prop InstanceHelpTopic :: (
	418
    )
    prop localCreate :: (
	if (.gNumOf == 0) {
	    HOOK_KNL.iIsUsed = 1,
	    .mkId(0)
	},
	"ok"
    )
    
    prop localDelete :: (
	if (.gNumOf == 2) {
	    HOOK_KNL.iIsUsed = 0,
	    .rmId
	},
	"ok"
    )
    prop maxObjs :: (32767)	 
    
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    global KNLID ::= (HOOK_KNL.Order - 1) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    inst initFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Initialization function"
	prop JSName :: "initFxn"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst createFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Create function"
	prop JSName :: "createFxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER"
    }
    inst deleteFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Delete function"
	prop JSName :: "deleteFxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER"
    }
    inst exitFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Exit function"
	prop JSName :: "exitFxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER"
    }
    inst callSwitchFxn :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Call switch function"
	prop JSName :: "callSwitchFxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER"
    }
    inst switchFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Switch function"
	prop JSName :: "switchFxn"
	prop Visible :: 1
	prop Writable :: .callSwitchFxn
    }
    inst callReadyFxn :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Call ready function"
	prop JSName :: "callReadyFxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER"
    }
    inst readyFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Ready function"
	prop JSName :: "readyFxn"
	prop Visible :: 1
	prop Writable :: .callReadyFxn
    }
     
    inst Order :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
	prop NoGen :: 1
	prop Writable :: 1
    }
     
    inst iPri :: 0 {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}
object HOOK_KNL :: HOOK {
    param Order :: 1
    param iComment :: "Used to support TSK function hooks (cannot be deleted)"
    param iIsUsed :: 0
    param iDelUser :: "HOOK"
    param iDelMsg :: "This hook instance is used by TSK and cannot be deleted"
    param initFxn :: @_FXN_F_nop
    param createFxn :: TSK.CREATEFXN
    param deleteFxn :: TSK.DELETEFXN
    param exitFxn :: TSK.EXITFXN
    param callSwitchFxn :: TSK.DOSWITCH
    param switchFxn :: TSK.VSWFXN
    param callReadyFxn :: TSK.DOREADY
    param readyFxn :: TSK.VRDYFXN
}
