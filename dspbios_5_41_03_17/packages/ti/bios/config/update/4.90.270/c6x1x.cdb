/*
 *  Copyright 2010 by Texas Instruments Incorporated.
 *  @(#) DSP/BIOS_Kernel 5,2,5,28 02-10-2010 (cuda-u28)
 */
/*
 *  Do not modify this file; it's generated from c6x1x.cdb.h
 *  via mkseed!
 */

//# c6x1x.cdb 4.90.270
object IRAM :: MEM {
    param iComment :: (
	"This object defines space for the DSP's on-chip memory"
    )
    param iAllocHeap :: 0
    param iId :: 0
    param iIsUsed :: 1			
    param iDelUser :: "USER"
    param base :: 0x00000000
    param len ::  0x00010000
    param space :: "code/data"
}
object CACHE_L2 :: MEM {
    param iDelMsg :: "L2 Cache cannot be deleted by user"
    param iComment :: "Generated by Cache Settings in GBL"
    param iDelUser :: "MEM"
    param iIsUsed :: 0		
    param iIsModifiable :: 0
    param base :: 0x0
    param len :: 0x0
    param iAllocHeap :: 0
    param space :: "Cache"
}
 
class Module {
    prop Visible :: 1
    prop Writable :: 1
    prop IsConfMod :: (
	.gNumOf > 0 ? 1 : 0
    )
    prop NoGen	::  0
    prop IsDirty ::  (
	$a = .gDirty,
	.gDirty = 0,
	$a
    )
    
    prop dataSize :: 0
    
    
    prop error :: #(
	"Error: ", .name,
	$1
    )
    
    prop warning :: (
	"Warning ...", .name,
	$1
    )
    
    prop minBit	:: (
	$a = 0,
	while (($1 & (1 << $a)) && $a < 32) {
	    ++$a
	},
	$a
    )
    
    
    prop name :: (
	"<unnamed module>"
    )
    
    prop numBit :: (
	$a = $b = 0,
	while ($a < 32) {
	    if ($1 & (1 << $a)) {
		++$b
	    }
	},
	$b
    )
    
    
    global gInit ::= (
	$a = 0,
	$b = 0,
	scan ($i; self) {
	    if ($i.IsConfObj()) {
		$a += 1,
		if (self.isFinite) {
		    $b |= 1 << $i.iId
		}
	    }
	},
	.gNumOf = $a,
	.gSetOf = $b,
	if (.gInitFlag == 0) {
	    .localInit()
	},
	.gInitFlag = 1
    ) {
	prop Visible :: 0   
	prop Writable :: 0
	prop NoGen :: 1	    
    }
    global gInitFlag :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    global  gDirty :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global  gNumOf :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    global  gSetOf :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    global  gUser :: "USER" {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
}
class ObjectMgr {
    isa	    Module
    
    prop CanCreate :: (
	if (.gNumOf < .maxObjs()) {
	    .localCanCreate()
	}
	else {
	    .warning("Maximum number of objects already created")
	}
    )
    
    
    prop CanDelete :: (
	if (.iDelMsg == "ok" || (.iDelUser == .gUser)) {
	    if (.iId >= 0 && .iIsUsed) {
		.localCanDelete()
	    }
	    else {
		.warning("Object already deleted")
	    }
	}
	else {
	    .warning(.iDelMsg)
	}
    )
    
    
    prop Create	:: (
	(.gUser = ($0 > 0 ? $1 : "USER")),
	if (($a = .CanCreate()) == "ok") {
	    if (($a = .localCreate()) == "ok") {
		if (.iIsUsed == 0) {
		    .mkId($0 > 1 ? $2 : -1),
		    .iIsUsed = 1,
		    GlobalStatus.gDirty = 1,
		    .gDirty = 1
		}
	    }
	},
	(.gUser = "USER"),
	$a
    )
    
    prop Delete :: (
	(.gUser = ($0 > 0 ? $1 : "USER")),
	if (($a = .CanDelete()) == "ok") {
	    if (($a = .localDelete()) == "ok") {
		.rmId(.iId),
		.iIsUsed = 0,
		GlobalStatus.gDirty = 1,
		.gDirty = 1
	    }
	},
	(.gUser = "USER"),
	$a
    )
    
    
    prop GetSetOf :: (
	.gSetOf
    )
    
    
    prop GetNumOf :: (
	.gNumOf
    )
    
    
    prop GetObjId :: (
	.iId
    )
    
    prop GetPriority :: (
	.iId
    )
    
    
    prop SetPriority :: (
	.iId = $1
    )
    
    
    prop IsConfObj ::  (
	.iIsUsed
    )
    
    prop localCanCreate :: (
	"ok"
    )
    
    prop localCanDelete :: (
	"ok"
    )
    
    prop localCreate :: (
	"ok"
    )
    
    prop localDelete :: (
	"ok"
    )
    
    
    prop localInit :: (
	0
    )
    
    
    prop isFinite :: (
	.maxObjs() <= GBL.DSPWORDSIZE ? 1 : 0
    )
    
    
    prop mkId ::  (
	if (.isFinite()) {
	    if ($1 < 0) {
		.iId = .minBit(.gSetOf)
	    }
	    else {
		.iId = $1
	    },
	    (.gSetOf |= (1 << .iId))
	}
	else {
	    .iId = 0
	},
	++.gNumOf,
	.iId
    )
    
    
    prop rmId :: (
	if (.isFinite()) {
	    .gSetOf &= ~(1 << .iId)
	},
	--.gNumOf
    )
    
    
    prop maxObjs :: (
	GBL.DSPWORDSIZE
    )
    
    prop isDriver :: (
	0
    )
    
    prop SortChildHierView :: (
	1
    )
    inst iDelMsg :: "ok" {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    inst iDelUser :: "USER" {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iId :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst iIsUsed :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    inst iComment :: .iDelUser == "USER" ? "<add comments here>" : .iDelMsg {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "comment"
	prop JSName :: "comment"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER" ? 1 : 0
	prop NoGen :: 1
    }
}
					    
type GlobalStatus {
    prop NoGen :: 1
    prop Visible :: 0
    prop Writable :: 0
    prop Label :: "Current Configuration Status"
    prop GlobalIcon :: 101
    prop InstanceIcon :: 101
    prop GlobalHelpTopic :: (
	100
    )
    prop GlobalPropertyPage :: (
	"{9D3AD931-847B-11d0-A621-0000C070F3E9}"
    )
    global GENLIB :: "bioscfg.dll" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Generation Library"
	prop NoGen :: 1
	prop Visible :: 0
	prop Writable :: 0
    }
    
    global DATE :: "" {		
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global GCONFVERS :: "" {	
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global SysDataSize ::= (
	$a = 0,
	scan ($i; nil) {		    
	    if ($i.dataSize() != nil) {	    
		$a = $a + $i.dataSize()	    
	    }
	},
	$a
    ) {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "Estimated Data Size: %d"
	prop StatusField :: 1
	prop NoGen :: 1
    }
    global MinStackSize ::= (
	$a = ((2 * (2)) * 4),	    
	$a = $a + ((2 * (5)) * 4),	    
	$a = $a + ((0) * 4),	    
	$b = 0,
	scan ($i; CLK) {	    
	    if ($i.IsConfObj()) {
		$b |= 1
	    }
	},
	$a = $a + (((2 * (2)) * 4) * $b), 
	$b = 0,
	scan ($i; HWI) {	    
	    if ($i.IsConfObj()) {   
		if (($i.function != @HWI_unused) && ($i.function != @RESERVED)) {
		    $b++
		}
	    }
	},
	$a = $a + (((12 + 14 + 2) * 4) * $b),    
	$b = 0,
	scan ($i; SWI) {	    
	    if ($i.IsConfObj()) {   
		if ($i.priority > $b) {
		    $b = $i.priority
		}
	    }
	},
	$a = $a + ((((2 * 2) + 18 + (2 * 4)) * 4) * $b), 
	$b = 0,
	scan ($i; PRD) {	    
	    if ($i.IsConfObj()) {
		$b |= 1
	    }
	},
	$a = $a + (((2 * (3)) * 4) * $b), 
	$a
    ) {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "Est. Min. Stack Size (MAUs): %d"
	prop StatusField :: 1
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global ConfigWarnings ::= (
	if (.MinStackSize > MEM.STACKSIZE) {
	    "Application stack size is too small; decrease the number of SWI priorities or increase the stack in MEM."
	}
	else {
	    "None"
	}
    ) {
	prop Label :: "Warnings"
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global SeedVersion ::= "@(#)*** cuda-4.90.02.10" {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global gDirty :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    prop Status :: (#.SeedVersion, #.MinStackSize, #.SysDataSize)
}
class EModule {
    isa Module
    prop IsXMod :: (
        1
    )
    prop Vendor :: (
	""
    )
    prop Version :: (
	""
    )
}
class EObjectMgr {
    isa ObjectMgr
    prop IsXMod :: (
        1
    )
    prop Vendor :: (
        ""
    )
    prop Version :: (
        ""
    )
}
class ModuleFolder {
    isa Module
    prop NoGen :: 1
}
type SYSTEM {
    isa ModuleFolder
    prop Label :: "System"
    prop GlobalIcon :: 151
    prop GlobalHelpTopic :: (
	500
    )
    prop GlobalPropertyPage :: (
	"{B936FB91-52A5-11d4-947C-0050048381B7}"
    )
}
type INS {
    isa ModuleFolder
    prop Label :: "Instrumentation"
    prop GlobalIcon :: 152
    prop GlobalHelpTopic :: (
	501
    )
    prop GlobalPropertyPage :: (
	"{053C8F90-52A6-11d4-947C-0050048381B7}"
    )
}
type SCH {
    isa ModuleFolder
    prop Label :: "Scheduling"
    prop GlobalIcon :: 153
    prop GlobalHelpTopic :: (
	502
    )
    prop GlobalPropertyPage :: (
	"{053C8F91-52A6-11d4-947C-0050048381B7}"
    )
}
type SYN {
    isa ModuleFolder
    prop Label :: "Synchronization"
    prop GlobalIcon :: 154
    prop GlobalHelpTopic :: (
	503
    )
    prop GlobalPropertyPage :: (
	"{053C8F92-52A6-11d4-947C-0050048381B7}"
    )
}
type IOF {
    isa ModuleFolder
    prop Label :: "Input/Output"
    prop GlobalIcon :: 155
    prop GlobalHelpTopic :: (
	504
    )
    prop GlobalPropertyPage :: (
	"{053C8F93-52A6-11d4-947C-0050048381B7}"
    )
}
type PROJ {
    isa  ObjectMgr
    prop name :: "PROJ"
    prop maxObjs :: 0	
    prop Label :: "Project Manager"
    prop GlobalIcon :: 121
    prop InstanceIcon :: 122
    prop InstanceHelpTopic :: (
	201
    )
    
    prop GlobalHelpTopic :: (
	101
    )
    prop InstancePropertyPage :: (
	"{AC3C77D1-890B-11d0-A621-0000C070F3E9}"
    )
    
    prop GlobalPropertyPage :: (
	"{AC3C77D2-890B-11d0-A621-0000C070F3E9}"
    )
    prop NoGen :: 1
    prop Visible :: 0
    
    global ALIASALL :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Generate C Names for All Objects"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global IGNOREWARNING :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Ignore Warnings"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global LIBPATH :: ".;../../lib;$(BIOSROOT)/lib" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Library Search Path"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global INCPATH :: ".;../../include;$(BIOSROOT)/include" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Include File Search Path"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global OBJDIR :: "." {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Object file directory"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global EXTEXE :: "out" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Executable File Extension"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    global EXTLIB :: "lib" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Library File Extension"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    global EXTASM :: "asm" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Assembly Language Source File Extension"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    global EXTOBJ :: "obj" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Object File Extension"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst projType ::  "Executable" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "Executable,Library"
	prop Label :: "Target Type"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst projName :: "$(PROG)" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Target File Name"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst useRpt :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Use RPT Instruction"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst minimizeSpace :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Optimize for Space over Time"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    inst tmx :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Avoid TMX Silicon Bugs"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
}
type PROJ_FILE {
    isa ObjectMgr
    prop Visible :: 0
    
    prop Label :: "Project File Manager"
    
    prop InstanceHelpTopic :: (
	BIOSHELP_PROJ_FILE_INSTANCE
    )
    
    prop GlobalHelpTopic :: (
	BIOSHELP_PROJ_FILE_GLOBAL
    )
    prop InstancePropertyPage :: (
	"{AC3C77D3-890B-11d0-A621-0000C070F3E9}"
    )
    
    prop GlobalPropertyPage :: (
	"{AC3C77D4-890B-11d0-A621-0000C070F3E9}"
    )
    prop NoGen :: 1
    
    inst elemType ::  "C Source" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "C Source,ASM Source,Library,Linker Command File"
	prop Label :: "Input File Type"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst elemName :: "$(PROG)" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Input File Name"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst optLevel :: "register+local+global" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "register,register+local,register+local+global,register+local+global+file"
	prop Label :: "Optimization Level"
	prop Visible :: 0
	prop Writable :: .elemType == "C Source" ? 1 : 0
	prop NoGen :: 1
    }
    inst inline :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Inline Expansion"
	prop Visible :: 0
	prop Writable :: .elemType == "C Source" ? 1 : 0
	prop NoGen :: 1
    }
    inst definitions :: "" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Additional Definitions"
	prop Visible :: 0
	prop Writable :: .elemType == "C Source" ? 1 : 0
	prop NoGen :: 1
    }
    inst iParent :: 0 {
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
}
type GBL {
    isa Module
    prop name :: "GBL"
    prop Label :: "Global Settings"
    prop IsContainedIn :: SYSTEM
    prop cGen :: 1
    prop GenLinkPrologue :: (
	if ((GBL.ROM == 1) && (GBL.DSPTYPE == 54)) {
	    "%10S\nSECTIONS {%4t\n.vers (COPY): {} /* version information */%0t\n}\n\n-priority\n%1S-lbios5402.o54%24t/* BIOS ROM library */%0t\n-l%2S%3S\n%15S%4S%16S%5S%6S%12S%7S\0, _autoInitStr, _board, _librarySuffix, _devLibStr, _biosLibStr, _rtdxLibStr, _rtsLibStr, _librarySuffix, _compilerModel, _lnkCmdStr, _lnkCmdFile, _cslLibStr, _chipType, _devLibSuffix, _chipStr, _sioLibStr"
	}
	else {
	    "%10S\nSECTIONS {%4t\n.vers (COPY): {} /* version information */%0t\n}\n\n-priority\n%1S-l%2S%3S\n%15S%4S%16S%5S%6S%12S%7S\0, _autoInitStr, _board, _librarySuffix, _devLibStr, _biosLibStr, _rtdxLibStr, _rtsLibStr, _librarySuffix, _compilerModel, _lnkCmdStr, _lnkCmdFile, _cslLibStr, _chipType, _devLibSuffix, _chipStr, _sioLibStr"
	}
    )
    prop GenLinkEpilogue :: (
	"%0t_GBL_CACHE = GBL_CACHE;\n\0"
    )
    
    prop ConfigurationClass :: "{2779A121-92CC-11d1-A63D-0000C070F3E9}"
    prop GlobalIcon :: 105
    prop InstanceIcon :: 106
	
    prop GlobalHelpTopic :: (
	103
    )
    prop InstanceHelpTopic :: (
	103
    )
    prop InstancePropertyPage :: (
	"{B7240DE4-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
	"{B7240DE5-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    prop localInit :: (
	RTA_toHost.Create("HST"),
	RTA_fromHost.Create("HST"),
	RTA_dispatcher.Create("HST"),
	IDL_busyObj.Create("IDL"),
	IDL.USEIDLBUSYOBJ = 1,
	IDL_cpuLoad.Create("IDL")
    )
    
    prop chipcall :: (
	"ok"
    )
    prop IsConfMod :: 1		
    
    prop L2Check :: (
	if (.DSPSUBTYPE == 6211 || .DSPSUBTYPE == 6711) {
	    .PCC = "mapped",            
	    if (.C641XL2CONFIGURE == 1) {
		.C641XL2CONFIGURE = 0,
		.L2CONFIGALLOC = 0
	    }
	}
	else {
	    if (.DSPSUBTYPE == 6400) {
		.PCC = "mapped",        
		if (.C621XL2CONFIGURE == 1) {
		    .C621XL2CONFIGURE = 0
		}
	    }
	    else {
		if (.C621XL2CONFIGURE == 1) {
		    .C621XL2CONFIGURE = 0
		}
		else {
		    if (.C641XL2CONFIGURE == 1) {
		        .C641XL2CONFIGURE = 0,
		        .L2CONFIGALLOC = 0
		    }
		}
	    }
	},
	.L2CacheSizeCheck()
    )
    prop C621xL2CacheSizeCheck :: (
	$e = "ok",
	$a = CACHE_L2.base,
	$b = CACHE_L2.len,
	if ( .C621XL2CONFIGURE == 0 ) {
	    CACHE_L2.Delete("MEM")
	}
	else {
	    if (.L2MODEOPTS == "SRAM" ) {
		CACHE_L2.base = 0x0,
		CACHE_L2.len = 0x0,
		CACHE_L2.Delete("MEM")
	    }
            else {
                if (.L2MODEOPTS == "1-way cache" ) {
		    CACHE_L2.Create("MEM"),
		    CACHE_L2.base = .CHIPTYPE == "6713" || .CHIPTYPE == "DA610" ? 0x3c000 : 0xc000,
		    CACHE_L2.len = 0x4000
                }
                else {
                    if (.L2MODEOPTS == "2-way cache" ) {
			CACHE_L2.Create("MEM"),
			CACHE_L2.base = .CHIPTYPE == "6713" || .CHIPTYPE == "DA610" ? 0x38000:0x8000,
			CACHE_L2.len = 0x8000
                    }
                    else {
                        if (.L2MODEOPTS == "3-way cache" ) {
			    CACHE_L2.Create("MEM"),
			    CACHE_L2.base = .CHIPTYPE == "6713" || .CHIPTYPE == "DA610" ? 0x34000:0x4000,
			    CACHE_L2.len = 0xc000
        	        }
        	        else {
        	            if (.L2MODEOPTS == "4-way cache" ) {
				CACHE_L2.Create("MEM"),
				CACHE_L2.base = .CHIPTYPE == "6713" || .CHIPTYPE == "DA610" ? 0x30000 : 0x0000,
				CACHE_L2.len = 0x10000
        	            }
        	        }
            	    }
                }
            }
       	},
        $e
    )
    
    prop C641xL2CacheSizeCheck :: (
	$e = "ok",
	$a = CACHE_L2.base,
	$b = CACHE_L2.len,
	if ( .C641XL2CONFIGURE == 0 ) {
	    CACHE_L2.Delete("MEM")
	}
	else {
            if (.C641XL2MODEOPTS == "4-way cache (0k)" ) {
		CACHE_L2.base = 0x0,
		CACHE_L2.len = 0x0,
		CACHE_L2.Delete("MEM")
	    }
            else {
                if (.C641XL2MODEOPTS == "4-way cache (32k)" ) {
		    CACHE_L2.Create("MEM"),
		    CACHE_L2.base = .CHIPTYPE == "6412" ||
			.CHIPTYPE == "DM642"
			? 0x38000 : 0xf8000,
		    CACHE_L2.len = 0x8000
                }
                else {
                    if (.C641XL2MODEOPTS == "4-way cache (64k)" ) {
			CACHE_L2.Create("MEM"),
			CACHE_L2.base = .CHIPTYPE == "6412" ||
			    .CHIPTYPE == "DM642"
			    ? 0x30000 : 0xf0000,
			CACHE_L2.len = 0x10000
                    }
                    else {
                        if (.C641XL2MODEOPTS == "4-way cache (128k)" ) {
			    CACHE_L2.Create("MEM"),
			    CACHE_L2.base = .CHIPTYPE == "6412" ||
				.CHIPTYPE == "DM642"
				? 0x20000 : 0xe0000,
			    CACHE_L2.len = 0x20000
        	        }
        	        else {
        	            if (.C641XL2MODEOPTS == "4-way cache (256k)" ) {
				CACHE_L2.Create("MEM"),
			    	CACHE_L2.base = .CHIPTYPE == "6412" ||
				    .CHIPTYPE == "DM642"
				    ? 0x0 : 0xc0000,
				CACHE_L2.len = 0x40000
        	            }
            	        }
            	    }
                }
            }
       	},
        $e
    )
    prop L2CacheSizeCheck :: (
    $e = "ok",
    scan ($i; MEM) {
	if ($i == CACHE_L2) {
            if (.C621XL2CONFIGURE)  {
	        $e = .C621xL2CacheSizeCheck()
            }
            else {
	        if (.C641XL2CONFIGURE) {
		    $e = .C641xL2CacheSizeCheck()
	        }
	        else {
		    if ((.DSPSUBTYPE == 6211 || .DSPSUBTYPE == 6711)) {
		        $e = .C621xL2CacheSizeCheck()
		    }
		    else {
		        if (.DSPSUBTYPE == 6400) {
		    	    $e = .C641xL2CacheSizeCheck()
		        }
		        else {
			    CACHE_L2.base = 0x0,
			    CACHE_L2.len = 0x0,
			    CACHE_L2.Delete("MEM")
		        } 
		    }
	        }    
            }
        }
    },
    $e
    )
    global PRODUCT :: 0 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
	prop Visible :: 0
	prop Writable :: 1      
	prop EnvField :: 1
    }
    
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global CHIPCHAIN :: nil {
	prop Visible ::0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global TRACE :: "CD-01234567" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Trace Mask"
	prop NoGen :: 1
	prop Visible :: 0
	prop Writable :: 0
    }
    global BOARD :: "c6211" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Target Board Name"
	prop JSName :: "BOARDNAME"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global ROM :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Link to ROM Library"
	prop Visible :: 0
	prop Writable :: 0 
	prop NoGen :: 0
    }
    global CPUCLOCK :: GBL.DSPTYPE == 62 ? .MIPS : .MIPS * 2 {
	
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    global MIPS :: 150.0 {		
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style :: 0x04
	prop Format :: "%.4f"
	prop Label :: "DSP Speed In MHz (CLKOUT)"
	prop JSName :: "CLKOUT"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    $a = .MIPS,
	    $b = (GBL.DSPTYPE == 62) ? $1 : $1 * 2,
	    $e = "ok",
	    .MIPS = $1,
	    if (($e = .setCPUClock($b)) != "ok") {
		.MIPS = $a
	    },
	    $e
	)
    }
    prop setCPUClock :: (
	$e = "ok",
	if ($1 != .CPUCLOCK) {
	    $a = .CPUCLOCK,
	    .CPUCLOCK = $1,
	    if (GBL.CALLBACKOBJ != nil) {
		$e = GBL.CALLBACKOBJ.call()
	    },
	    if ($e != "ok") {
		.CPUCLOCK = $a,
		GBL.CALLBACKOBJ.call()
	    }
	},
	if ($e == "ok") {
	    "ok"
	}
	else {
	    .error($e)
	}
    )
    
    
    global OSTYPE :: "BIOS" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "BIOS"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    global DSPTYPE :: 62 {		
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "DSP Major Type"
	prop JSName :: "DSPTYPE"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global DSPSUBTYPE :: 6211 {	
	prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "6211,6711"
	prop Label :: "DSP Type"
	prop Visible :: 1
	prop Writable :: .CHIPTYPE == "other" || .CHIPTYPE == "custom"
	prop Set :: (.DSPSUBTYPE = $1,
		     .L2Check(),
		     "ok"
	)
	prop NoGen :: 1
    }
    global CHIPTYPE :: (
	if ( .DSPSUBTYPE == 6200) {
	    "6201"
	}
	else {
	    if ( .DSPSUBTYPE == 6211) {
		"6211"
	    }
	    else {
		if ( .DSPSUBTYPE == 6400 ) {
		    "6416"
		}
		else {
		    if ( .DSPSUBTYPE == 6700 ) {
			"6701"
		    }
		    else {
			"6711"
		    }
		}
	    }
	}
    )
    {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "6211,6711,6712,6713,DA610,custom,other"
	prop Label :: "Chip Support Library (CSL)"
	prop JSName :: "CHIPTYPE"
	prop NoGen :: 1
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    if ( $1 == "6201" || $1 == "6202" || $1 == "6203" ||
		 $1 == "6204" || $1 == "6205" ) {
		 .DSPSUBTYPE = 6200
	    }
	    else {
		if ($1 == "6701") {
		    .DSPSUBTYPE = 6700
		}
		else {
		    if ($1 == "6211") {
			.DSPSUBTYPE = 6211
		    }
		    else {
			if ($1 == "6711" || $1 == "6712" || $1 == "6713" || $1 == "DA610") {
			    .DSPSUBTYPE = 6711
			}
			else {
			    if ($1 == "DM642" || $1 == "6412" || $1 == "6414" ||
				$1 == "6415" || $1 == "6416") {
			        .DSPSUBTYPE = 6400
			    }	
			}
		    }
		}
	    },
	    .CHIPTYPE = $1,
	    .CSLNAME = .setCSLNAME(),
	    if (.CHIPTYPE == "other" || .CHIPTYPE == "custom") {
		.C621XL2CONFIGURE = 0,
		.C641XL2CONFIGURE = 0,
		.L2CONFIGURE = 0
	    },
	    .L2Check(),
	    $e = "ok",
	    if (GBL.CHIPCHAIN != nil) {
	        $e = GBL.CHIPCHAIN.chipcall()
	    },
	    $e
	)
    }
    prop setCSLNAME :: (
	if (.ENDIAN == "big") {
	  .CHIPTYPE == "6201" ? "csl6201e.lib" :
	    .CHIPTYPE == "6202" ? "csl6202e.lib" :
	      .CHIPTYPE == "6203" ? "csl6203e.lib" :
	        .CHIPTYPE == "6204" ? "csl6204e.lib" :
		  .CHIPTYPE == "6205" ? "csl6205e.lib" :
		    .CHIPTYPE == "6211" ? "csl6211e.lib" :
		      .CHIPTYPE == "6701" ? "csl6701e.lib" :
		        .CHIPTYPE == "6711" ? "csl6711e.lib" :
			  .CHIPTYPE == "6712" ? "csl6712e.lib" :
			    .CHIPTYPE == "6713" ? "csl6713e.lib" :
			      .CHIPTYPE == "DA610" ? "cslDA610e.lib" :
			        .CHIPTYPE == "DM642" ? "cslDM642e.lib" :
			          .CHIPTYPE == "6412" ? "csl6412e.lib" :
			            .CHIPTYPE == "6414" ? "csl6414e.lib" :
			              .CHIPTYPE == "6415" ? "csl6415e.lib" :
			                .CHIPTYPE == "6416" ? "csl6416e.lib" :
			                  ""
	}
	else {
	  .CHIPTYPE == "6201" ? "csl6201.lib" :
	    .CHIPTYPE == "6202" ? "csl6202.lib" :
	      .CHIPTYPE == "6203" ? "csl6203.lib" :
	        .CHIPTYPE == "6204" ? "csl6204.lib" :
		  .CHIPTYPE == "6205" ? "csl6205.lib" :
		    .CHIPTYPE == "6211" ? "csl6211.lib" :
		      .CHIPTYPE == "6701" ? "csl6701.lib" :
		        .CHIPTYPE == "6711" ? "csl6711.lib" :
		          .CHIPTYPE == "6712" ? "csl6712.lib" :
			    .CHIPTYPE == "6713" ? "csl6713.lib" :
			      .CHIPTYPE == "DA610" ? "cslDA610.lib" :
			        .CHIPTYPE == "DM642" ? "cslDM642.lib" :
			          .CHIPTYPE == "6412" ? "csl6412.lib" :
			            .CHIPTYPE == "6414" ? "csl6414.lib" :
			              .CHIPTYPE == "6415" ? "csl6415.lib" :
			                .CHIPTYPE == "6416" ? "csl6416.lib" :
			                  ""
	}
    )
    global CSLNAME ::= .setCSLNAME() {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label ::  "Chip Support Library Name"
	prop Visible :: 1
	prop Writable :: .CHIPTYPE == "custom"
	prop NoGen :: 1
    }
    global DISPCALLCSLCFGINIT ::= (
	    .CHIPTYPE != "other" && .CHIPTYPE != "custom"
	) {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Call CSL_cfgInit Initialization routine"
	prop Visible :: 0
	prop Writable :: .SUPPORTCSL
	prop NoGen :: 1
    }
    prop cGenCPrologue :: (
       "\n#ifdef __cplusplus\n#pragma CODE_SECTION(\".text:CSL_cfgInit\")\n#else\n#pragma CODE_SECTION(CSL_cfgInit,\".text:CSL_cfgInit\")\n#endif\n
\n#ifdef __cplusplus\n#pragma FUNC_EXT_CALLED()\n#else\n#pragma FUNC_EXT_CALLED(CSL_cfgInit)\n#endif\n"
    )
    global DSPNAME :: "TMS320C62XX" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global DSPARITHMETIC ::= (
	if (GBL.DSPTYPE == 62 && (GBL.DSPSUBTYPE / 100) == 67) {
	    "FLOAT"
	}
	else {
	    "FIXED"
	}
    ) {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "FIXED,FLOAT"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global DSPWORDSIZE :: = (
	if (GBL.DSPTYPE == 30 || GBL.DSPTYPE == 40 || GBL.DSPTYPE == 62) {
	    32		
	}
	else {
	    16		
	}
    ) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "DSP Word Size"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global DSPCHARSIZE :: = (GBL.DSPTYPE == 62 ? 8 : GBL.DSPWORDSIZE) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "DSP Byte Size"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    global DATAPTRSIZE ::= (
	if (GBL.DSPTYPE == 62) {
	    32
	}
	else {
	    if (GBL.DSPTYPE == 54) {
		16
	    }	
	    else {
		if (GBL.DSPTYPE == 55) {
		    if (GBL.MEMORYMODEL == "SMALL") {
			16	
		    }
		    else {
			23
		    }
		}
		else {
			if (GBL.DSPTYPE == 28) {
				22
			}
			else {	
		    		0
			}
		}
	    }
	})
    {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop iComment :: "Size of the Data Pointer"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global CODEPTRSIZE ::= (
	if (GBL.DSPTYPE == 62) {
	    32
	}
	else {
	    if (GBL.DSPTYPE == 54) {
		if (GBL.CALLMODEL == "near") {
		    16
		}
		else {
		    24
		}
	    }	
	    else {
		if (GBL.DSPTYPE == 55) {
		    24
		}
		else {
	            if (GBL.DSPTYPE == 28) {
			22
		    }
		    else {
			0
		    }
		}
	    }
	})
    {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop iComment :: "Size of Code Pointer"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global ENDIAN :: "little" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "little,big"
	prop Label :: "DSP Endian Mode"
	prop JSName :: "ENDIANMODE"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    .ENDIAN = $1,
	    .CSLNAME = .setCSLNAME(),
	    "ok"
	)
    }
    
    global BIGENDIAN ::= .ENDIAN == "little" ? 0 : 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global AUTOINIT :: "ROM" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "ROM,RAM"
	prop Label :: "C Autoinitialization Model"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    global USERINIT :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Call User Init Function"
	prop JSName :: "CALLUSERINITFXN"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    if ($1 == 0) {	
		.USERINITFXN = @_FXN_F_nop,
		.USERINIT = $1
	    }
	    else {
		.USERINIT = $1
	    },
	    "ok"
	)
    }
    global USERINITFXN :: @_FXN_F_nop {
    	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
    	prop Label :: "User Init Function"
	prop JSName :: "USERINITFXN"
        prop Visible :: 1
        prop Writable :: .USERINIT
        prop NoGen :: 0
    }
    global OLDAUTOCALCULATE :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "previous value for autocalculate"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global ENABLEINST :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable Real Time Analysis"
	prop JSName :: "ENABLEINST"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    if ($1 != .ENABLEINST) {	
	        if ($1) {	
		    RTA_toHost.Create("HST"),
		    RTA_fromHost.Create("HST"),
		    RTA_dispatcher.Create("HST"),
		    IDL_busyObj.Create("IDL"),
		    IDL.USEIDLBUSYOBJ = 1,
		    IDL_cpuLoad.Create("IDL"),
		    IDL.AUTOCALCULATE = .OLDAUTOCALCULATE
		}
	        else {
		    RTA_toHost.Delete("HST"),
		    RTA_fromHost.Delete("HST"),
		    RTA_dispatcher.Delete("HST"),
		    IDL_busyObj.Delete("IDL"),
		    IDL.USEIDLBUSYOBJ = 0,
		    IDL_cpuLoad.Delete("IDL"),
		    .OLDAUTOCALCULATE = IDL.AUTOCALCULATE,
		    IDL.AUTOCALCULATE = 0
		},
		.ENABLEINST = $1
	    },
	    "ok"
	)
    }
    
    global CGENERATE :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Do C Generation"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global PCC :: "mapped" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "mapped,cache enable,cache freeze,cache bypass"
        prop Label :: "Program Cache Control - CSR(PCC)       "
	prop JSName :: "CSRPCC"
        prop Visible :: 1
        prop Writable :: (
	    GBL.DSPSUBTYPE == 6211 || GBL.DSPSUBTYPE == 6711 ||
	    GBL.DSPSUBTYPE == 6400 || GBL.CHIPTYPE == "other" ||
	    GBL.CHIPTYPE == "custom")
	? 0 : 1
        prop NoGen :: 1
	prop TabName :: "620x/670x"
    }
    global DCC :: "mapped" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "mapped,cache enable,cache freeze,cache bypass"
        prop Label :: "Data Cache Control"
        prop Visible :: 0   
        prop Writable :: 1
        prop NoGen :: 1
	prop TabName :: "620x/670x"
    }
    global PCACHE ::= (
        if (.PCC == "mapped") {
            0x0000
        }
	else {
            if (.PCC == "cache enable") {
		0x0040
	    }
	    else {
		if (.PCC == "cache freeze") {
		    0x0060
		}
		else {
		    0x0080  
		}
	    }
        }
    ) {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DCACHE ::= (
        if (.DCC == "mapped") {
            0x0000
        }
        else {
            if (.DCC == "cache enable") {
                0x0008
            }
            else {
                if (.DCC == "cache freeze") {
                    0x000c
                }
                else {
                    0x0010  
                }
            }
        }
    ) {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CACHE ::= (.PCACHE | .DCACHE) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    } 
    global C621XL2CONFIGURE :: 0 {
    	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    	prop Label :: "621x/671x - Configure L2 Memory Settings"
	prop JSName :: "C621XCONFIGUREL2"
    	prop Visible :: 1
    	prop Writable :: (
	    GBL.CHIPTYPE == "6211" || GBL.CHIPTYPE == "6711" ||
	    GBL.CHIPTYPE == "6712" || GBL.CHIPTYPE == "6713" ||
	    GBL.CHIPTYPE == "DA610")
	? 1 : 0
	prop TabName :: "621x/671x"
	prop Set :: (
	    $e = "ok",
	    .C621XL2CONFIGURE = $1,
	    .L2CONFIGURE = $1,
	    .PCC = "mapped",
	    $e = .L2CacheSizeCheck(),
	    $e
	)
	prop NoGen :: 1
    }
    global C641XL2CONFIGURE :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "641x - Configure L2 Memory Settings"
	prop JSName :: "C641XCONFIGUREL2"
	prop Visible :: 1
	prop Writable :: (
	    GBL.CHIPTYPE == "6414" || GBL.CHIPTYPE == "6415" ||
	    GBL.CHIPTYPE == "6416" || GBL.CHIPTYPE == "6412" ||
	    GBL.CHIPTYPE == "DM642" )
	? 1 : 0
	prop TabName :: "641x"
	prop Set :: (
	    $e = "ok",
	    .C641XL2CONFIGURE = $1,
	    .L2CONFIGURE = $1,
	    .PCC = "mapped",
	    $e = .L2CacheSizeCheck(),
	    $e
	)
    	prop NoGen :: 1
    }
    
    global L2CONFIGURE ::= (.C621XL2CONFIGURE | .C641XL2CONFIGURE) {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Configure L2 Cache Control (c6x1x support)"
        prop Visible :: 0   
        prop NoGen :: 0
    }
    global C621XPCC :: "Cache Enabled - Direct Mapped" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Cache Enabled - Direct Mapped"
        prop Label :: "Program Cache Control - CSR(PCC)                     "
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "621x/671x"
    }
    global C641XPCC :: "Cache Enabled - Direct Mapped" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Cache Enabled - Direct Mapped"
        prop Label :: "641x - Program Cache Control - CSR(PCC)"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "641x"
    }
    global L2MODEOPTS ::= "SRAM" { 
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "L2 Mode - CCFG(L2MODE)"
	prop JSName :: "C621XCCFGL2MODE"
	prop Enum :: "SRAM,1-way cache,2-way cache,3-way cache,4-way cache"
	prop Visible :: 1
        prop Writable :: ((GBL.CHIPTYPE == "6211" || GBL.CHIPTYPE == "6711" || GBL.CHIPTYPE == "6712" || GBL.CHIPTYPE == "6713" || GBL.CHIPTYPE == "DA610")
			&& GBL.L2CONFIGURE == 1)
			? 1 
			: 0
	prop NoGen :: 1
	prop TabName :: "621x/671x"
	prop Set :: (
	    $i = .L2MODEOPTS,
	    .L2MODEOPTS = $1,
	    $e = .L2CacheSizeCheck(),
	    if ($e != "ok") {
		.L2MODEOPTS = $i
	    },
	    $e
	)
    }
    global C641XL2MODEOPTS :: "4-way cache (0k)" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "641x L2 Mode - CCFG(L2MODE)"
        prop Enum :: "4-way cache (0k),4-way cache (32k),4-way cache (64k),4-way cache (128k),4-way cache (256k)"
	prop JSName :: "C641XCCFGL2MODE"
        prop Visible :: 1
        prop Writable :: ((GBL.DSPSUBTYPE == 6400) && GBL.L2CONFIGURE ==1)
			     ? 1
	    		     : 0
        prop NoGen :: 1
        prop TabName :: "641x"
	prop Set :: (
	    $i = .C641XL2MODEOPTS,
	    .C641XL2MODEOPTS = $1,
	    $e = .L2CacheSizeCheck(),
	    if ($e != "ok") {
		.C641XL2MODEOPTS = $i
	    },
	    $e
	)
    }
    prop setL2MODE :: (
	if (.L2MODEOPTS == "SRAM") {
	    0x0
	}
	else {
	    if (.L2MODEOPTS == "1-way cache") {
		0x1
	    }
	    else {
		if (.L2MODEOPTS == "2-way cache") {
		    0x2
		}
	        else {
		    if (.L2MODEOPTS == "3-way cache") {
			0x3
		    }	
		    else {
			0x7
		    }
		}
	    }
	}
    )
    prop setC641XL2MODE :: (
	if (.C641XL2MODEOPTS == "4-way cache (0k)") {
		0x0
	}
	else {
	    if (.C641XL2MODEOPTS == "4-way cache (32k)") {
	        0x1
	    }
	    else {
	        if (.C641XL2MODEOPTS == "4-way cache (64k)") {
		    0x2
	        }
		else {
		    if (.C641XL2MODEOPTS == "4-way cache (128k)") {
		        0x3
		    }
	            else {
	                0x7
		    }
	        }
	    }
        }
    )
    global L2MODE ::= if (GBL.DSPSUBTYPE == 6400) {
			  .setC641XL2MODE()
		      }
		      else {
			  .setL2MODE()
		      } {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "L2 Mode - CCFG(L2MODE) Values"
        prop Enum :: "0,1,2,3,7"
	prop Visible :: 0
        prop Writable :: ((GBL.CHIPTYPE == "6211" || GBL.CHIPTYPE == "6711" || GBL.CHIPTYPE == "6712" || GBL.CHIPTYPE == "6713" || GBL.CHIPTYPE == "DA610" )
			&& GBL.L2CONFIGURE == 1) 
			? 1 
			: 0
	prop NoGen :: 0
    }
    global L2PRIORITY :: 0 {
	prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "L2 Requestor Priority - CCFG(P)"
	prop Enum :: "0,1"
	prop Visible :: 0
	prop Writable :: ((GBL.CHIPTYPE == "6211" || GBL.CHIPTYPE == "6711" || GBL.CHIPTYPE == "6712" || GBL.CHIPTYPE == "6713" || GBL.CHIPTYPE == "DA610")
			 && GBL.L2CONFIGURE == 1)
			 ? 1
			 : 0
	prop NoGen :: 0
    }
    global L2MARMASK :: 0x0001 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Label :: "L2 MAR0-15 - bitmask used to initialize MARs"
	prop JSName :: "C621XMAR"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
	prop Visible :: 1
        prop Writable :: ((GBL.CHIPTYPE == "6211" || GBL.CHIPTYPE == "6711" || GBL.CHIPTYPE == "6712" || GBL.CHIPTYPE == "6713" || GBL.CHIPTYPE == "DA610")
			&& GBL.L2CONFIGURE == 1)
			? 1 
			: 0
	prop NoGen :: 0
	prop TabName :: "621x/671x"
    }
    global SUPPORTCSL ::= .CHIPTYPE != "other" {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 0
    }
    global ENABLEALLTRC :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable All TRC Trace Event Classes"
	prop JSName :: "ENABLEALLTRC"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    if ($1) {
		.TRCMASKVALUE = 0xDBEF
	    }
	    else {
		.TRCMASKVALUE = 0x4000
	    },
	    .ENABLEALLTRC = $1,
	    "ok"
	)
    }
    global TRCMASKVALUE :: 0xDBEF {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 0
    }
    global CALLCSLCFGINIT ::= .DISPCALLCSLCFGINIT {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 0
    }
 
    
    global CDBPATH :: "" { 
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "CDB search path in COFF file"
	prop JSName :: "CDBRELATIVEPATH"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global C641XL2PRIORITY :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: ((GBL.DSPSUBTYPE == 6400)
			    && GBL.L2CONFIGURE == 1)
			    ? 1
			    : 0
	prop NoGen :: 0
	prop TabName :: "641x"
    }
    global L2MARMASK1 :: 0x0 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR96-111 - bitmask controls EMIFB CE space"
	prop JSName :: "C641XMAREMIFB"
	prop Format :: "0x%04x"
	prop Style :: 0x01 | 0x02
	prop Visible :: 1
	prop Writable :: ((GBL.DSPSUBTYPE == 6400)
			&& GBL.L2CONFIGURE == 1)
			? 1
			: 0
	prop NoGen :: 0
	prop TabName :: "641x"
    }
    global L2MARMASK2 :: 0x0 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR128-143 - bitmask controls EMIFA CE0 space"
	prop JSName :: "C641XMARCE0"
	prop Format :: "0x%04x"
	prop Style :: 0x01 | 0x02
	prop Visible :: 1
	prop Writable :: ((GBL.DSPSUBTYPE == 6400)
			    && GBL.L2CONFIGURE == 1)
			    ? 1
			    : 0
	prop NoGen :: 0
	prop TabName :: "641x"
    }
    global L2MARMASK3 :: 0x0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Label :: "MAR144-159 - bitmask controls EMIFA CE1 space"
	prop JSName :: "C641XMARCE1"
	prop Format :: "0x%04x"
	prop Style :: 0x01 | 0x02
	prop Visible :: 1
	prop Writable :: ((GBL.DSPSUBTYPE == 6400)
			    && GBL.L2CONFIGURE == 1)
			    ? 1
			    : 0
	prop NoGen :: 0
	prop TabName :: "641x"
    }
    global L2MARMASK4 :: 0x0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Label :: "MAR160-175 - bitmask controls EMIFA CE2 space"
	prop JSName :: "C641XMARCE2"
	prop Format :: "0x%04x"
	prop Style :: 0x01 | 0x02
	prop Visible :: 1
	prop Writable :: ((GBL.DSPSUBTYPE == 6400)
			    && GBL.L2CONFIGURE == 1)
			    ? 1
			    : 0
	prop NoGen :: 0
	prop TabName :: "641x"
    }
    global L2MARMASK5 :: 0x0 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR176-191 - bitmask controls EMIFA CE3 space"
	prop JSName :: "C641XMARCE3"
	prop Format :: "0x%04x"
	prop Style :: 0x01 | 0x02
	prop Visible :: 1
	prop Writable :: ((GBL.DSPSUBTYPE == 6400)
			    && GBL.L2CONFIGURE == 1)
			    ? 1
			    : 0
	prop NoGen :: 0
	prop TabName :: "641x"
    }
    global L2REQPRIORITY :: "urgent" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "641x L2 Requestor Priority Queue - CCFG(P)"
	prop JSName :: "C641XCCFGP"
	prop Enum :: "urgent,high,medium,low"
	prop Visible :: 1
	prop Writable :: ((GBL.DSPSUBTYPE == 6400)
			    && GBL.L2CONFIGURE == 1)
			    ? 1
			    : 0
	prop NoGen :: 1
	prop Set :: (
		.L2REQPRIORITY = $1,
		if (.L2REQPRIORITY == "urgent") {
		    .C641XL2PRIORITY = 0
		}
		else {
		    if (.L2REQPRIORITY == "high") {
			.C641XL2PRIORITY = 1
		    }
		    else {
		        if (.L2REQPRIORITY == "medium") {
			    .C641XL2PRIORITY = 2
		        }
			else {
			    .C641XL2PRIORITY = 3
		        }
		    }
		},
		"ok"
	)
	prop TabName :: "641x"
    }
    global L2CONFIGALLOC :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Configure Priority Queues"
	prop JSName :: "C641XSETL2ALLOC"
	prop Visible :: 1
	prop Writable :: (GBL.DSPSUBTYPE == 6400 && GBL.L2CONFIGURE == 1)
	prop NoGen :: 0
	prop TabName :: "641x"
    }
    global L2ALLOC0 :: 6 {
	prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Max L2 Transfer Requests on URGENT Queue (L2ALLOC0)"
	prop JSName :: "C641XL2ALLOC0"
	prop Enum :: "0,1,2,3,4,5,6,7"
	prop Visible :: 1
	prop Writable :: (GBL.DSPSUBTYPE == 6400 && GBL.L2CONFIGURE == 1 &&
			    GBL.L2CONFIGALLOC == 1)
			    ? 1
			    : 0
	prop NoGen :: 1
	prop TabName :: "641x"
    }
    global L2ALLOC1 :: 2 {
	prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Max L2 Transfer Requests on HIGH Queue (L2ALLOC1)"
	prop JSName :: "C641XL2ALLOC1"
	prop Enum :: "0,1,2,3,4,5,6,7"
	prop Visible :: 1
	prop Writable :: (GBL.DSPSUBTYPE == 6400 && GBL.L2CONFIGURE == 1 &&
			    GBL.L2CONFIGALLOC == 1)
			    ? 1
			    : 0
	prop NoGen :: 1
	prop TabName :: "641x"
    }
    global L2ALLOC2 :: 2 {
	prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Max L2 Transfer Requests on MEDIUM Queue (L2ALLOC2)"
	prop JSName :: "C641XL2ALLOC2"
	prop Enum :: "0,1,2,3,4,5,6,7"
	prop Visible :: 1
	prop Writable :: (GBL.DSPSUBTYPE == 6400 && GBL.L2CONFIGURE == 1 &&
			    GBL.L2CONFIGALLOC == 1)
			    ? 1
			    : 0
	prop NoGen :: 1
	prop TabName :: "641x"
    }
    global L2ALLOC3 :: 2 {
	prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Max L2 Transfer Requests on LOW Queue (L2ALLOC3)"
	prop JSName :: "C641XL2ALLOC3"
	prop Enum :: "0,1,2,3,4,5,6,7"
	prop Visible :: 1
	prop Writable :: (GBL.DSPSUBTYPE == 6400 && GBL.L2CONFIGURE == 1 &&
			    GBL.L2CONFIGALLOC == 1)
			    ? 1
			    : 0
	prop NoGen :: 1
	prop TabName :: "641x"
    }
    global L2ALLOC ::= ( (.L2ALLOC0) | (.L2ALLOC1 << 4) | (.L2ALLOC2 << 8) | (.L2ALLOC3 << 12)) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop NoGen :: 0
    }
    prop _cint00Str :: "-u_c_int00 %24t/* link with alternate boot.obj */%0t\n"
    prop _autoInitStr :: ""
    prop _board :: (
	if (HST.RTDX == 1) {
	    "lnkrtdx"
	}
	else {
	    if (HST.DSM == 1) {
	        "lnkdsm"
	    }
	    else {
		if(HST.EVM54 == 1) {
		    "lnkevm54"
	 	}
	        else {
	            "lnknone"
	        }
	    }
	}
    )
    prop _dsptype :: GBL.DSPTYPE
    prop _compilerModel :: .ENDIAN == "big" ? "e" : ""
    prop _librarySuffix :: (
	if ( .DSPSUBTYPE == 6400 ) {
	    if ( .ENDIAN == "big" ) {
	      ".a64e"
	    }
	    else {
		".a64"
	    }
	}
	else {
	   if ( .ENDIAN == "big" ) {
	       ".a62e"
	   }
	   else {
	       ".a62"
	   }
	}
    )
    prop _devLibSuffix :: (
        if ( .DSPSUBTYPE == 6700 || .DSPSUBTYPE == 6711) {
            if ( .ENDIAN == "big" ) {
              ".a67e"
            }
            else {
                ".a67"
            }
        }
        else {
            if ( .DSPSUBTYPE == 6400 ) {
                if ( .ENDIAN == "big" ) {
                  ".a64e"
                }
                else {
                    ".a64"
                }
            }
            else {
               if ( .ENDIAN == "big" ) {
                   ".a62e"
               }
               else {
                   ".a62"
               }
            }
        }
    )
    prop _rtdxLibStr :: RTDX.RTDXTYPE == "JTAG" ?
	"-lrtdx%9S.lib %24t/* RTDX support */%0t\n" :
	RTDX.RTDXTYPE == "Simulator" ?
	    "-lrtdxsim%9S.lib %24t/* RTDX support */%0t\n" :
	    "-lrtdxhs%9S.lib %24t/* RTDX support */%0t\n"
    prop _rtsLibStr :: (
	if (.DSPSUBTYPE == 6700 || .DSPSUBTYPE == 6711) {
	    "-lrts6700%9S.lib%24t/* C and C++ run-time library support */%0t\n"
   	} 
	else {
	    if ( .DSPSUBTYPE == 6400 ) {
	        "-lrts6400%9S.lib%24t/* C and C++ run-time library support */%0t\n"
	    }
	    else {
	        "-lrts6200%9S.lib%24t/* C and C++ run-time library support */%0t\n"
	    }
	}
    )
    prop _chipStr :: ""
    
    prop _biosLibStr :: .ENABLEINST ?
        "-lbiosi%8S %24t/* DSP/BIOS support */%0t\n"
    :
        "-lbios%8S %24t/* DSP/BIOS support */%0t\n"
    prop _sioLibStr :: SIO.USEISSUERECLAIM == 1 ?
	"-lsioir%8S %24t/* supports SIO Issue/Reclaim model only */%0t\n" :
	"-lsioboth%8S %24t/* supports both SIO models */%0t\n"
    prop _devLibStr :: "-ldrivers%14S %24t/* device drivers support */%0t\n"
    prop _lnkCmdFile :: MEM.LNKCMDFILE
    prop _lnkCmdStr :: (
	if (MEM.LNKCMDFILE == "") {
	    ""
	}
	else {
	    "-l%11S %24t/* User Specified Linker cmd file */%0t\n"
	}
    )
    prop _cslLibStr :: .CSLNAME == "" ? "" : "-l%13S\n"
    prop _chipType :: .CSLNAME
}
type MEM {
    isa ObjectMgr
    prop Label :: "MEM - Memory Section Manager"
    prop name :: "MEM"
    
    prop DependsOn :: "SEM"
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 115
    prop InstanceIcon :: 116
    prop GlobalHelpTopic :: (
	108
    )
    prop InstanceHelpTopic :: (
	208
    )
    prop InstancePropertyPage :: (
	    "{3D658E70-05E7-11d0-BD44-0020AFEE33C8}"
    )
    
    prop GlobalPropertyPage :: (
	    "{3D658E71-05E7-11d0-BD44-0020AFEE33C8}"
    )
    prop GenLinkPrologue :: (
	if (GBL.DSPTYPE == 55) {
	    "-stack 0x%1x\n-sysstack 0x%2x\n\nSECTIONS { .sysstack : block(0x20000) fill = 0xfeeb {%12t\nGBL_sysstackbeg = .;\n*(.sysstack)\nGBL_sysstackend = GBL_sysstackbeg + 0x%2x -1 ;%12t\n _HWI_SYSSTKTOP = GBL_sysstackbeg; %12t\n _HWI_SYSSTKBOTTOM =
(GBL_sysstackend+1);\n%8t} > %3s}%0t\n\nMEMORY {%4t\0, _cmd55stksz, _cmd55systksz, _sysstackSeg"
	}
	else {
	    "-stack 0x%1x\nMEMORY {%4t\0, _stackSize"
	}
    )
    prop _stackSize :: MEM.STACKSIZE
    prop AllocType :: (
	if (.REUSE == 0 && .USERCMD == 0) {
	"19\0,	_argsString,	_argsSeg,	_midPlace, \
		_sysdataString,	_sysdataSeg,	_thirdPlace, \
		_trcinitString,	_trcinitSeg,	_midPlace, \
		_gblinitString,	_gblinitSeg,	_midPlace, \
		_memObjString,	_memObjSeg,	_midPlace, \
		_sysinitString,	_initSeg,	_sysinitPlace, \
		_sysregsString,	_regsSeg,	_midPlace, \
		_bssString,	_bssSeg,	_firstPlace, \
		_farString,	_farSeg,	_secondPlace, \
		_cinitString,	_cinitSeg,	_midPlace, \
		_pinitString,	_pinitSeg,	_midPlace, \
		_dataString,	_dataSeg,	_midPlace, \
		_constString,	_constSeg,	_midPlace, \
		_switchString,	_switchSeg,	_midPlace, \
		_cioString,	_cioSeg,	_midPlace, \
		_textString,	_textSeg,	_midPlace, \
		_frtString,	_frtSeg,	_midPlace, \
		_biosString,	_biosSeg,	_midPlace, \
		_stackString,	_stackSeg,	_midPlace"
	}
	else { if (.REUSE == 0 && .USERCMD == 1) {
	"9\0,	_argsString,	_argsSeg,	_midPlace, \
		_sysdataString,	_sysdataSeg,	_thirdPlace, \
		_trcinitString,	_trcinitSeg,	_midPlace, \
		_gblinitString,	_gblinitSeg,	_midPlace, \
		_memObjString,	_memObjSeg,	_midPlace, \
		_sysinitString,	_initSeg,	_sysinitPlace, \
		_sysregsString,	_regsSeg,	_midPlace, \
		_biosString,	_biosSeg,	_midPlace, \
		_stackString,	_stackSeg,	_midPlace"
	}
	else { if (.REUSE == 1 && .USERCMD == 0) {
	
	"18\0,	_argsString,	_argsSeg,	_midPlace, \
		_sysdataString,	_sysdataSeg,	_thirdPlace, \
		_trcinitString,	_trcinitSeg,	_midPlace, \
		_gblinitString,	_gblinitSeg,	_midPlace, \
		_memObjString,	_memObjSeg,	_midPlace, \
		_sysregsString,	_regsSeg,	_midPlace, \
		_bssString,	_bssSeg,	_firstPlace, \
		_farString,	_farSeg,	_secondPlace, \
		_cinitString,	_cinitSeg,	_midPlace, \
		_pinitString,	_pinitSeg,	_midPlace, \
		_dataString,	_dataSeg,	_midPlace, \
		_constString,	_constSeg,	_midPlace, \
		_switchString,	_switchSeg,	_midPlace, \
		_cioString,	_cioSeg,	_midPlace, \
		_textString,	_textSeg,	_midPlace, \
		_frtString,	_frtSeg,	_midPlace, \
		_biosString,	_biosSeg,	_midPlace, \
		_stackString,	_stackSeg,	_midPlace"
	}
	else { 
	"8\0,	_argsString,	_argsSeg,	_midPlace, \
		_sysdataString,	_sysdataSeg,	_thirdPlace, \
		_trcinitString,	_trcinitSeg,	_midPlace, \
		_gblinitString,	_gblinitSeg,	_midPlace, \
		_memObjString,	_memObjSeg,	_midPlace, \
		_sysregsString,	_regsSeg,	_midPlace, \
		_biosString,	_biosSeg,	_midPlace, \
		_stackString,	_stackSeg,	_midPlace"
	}}}
    )
 
    prop _firstPlace  :: 0 
    prop _secondPlace :: 0 + 1
    prop _thirdPlace :: 0 + 2
    prop _midPlace    :: (0x7fffffff / 2)
    prop _sysinitPlace :: (0x7fffffff / 2)
    prop _argsString    :: ("%8t .args: fill=0 {%12t\n *(.args)\n . += 0x%1x;%8t\n }\0, _argsSize")
    prop _bssString     :: ("%8t .bss:     {}")
    prop _farString     :: ("%8t .far:     {}")
    prop _cinitString   :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.CINITSEG == MEM.LOADCINITSEG) {
		"%8t .cinit:    {}"
	    }
	    else {
		"%8t .cinit:   {} load > %1s, run\0, _loadcinitSeg"
	    }
	}
	else {
	    "%8t .cinit:    {}"
	}
    )
    prop _pinitString   :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.PINITSEG == MEM.LOADPINITSEG) {
		"%8t .pinit:   {}"
	    }
	    else {
		"%8t .pinit:   {} load > %1s, run\0, _loadpinitSeg"
	    }
	}
	else {
		"%8t .pinit:   {}"
	}
    )
prop _trcinitString :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.TRCINITSEG == MEM.LOADTRCINITSEG) {
		"%8t .trcdata:   {}"
	    }
	    else {
		"%8t .trcdata:   {} load > %1s, run\0, _loadtrcinitSeg"
            }
        }
	else {
	    "%8t .trcdata:    {}"
	}
    )
    prop _gblinitString :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.BIOSINITSEG == MEM.LOADBIOSINITSEG) {
		"%8t .gblinit:   {}"
    	    }
	    else {
		"%8t .gblinit:   {} load > %1s, run\0, _loadgblinitSeg"
   	    }
	}
	else {
	    "%8t .gblinit:    {}"
	}
    )
    prop _dataString    :: ("%8t .data:    {}")
    prop _constString   :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.CONSTSEG == MEM.LOADCONSTSEG) {
		"%8t .const:   {}"
	    }
	    else {
		 if ((62 == 54) || (62 == 28)) {
	       "%8t .const:   {} load > %1s PAGE %2s, run\0, _loadconstSeg, _pg" 
              }
              else {
                "%8t .const: {} load > %1s, run\0, _loadconstSeg"
              }
	    }
	}
	else {
	    "%8t .const:    {}"
	}
    )
    prop _switchString  :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.SWITCHSEG == MEM.LOADSWITCHSEG) {
		"%8t .switch:   {}"
	    }
	    else {
		"%8t .switch:   {} load > %1s, run\0, _loadswitchSeg"
	    }
	}
	else {
	    "%8t .switch:    {}"
	}
    )
    prop _sysmemString	:: ("%8t .sysmem:  {}")
    prop _cioString	:: ("%8t .cio:     {}")
    prop _memObjString  :: ("%8t .mem: 	  {}")
    prop _sysdataString :: (
	if((GBL.ROM == 0) && (GBL.DSPTYPE == 54)) {
	    "%8t .sysdata: align = 128 {%12t\n GBL_A_SYSPAGE = .;\n GBL_A_SYSDP = GBL_A_SYSPAGE >> 7;\n %8t }"
	}
	else {
	    "%8t .sysdata: {}"
	}
    )
    prop _sysinitString :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.INITSEG == MEM.LOADINITSEG) {
		"%8t .sysinit:   {}"
	    }
	    else {
		"%8t .sysinit:   {} load > %1s, run\0, _loadinitSeg"
	    }
        }
	else {
	    "%8t .sysinit:    {}"
	}
    )
    prop _sysregsString :: ("%8t .sysregs: {}")
    prop _textString  :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.TEXTSEG == MEM.LOADTEXTSEG) {
		"%8t .text:    {}"
	    }
	    else {
		"%8t .text:    {} load > %1s, run\0, _loadtextSeg"
	    }
        }
	else {
	    "%8t .text:    {}"
	}
    )
    prop _frtString	:: ("%8t frt:    {}")
    prop _biosString    :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.BIOSSEG == MEM.LOADBIOSSEG) {
		"%8t .bios:    {}"
	    }
	    else {
		"%8t .bios:    {} load > %1s, run\0, _loadbiosSeg"
    	   }
    	}
	else {
	    "%8t .bios:    {}"
	}
    )
    prop _stackString :: (
      if (GBL.DSPTYPE == 62) {
         "%8t .stack: fill=0xc0ffee {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = GBL_stackbeg + 0x%1x - 1;%12t\n _HWI_STKBOTTOM = GBL_stackbeg + 0x%1x - 4 & ~7;%12t\n _HWI_STKTOP = GBL_stackbeg;%8t\n }\0, _stackSize, _stackSize"
      }
      else {
	if (GBL.DSPTYPE == 54) {
             "%8t .stack: fill=0xbeef {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = ((GBL_stackbeg + 0x%1x - 1) & 0xfffe) ;%8t\n _HWI_STKBOTTOM = GBL_stackend;%12t\n _HWI_STKTOP = GBL_stackbeg;%8t\n }\0, _stackSize"
        }
        else {
	 if (GBL.DSPTYPE == 55) {
		"%8t .stack: block(0x20000) fill=0xbeef {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = (GBL_stackbeg + 0x%1x - 1) ;%12t\n _HWI_STKBOTTOM = (GBL_stackend+1);%12t\n _HWI_STKTOP = (GBL_stackbeg);%8t\n }\0, _cmd55stksz"
		 }
	  else
	   {  
             "%8t .stack: fill=0xbeef {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = GBL_stackbeg + 0x%1x - 1;%8t\n _HWI_STKBOTTOM = GBL_stackbeg;%12t\n _HWI_STKTOP = (GBL_stackend + 1);%8t\n }\0, _stackSize"
          }
        }
      }
    )
    prop _memHdrSize :: 8
    prop GenLinkEpilogue :: (
	"%0t}"
    )
    prop _stackSeg :: MEM.STACKSEG
    prop _textSeg :: MEM.TEXTSEG
    prop _frtSeg :: MEM.TEXTSEG
    prop _biosSeg :: MEM.BIOSSEG
    prop _dataSeg :: MEM.DATASEG
    prop _cioSeg :: MEM.CIOSEG
    prop _sysmemSeg :: MEM.SYSMEMSEG
    prop _constSeg :: MEM.CONSTSEG
    prop _initSeg :: MEM.INITSEG
    prop _pinitSeg :: MEM.PINITSEG              
    prop _trcinitSeg :: MEM.TRCINITSEG
    prop _gblinitSeg :: MEM.BIOSINITSEG
    prop _regsSeg :: MEM.SYSDATASEG		
    prop _sysdataSeg :: MEM.SYSDATASEG
    prop _argsSeg :: MEM.ARGSSEG
    prop _argsSize :: MEM.ARGSSIZE
    prop _bssSeg :: MEM.BSSSEG
    prop _farSeg :: MEM.FARSEG
    prop _cinitSeg :: MEM.CINITSEG
    prop _memObjSeg :: MEM.CFGOBJSEG
    prop _switchSeg :: MEM.SWITCHSEG
    prop _loadtextSeg :: MEM.LOADTEXTSEG
    prop _loadbiosSeg :: MEM.LOADBIOSSEG
    prop _loadconstSeg :: MEM.LOADCONSTSEG
    prop _loadinitSeg :: MEM.LOADINITSEG
    prop _loadpinitSeg :: MEM.LOADPINITSEG      
    prop _loadtrcinitSeg :: MEM.LOADTRCINITSEG
    prop _loadgblinitSeg :: MEM.LOADBIOSINITSEG
    prop _loadcinitSeg :: MEM.LOADCINITSEG
    prop _loadswitchSeg :: MEM.LOADSWITCHSEG
    prop AllocInst :: (
        if (.iAllocHeap == 1) {
        "1\0, _instAllocDesc, _objMemSeg, _placement"
        }
    )
    
    prop _instAllocDesc :: (
	.INITSEG.iAllocHeap && .REUSE && .INITSEG == self
	? "%8t .%0r$heap: {%12t\n %0r$B = .;\n%12t\n _%0r_base = .;\n . += 0x%2x;\n *(.sysinit)\n %0r$L = . + 0x%3x - %0r$B;\n _%0r_length = . + 0x%3x - %0r$B;\n . += 0x%1x;%8t\n }\0, _heapsize, _sysinitgap, _heaplen"
	: "%8t .%0r$heap: {%12t\n %0r$B = .;\n _%0r_base = .;\n %0r$L = 0x%2x;\n _%0r_length = 0x%2x;\n . += 0x%1x;%8t\n }\0, _heapsize, _heaplen"
    )
    prop _objMemSeg :: self
    prop _placement :: 0x7fffffff - 1
    prop _heapsize :: (.iHeapSize)
    prop _heaplen ::  (.iHeapSize)
    
    prop _sysinitgap :: 2 * 4 
    prop GenInstLink :: (GBL.DSPTYPE == 62
	? "%0r %16t: origin = 0x%1x, %40tlen = 0x%2x%4t\0, _origin, _len"
	: GBL.DSPTYPE == 55
	
	? "%0r: %16torigin = 0x%1x, %40tlen = 0x%2x%4t\0, _cmd55origin, _cmd55len"
	: "PAGE %3d: %14t%0r: %26torigin = 0x%1x, %50tlen = 0x%2x%4t\0, _origin, _len, _page"
    )
    prop localInit :: (
	$d = "ok",
	scan ($i; MEM) {
	    if ($i.space == "code" && $i.iAllocHeap == 1) {
		$d = .error ("Code memory cannot have a heap")
	    }
	},
	if (.SEGZERO.iAllocHeap == 1) {
	    .SEGZERO.iReqHeapCount++
	}
	else {
	    $d = .error ("Segment for DSP/BIOS objects must be a memory segment with a heap")
	},
	if (.MALLOCSEG.iAllocHeap == 1) {
	    .MALLOCSEG.iReqHeapCount++
	}
	else {
	    $d = .error ("Segment for malloc()/free() must be a memory segment with a heap")
	},
	$d
    )
    prop _page :: (.page)
    prop _origin :: (.base)
    prop _len :: (.len)
    prop maxObjs :: (
	32767				
    )
    
    prop codeMember :: (
	GBL.DSPTYPE == 62
	    ? (($1.space == "code") || ($1.space == "code/data"))
	    : GBL.DSPTYPE == 54
	        ? ($1.space == "code")
	    : GBL.DSPTYPE == 28
	        ? ($1.space == "code")
	    : ($1.space == "code/data")
    )
    prop dataMember :: (
	GBL.DSPTYPE == 62
	    ? ($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL
	    : GBL.DSPTYPE == 54
	        ? (($1.space != "code") && ($1 != MEM_NULL)) && $1.space != "io"
	    : GBL.DSPTYPE == 28
	        ? (($1.space != "code") && ($1 != MEM_NULL)) && $1.space != "io"
	        : (($1.space == "code/data") && ($1 != MEM_NULL))
    )
    
    prop dataNullMember :: (
	GBL.DSPTYPE == 62
	    ? $1.space == "data" || $1.space == "code/data"
	    : GBL.DSPTYPE == 54
	        ? $1.space != "code" && $1.space != "io"
	    : GBL.DSPTYPE == 28
	        ? $1.space != "code" && $1.space != "io"
	        : $1.space == "code/data"
    )
    prop dataCodeMember :: (		
	GBL.DSPTYPE == 62
	    ? ($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL
	    : GBL.DSPTYPE == 54
	        ? $1.space == "code" && $1 != MEM_NULL	
							
	    : GBL.DSPTYPE == 28
	        ? $1.space == "code" && $1 != MEM_NULL	
							
	        : $1.space == "code/data" && $1 != MEM_NULL 
							    
    )
    
    prop memWritable :: (.iIsModifiable && .iDelUser != "MEM")
    
    global CALLBACKOBJ :: nil {
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumHeap ::= (
	    $a = 0,
	    scan($i; MEM) {
		if ($i != MEM_NULL) {
		    $a += $i.iAllocHeap
		}
	    },
	    $a
	)  {
	prop NoGen :: 0
    }
    global REUSE ::=
	    (.INITSEG.space != "code" && .INITSEG.iAllocHeap == 1 ? .SAVEREUSE : 0) {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Reuse Startup Code Space"
	prop JSName :: "REUSECODESPACE"
	prop Visible :: 1
	prop Writable  :: .INITSEG.space != "code" && .INITSEG.iAllocHeap == 1
	prop NoGen :: 1
	prop Set :: (
	    .SAVEREUSE = $1,
	    "ok"
	)
    }
    global SAVEREUSE :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    
    global doCheckOverlap :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    prop validate :: (
        $e = .checkMemOverlap($1),
        if ($e == "ok") {
            $e = .checkHeapSize($1)
        },
        $e
    )
    
    prop checkHeapSize :: (
        $e = "ok",
        if (MEM.NOHEAPS == 0) {
            if ($1.iAllocHeap && $1 != MEM_NULL) {
                if ($1.iHeapSize > $1.len) {
                    $e = ("MEM segment %s: heap cannot be larger than the length of segment that contains it.")
                }
            }
        },
        $e
    )
    
    prop checkMemOverlap :: (
        $e = "ok",
        if ($1 != MEM_NULL && $1.iIsUsed == 1) {
            if ($1.len == 0) {
                $a = $1.base
            }
            else {
                $a = ($1.base + $1.len - 1)
            },
            scan ($j; MEM) {
                if ($1 != $j && $j != MEM_NULL && $j.iIsUsed == 1 &&
                    (GBL.DSPTYPE == 62 || GBL.DSPTYPE == 55 ||
                    $1.space == $j.space)) {
                    if (!($j == CACHE_L2 && GBL.L2CONFIGURE == 0)) {
                        $b = $j.base,
                        if ($j.len == 0) {
			    $c = $j.base
			}
			else {
			    $c = ($j.base + $j.len - 1)
			},
                        
                        if ($a >= $b && $1.base <= $c) {
                            $e = ("MEM segment %s: overlaps with another segment or cache configuration."),
                            break
                        }
                    }
                }
            }
        },
        $e
    )
    
    global MAPSELECT :: "Map 1" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Map Mode"
	prop JSName :: "MAPMODE"
	prop Enum :: "Map 0,Map 1"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global ARGSSIZE :: 4 {		
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04x"
	prop Style :: 0x01 | 0x02
	prop Label :: "Argument Buffer Size"
	prop JSName :: "ARGSSIZE"
	prop Visible :: 1	
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    if ($1 < 4) {
		.error("The 'arguments' section must have at least 4 words.")
	    }
	    else {
		.ARGSSIZE = $1,
		"ok"
	    }
	)
    }
    global ARGSSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataMember($1)
	prop Label :: "Argument Buffer Section (.args)"
	prop JSName :: "ARGSSEG"
	prop Visible :: 1	
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
    }
    
    global BIOSSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .codeMember($1)
	prop Label :: "BIOS Code Section (.bios)"
	prop JSName :: "BIOSSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Code"
    }
    global STACKSIZE :: GBL.DSPTYPE == 62 ? 1024 : (GBL.DSPTYPE == 55) ? 1024 : (GBL.DSPTYPE == 54)?256:(GBL.DSPTYPE == 28)?512:256 { 
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04x"
	prop Style :: 0x01 | 0x02
	prop Label :: "Stack Size (MAUs)"
	prop JSName :: "STACKSIZE"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
		.STACKSIZE = $1,
		"ok"
	)
	prop PropSetOkUserMsg :: (MEM.STACKSIZE < GlobalStatus.MinStackSize)?"Warning: You are setting the stack size to a value that is less than the Estimated Minimum Stack Size!":"ok"
    }
    global USERCMD :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "User .cmd File For Non-DSP/BIOS Sections"
	prop JSName :: "USERCOMMANDFILE"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global STACKSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataMember($1)
	prop Label :: "Stack Section (.stack)"
	prop JSName :: "STACKSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
	prop Set :: (
	    if (GBL.DSPTYPE == 55) {
	        (MEM.STACKSEG = $1), 
		(MEM.SYSSTACKSEG = $1)
		}
		else {
		(MEM.STACKSEG = $1)
		},
		"ok"
	)
    }
    global ENABLELOADSEG :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify Separate Load Addresses"
	prop JSName :: "ENABLELOADADDR"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global LOADBIOSSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .codeMember($1)
	prop Label :: "Load Address - BIOS Code Section (.bios)"
	prop JSName :: "LOADBIOSSEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global INITSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .codeMember($1)
	prop Label :: "Startup Code Section (.sysinit)"
	prop JSName :: "SYSINITSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Code"
    }
    global LOADINITSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .codeMember($1)
	prop Label :: "Load Address - Startup Code Section (.sysinit)"
	prop JSName :: "LOADSYSINITSEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global BIOSINITSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataCodeMember($1)
	prop Label ::"DSP/BIOS Init Tables (.gblinit)"
	prop JSName :: "GBLINITSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
    }
    global TRCINITSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataCodeMember($1)
	prop Label ::"TRC Initial Value (.trcdata)"
	prop JSName :: "TRCDATASEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
    }
    global LOADBIOSINITSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataCodeMember($1)
	prop Label ::"Load Address - DSP/BIOS Init Tables (.gblinit)"
	prop JSName :: "LOADGBLINITSEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global LOADTRCINITSEG ::= .TRCINITSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataCodeMember($1)
	prop Label ::"Load Address - TRC Initial Value (.trcdata)"
	prop JSName :: "LOADTRCDATASEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global SYSDATASEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataMember($1)
	prop Label :: "DSP/BIOS Kernel State (.sysdata)"
	prop JSName :: "SYSDATASEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
    }
    global CFGOBJSEG :: IRAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
	prop MemberTest :: .dataMember($1)
        prop Label :: "DSP/BIOS Conf Sections (.*obj)"
	prop JSName :: "OBJSEG"
        prop Visible :: 1
        prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
    }
    global NOHEAPS :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "No Dynamic Memory Heaps"
	prop JSName :: "NOMEMORYHEAPS"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    if ($1) {
		
		.SEGZERO.iReqHeapCount--,
		.SEGZERO = MEM_NULL,
		.MALLOCSEG.iReqHeapCount--,
		.MALLOCSEG = MEM_NULL,
		TSK.STACKSEG.iReqHeapCount--,
		TSK.STACKSEG = MEM_NULL,
		scan ($i; MEM) {
		    if ($i.iAllocHeap && $i != MEM_NULL) {
			$i.iAllocHeap = 0,
			$i.iHeapSize = 0
		    }
		}
	    },
	    .NOHEAPS = $1,
	    "ok"
	)
	prop PropSetOkUserMsg :: (MEM.NOHEAPS == 1)?"Currently specified heaps no longer valid":"Please reconfigure heaps under individual mem segments"
    }
    global SEGZERO :: MEM_NULL { 
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataNullMember($1) && $1.iAllocHeap)
	prop Label :: "Segment For DSP/BIOS Objects"
	prop JSName :: "BIOSOBJSEG"
	prop Visible :: 1
	prop Writable :: MEM.NOHEAPS == 0
	prop NoGen :: 0
        prop Set :: (
            if (.SEGZERO.iReqHeapCount > 0) {
                .SEGZERO.iReqHeapCount--
            },
            .SEGZERO = $1,
            .SEGZERO.iReqHeapCount++,
            "ok"
        )
    }
    global MALLOCSEG :: MEM_NULL {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
	prop MemberTest :: (.dataNullMember($1) && $1.iAllocHeap)
        prop Label :: "Segment For malloc() / free()"
	prop JSName :: "MALLOCSEG"
        prop Visible :: 1
	prop Writable :: (MEM.NOHEAPS == 0)
	prop NoGen :: 0
        prop Set :: (
            if (.MALLOCSEG.iReqHeapCount > 0) {
                .MALLOCSEG.iReqHeapCount--
            },
            .MALLOCSEG = $1,
            .MALLOCSEG.iReqHeapCount++,
            "ok"
        )
    }
    global LNKCMDFILE :: "" {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify User Linker cmd File"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    
    global TEXTSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.codeMember($1))
	prop Label :: "Text Section (.text)"
	prop JSName :: "TEXTSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global LOADTEXTSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.codeMember($1))
	prop Label :: "Load Address - Text Section (.text)"
	prop JSName :: "LOADTEXTSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0 && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global SWITCHSEG :: GBL.DSPTYPE == 62 ? MEM.BSSSEG :(GBL.DSPTYPE == 55 && GBL.DSPSUBTYPE == 5561)? IRAM: MEM.TEXTSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1))
	prop Label :: "Switch Jump Tables (.switch)"
	prop JSName :: "SWITCHSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global LOADSWITCHSEG :: GBL.DSPTYPE == 62 ? MEM.BSSSEG :(GBL.DSPTYPE == 55 && GBL.DSPSUBTYPE == 5561)? IRAM: MEM.TEXTSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1))
	prop Label :: "Load Address - Switch Jump Tables (.switch)"
	prop JSName :: "LOADSWITCHSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0 && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global BSSSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "C Variables Section (.bss)"
	prop JSName :: "BSSSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global FARSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "C Variables Section (.far)"
	prop JSName :: "FARSEG"
	prop Visible :: GBL.DSPTYPE == 62 ? 1 : 0
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global CINITSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1))
	prop Label :: "Data Initialization Section (.cinit)"
	prop JSName :: "CINITSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global LOADCINITSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1))
	prop Label :: "Load Address - Data Initialization Section (.cinit)"
	prop JSName :: "LOADCINITSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0 && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    
    global PINITSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1))
	prop Label :: "C Function Initialization Table (.pinit)"
	prop JSName :: "PINITSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    
    global LOADPINITSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1))
	prop Label :: "Load Address - C Function Initialization Table (.pinit)"
	prop JSName :: "LOADPINITSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0 && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global CONSTSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "Constant Section (.const)"
	prop JSName :: "CONSTSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global LOADCONSTSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "Load Address - Constant Section (.const)"
	prop JSName :: "LOADCONSTSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0 && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global DATASEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "Data Section (.data)"
	prop JSName :: "DATASEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global CIOSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "Data Section (.cio)"
	prop JSName :: "CIOSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global SYSMEMSEG ::= .CIOSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "Data Section (.sysmem)"
	prop JSName :: "SYSMEMSEG"
	prop Visible :: 0
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global STUBMEMSEG ::= HWI.STUBMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "Function Stub Memory (.hwi)"
	prop JSName :: "HWISEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Code"
	prop Set :: (
	    .STUBMEMSEG = $1,
	    HWI.STUBMEMSEG = $1,
	    "ok"
	)
    }
    
    global LOADSTUBMEMSEG :: HWI.STUBMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "Load Address - Function Stub Memory (.hwi)"
	prop JSName :: "LOADHWISEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global VECMEMSEG ::= HWI.VECMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "Interrupt Service Table Memory (.hwi_vec)"
	prop JSName :: "HWIVECSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Code"
	prop Set :: (
		.VECMEMSEG = $1,
		HWI.VECMEMSEG = $1,
		GlobalStatus.gDirty = 1,
		if ($1.base == 0) {
		    HWI.GENERATE_RESET_VEC = 0
		},
		"ok"
	)
    }
    global LOADVECMEMSEG :: HWI.VECMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "Load Address -Interrupt Service Table Memory (.hwi_vec)"
	prop JSName :: "LOADHWIVECSEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global RTDXTEXTMEMSEG ::= RTDX.TEXTMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "RTDX Text Segment (.rtdx_text)"
	prop JSName :: "RTDXTEXTSEG"
	prop Visible :: 1
	prop Writable :: RTDX.USERTDX
	prop NoGen :: 1
	prop TabName :: "BIOS Code"
	prop Set :: (
	    .RTDXTEXTMEMSEG = $1,
	    RTDX.TEXTMEMSEG = $1,
	    "ok"
	)
    }
    global LOADRTDXTEXTMEMSEG :: RTDX.TEXTMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "Load Address - RTDX Text Segment (.rtdx_text)"
	prop JSName :: "LOADRTDXTEXTSEG"
	prop Visible :: 1
	prop Writable :: (RTDX.USERTDX && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    inst base :: 0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: GBL.DSPTYPE == 62 ? "0x%08x" : "0x%06x"
	prop Style :: 0x02
	prop Label :: "base"
	prop JSName :: "base"
	prop Visible :: 1
	prop Writable :: (.iIsModifiable)
	prop NoGen :: 1
	prop Set :: (
	    .base = $1,
	    "ok"
	)
    }
    inst len :: 0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: GBL.DSPTYPE == 62 ? "0x%08x" : "0x%04x"
	prop Style :: 0x08
	prop Label :: "len"
	prop JSName :: "len"
	prop Visible :: 1
	prop Writable :: (.memWritable)
	prop NoGen :: 0
	prop Set :: (
	    .len = $1,
	    "ok"
	)
    }
    inst page ::= (
	
	GBL.DSPTYPE == 62
	    ? -1
	    : GBL.DSPTYPE == 55 
		? -1 
		:.space == "code"
		   ? 0
		   : .space == "data"
		       ? 1
		       	: .space == "io"
		      	    ? 2
			     : 3) {	
	prop Type  :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
	
    
    inst iAllocHeap :: MEM.NOHEAPS == 1 ? 0 : 1 {
	prop Type  :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "create a heap in this memory"
	prop JSName :: "createHeap"
	prop Visible :: 1
	prop Writable :: (.space == "data" || .space == "code/data")
		&& (MEM.NOHEAPS == 0) && .iIsModifiable
	prop NoGen :: 0
	prop Set :: (
	    $a = "ok",
	    if ($1 == 0 && .iReqHeapCount > 0) {
	        .error("This heap is used by one or more of: segment for DSP/BIOS objects, segment for malloc()/free(), TSK default stack segment")
	    }
	    else {
		if ($1 == 0) {
		    .iUserHeapId = 0,
		    .iHeapId = @segment_name
		},
		.iAllocHeap = $1,
		MEM.gDirty = 1,
		$a
	    }
	)
    }
    inst iHeapSize :: 0x8000 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: GBL.DSPTYPE == 62 ? "0x%08x" : "0x%04x"
        prop Style :: 0x02
        prop Label :: "heap size"
	prop JSName :: "heapSize"
        prop Visible :: 1
        prop Writable :: (.iAllocHeap) && (.iIsModifiable) && (MEM.NOHEAPS == 0)
        prop Set :: (
            .iHeapSize =  $1,
            "ok"
        )
        prop NoGen :: 1
    }
    inst iSegZero ::= MEM.SEGZERO
    inst iUserHeapId :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "enter a user defined heap identifier label"
	prop JSName :: "enableHeapLabel"
	prop Set :: (
	    if ($1 == 0) {
		.iHeapId = @segment_name
	    },
	    .iUserHeapId = $1,
	    "ok"
	)
	prop Visible :: 1
	prop Writable :: (.iAllocHeap) && (.iIsModifiable) && (.NOHEAPS == 0)
	prop NoGen :: 1
    }
    inst iHeapId :: @segment_name {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "heap identifier label"
	prop JSName :: "heapLabel"
	prop Set :: (
	    $e = .checkHeapId($1),
	    if ($e == "ok") {
		.iHeapId = $1
	    },
	    $e
	)
	prop Writable :: (.iAllocHeap) && (.iIsModifiable) && (.NOHEAPS == 0) &&(.iUserHeapId)
	prop Visible :: 1
	prop NoGen :: 0
    }
    prop checkHeapId :: (
	$e = "ok",
	scan ($i; MEM) {
	    if ($i.iAllocHeap == 1 && $i.iUserHeapId == 1 && $i.iHeapId == $1 && $i.iHeapId != @segment_name) {
		$e = .error ("This identifier label is already in use"),
		break
	    }
	},
	$e
    ) 
    inst iReqHeapCount :: 0 {	
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    inst space :: ( GBL.DSPTYPE == 55 ? "code/data" : "data") {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	
	prop Enum :: GBL.DSPTYPE == 62
	    ? "code,data,code/data"
	    : GBL.DSPTYPE == 54
	        ? "code,data,io,other"
		: GBL.DSPTYPE == 28
		   ? "code,data,io,other"
	           : "code/data,io"
	prop JSName :: "space"
	prop Visible :: 1
	prop Writable :: (.memWritable)
	prop NoGen :: 1
	prop Set :: (
	    $e = "ok",
	    if ($1 != "data" && $1 != "code/data" && .iAllocHeap == 1) {
		$e = .error("Cannot select this space if a heap will be created")
	    }
	    else {
		.space = $1
	    },
	    $e
	)
    }
    inst iIsModifiable :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
}
object MEM_NULL :: MEM {
    param iComment :: "Place holder segment which allows user to disable heaps"
    param iAllocHeap :: 1
    param iIsUsed :: 0
}
type OBJ {
    isa ObjectMgr
    prop name :: "OBJ"
    prop Visible :: 0
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _objMemDesc, _memSeg, _placement"
	}
    )
    prop _objMemDesc :: ("%8t .obj: {}")
    prop _memSeg :: MEM.CFGOBJSEG
    prop _placement :: (0x7fffffff / 2)
}
   
 
type BUF {
    isa  ObjectMgr
    prop name :: "BUF"
    prop Label :: "BUF - Buffer pool Manager"
    prop IsContainedIn :: SYSTEM 
    prop GlobalIcon :: 199
    prop InstanceIcon :: 200
    prop InstanceHelpTopic :: (
	421
    )
    
    prop GlobalHelpTopic :: (
	321
    )
    prop InstancePropertyPage :: (
	"{B7240DE8-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
	"{B7240DE9-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    prop maxObjs :: (32767)
    
    
    prop AllocType :: (
      if (.gNumOf > 0) {
	"1\0,      _globalAllocDesc, _memSeg, _placement"
      }
    )
    prop _globalAllocDesc :: (
       "%8t.buf:{}"
    )
	    
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: .OBJMEMSEG
    
    prop AllocInst :: (
          "1\0, _instAllocDesc, _instMemSeg, _placement"
    )
    prop _instAllocDesc :: (
          "%8t .%0s$data: align = 0x%1x {%12t\n %0s$databeg = .;\n .+= %2d; %8t\n }\0, _objAlign, _buflength"
    )
    prop _objAlign :: .align
    prop _instMemSeg :: .bufseg
    prop _buflength :: (.postalignsize *  .bufcount) 
    
    prop cGen :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "buf.h" : ""
    
    prop cGenHInst :: (
	if (GBL.DSPTYPE == 62) {
	    "extern far BUF_Obj %0r;\n\0"
	}
	else {
	    "extern BUF_Obj %0r;\n\0"
	}
    )
    
    
    prop dataSize :: (
	$d = 0,
	scan ($i; BUF) {
	    if ($i.IsConfObj()) {
		$d += $i.len 
	    },
	    $d += 7 * 4	
	},
	$d
    )
    
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global ENABLED :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Compile in logging"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    
    inst bufseg :: .OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Memory segment for buffer pool"
	prop JSName :: "bufSeg"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    
    inst bufcount :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Buffer count"
	prop JSName :: "bufCount"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    .bufcount = $1,
            .postalignsize = (.size + (.align - 1)) & ~(.align - 1),
	    .len = $1 * .postalignsize, 
	    "ok"
	)
    }
    
    inst size :: 8 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Buffer size (MADUs)"
	prop JSName :: "size"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
             if($1 < 8) {
                .error("Size should be atleast 8 bytes")
             }
             else { 
	        .size = $1,
                .postalignsize = ($1 + (.align - 1)) & ~(.align - 1),
                .len = .postalignsize * .bufcount,
	        "ok"
             }
	)
    }
    
    inst align :: 4 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Buffer alignment(Power of 2)"
	prop JSName :: "align"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0 
	prop Set :: (
             if($1 < 4) {
                .error("Alignment should be atleast 4 ")
             }
             else { 
	         .align = $1,
                 .postalignsize = (.size + ($1 - 1)) & ~($1 - 1),
                 .len = .postalignsize * .bufcount,
	         "ok"
             }
	 )
    }
    
    inst len :: .size {
	prop Label :: "Buffer pool length (MADUs)"
	prop JSName :: "len"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    inst postalignsize :: .size {
	prop Label :: "Buffer size after alignment (MADUs)"
	prop JSName :: "postalignsize"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: 0
	prop NoGen :: 0
    }
    
}
type CLK {
    isa ObjectMgr
    prop name :: "CLK"
    prop Label :: "CLK - Clock Manager"
    prop IsContainedIn :: SCH
    prop IsConfMod :: 1 		
    prop GlobalIcon :: 103
    prop InstanceIcon :: 104
    prop InstanceHelpTopic :: (
	202
    )
    prop GlobalHelpTopic :: (
	102
    )
    prop InstancePropertyPage :: (
	"{EEB2AB41-51E3-11d0-A61D-0000C070F3E9}"
    )
    prop GlobalPropertyPage :: (
	"{EEB2AB40-51E3-11d0-A61D-0000C070F3E9}"
    )
    prop GenLinkPrologue :: (
	"SECTIONS {%4t\n.%1L: {\n%8t _CLK_start = %6s;\n CLK_F_gethtime = %5s;\n %1U_A_TABBEG = .;\n %4S\n %1U_A_TABEND = .;\n %1U_A_TABLEN = (. - %1U_A_TABBEG) / %2d;\n%4t} > %3s \0, name, _objSize, _memSeg, _linkString, clkFxn, _clkStartFxn"
    )
    prop _clkStartFxn :: (GBL.SUPPORTCSL && .USETIMER) ? @_CLK_start6x : @FXN_F_nop
    prop GenLinkEpilogue :: (
	"%0t}\n_CLK_PRD = CLK_PRD;\n_CLK_COUNTSPMS = CLK_COUNTSPMS;\n_CLK_REGS = CLK_REGS;\n_CLK_USETIMER = CLK_USETIMER;\n_CLK_TIMERNUM = CLK_TIMERNUM;\n_CLK_TDDR = CLK_TDDR;\n\0"
    )
    prop _linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no CLK objs */"
    prop _memSeg :: CLK.OBJMEMSEG
    prop _objSize :: 1
    prop clkFxn :: (.USETIMER == 1) ? .CLKFXN : @FXN_F_zero
    prop maxObjs :: (
	32767				
    )
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    prop localInit :: (
	if (GBL.CALLBACKOBJ != CLK) {
	    CLK.gGBLChain = GBL.CALLBACKOBJ,
	    GBL.CALLBACKOBJ = CLK
	}
    )
    
    prop dataSize :: (
	1 * (CLK.gNumOf + 1)	
    )
    prop localCanCreate :: (
	.USETIMER ? "ok" : .error ("The CLK Manager must be enabled before inserting a CLK")
    )
    prop localCreate :: (
	CLK.HOOKFXN = @HWI_F_dispatch,
	.seizeHwi(.WHICHHWI),
	"ok"
    )
    prop localDelete :: (
	if (.gNumOf == 1) {	
	    if (GBL.CALLMODEL == "far") {
	        CLK.HOOKFXN = @CLK_F_frete,
		.seizeHwi(.WHICHHWI)
	    }
	    else {
	        CLK.HOOKFXN = @CLK_F_rete,
		.seizeHwi(.WHICHHWI)
	    }
	},
	"ok"
    )
    global gGBLChain :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
 	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: .USETIMER
	prop NoGen :: 1
    }
    global WHICHHWI :: .WHICHTIMER == "Timer 0" ? Timer_0.iHwi : Timer_1.iHwi{
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: HWI
	prop Label :: "CPU Interrupt"
	prop Visible :: 1
	prop Writable :: 0
	prop NoGen :: 1
    }
    global INTBIT ::= .WHICHHWI.iIntrEnableMask
    global WHICHTIMER :: "Timer 0" { 
        prop Label :: "Timer Selection"
 	prop JSName :: "TIMERSELECT"
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "Timer 0,Timer 1"
	prop Visible :: 1
	prop Writable :: .USETIMER 
	prop NoGen :: 1
	prop Set :: (
	    if (.WHICHTIMER != $1) {
		if (.USETIMER == 0) {
		    $e = "ok"
		}
		else {
		    if ($1 == "Timer 0") {
			$a = Timer_0.iHwi
		    }
		    else {
			$a = Timer_1.iHwi
		    },
		    $e = .seizeHwi($a)
		},
		if ($e == "ok") {
		    .releaseHwi(.WHICHHWI),
	            if ($1 == "Timer 0") {
		        .REGS = 0x01940000,
			.TIMERNUM = 0,
			.WHICHHWI = Timer_0.iHwi
		    }
	            else {
		        .REGS = 0x01980000,
			.TIMERNUM = 1,
			.WHICHHWI = Timer_1.iHwi
		    },
	            .WHICHTIMER = $1,
		    .HOOKFXN = .gNumOf > 0 ? @HWI_F_dispatch : (GBL.CALLMODEL == "far" ? @CLK_F_frete : @CLK_F_rete),
		    .seizeHwi(.WHICHHWI)
	        },
		$e
	    }
	)
    }
    global REGS :: 0x01940000 {	
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
    }
    global TIMERNUM :: 0 {	
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
    }
    global USETIMER :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable CLK Manager"
 	prop JSName :: "ENABLECLK"
	prop Visible :: 1
	prop Writable :: .gNumOf > 0 ? 0 : 1
	prop NoGen :: 0
	prop Set :: (
	    if ($1 == 1 && .USETIMER == 0) {
		if (($e = .seizeHwi(.WHICHHWI)) == "ok") {
		    .USETIMER = 1,
	    	    
		    .TIMEFXN = CLK.HIRES ? CLK.clkFxn() : @CLK_F_getltime,
    		    .HOOKFXN = GBL.CALLMODEL == "far" ? @CLK_F_frete : @CLK_F_rete,
		    .seizeHwi(.WHICHHWI),
		        
		    GlobalStatus.gDirty = 1,
		    if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {
			.releaseHwi(.WHICHHWI),
			.TIMEFXN = @FXN_F_zero,
			.HOOKFXN = @FXN_F_nop,	
			.USETIMER = 0,
			GlobalStatus.gDirty = 1,
			.error("Current stack size inadequate to enable CLK")
			}
			else 
			{
		        if (GBL.ENABLEINST == 1) {
		        IDL_busyObj.Create("IDL"),
			IDL.USEIDLBUSYOBJ = 1,
		        IDL_cpuLoad.Create("IDL"),
                        IDL.AUTOCALCULATE = GBL.OLDAUTOCALCULATE
		         },
		          $e
	        	 }
		     }
		     else {
		          $e	
			}
	    }
	    else {
		if ($1 == 0 && .USETIMER == 1) {
			.releaseHwi(.WHICHHWI),
			.TIMEFXN = @FXN_F_zero,
			
			.HOOKFXN = @FXN_F_nop,	
			.USETIMER = 0,
		        if (GBL.ENABLEINST == 1) {
			    IDL_busyObj.Delete("IDL"),
			    IDL.USEIDLBUSYOBJ = 0,
			    IDL_cpuLoad.Delete("IDL"),
                            GBL.OLDAUTOCALCULATE = IDL.AUTOCALCULATE,
                            IDL.AUTOCALCULATE = 0
			},
			  "ok"
		     }
		     else {
		          "ok"
	        }
	    }
	)
    }
    
    global HIRES ::= 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Use high resolution time for internal timings"
 	prop JSName :: "HIRESTIME"
	prop Visible :: 1
	prop Writable :: .USETIMER
	prop NoGen :: 1
	prop Set :: (
	    if (CLK.USETIMER) {
		CLK.HIRES = $1,
		if (CLK.USETIMER) {
		    CLK.TIMEFXN = CLK.HIRES ? CLK.clkFxn() : @CLK_F_getltime
		},
		"ok"
	    }
	    else {
		.error("CLK Manager must be enabled in order to get high resolution timings.")
	    }
	)
    }
    global INSTRPERCLK :: 4 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    
    global MICROSECONDS :: (((float((CLK.PRD)) + CLK.adjustPrd) * ((CLK.TDDR) + 1.0) * 4 / GBL.CPUCLOCK)) {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style :: 0x04
	prop Format :: "%.4f"
	prop Label :: "Microseconds/Int"
 	prop JSName :: "MICROSECONDS"
	prop Set :: (
	    .setMicroseconds($1)
	)
	prop Visible :: 1
	prop Writable :: ((CLK.PROGTIMREGS != 0) | (.USETIMER == 0)) ? 0 : 1
	prop NoGen :: 1
    }
    
    global PROGTIMREGS ::= 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Directly configure on-chip timer registers"
	prop JSName :: "CONFIGURETIMER"
	prop Visible :: 1
	prop Writable :: .USETIMER
	prop NoGen :: 1
    }
    global TCR :: = 0x20 | CLK.TDDR {	
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global FIXTDDR :: (GBL.DSPTYPE == 62) ? 1 : 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Fix TDDR"
 	prop JSName :: "FIXTDDR"
	prop Visible :: GBL.DSPTYPE != 62
	prop Writable :: CLK.PROGTIMREGS && GBL.DSPTYPE != 62
	prop NoGen :: 1
    }
    
    global TDDR :: (GBL.DSPTYPE == 62) ? 0 : (GBL.DSPSUBTYPE == 5502) ? 0 : (int(round(1000.0 * GBL.CPUCLOCK/4)) >> 16) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: GBL.DSPSUBTYPE == 5502 ? 0x02 :
		GBL.DSPWORDSIZE == 16 ? 0x01 | 0x02
		: 0x02
	prop Label :: GBL.DSPSUBTYPE == 5561 ? "TDDR Register (PREMD=0)" : 
						"TDDR Register"
 	prop JSName :: "TCRTDDR"
	prop Set :: (
	    if ( (GBL.DSPSUBTYPE != 5502) && ($1 > 0) ) {
	        .error("The on-chip timer does not have enough range to support this value, maximum is 15.")
	    }
	    else {
		CLK.TDDR = $1,
		CLK.MICROSECONDS = ((float((CLK.PRD)) + CLK.adjustPrd) * ((CLK.TDDR) + 1.0) * 4 / GBL.CPUCLOCK),
		if (CLK.CALLBACKOBJ != nil) {
		    CLK.CALLBACKOBJ.call()
		},
		"ok"
	    }
	)
	prop Visible :: GBL.DSPTYPE != 62
	prop Writable :: CLK.PROGTIMREGS && GBL.DSPTYPE != 62
	prop NoGen :: 0 
    }
    
    global TDDRHIGH ::= ((.TDDR & 0xffff0000) >> 16) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    global PRD :: int(round((1000.0 * GBL.CPUCLOCK / (CLK.TDDR + 1) / 4) - CLK.adjustPrd))  { 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: GBL.DSPSUBTYPE == 5502 ? 0x02 :
		GBL.DSPWORDSIZE == 16 ? 0x01 | 0x02
		: 0x02
	prop Label :: "PRD Register"
 	prop JSName :: "PRD"
	prop Set :: (
	    
	    CLK.PRD = $1,
	    CLK.MICROSECONDS = ((float((CLK.PRD)) + CLK.adjustPrd) * ((CLK.TDDR) + 1.0) * 4 / GBL.CPUCLOCK),
	    if (CLK.CALLBACKOBJ != nil) {
		CLK.CALLBACKOBJ.call()
	    },
	    "ok"
	)
	prop Visible :: 1
	prop Writable :: ((.PROGTIMREGS) && (.USETIMER)) ? 1 : 0
	prop NoGen :: 0
    }
    
    
    global PRDHIGH ::= ((.PRD & 0xffff0000) >> 16) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    
    global COUNTSPMS ::= int(round(GBL.CPUCLOCK * 1000.0 / (CLK.TDDR + 1) / 4)) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    
    
    global COUNTSPMSHIGH ::= ((.COUNTSPMS & 0xffff0000) >> 16) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    prop adjustPrd :: (GBL.DSPTYPE == 62 ? 0 : 1)
    
     	
    prop seizeHwi :: (
	if ($1.client == "USER" && $1.function != @HWI_unused) {
	    .error("Interrupt mapped to selected timer is already in use.")
	}
	else {
	    if( $1.client == "CSL") {
	    .error("Interrupt mapped to selected timer is already in use by CSL.")
	    }
	    else {
	    	$1.function = @CLK_F_isr,
	    	$1.client = "CLK",
	    	$1.iUseDispatcher = (CLK.HOOKFXN == @HWI_F_dispatch ? 1 : 0),
	    	$1.iArg = ($1.iUseDispatcher == 1 ? @CLK_A_TABBEG : 0),
	    	HWI.gDirty = 1,
	    	"ok"
	    }
	}
    )
    prop releaseHwi :: (
	$1.function = @HWI_unused,
	$1.client = "USER",
	$1.iUseDispatcher = 0,
	$1.iArg = 0,
	HWI.gDirty = 1,
	"ok"
    )
    prop seizeTimer :: (
        if( $1 == "Timer 0") {
            .WHICHTIMER = "Timer 0",
            .WHICHHWI = Timer_0.iHwi,
            .REGS = 0x01000,
            .TIMERNUM = 0,
            .TIMERIMR = 0x0,
            .TIMERIFR = 0x1,
            .INTBIT = 4,
            .TIMERIMRMASK = .WHICHHWI.Ier0Mask,
            .IMR0TINTMASK = .WHICHHWI.Ier0Mask,
            .IMR1TINTMASK = 0x0,
            .setMicroseconds(.MICROSECONDS)
        }
        else {
          if ($1 == "Timer 1") {
            .WHICHTIMER = "Timer 1",
            .WHICHHWI = Timer_1.iHwi,
            .REGS = 0x2400,
            .TIMERNUM = 1,
            .TIMERIMR = 0x45,
            .TIMERIFR = 0x46,
            .INTBIT = 6,
            .TIMERIMRMASK = .WHICHHWI.Ier1Mask,
            .IMR0TINTMASK =  0x0,
            .IMR1TINTMASK =  .WHICHHWI.Ier1Mask,
            .setMicroseconds(.MICROSECONDS)
          } 
          else {
            if ($1 == "Timer 2") {
              .WHICHTIMER = "Timer 2",
              .WHICHHWI = Timer_2.iHwi,
              .REGS = 0x4000,
              .TIMERNUM = 2,
              .TIMERIMR = 0x0,
              .TIMERIFR = 0x1,
              .INTBIT = 11,
              .TIMERIMRMASK = .WHICHHWI.Ier0Mask,
              .IMR0TINTMASK = .WHICHHWI.Ier0Mask,
              .IMR1TINTMASK =  0x0,
              .setMicroseconds(.MICROSECONDS)
            } 
          }
        },
            "ok"
    )
    prop setMicroseconds :: (
	
	
	$a = FIXTDDR == 1 ? .TDDR : (GBL.DSPSUBTYPE == 5502 ? CLK_MAXTDDR5502 : 0),
	$b = GBL.DSPSUBTYPE == 5502 ? CLK_MAXREG5502 : 0xffffffff,
	$c = (float($a) + 1.0) * ((float($b) + .adjustPrd) / (GBL.CPUCLOCK / 4)),
	if ($1 < $c && $1 > 0.1) {
	    if (.FIXTDDR == 0) {
		.TDDR = int((1.0 * $1 * GBL.CPUCLOCK / 4) / (float($b) + .adjustPrd))
	    },
	    
	    .PRD = int((1.0 * $1 * GBL.CPUCLOCK) / (4 * (.TDDR + 1.0))) - .adjustPrd,
	    .MICROSECONDS = ((float((.PRD)) + CLK.adjustPrd) * ((.TDDR) + 1.0) * 4 / GBL.CPUCLOCK),
	    if (.CALLBACKOBJ != nil) {
		.CALLBACKOBJ.call()
	    },
	    "ok"
	}
	else {
	    .error("The on-chip timer does not have enough range to support this combination of DSP MIPS and Microseconds/Int")
	}
    )
    
    prop call :: (
	$a = ((float((CLK.PRD)) + CLK.adjustPrd) * ((CLK.TDDR) + 1.0) * 4 / GBL.CPUCLOCK),
	$b = CLK.MICROSECONDS,
	$e = "ok",
	if (($e = .setMicroseconds(CLK.MICROSECONDS)) == "ok") {
	    if (CLK.gGBLChain != nil) {
		$e = CLK.gGBLChain.call()
	    },
	    if ($e != "ok") {
		.setMicroseconds($b),
		.error($e)
	    }
	    else {
		"ok"
	    }
	}
	else {
	    $e
	}
    )
    global INSTRUCTIONS ::= (
	1.0 * (float(CLK.PRD) + CLK.adjustPrd) * (CLK.TDDR + 1.0) * 4
    ) {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style :: 0x04
	prop Format :: "%.0f"
	prop Label :: "Instructions/Int"
	prop Visible :: 1
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    global TIMEFXN ::= CLK.clkFxn() {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    
    
    global HOOKFXN ::= (GBL.CALLMODEL == "far" ? @CLK_F_frete : @CLK_F_rete) {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    
    global CLKFXN ::= (GBL.DSPSUBTYPE == 5502 ? @CLK_F_getBIOStime :
		(CLK.PRD == 0xffffffff) ? @CLK_F_getfhtime : @CLK_F_getshtime) {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst function :: @FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "function"
 	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
    
    inst Order :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
	prop NoGen :: 1
	prop Writable :: 1
    }
    
    inst iPri :: 0 {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}
type PRD {
    isa ObjectMgr
    prop name :: "PRD"
    prop Label :: "PRD - Periodic Function Manager"
    prop IsContainedIn :: SCH
    
    prop IsConfMod :: 1
    prop GlobalIcon :: 119
    prop InstanceIcon :: 120
    prop InstanceHelpTopic :: (
	210
    )
    
    prop GlobalHelpTopic :: (
	110
    )
    prop InstancePropertyPage :: (
	"{B7240DE0-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
	"{B7240DE1-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    prop STSGetMaxFmt :: (
	"%g ticks"
    )
    prop STSGetSumFmt :: (
	PRD.STSGetMaxFmt()
    )
    prop STSGetAvgFmt :: (
	"%.2f ticks"
    )
    prop GetPeriod :: .period
    prop IsOneShot :: .mode == "one-shot" ? 1 : 0
    
    prop GenLinkPrologue :: (
	"SECTIONS {%4t\n.%1L: {\n%8t %1U_A_TABBEG = .;\n %4S\n %1U_A_TABEND = .;\n %1U_A_TABLEN = (. - %1U_A_TABBEG) / %2d;\n%4t} > %3s%5s\0, name, objSize, memSeg, linkString, pageString"
    )
    prop GenLinkEpilogue :: (
	"%0t}\n\0"
    )
    prop linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop pageString :: GBL.DSPTYPE == 62 ? "" : GBL.DSPTYPE == 55 ? "" : GBL.DSPTYPE == 28 ? " PAGE 1 " : " PAGE 1"
    prop memSeg :: PRD.OBJMEMSEG
    prop objSize :: GBL.DSPTYPE == 55 ? (8 * 4) * 2 : (8 * 4)
    prop dataSize :: (
	(8 * 4) * PRD.gNumOf
    )
    prop localInit :: (
	if (CLK.CALLBACKOBJ != nil) {
	    .error("PRD initialization failure")
	},
	CLK.CALLBACKOBJ = PRD,
	if (PRD.USECLK && PRD_clock.iIsUsed == 0) {
	    PRD_clock.Create("PRD")
	},
	if (PRD_clock.iIsUsed == 1) {
	  if (.gNumOf == 0) {
            if (TSK.USETSK == 1 && TSK.TSKTICK == "PRD") {
  	      PRD_clock.function = @PRD_F_tick
            }
            else {
  	      PRD_clock.function = @FXN_F_nop
            }
          }
          else {
  	    PRD_clock.function = @PRD_F_tick
          }
        }
    )
    prop localCanCreate :: (
	if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {
	  .error(" System Stack Size too small")
	  }
        else {
	.myCreate("can")
	}
    )
    
    prop localCreate :: (
	STS.gNumEmbed += 1,
	if (($a = .myCreate("do")) == "ok") {
	  if (PRD_clock.iIsUsed == 1) {
	    if (.gNumOf == 0) {
  	      PRD_clock.function = @PRD_F_tick
            }
          }
        },
        $a
    )
    
    prop localCanDelete :: (
	.myDelete("can")
    )
    prop localDelete :: (
	STS.gNumEmbed -= 1,
	if (($a = .myDelete("do")) == "ok") {
	  if (.gNumOf == 1) {
	    if (PRD_clock.iIsUsed == 1) {
              if (TSK.USETSK == 1 && TSK.TSKTICK == "PRD") {
  	        PRD_clock.function = @PRD_F_tick
              }
              else {
  	        PRD_clock.function = @FXN_F_nop
              }
            }
	  }
	},
        $a
    )
    
    prop maxObjs :: (
	32767				
    )
    prop myCreate :: (
	if (PRD_swi.function != @PRD_F_swi) {
	    PRD_swi.function = @PRD_F_swi
	},
	if (PRD_swi.iIsUsed) {
	    "ok"
	}
	else {
	    if (SWI.CanCreate() == "ok") {
		if ($1 == "do") {
		    if (KNL_swi.iIsUsed == 1 && PRD_swi.pri == 0) {
			PRD_swi.pri = 1
		    },
		    PRD_swi.Create("PRD")
		}
		else {
		    "ok"
		}
	    }
	    else {
		.error("Can't create an SWI for PRD (try deleting a SWI)")
	    }
	}
    )
    
    prop myDelete :: (
	if (PRD_swi.function != @PRD_F_swi) {
	    PRD_swi.function = @PRD_F_swi
	},
	if (.gNumOf == 1) {
	    if ($1 == "do") {
		PRD_swi.Delete("PRD")
	    }
	    else {
		"ok"
	    }
	}
	else {
	    "ok"
	}
    )
    
    prop call :: (
	if (CLK.USETIMER != 0) {
	    PRD.MICROSECONDS = CLK.MICROSECONDS
	},
	PRD.CALLBACKOBJ.call()
    )
    
    prop cGen :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "prd.h" : ""
    
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far PRD_Obj %0r;\n\0"
	}
	else {
	    "extern PRD_Obj %0r;\n\0"
	}
    )
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global USECLK :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Use CLK Manager to drive PRD"
	prop JSName :: "USECLK"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    if ($1 == 1 && .USECLK == 0) {
		if (CLK.USETIMER == 0) {
		    .error("In order to drive periodic functions, the CLK Manager must be enabled")
		}
		else {
		    .USECLK = 1,
		    .MICROSECONDS = CLK.MICROSECONDS,
		    CLK.CALLBACKOBJ = PRD,
		    PRD_clock.Create("PRD"),
		    GlobalStatus.gDirty = 1,
		    if (GlobalStatus.MinStackSize >= MEM.STACKSIZE){
                      .USECLK = 0,
		      .MICROSECONDS = 0.0,
                      CLK.CALLBACKOBJ = nil,
                      PRD_clock.Delete("PRD"),
                      .error("Current Stack size inadequate to enable this option")
		      }
		    else {
		      "ok"
		    }
		}
	    }
	    else {
		if ($1 == 0 && .USECLK == 1) {
		    .USECLK = 0,
		    .MICROSECONDS = 0.0,
		    CLK.CALLBACKOBJ = nil,
		    PRD_clock.Delete("PRD")
		},
		      "ok"
	    }
	)
	prop NoGen :: 1
    }
   
    
    
    global MICROSECONDS ::= CLK.MICROSECONDS {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style :: 0x04
	prop Format :: "%.1f"
	prop Label :: "Microseconds/Tick"
	prop JSName :: "MICROSECONDS"
	prop Visible :: 1
	prop Writable :: .USECLK == 0
	prop NoGen :: 1
    }
    global SCALAR ::= (		
	$d = 2,
	$f = 0,
	
	while ($d <= 0x4000 && $f == 0) {
	    scan ($i; PRD) {
		if (($i.period / $d) * $d != $i.period) {
		    $f = 1
		}
	    },
	    if ($f == 0) {
		$d = 2 * $d
	    }
	},
	$d / 2
    ) {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    
    prop DEFAULT_THOOKFXN :: @_KNL_tick 
    global THOOKFXN :: .DEFAULT_THOOKFXN {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "System Tick Hook Function"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
    }
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst period :: 0xffff {	
	prop Label :: "period (ticks)"
	prop JSName :: "period"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    if ($1 > 0) {
		.period = $1,
		.gDirty = 1,
		"ok"
	    }
	    else {
		.error("Periodic function periods must be greater than 0")
	    }
	)
    }
    inst mode :: "continuous" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "continuous,one-shot"
	prop JSName :: "mode"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst function :: @FXN_F_nop {	
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst arg0 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg0"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst arg1 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg1"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst milliseconds ::= (
	(.period * PRD.MICROSECONDS) / 1000.0
    ) {
	prop Label :: "period (ms)"
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style :: 0x04
	prop Format :: "%.1f"
	prop Visible :: 1
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    inst Order :: 0 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
        prop NoGen :: 1
        prop Writable :: 1
    }
    
    inst iPri :: 0 {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}
object PRD_swi :: SWI {
    param function :: @PRD_F_swi
    param iComment :: "This Software ISR executes all configured PRD functions"
    param iDelUser :: "PRD"
    param iDelMsg  :: (
	"This object is automatically deleted when all PRD objects are deleted"
    )
}
object PRD_clock :: CLK {
    param function :: @PRD_F_tick
    param iComment :: "This clock function calls PRD_tick from within the on-chip timer ISR"
    param iDelUser :: "PRD"
    param iDelMsg  :: (
	"This object is automatically deleted by disabling the 'Use CLK Manager to drive PRD' option of PRD"
    )
}
type RTDX {
    isa ObjectMgr
    prop Label :: "RTDX - Real-Time Data Exchange Settings"
    prop name :: "RTDX"
    prop IsConfMod :: .USERTDX		
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 145
    prop InstanceIcon :: 146
    prop GlobalHelpTopic :: (
	113
    )
    prop InstanceHelpTopic :: (
	213	
    )
    prop InstancePropertyPage :: (		
	"{f80273c0-3838-11d2-a32c-006097656921}"
    )
    
    prop GlobalPropertyPage :: (		
	"{050a0600-3839-11d2-a32c-006097656921}"
    )
    prop AllocType :: (.USERTDX ?
	"2\0, _rtdxDataAllocDesc, _rtdxDataSeg, _placement,
	     _rtdxTextAllocDesc, _rtdxTextSeg, _placement"
	:
	""
    )
    prop _rtdxDataAllocDesc :: (
	" .%1L_data: {} \0, name"	
    )
    prop _rtdxTextAllocDesc :: (
	if (MEM.ENABLELOADSEG == 1) {
	    if (MEM.RTDXTEXTMEMSEG == MEM.LOADRTDXTEXTMEMSEG) {
		" .%1L_text: {} \0, name"	
	    }
	    else {
		" .%1L_text: {} load > %2s, run \0, name, _loadRtdxTextMemSeg"
	    }
	}
	else {
	    " .%1L_text: {} \0, name"
	}
    )
    prop _rtdxDataSeg :: RTDX.DATAMEMSEG
    prop _rtdxTextSeg :: MEM.RTDXTEXTMEMSEG
    prop _loadRtdxTextMemSeg :: MEM.LOADRTDXTEXTMEMSEG
    prop _placement :: (0x7fffffff / 2)
    prop _objSize :: RTDX.BUFMEMSIZE
    prop GenLinkPrologue :: (.USERTDX ?
         "_RTDX_interrupt_mask = 0x%1x;\n\0, _interruptMask"
	:
	""
    )
    prop _interruptMask :: RTDX.MASK
    
    prop cGen :: 1
    
    
    prop noObjectAlias :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "rtdx.h" : ""
    
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
            if (.iChannelMode == "output") {
	        "extern far RTDX_outputChannel %0r;\n\0"
	    }
	    else {
	        "extern far RTDX_inputChannel %0r;\n\0"
	    }
	}
        else {
            if (.iChannelMode == "output") {
                "extern RTDX_outputChannel %0r;\n\0"
	    }
	    else {
	        "extern RTDX_inputChannel %0r;\n\0"
	    }
        }
    )
    prop cGenCInst :: (
	if (.iChannelMode == "output") {
	    "RTDX_CreateOutputChannel(%0r);\n\0"
	}
	else {
	    "RTDX_CreateInputChannel(%0r);\n\0"
	}
    )
    prop dataSize :: (
	$d = 0,
	if (.USERTDX) {
	    $d = RTDX.BUFMEMSIZE
	}
	else {
	    $d = 0
	},
	scan ($a; RTDX) {
	    if ($a.iChannelMode == "output") {
		$d += 1
	    }
	    else {
		$d += 3
	    }
	},
	$d
    )
    prop localCanCreate :: (
	$e = "ok",
	if (RTDX.USERTDX != 1) {
	    $e = .error("RTDX manager not enabled")
	},
	$e
    )
    global USERTDX ::= 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable Real-Time Data Exchange (RTDX)"
	prop JSName :: "ENABLERTDX"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
        prop Set :: (
            if($1 == 0) {
                if(HST.LNKTYPE == "RTDX") {
                    .error("RTDX is being used by HST; select a different host link type before attempting to disable RTDX") 
                }
                else {
		    if (.gNumOf > 0) {
			.error("Cannot disable RTDX until all RTDX objects are deleted.")
		    }
		    else {
		        GlobalStatus.gDirty = 1,   
                        .USERTDX = $1,
	                if (RTDX.CALLBACKOBJ != nil) {
		            RTDX.CALLBACKOBJ.call()
                        },
                        "ok"
		    }
                }
            }
	    else {
		GlobalStatus.gDirty = 1,	
                .USERTDX = $1,
		if (RTDX.CALLBACKOBJ != nil) {
		    RTDX.CALLBACKOBJ.call()
                },
                "ok"
            }
        )
    }
    global USERTEXECUTION ::= 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable Real-Time Execution Control"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global RTDXTYPE :: "JTAG" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "JTAG,HSRTDX,Simulator"
	prop Label :: "RTDX Mode"
	prop JSName :: "MODE"
	prop Visible :: 1
	prop Writable :: .USERTDX
	prop NoGen :: 1
	prop Set :: (
	    .RTDXTYPE = $1,
	    if (RTDX.CALLBACKOBJ != nil) {
		RTDX.CALLBACKOBJ.call()
	    },
	    "ok"
	)
     }
    global DATAMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "RTDX Data Segment (.rtdx_data)"
	prop JSName :: "RTDXDATASEG"
	prop Visible :: 1
	prop Writable :: .USERTDX 
	prop NoGen :: 0
    }
    
    global BUFMEMSIZE ::= (256 + 2) * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE) {  
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Label :: "RTDX Buffer Size (MAUs)"
	prop JSName :: "BUFSIZE"
	prop Visible :: 1
	prop Writable :: .USERTDX 
	prop NoGen :: 0
        prop Set :: (
	    if (HST.RTDX == 0) {
                .BUFMEMSIZE = $1,
		GlobalStatus.gDirty = 1,	
		"ok"
	    }
	    else {
                if ($1 < (HST.MAXFRAMESET + 2) * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) {
                    .error("size (in MAUs) must be at least: (largest configured HST channel framesize in words + 2) * (MAUs per word)")
                }
                else {
                    .BUFMEMSIZE = $1,
		    GlobalStatus.gDirty = 1, 	
		    if (HST.LNKTYPE == "RTDX") {
			HST.MAXFRAMEALLOWED = (.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 2,
			"ok"
		    }
		    else {
			"ok"
		    }
                }
	    }
        )
    }
    global TEXTMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "RTDX Text Segment (.rtdx_text)"
	prop Visible :: 0
	prop Writable :: .USERTDX 
	prop NoGen :: 1
    }
    global MASK :: 0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%08x"
	prop Style :: 0x02
	prop Label :: "RTDX Interrupt Mask"
	prop JSName :: "INTERRUPTMASK"
	prop Visible :: 1
	prop Writable :: .USERTDX 
	prop NoGen :: 1
	prop Set :: (
	    .MASK = $1,
	    "ok"
	)
    }
    
    inst iChannelMode :: "output" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Channel Mode"
	prop JSName :: "channelMode"
	prop Enum :: "input,output"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    GlobalStatus.gDirty = 1,
	    .iChannelMode = $1,
	    "ok"
	)
    }
    
     global CALLBACKOBJ :: nil {
	 prop Visible :: 0
	 prop Writable :: 0
	 prop NoGen :: 1
    }
}
type HST {
    isa  ObjectMgr
    prop name :: "HST"
    prop Label :: "HST - Host Channel Manager"
    prop IsContainedIn :: IOF
    prop FileStream :: 1
    prop GlobalIcon :: 107
    prop InstanceIcon :: 108
    prop GlobalHelpTopic :: (
	104
    )
    prop InstanceHelpTopic :: (
	204
    )
    prop maxObjs :: (
	GBL.DSPWORDSIZE
    )
    prop dataSize :: (
	$b = 0,
	scan ($i; HST) {
	    if ($i.IsConfObj()) {
		$b += (12 + $i.framesize) * $i.numframes + 100 + (5 * 4)
	    }
	},
	$b
    )
    prop InstancePropertyPage :: (
	    "{B7240DEA-AA51-11cf-9BFE-0000C0AC14C8}"
    )
    
    prop GlobalPropertyPage :: (
	    "{B7240DEB-AA51-11cf-9BFE-0000C0AC14C8}"
    )
    prop DependsOn :: "HWI"
    prop localCreate :: (
	PIP.gNumEmbed += 1,
	if (.gNumOf == 0) {
	    (LNK_dataPump.Create("HST"))
	},
     	"ok"
    )
    prop localDelete :: (
	PIP.gNumEmbed -= 1,
	$b = 0,			
	scan ($i; HST) {
	    if ($i != self) {
	        if($i.IsConfObj()) {
	            if($i.framesize > $b) {
	                $b = $i.framesize 
	            } 
	        }
	    }
        },
	.MAXFRAMESET = $b,
	if (.gNumOf == 1) {
	    (LNK_dataPump.Delete("HST"))
	},
	"ok"
    )
    prop AllocType :: (
	"2\0, _globalAllocDesc, _memSeg, _placement, \
	      _dsmAllocDesc, _dsmMemSeg, _placement"
    )
    prop _globalAllocDesc :: (
	"%8t .%1L: {%12t\n  %1U_A_TABBEG = .;\n _%1U_A_TABBEG = .;\n %2S\n %1U_A_TABEND = .;\n _%1U_A_TABEND = .;\n  %1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;\n _%1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;%8t\n }\0, name, _linkString, _objSize"
    )
    prop _dsmAllocDesc :: (
	"%8t .dsm: {}"
    )
    prop _placement :: (0x7fffffff / 2)
    prop AllocInst :: (
	"1\0, _instAllocDesc, _objMemSeg, _placement"
    )
    prop _instAllocDesc :: (
	"/* %0s buffer */\n.hst%2d: %3S\0, name, _objId, _alignString, _objAlign"
    )
    prop _alignString :: .bufalign > 1 ? "align = 0x%4x {}" : ""
    prop _objId :: .iId
    prop _objAlign :: .bufalign
    prop _objMemSeg :: .bufseg
    prop _linkString :: (.gNumOf + .gNumEmbed) > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop _memSeg :: HST.OBJMEMSEG
    prop _dsmMemSeg :: HST.DSMBUFSEG
    prop _objSize :: (5 * 4)
    
    prop cGen :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "hst.h" : ""
    
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far HST_Obj %0r;\n\0"
	}
	else {
	    "extern HST_Obj %0r;\n\0"
        }
    )
    prop modifiable :: (
	(.iDelUser == "USER" ? 1 : 0)
    )
    global gNumEmbed :: 0 {     
        prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global LNKTYPE :: (
		if (0 == 0) {
		     "RTDX"
		}
		else {
		    if (0 == 1) {
			"Shared Memory"
		    }
		    else {
		        if (0 == 3) {
			    "EVM54"
		        }
		        else {
			    "NONE"
		        }
		    }
		} ) {
        prop Label :: "Host Link Type"
	prop JSName :: "HOSTLINKTYPE"
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "RTDX,NONE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (
	    if ($1 == "RTDX") {
		if (RTDX.USERTDX == 0) {
                    .error("RTDX module must be enabled before it can be used by HST")
		}
		else {
                    if ((RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 2 < .MAXFRAMESET) {
                        .error("RTDX buffer size too small for largest configured HST channel")
                    }
                    else {
			if (.LNKTYPE == "NONE") {
                    	    GlobalStatus.gDirty = 1,
                            .LNKTYPE = $1,
	    		    $b = 0,
	    		    scan ($i; HST) {
	        	        if($i.IsConfObj()) {
	             		    if($i.framesize > $b) {
	                 	        $b = $i.framesize 
	             	    	    } 
	         	        }
            		    },
			    .MAXFRAMESET = $b,
    			    .MAXFRAMEALLOWED = (RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 2, 
                            "ok"
			}
			else {
                            .LNKTYPE = $1,
    			    .MAXFRAMEALLOWED = (RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 2, 
                            "ok"
			}
                    }
		}
	    }
	    else {
		if ($1 == "Shared Memory") {
                    if ((.DSMMEMSIZE/4) < .MAXFRAMESET) {
                        .error("Shared memory buffer too small for largest configured HST channel")
                    }
                    else {
			if (.LNKTYPE == "NONE") {
                    	    GlobalStatus.gDirty = 1,
                            .LNKTYPE = $1,
	    		    $b = 0,
	    		    scan ($i; HST) {
	        	        if ($i.IsConfObj()) {
	             		    if($i.framesize > $b) {
	                 	        $b = $i.framesize 
	             	    	    } 
	         	        }
            		    },
			    .MAXFRAMESET = $b,
    			    .MAXFRAMEALLOWED  = .DSMMEMSIZE/4,
                            "ok"
			}
			else {
                            .LNKTYPE = $1,
    			    .MAXFRAMEALLOWED  = .DSMMEMSIZE/4,
                            "ok"
			}
                    }
		}
		else {
                    GlobalStatus.gDirty = 1,
                    .LNKTYPE = $1,
                    "ok"
		}
            }
        )
    }
    global RTDX ::= .LNKTYPE == "RTDX" ? 1 : 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use RTDX for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global DSM ::= .LNKTYPE == "Shared Memory" ? 1 : 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Shared Memory for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global EVM54 ::= .LNKTYPE == "EVM54" ? 1 : 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use EVM54's I/O ports for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global NONE ::= .LNKTYPE == "NONE" ? 1 : 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "No host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global MAXFRAMESET ::= (
	    $b = 0,		
	    scan ($i; HST) {
	        if($i.IsConfObj()) {
	             if($i.framesize > $b) {
	                 $b = $i.framesize 
	             } 
	         }
            }
	) {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAXFRAMESET"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global MAXFRAMEALLOWED ::= .RTDX == 1 ? (RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 2 : .DSMMEMSIZE /4 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAXFRAMEALLOWED"
        prop Visible :: 0 	
        prop Writable :: 1
        prop NoGen :: 0
    }
    global DSMBUFSEG ::= .OBJMEMSEG {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Shared Memory Segment"
        prop Visible :: 0			
        prop Writable :: .DSM 
        prop NoGen :: 0
    }
 
    global DSMMEMSIZE ::= 1024 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop Label :: "Shared Memory Frame Size (MAUs)"
        prop Visible :: 0
        prop Writable :: .DSM
        prop NoGen :: 0
        prop Set :: (
            if ($1 < HST.MAXFRAMESET *4) {
                .error("size (in MAUs) must be at least: 4 * largest configured HST channel framesize (in words)")
            }
            else {
                .DSMMEMSIZE = $1,
                GlobalStatus.gDirty = 1,    
	        if (.LNKTYPE == "Shared Memory") {
	            .MAXFRAMEALLOWED  = .DSMMEMSIZE/4,
                    "ok"
		}
		else {
		    "ok"
		}
            }
        )
    }
    inst mode :: "output" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "mode"
	prop Enum :: "input,output"
	prop Visible :: 1
	prop Writable :: .modifiable()
	prop NoGen :: 0
    }
    inst bufseg ::= .OBJMEMSEG {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "bufseg"
	prop JSName :: "bufSeg"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst bufalign :: 4 { 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "bufAlign"
	prop Visible :: 1
	prop Writable :: .modifiable()
	prop NoGen :: 1
	prop Set :: (	        
	    if ($1 < 4) {		
	        .error("Alignment must be greater than or equal to 4")
	    }
	    else {
		if (($1 % 2) != 0) {  	
	            .error("Alignment must be a power of 2")
		}
		else {
		    $i = $1,	
		    while ((($i % 2) == 0) && ($i != 2)) {
		        $i = $i / 2
		    },
		    if(($i % 2) != 0) {	
	                .error("Alignment must be a power of 2")
		    }
		    else {	     	
		        .bufalign = $1,
	  	        "ok"
		    }
		}
	    }
	)
    }
    inst buf :: "<NULL>" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst framesize :: 0x80 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "framesize (words)"
	prop JSName :: "frameSize"
	prop Style :: 0x01 | 0x02
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    if ($1 < 1) {
		.error("framesize must be >= 1.")
	    }
	    else {
		if (($1 > .MAXFRAMEALLOWED) && ((.RTDX == 1) || (.DSM == 1)) ) {
		    if (.RTDX == 1) {
		        .error("size (in words) is limited to: (RTDX buffer size in MAUs) / (MAUs per word) - 2")
		    }
		    else {
		            .error("size (in words) is limited to: shared memory frame size (in MAUs)/4")
		    }
		}
		else {
		    .framesize = $1,		
		    $b = 0,			
		    scan ($i; HST) {
	        	if($i.IsConfObj()) {
	            	    if($i.framesize > $b) {
	                	$b = $i.framesize 
	            	    } 
	        	}
        	    },
		    .MAXFRAMESET = $b,		
	  	    GlobalStatus.gDirty = 1,	
		    "ok"
		}
	    }
	)
    }
    inst numframes :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01
	prop JSName :: "numFrames"
	prop Visible :: 1
	prop Writable :: .modifiable()
	prop NoGen :: 0
	prop Set :: (
	    if ($1 < 1) {
		.error("Channels must contain at least 1 frame.")
	    }
	    else {
		GlobalStatus.gDirty = 1,
		.numframes = $1,
		"ok"
	    }
	)
    }
    inst stsflg :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "statistics"
	prop JSName :: "statistics"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst notify :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyFxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "DHL" || .iDelUser != "USER" ? 0 : 1)
	prop NoGen :: 0
	prop TabName :: "Notify Function"
    }
    inst arg0 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg0"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "DHL" || .iDelUser != "USER" ? 0 : 1)
	prop NoGen :: 0
	prop TabName :: "Notify Function"
    }
    inst arg1 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg1"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "DHL" || .iDelUser != "USER" ? 0 : 1)
	prop NoGen :: 0
	prop TabName :: "Notify Function"
    }
    
    inst lnk ::= .RTDX ? "RTDX" : "NOTRTDX" {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "link type"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst iDHLAvailable :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Make this channel available for a new DHL device"
	prop JSName :: "availableForDHL"
        prop Set :: (
	    if (($1 == 0) && (.iDHLAvailable == 1)) {
		DHL.gChannelsAvailable--
	    }
	    else {
		if (($1 == 1) && (.iDHLAvailable == 0)) {
		    DHL.gChannelsAvailable++
		}
	    },
	    .iDHLAvailable = $1,
	    "ok"
	)
	prop Writable :: .modifiable()
        prop Visible :: 1
	prop NoGen :: 1
    }
    
    inst bufFrameAlign ::= .bufalign  { 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
}
object LNK_dataPump :: IDL {
    param function :: @LNK_F_dataPump
    param cycles :: 0			
    param iDelUser :: "HST"
    param iDelMsg  :: (
	"This object cannot be deleted"
    )
}
object RTA_dispatcher :: IDL {
    param function :: @RTA_F_dispatch
    param cycles :: 0			
    param iDelUser :: "HST"
    param iDelMsg  :: (
	"This object cannot be deleted"
    )
}
object RTA_fromHost :: HST {
    param iComment  :: (
	"Used to access LOG and STS data"
    )
    param mode :: "input"
    param framesize :: 4 
    param numframes :: 1 
    param iDelUser :: "HST"
    param iDelMsg  :: (
	"This object cannot be deleted"
    )
    param iDHLAvailable :: 0 
} 
object RTA_toHost :: HST {
    param iComment  :: (
	"Used to access LOG and STS data"
    )
    param mode :: "output"
    param framesize :: 64 
    param numframes :: 1 
    param iDelUser :: "HST"
    param iDelMsg  :: (
	"This object cannot be deleted"
    )
    param iDHLAvailable :: 0
}
type HWI {
    isa	 ObjectMgr
    prop name :: "HWI"
    prop Label :: "HWI - Hardware Interrupt Service Routine Manager"
    prop IsContainedIn :: SCH
    prop SortChildHierView :: 0
    prop GlobalIcon :: 109
    prop InstanceIcon :: 110
    prop InstanceHelpTopic :: (
	205
    )
    
    prop GlobalHelpTopic :: (
	105
    )
    prop dataSize :: (
	 0 * HWI.gNumOf
    )
    prop localCanCreate :: (
	.error("New hardware interrupt objects cannot be created")
    )
    prop InstancePropertyPage :: (
	    "{B7240DE6-AA51-11cf-9BFE-0000C0AC14C7}"
    )
   
    prop GlobalPropertyPage :: (
	    "{B7240DE7-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    prop DependsOn :: "GBL,OBJ,CLK,IDL,LCK,LOG,MBX,MEM,PIP,PRD,QUE,RTDX,SEM,STS,SYS"
   prop AllocType :: (.ZEROTAB ?
	"1\0,	_stubsAllocDesc,	_memSeg,	_placement"
	:
        if ((MEM.ENABLELOADSEG) && (MEM.VECMEMSEG != MEM.LOADVECMEMSEG)) {
	    "2\0,	_stubsAllocDesc,	_memSeg,	_placement,
	   		_vectAllocDesc,		_loadvecSeg,	_minplace"
	}
	else {
	    "2\0,	_stubsAllocDesc,	_memSeg,	_placement,
			_vectAllocDesc,		_vecSeg,	_minplace"
	}
    )
    prop _stubsAllocDesc :: (
	if ((MEM.ENABLELOADSEG) && (MEM.STUBMEMSEG != MEM.LOADSTUBMEMSEG))  {
	    "%8t .%1L: {} load > %2s, run\0, name, _loadstubSeg"
	}
	else {
	    "%8t .%1L: {} \0, name"
	}
    )
    prop _vectAllocDesc :: (
        if ((MEM.ENABLELOADSEG) && (MEM.VECMEMSEG != MEM.LOADVECMEMSEG)) {
	    "%8t .%1L_vec: {%12t\n %1U_A_VECS = .;\n *(.hwi_vec)%8t\n } run > %2s align = 0x400, load \0, name, _vecSeg"
	}
	else {
	    "%8t .%1L_vec: {%12t\n %1U_A_VECS = .;\n *(.hwi_vec)%8t\n } align = 0x400\0, name"
	}
	    
    )
    prop _placement :: (0x7fffffff / 2)
    prop _minplace  :: 0
    prop GenLinkPrologue :: (.ZEROTAB ?
  	if ((MEM.ENABLELOADSEG) && (MEM.VECMEMSEG != MEM.LOADVECMEMSEG)) {
         "SECTIONS {%4t\n .%1L_vec: {%8t\n %1U_A_VECS = .;\n *(.hwi_vec)%4t\n }  load >  %2s, run = 0x0 %0t\n}\n\0 , name, _loadvecSeg"
 	}
  	else {
	"SECTIONS {%4t\n .%1L_vec: 0x0 {%8t\n %1U_A_VECS = .;\n *(.hwi_vec)%4t\n }%0t\n}\n\0, name"
 	}
         :.GENERATE_RESET_VEC ?
         "SECTIONS {%4t\n .%1L_reset: 0x0 {}%0t\n}\n\0, name":""
    )
    prop localInit :: (
	if (RTDX.CALLBACKOBJ != nil) {
	    .error("HWI initialization failure.")
        },
	RTDX.CALLBACKOBJ = HWI
    )
    prop call :: (
	if ( RTDX.USERTDX == 0 ) {
	    HWI_RESERVED1.function = @HWI_unused,
	    HWI_RESERVED1.iUseDispatcher = 0
        }
	else {
	    HWI_RESERVED1.function = @_RTDX_Poll,
	    HWI_RESERVED1.iUseDispatcher = 1
        }
    )
    prop _memSeg :: MEM.STUBMEMSEG
    prop _loadstubSeg :: MEM.LOADSTUBMEMSEG
    prop _linkString :: (
	$b = 0,
	scan ($a; HWI) {
	    if ($a.monitor != "Nothing") {
		$b = 1
	    }
	},
	if ($b == 1) {
	    "*(.hwi)"
	}
	else {
	    "/* no HWI stubs are necessary */"
	}
    )
    
    prop name2addr :: (
	$i = 0,
	$b = nil,
	scan ($a; { "Nothing","Data Value","Stack Pointer","Top of SW Stack", "A0","A1","A2","A3","A4","A5","A6","A7","A8","A9","A10", "A11","A12","A13","A14","A15", "B0","B1","B2","B3","B4","B5","B6","B7","B8","B9","B10", "B11","B12","B13","B14","B15"}) {		
	    if ($b == nil) {		
		if ($a == $1) {		
		    $b = {0, 0, 0, @GBL_stackbeg,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}[$i]	
		},
		$i++
	    }
	},
	if ($b == nil) {		
	    $b = 0			
	},
	$b
    )
    
    prop name2type :: (
	$i = 0,
	$b = nil,
	scan ($a; { "Nothing","Data Value","Stack Pointer","Top of SW Stack", "A0","A1","A2","A3","A4","A5","A6","A7","A8","A9","A10", "A11","A12","A13","A14","A15", "B0","B1","B2","B3","B4","B5","B6","B7","B8","B9","B10", "B11","B12","B13","B14","B15"}) {		
	    if ($b == nil) {		
		if ($a == $1) {		
		    if ($i < 5) {
			$b = {"unsigned", "signed", "unsigned", "unsigned", "unsigned"}[$i] 
		    }
		},
		$i++
	    }
	},
	if ($b == nil) {		
	    $b = "unsigned"		
	},
	$b
    )
    
    global STUBMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
	prop Label :: "Function Stub Memory"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global ZEROTAB ::= MEM.VECMEMSEG.base == 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Writable :: 0
	prop Visible :: 0
    }
    prop _vecSeg :: MEM.VECMEMSEG
    prop _loadvecSeg :: MEM.LOADVECMEMSEG
    global VECMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop Label :: "Interrupt Service Table Memory"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
        prop MemberTest :: MEM.codeMember($1)
	prop Set :: (
		.VECMEMSEG = $1,
		if ($1.base == 0) {
			.GENERATE_RESET_VEC = 0
		},
		"ok"
	)
    }
    global GENERATE_RESET_VEC :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Generate RESET vector at address 0 "
	prop JSName :: "RESETVECTOR"
	prop Writable :: .ZEROTAB == 0
	prop Visible :: 1
	prop NoGen :: 0
    }
    global EXT4_POLARITY :: "low-to-high" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "low-to-high,high-to-low"
	prop Label :: "External Interrupt Pin 4 Polarity"
	prop JSName :: "EXTPIN4POLARITY"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global EXT5_POLARITY :: "low-to-high" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "low-to-high,high-to-low"
	prop Label :: "External Interrupt Pin 5 Polarity"
	prop JSName :: "EXTPIN5POLARITY"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global EXT6_POLARITY :: "low-to-high" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "low-to-high,high-to-low"
	prop Label :: "External Interrupt Pin 6 Polarity"
	prop JSName :: "EXTPIN6POLARITY"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global EXT7_POLARITY :: "low-to-high" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "low-to-high,high-to-low"
	prop Label :: "External Interrupt Pin 7 Polarity"
	prop JSName :: "EXTPIN7POLARITY"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global POLARITYMASK ::=
	(.EXT4_POLARITY == "high-to-low" ? 1 : 0) | (.EXT5_POLARITY == "high-to-low" ? 1 : 0) << 1 | (.EXT6_POLARITY == "high-to-low" ? 1 : 0) << 2 | (.EXT7_POLARITY == "high-to-low" ? 1 : 0) << 3 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global INTRMULTLOW ::=
	(HWI_INT4.iSource.iIntrSelectNum) | (HWI_INT5.iSource.iIntrSelectNum << 5) | (HWI_INT6.iSource.iIntrSelectNum << 10) | (HWI_INT7.iSource.iIntrSelectNum << 16) | (HWI_INT8.iSource.iIntrSelectNum << 21) | (HWI_INT9.iSource.iIntrSelectNum << 26){
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Writable :: 0
	prop Visible :: 0
	prop NoGen :: 0
    }
    global INTRMULTHIGH ::= 
	(HWI_INT10.iSource.iIntrSelectNum) | (HWI_INT11.iSource.iIntrSelectNum << 5) | (HWI_INT12.iSource.iIntrSelectNum << 10) | (HWI_INT13.iSource.iIntrSelectNum << 16) | (HWI_INT14.iSource.iIntrSelectNum << 21) | (HWI_INT15.iSource.iIntrSelectNum << 26){
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Writable :: 0
	prop Visible :: 0
	prop NoGen :: 0
    }
    inst iSource :: Reset {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: ISRC
	prop MemberTest :: 1
	prop Label :: "interrupt source"
	prop JSName :: "interruptSource"
	prop Visible :: 1
	prop Writable :: .iReMappable
	prop NoGen :: 1
	prop Set :: (
	    $a = $1,
	    if ($a == Reset) {
		.error ("The Reset interrupt source cannot be remapped")
	    }
	    else {
		if ($a == Non_Maskable) {
		    .error ("The Non-Maskable interrupt source cannot be remapped")
		}
		else {
		    if ($a == Reserved) {
			.error ("The Reserved interrupt source cannot be remapped")
                    }
		    else {
		        
		        if (CLK.WHICHHWI == self && $a != .iSource && CLK.USETIMER) {
		           .error ("This interrupt is in use by CLK, settings may be changed in the CLK Manager")
		        }
		        else {
		  	    
			    if ($a == CLK.WHICHHWI.iSource && CLK.USETIMER == 1) {
			        .error ("Interrupt source is in use by CLK, settings may be changed in the CLK Manager.")
			    }
			    else {
			        
			        $a.iHwi = self,
				
				.iSource.iHwi = HWI_UNUSED,
  			        .iSource = $1,
			        "ok"
			    }
			}
		    }
		}
	    }
	)
    }
    inst iReMappable :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iIntrEnableMask :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen  :: 1
    }
    inst function :: @HWI_unused {
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: (( .function == @RESERVED ) || ( .client != "USER" )) ? 0 : 1
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop NoGen :: 0
	prop Set :: (
		.function = $1,
		GlobalStatus.gDirty = 1,
		"ok"
	)
    }
    inst iSTSObj :: HWI_RESETSTS {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    inst monitor :: "Nothing" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "Nothing,Data Value,Stack Pointer,Top of SW Stack,A0,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14,A15,B0,B1,B2,B3,B4,B5,B6,B7,B8,B9,B10,B11,B12,B13,B14,B15"
	prop JSName :: "monitor"
	prop Visible :: 1
	prop Writable :: ((.function != @HWI_unused && .function != @RESERVED) && (.iId != 0))
	prop NoGen :: 0
	prop Set :: (
	    if ($1 != .monitor) {	
		$e = "ok",
		if ($1 == "Nothing") {
		    if (($e = .iSTSObj.Delete("HWI")) == "ok") {
			.monitor = "Nothing",
			.addr = .name2addr(.monitor),
			.dataType = .name2type(.monitor)
		    }
		}
		else {
		    if (.iSTSObj.iIsUsed || ($e = .iSTSObj.Create("HWI")) == "ok") {
			.monitor = $1,
			if (.monitor == "Data Value") {
			    .addr = .saveAddr,
			    .dataType = .saveType
			}
			else {
			    .addr = .name2addr(.monitor),
			    .dataType = .name2type(.monitor)
			}
		    }
		    else {
			.monitor = "Nothing"
		    }
		},
		$e
	    }
	    else {
		"ok"
	    }
	)
    }
    inst saveAddr :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    inst saveType :: "signed" {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    inst addr :: 0 {
	prop JSName :: "addr"
	prop Visible :: 1
	prop Writable :: (.monitor == "Data Value" ? 1 : 0)
	prop NoGen :: 0
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Format :: GBL.DSPTYPE == 62 ? "0x%08x" : "0x%04x"
	prop Set :: (
	    .addr = $1,
	    .saveAddr = $1,
	    "ok"
	)
    }
    inst dataType :: "signed" {
	prop Visible :: 1
	prop Writable :: (.monitor == "Nothing" ? 0 : 1)
	prop NoGen :: 0
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "signed,unsigned"
	prop Label :: "type"
	prop JSName :: "dataType"
	prop Set :: (
	    if (.monitor != "Nothing") {
		.dataType = $1,
		.saveType = $1,
		"ok"
	    }
	    else {
		.error("The monitor field must set to modify this field")
	    }
	)
    }
    inst operation :: "STS_add(*addr)" {
	prop Visible :: 1
	prop Writable :: (.monitor == "Nothing" ? 0 : 1)
	prop NoGen :: 0
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "operation"
	prop Enum :: "STS_add(*addr),STS_delta(*addr),STS_add(-*addr),STS_delta(-*addr),STS_add(|*addr|),STS_delta(|*addr|)"
	prop Set :: (
	    if (.monitor != "Nothing") {
		.operation = $1,
		"ok"
	    }
	    else {
		.error("The monitor field must set to modify this field")
	    }
	)
    }
    inst client :: "USER" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst iUseDispatcher :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Use Dispatcher"
	prop JSName :: "useDispatcher"
	prop Visible :: 1
	prop Writable :: ( .client == "USER" ) ? 1 : 0
	prop NoGen :: 0
	prop TabName :: "Dispatcher"
	prop Set :: (
		if(self == HWI_NMI){
			.error ("HWI dispatcher can't be used for  NMI")
		}
		else{
		.iUseDispatcher = $1,
		"ok"
		}
	)
    }
    inst iArg :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Arg"
	prop JSName :: "arg"
	prop Visible :: 1
	prop Writable :: (( .iUseDispatcher == 1 ) && ( .client == "USER" )) ? 1 : 0
	prop NoGen :: 0
	prop TabName :: "Dispatcher"
	prop Set :: (
	    .iArg = $1,
	    "ok"
	)
    }
    inst iIntrMask :: "self" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Interrupt Mask"
	prop JSName :: "interruptMask"
	prop Enum :: "all,none,self,bitmask"
	prop Visible :: 1
	prop Writable :: ( .iUseDispatcher == 1 ) ? 1 : 0
	prop NoGen :: 1
	prop TabName :: "Dispatcher"
	prop Set :: (
	    if ( $1 == "all" ) {
		.IntrMask = 0xffff
	    }
	    else {
		if ( $1 == "self" ) {
		    .IntrMask = 1 << .iId
		}
		else {
		    if ( $1 == "none" ) {
			.IntrMask = 0
		    }
		}
	    },
	    .iIntrMask = $1,
	    "ok"
	)
    }
	
    inst IntrMask :: ( 1 << .iId)  {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04x"
	prop Style :: 0x02
	prop Label :: "Interrupt Bit Mask"
	prop JSName :: "interruptBitMask"
	prop Visible :: 1
	prop Writable :: ((.iUseDispatcher == 1) && (.iIntrMask == "bitmask" )) ? 1 : 0
	prop NoGen :: 0
	prop TabName :: "Dispatcher"
	prop Set :: (
	    if ( $1 > 0xffff) {
		.error("Invalid Number")
	    }
	    else {
		.IntrMask = $1,
		"ok"
	    }
	)
    }
    inst iCacheControl :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Don't modify cache control"
	prop JSName :: "cacheControl"
	prop Visible :: 1
	prop Writable :: ( .iUseDispatcher == 1 ) ? 1 : 0
	prop NoGen :: 1
	prop TabName :: "Dispatcher"
	prop Set :: (
	    if ( $1 == 1 ) {
		.iCCBitMask = 0x1
	    }
	    else {
		.iCCBitMask = ( .iPCCBitMask | .iDCCBitMask)
	    }
	    ,
	    .iCacheControl = $1,
	    "ok"
	)
    }	
    inst iPCCMask :: (
	if (GBL.DSPSUBTYPE == 6200 || GBL.DSPSUBTYPE == 6700) {
	    "mapped"
	}
	else {
	    "cache enable"
	}
    ) {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "mapped,cache enable,cache freeze,cache bypass"
	prop Label :: "Program Cache Control Mask"
	prop JSName :: "progCacheMask"
	prop Visible :: 1
	prop Writable :: (( .iUseDispatcher == 1 ) && ( .iCacheControl == 0)) ? 1 : 0
	prop NoGen :: 1
	prop TabName :: "Dispatcher"
	prop Set :: (
	    if ((GBL.DSPSUBTYPE == 6211 || GBL.DSPSUBTYPE == 6711
	        || GBL.DSPSUBTYPE == 6400) && $1 != "cache enable") {
		.error("unsupported cache mode for 6x1x/64x device (cache enable must be selected)")
	    }
	    else {
		if ( $1 == "mapped" ) {
		    .iPCCBitMask = 0x0000
		}
		else {
		    if ( $1 == "cache enable" ) {
			.iPCCBitMask = 0x0040
		    }
		    else {
			if ( $1 == "cache freeze" ) {
			    .iPCCBitMask = 0x0060
			}
			else {
			    .iPCCBitMask = 0x0080
			}
		    }
		},
		.iPCCMask = $1,
		.iCCBitMask = .iPCCBitMask | .iDCCBitMask,
		"ok"
	    })
    }
    inst iPCCBitMask :: 0x0000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iDCCMask :: (
	if (GBL.DSPSUBTYPE == 6200 || GBL.DSPSUBTYPE == 6700) {
	    "mapped"
	}
	else {
	    "cache enable"
	}
    ) {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "mapped,cache enable,cache freeze,cache bypass"
	prop Label :: "Data Cache Control Mask"
	prop JSName :: "dataCacheMask"
	prop Visible :: 1
	prop Writable :: (( .iUseDispatcher == 1 ) && ( .iCacheControl == 0)) ? 1 : 0
	prop NoGen :: 1
	prop TabName :: "Dispatcher"
	prop Set :: (
	    if ((GBL.DSPSUBTYPE == 6211 || GBL.DSPSUBTYPE == 6711
	        || GBL.DSPSUBTYPE == 6400) && $1 != "cache enable") {
		.error("unsupported cache mode for 6x1x/64x device (cache enable must be selected)")
	    }
	    else {
		if ( $1 == "mapped" ) {
		    .iDCCBitMask = 0x0000
		}
		else {
		    if ( $1 == "cache enable" ) {
			.iDCCBitMask = 0x0008
		    }
		    else {
			if ( $1 == "cache freeze" ) {
			    .iDCCBitMask = 0x000C
			}
			else {
			    .iDCCBitMask = 0x0010
			}
		    }
		},
		.iDCCMask = $1,
		.iCCBitMask = .iPCCBitMask | .iDCCBitMask,
		"ok"
	    }
	)
    }
    inst iDCCBitMask :: 0x0000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iCCBitMask :: 1 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
}
object HWI_RESET_STS :: STS {
    param iComment :: "provides statistics for the RESET ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_RESET :: HWI {
    param iComment :: "defines function for the RESET ISR"
    param iSource :: Reset
    param iId :: 0			
    param iReMappable :: 0
    param function :: @_c_int00
    param iIsUsed :: 1
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_RESET_STS
    param iIntrEnableMask :: 1
}
object HWI_NMI_STS :: STS {
    param iComment :: "provides statistics for the NMI ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_NMI :: HWI {
    param iComment :: "defines function for the NMI ISR"
    param iSource :: Non_Maskable
    param iId :: 1			
    param iReMappable :: 0
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_NMI_STS
    param iIntrEnableMask :: 0x2
}
object HWI_RESERVED0_STS :: STS {
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_RESERVED0 :: HWI {
    param iComment :: "RESERVED for RTDX"
    param iId :: 2			
    param iSource :: Reserved
    param iReMappable :: 0
    param function :: @RESERVED
    param client :: "RTDX"
    param iIsUsed :: 1
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_RESERVED0_STS
    param iIntrEnableMask :: 0x4
}
object HWI_RESERVED1_STS :: STS {
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_RESERVED1 :: HWI {
    param iComment :: "RESERVED for RTDX"
    param iId :: 3			
    param iSource :: Reserved
    param iReMappable :: 0
    param function :: ( RTDX.USERTDX == 1 ) ? @_RTDX_Poll : @HWI_unused
    param client :: "RTDX"
    param iIsUsed :: 1
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_RESERVED1_STS
    param iIntrEnableMask :: 0x8
    param iUseDispatcher :: 1
}
object HWI_INT4_STS :: STS {
    param iComment :: "provides statistics for the INT4 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT4 :: HWI {
    param iComment :: "defines the INT4 Interrupt"
    param iSource :: External_Pin_4
    param iId :: 4			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT4_STS
    param iIntrEnableMask :: 0x10
}
object HWI_INT5_STS :: STS {
    param iComment :: "provides statistics for the INT5 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT5 :: HWI {
    param iComment :: "defines the INT5 Interrupt"
    param iSource :: External_Pin_5
    param iId :: 5			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT5_STS
    param iIntrEnableMask :: 0x20
}
object HWI_INT6_STS :: STS {
    param iComment :: "provides statistics for the INT6 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT6 :: HWI {
    param iComment :: "defines the INT6 Interrupt"
    param iSource :: External_Pin_6
    param iId :: 6			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT6_STS
    param iIntrEnableMask :: 0x40
}
object HWI_INT7_STS :: STS {
    param iComment :: "provides statistics for the INT7 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT7 :: HWI {
    param iComment :: "defines the INT7 Interrupt"
    param iSource :: External_Pin_7
    param iId :: 7			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT7_STS
    param iIntrEnableMask :: 0x80
}
object HWI_INT8_STS :: STS {
    param iComment :: "provides statistics for the INT8 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT8 :: HWI {
    param iComment :: "defines the INT8 Interrupt"
    param iSource :: EDMA_Controller
    param iId :: 8			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT8_STS
    param iIntrEnableMask :: 0x100
}
object HWI_INT9_STS :: STS {
    param iComment :: "provides statistics for the INT9 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT9 :: HWI {
    param iComment :: "defines the INT9 Interrupt"
    param iSource :: MCSP_0_Transmit
    param iId :: 9			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT9_STS
    param iIntrEnableMask :: 0x200
}
object HWI_INT10_STS :: STS {
    param iComment :: "provides statistics for the INT10 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT10 :: HWI {
    param iComment :: "defines the INT10 Interrupt"
    param iSource :: EMIF_SDRAM_Timer
    param iId :: 10			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT10_STS
    param iIntrEnableMask :: 0x400
}
object HWI_INT11_STS :: STS {
    param iComment :: "provides statistics for the INT11 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT11 :: HWI {
    param iComment :: "defines the INT11 Interrupt"
    param iSource :: RTDX.RTDXTYPE == "HSRTDX" ? DMA_Channel_2 : MCSP_0_Receive
    param iReMappable :: ( RTDX.RTDXTYPE == "HSRTDX" ) ? 0 : 1
    param function :: ( RTDX.RTDXTYPE == "HSRTDX" ) ? @_HSRTDX_xmt : @HWI_unused
    param iId :: 11			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT11_STS
    param iIntrEnableMask :: 0x800
}
object HWI_INT12_STS :: STS {
    param iComment :: "provides statistics for the INT12 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT12 :: HWI {
    param iComment :: "defines the INT12 Interrupt"
    param iSource :: RTDX.RTDXTYPE == "HSRTDX" ? DMA_Channel_3 : MCSP_1_Transmit
    param iReMappable :: ( RTDX.RTDXTYPE == "HSRTDX" ) ? 0 : 1
    param function :: ( RTDX.RTDXTYPE == "HSRTDX" ) ? @_HSRTDX_rec : @HWI_unused
    param iId :: 12			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT12_STS
    param iIntrEnableMask :: 0x1000
}
object HWI_INT13_STS :: STS {
    param iComment :: "provides statistics for the INT13 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT13 :: HWI {
    param iComment :: "defines the INT13 Interrupt"
    param iSource :: Host_Port_Host_to_DSP
    param iId :: 13			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT13_STS
    param iIntrEnableMask :: 0x2000
}
object HWI_INT14_STS :: STS {
    param iComment :: "provides statistics for the INT14 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT14 :: HWI {
    param iComment :: "defines the INT14 Interrupt"
    param function :: CLK.WHICHHWI == self ? @CLK_F_isr : @HWI_unused
    param client   :: CLK.WHICHHWI == self ? "CLK" : "USER"
    param iSource :: Timer_0
    param iId :: 14			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT14_STS
    param iIntrEnableMask :: 0x4000
    param iUseDispatcher :: (CLK.WHICHHWI == self && CLK.HOOKFXN == @HWI_F_dispatch) ? 1 : 0
    param iArg :: (.iUseDispatcher && CLK.WHICHHWI == self) ? @CLK_A_TABBEG : 0
}
object HWI_INT15_STS :: STS {
    param iComment :: "provides statistics for the INT15 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT15 :: HWI {
    param iComment :: "defines the INT15 Interrupt"
    param function :: CLK.WHICHHWI == self ? @CLK_F_isr : @HWI_unused
    param client   :: CLK.WHICHHWI == self ? "CLK" : "USER"
    param iSource :: Timer_1
    param iId :: 15			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT15_STS
    param iIntrEnableMask :: 0x8000
    param iUseDispatcher :: CLK.WHICHHWI == self ? 1 : 0
    param iArg :: (.iUseDispatcher && CLK.WHICHHWI == self) ? @CLK_A_TABBEG : 0
}
object HWI_UNUSED :: HWI {
    param iComment :: "a dummy DSP interrupt for unused sources"
    param iId :: 16			
    param iIsUsed :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT15_STS
    param iIntrEnableMask :: 0
}
type SWI {
    isa	ObjectMgr
    prop name :: "SWI"
    prop Label :: "SWI - Software Interrupt Manager"
    prop IsContainedIn :: SCH
    prop GlobalIcon :: 123
    prop InstanceIcon :: 124
    prop InstanceHelpTopic :: (
	211
    )
    
    prop GlobalHelpTopic :: (
	111
    )
    
    prop HighTimeBased :: (
        CLK.HIRES == 1 ? 1 : 0
    )
    prop LowTimeBased :: (
        CLK.HIRES == 1 ? 0 : 1
    )
    prop STSGetMaxFmt :: (
	if (SWI.STSUNITS == "raw") {
	    CLK.HIRES ? "%g inst" : "%g ints"
	}
	else {
	    SWI.STSUNITS == "microseconds" ? "%.1f us" : "%.2f ms"
	}
    )
    prop STSGetSumFmt :: (
	SWI.STSGetMaxFmt()
    )
    prop STSGetAvgFmt :: (
	if (SWI.STSUNITS == "raw") {
	    CLK.HIRES ? "%.2f inst" : "%.2f ints"
	}
	else {
	    SWI.STSUNITS == "microseconds" ? "%.1f us" : "%.2f ms"
	}
    )
    prop STSFilterMax :: (
	$a = (CLK.HIRES) ? $1 * CLK.INSTRPERCLK : $1,
	$a = $a * (CLK.TDDR + 1),
	$a
    )
    prop STSFilterSum :: (
	SWI.STSFilterMax($1)
    )
    
    prop GetPriority :: (
	.pri
    )
prop GenLinkPrologue :: (
	"SECTIONS {%4t\n.%1L: {%8t\n %1U_A_TABBEG = .;\n %4S\n %1U_A_TABEND = .;\n %1U_A_TABLEN = (. - %1U_A_TABBEG) / %2d;%4t\n} > %3s%5s\0, name, objSize, memSeg, linkString, pageString"
    )
    
    prop GenLinkEpilogue :: (
	"%0t}\n\0"
    )
    prop linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop pageString :: GBL.DSPTYPE == 62 ? "" : GBL.DSPTYPE == 55 ? "" : " PAGE 1"
    prop memSeg :: SWI.OBJMEMSEG
    
    prop objSize :: GBL.DSPTYPE == 55 ? (2 * (11 * 4)) : (11 * 4)
    prop maxObjs :: (
	32767				
    )
    prop dataSize :: (
	(11 * 4) * SWI.gNumOf
    )
    prop localCanCreate :: (
	if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {
	    .error("System stack size (see MEM) is too small to support a new SWI priority level.")
	}
	else {
	    "ok"
	}
    )
    prop localCreate :: (
	STS.gNumEmbed += 1,
	SWI.EXECFXN = @SWI_F_iexec,
	SWI.RUNFXN = @SWI_F_run,
	"ok"
    )
    prop localDelete :: (
	STS.gNumEmbed -= 1,
	if (.gNumOf == 1) {	
	    
	    SWI.EXECFXN = @FXN_F_nop,
	    SWI.RUNFXN = @FXN_F_nop
	},
	"ok"
    )
    prop SortByField :: "pri"
    prop SortGroups :: 15
    prop InstancePropertyPage :: (
	    "{B7240DEC-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
	    "{B7240DED-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    prop DependsOn :: "HWI,SIO"
    
    prop cGen :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "swi.h" : ""
    
    prop cGenHInst :: (
	if (GBL.DSPTYPE == 62) {
	    "extern far SWI_Obj %0r;\n\0"
	}
	else {
	    "extern SWI_Obj %0r;\n\0"
	}
    )
    global EHOOKFXN :: @GBL_NULL {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Enable Scheduler and Return to Idle Function"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
    }
    global IHOOKFXN :: @GBL_NULL {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Exit Scheduler and Return to Idle Function"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
    }
    global EXECFXN :: @FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Configured SWI executive"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global RUNFXN :: @FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Configured SWI executive body"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global STSUNITS :: "raw" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "raw,milliseconds,microseconds"
	prop Label :: "Statistics Units"
	prop Visible :: 0		
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst priority :: = (.pri + 1) {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "priority"
	prop JSName :: ""
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst function :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
    inst pri :: 1 {		
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	
	prop Enum :: "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14"
	prop Label :: "priority"
	prop JSName :: "priority"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
            $a = .pri,
            .pri = $1,
	    if (self == KNL_swi) {
		if ($1 != 0) {
		    .pri = $a,
		    .error("KNL_swi must remain at Priority 0.")
		}
		else {
		    "ok"
		}
	    }
	    else {
		if ($1 == 0 && KNL_swi.iIsUsed == 1) {
		    .pri = $a,
		    .error("Priority 0 reserved for KNL_swi only.")
		}
		else {
		    GlobalStatus.gDirty = 1,
		    if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {
			.pri = $a,
			.error("System stack size (see MEM) is too small to support a new SWI priority level.")
		    }
		    else {
			if ($1 > 14) {
			    .pri = $a,
			    .error("SWI can only support 15 priority levels.")
			}
			else {
			    "ok"
			}
		    }
		}
	    }
	)
    }
    inst mailbox :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "mailbox"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
    inst arg0 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg0"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
    inst arg1 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg1"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
    inst dorta :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    
    inst Order :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
	prop NoGen :: 1
	prop Writable :: 1
     }
}    
type TSK {
    isa ObjectMgr
    prop name :: "TSK"
    prop Label :: "TSK - Task Manager"
    prop IsConfMod :: .USETSK
    prop IsContainedIn :: SCH
    
    prop DependsOn :: "SWI,HOOK"
    prop GlobalIcon :: 143
    prop InstanceIcon :: 144
    prop GlobalHelpTopic :: (
	314
    )
    prop InstanceHelpTopic :: (
	414
    )
    prop InstancePropertyPage :: (
	"{473C4A64-B1A8-11d0-9885-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{473C4A65-B1A8-11d0-9885-0020AFEE33C6}"
    )
    prop SortByField :: "iPRI"
    prop SortGroups :: 17
    prop AllocType :: (
	if (.USETSK) {
	    "1\0,    _bssAllocDesc, _bssmemSeg, _placement"
	}
	else {
	    ""
	}
    )
    prop _objAllocDesc :: (   
	"%8t .TSK$obj: {}"
    )
    prop _bssAllocDesc :: (
	"%8t .tsk: {%12t\n *(.tsk)%8t\n }"
    )
    prop _bssmemSeg :: .OBJMEMSEG
    prop _objmemSeg :: MEM.CFGOBJSEG	
    prop AllocInst :: (
	.iAUTOSTK ? "1\0, _instStackDesc, _instStackSeg, _placement" : "0\0"
    )
    prop _instStackDesc :: (
        if (GBL.DSPTYPE == 40) {
	    "%8t .%0s$stk: fill = 0xC0FFEE {%12t\n %0s$stack = .;\n . += %1d;%8t\n }\0, _instStackSize"
	}
	else {
	    "%8t .%0s$stk: {%12t\n *(.%0s$stk)%8t\n }\0"
	}
    )
    prop _self :: self
    prop _instStackSize :: .iSTKSZ * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    prop _instStackSeg :: .iSTKSEG
    prop _placement :: (0x7fffffff / 2)
    prop localInit :: (
	KNL_swi.Create("SWI"),
 	if (.STACKSEG.iAllocHeap == 1) {
	    .STACKSEG.iReqHeapCount++,
	    "ok"
	}
	else {
	    .error ("TSK default stack segment must be a memory segment with a heap")
	}
    )
    
    prop HighTimeBased :: (
        CLK.HIRES == 1 ? 1 : 0
    )
    prop LowTimeBased :: (
        CLK.HIRES == 1 ? 0 : 1
    )
    prop STSGetMaxFmt :: (
	if (TSK.STSUNITS == "raw") {
	    CLK.HIRES ? "%g inst" : "%g ints"
	}
	else {
	    TSK.STSUNITS == "microseconds" ? "%.1f us" : "%.2f ms"
	}
    )
    prop STSGetSumFmt :: (
	TSK.STSGetMaxFmt()
    )
    prop STSGetAvgFmt :: (
	if (TSK.STSUNITS == "raw") {
	    CLK.HIRES ? "%.2f inst" : "%.2f ints"
	}
	else {
	    TSK.STSUNITS == "microseconds" ? "%.1f us" : "%.2f ms"
	}
    )
    
    prop STSFilterMax :: (
	$a = (CLK.HIRES) ? $1 * CLK.INSTRPERCLK : $1,
	$a = $a * (CLK.TDDR + 1),
	$a
    )
    prop STSFilterSum :: (
	TSK.STSFilterMax($1)
    )
    prop localCreate :: (
	STS.gNumEmbed += 1,
	"ok"
    )
    prop localCanCreate :: (
	$e = "ok",
	if (TSK.USETSK != 1) {
	    $e = .error("TSK manager not enabled")
	},
	$e
    )
    prop localDelete :: (
	STS.gNumEmbed -= 1,
	"ok"
    )
    
    prop GenLinkPrologue :: (
	if (.USETSK == 0) {
		"_KNL_swi = 0;"
	}
    )
    
    prop cGen :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "tsk.h" : ""
    
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far TSK_Obj %0r;\n\0"
        }
	else {
	    "extern TSK_Obj %0r;\n\0"
        }
    )
    global USETSK :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable TSK Manager"
	prop JSName :: "ENABLETSK"
	prop Visible :: 1
	prop Writable :: GBL.DSPSUBTYPE == 0x55DA200 ? 0:1
	prop NoGen :: 1
	prop Set :: (
	    if ($1 == 0) {
		if (.gNumOf > 1) {
		    .error("Cannot disable TSK until all TSK objects are deleted.")
		}
		else {
		    .STACKSEG.iReqHeapCount--,
		    TSK.STACKSEG = MEM_NULL,	
		    TSK.OBJMEMSEG = MEM_NULL,
		    TSK_idle.iSTKSEG = MEM_NULL,
		    TSK_idle.Delete("TSK"),
		    KNL_swi.Delete("TSK"),
		    PRD.THOOKFXN = @FXN_F_nop,
                    if (PRD.gNumOf == 0) {
                      if (PRD_clock.iIsUsed == 1) {
                        PRD_clock.function = @FXN_F_nop
                      }
                    },
		    .USETSK = $1,
		    "ok"
		}
	    } else {
		$e = "ok",
	        GlobalStatus.gDirty = 1,
	        if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {
                    $e = .error("Current stack size inadequate to enable TSK"),
		    break
		    },
		scan ($a; SWI) {
		    if ($a != KNL_swi && $a.pri == 0 && $a.iIsUsed == 1) {
			$e = .error("Cannot enable TSK when there are SWI objects at Priority 0."),
			break
		    }
		},
		if ($e == "ok") {
		    TSK.STACKSEG = MEM_NULL,  
		    scan($b; MEM) {
			if ($b.iAllocHeap && $b != MEM_NULL) {
		    	    
		    	    TSK.STACKSEG = $b,
			    break
			}
		    },
		    .STACKSEG.iReqHeapCount++,
		    .USETSK = $1,
		    				
		    TSK.OBJMEMSEG = SWI.OBJMEMSEG,
		    TSK_idle.iSTKSEG = .OBJMEMSEG,  
		    TSK_idle.Create("TSK"),
		    KNL_swi.Create("TSK"),
		    PRD.THOOKFXN = PRD.DEFAULT_THOOKFXN,
                    if (TSK.TSKTICK == "PRD") {
                      if (PRD_clock.iIsUsed == 1) {
                        PRD_clock.function = @PRD_F_tick
                      }
                    },
		    if ( MEM.NOHEAPS ) {
			.STACKSEG.iReqHeapCount++,
			$e = "No Memory Heaps Are Allocated for Dynamic TSK creation"
		    },
		    $e
		}
		else {
		    $e
		}
	    }
	)
    }
    
    prop _objId :: .iId
    prop dataSize :: (
	$d = 0,
	scan ($i; TSK) {
	    
	    $d += ($i.iSTKSZ + (3 + 21) * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE))
	},
	$d
    )
    
    prop minStackSize :: (
	$a = .STACKSIZE,
	scan ($i; TSK) {
	    if ($i.STACKSIZE < $a) {
		$a = $i.STACKSIZE
	    }
	},
	$a
    )
    prop maxObjs :: (32767)			
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "OBJMEMSEG"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataNullMember($1)
	prop Label :: "Object Memory"
	prop Visible :: 1
	prop Writable :: .USETSK
	prop NoGen :: 1
    }
    
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global STACKSIZE :: GBL.DSPTYPE == 62 ? 1024 : (GBL.DSPTYPE == 55) ? 1024 :(GBL.DSPTYPE == 28) ? 128 : 256 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01
	prop Label :: "Default stack size (MAUs)"
	prop JSName :: "STACKSIZE"
	prop Visible :: 1
	prop Writable :: .USETSK
    }	
    
    global STACKSEG :: MEM_NULL {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataNullMember($1) && $1.iAllocHeap
	prop Label :: "Stack segment for dynamic tasks"
	prop JSName :: "STACKSEG"
	prop Visible :: 1
	prop Writable :: .USETSK && (MEM.NOHEAPS == 0)
	prop Set :: (
	    if (.STACKSEG.iReqHeapCount > 0) {
		.STACKSEG.iReqHeapCount--
	    },
	    .STACKSEG = $1,
	    .STACKSEG.iReqHeapCount++,
	    "ok"
	)
    }	
    global PRIORITY :: 1 {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "PRIORITY"
	prop Enum :: "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
	prop Label :: "Default task priority"
	prop Visible :: 1
	prop Writable :: .USETSK
    }
    global CREATEFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Create function"
	prop JSName :: "CREATEFXN"
	prop Visible :: 1
	prop Writable :: .USETSK
	prop TabName :: "Function Hooks"
	prop Set :: (
	    .CREATEFXN = $1,
	    HOOK_KNL.createFxn = .CREATEFXN,
	    "ok"
	)
	prop NoGen :: 1
    }
    global VCREATEFXN ::= HOOK_KNL.iIsUsed == 1 ? @__HOOK_doCreate : .CREATEFXN {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
    }
    global DELETEFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Delete function"
	prop JSName :: "DELETEFXN"
	prop Visible :: 1
	prop Writable :: .USETSK
	prop TabName :: "Function Hooks"
	prop Set :: (
	    .DELETEFXN = $1,
	    HOOK_KNL.deleteFxn = .DELETEFXN,
	    "ok"
	)
	prop NoGen :: 1
    }
    global VDELETEFXN ::= HOOK_KNL.iIsUsed == 1 ? @__HOOK_doDelete : .DELETEFXN {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
    }
    global EXITFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Exit function"
	prop JSName :: "EXITFXN"
	prop Visible :: 1
	prop Writable :: .USETSK
	prop TabName :: "Function Hooks"
	prop Set :: (
	    .EXITFXN = $1,
	    HOOK_KNL.exitFxn = .EXITFXN,
	    "ok"
	)
	prop NoGen :: 1
    }
    global VEXITFXN ::= HOOK_KNL.iIsUsed == 1 ? @__HOOK_doExit : .EXITFXN {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
    }
    global DOSWITCH :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Call switch function"
	prop JSName :: "CALLSWITCHFXN"
	prop Writable :: .USETSK
	prop Visible :: 1
	prop NoGen :: 1
	prop Set :: (
	    .DOSWITCH = $1,
	    HOOK_KNL.callSwitchFxn = .DOSWITCH,
	    "ok"
	)
	prop TabName :: "Function Hooks"
    }
    global VSWFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Switch function"
	prop JSName :: "SWITCHFXN"
	prop Visible :: 1
	prop NoGen :: 1
	prop Writable :: .DOSWITCH && .USETSK
	prop Set :: (
	    .VSWFXN = $1,
	    HOOK_KNL.switchFxn = .VSWFXN,
	    "ok"
	)
	prop TabName :: "Function Hooks"
    }
    global SWITCHFXN ::= .DOSWITCH ? (HOOK_KNL.iIsUsed == 1 ? @__HOOK_doSwitch : .VSWFXN) : 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: ""
	prop TabName :: "Function Hooks"
    }
    global DOREADY :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Call ready function"
	prop JSName :: "CALLREADYFXN"
	prop Writable :: .USETSK
	prop Visible :: 1
	prop NoGen :: 1
	prop Set :: (
	    .DOREADY = $1,
	    HOOK_KNL.callReadyFxn = .DOREADY,
	    "ok"
	)
	prop TabName :: "Function Hooks"
    }
    global VRDYFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Ready function"
	prop JSName :: "READYFXN"
	prop Visible :: 1
	prop Writable :: .DOREADY && .USETSK
	prop NoGen :: 1
	prop Set :: (
	    .VRDYFXN = $1,
	    HOOK_KNL.readyFxn = .VRDYFXN,
	    "ok"
	)
	prop TabName :: "Function Hooks"
    }
    global READYFXN ::= .DOREADY ? (HOOK_KNL.iIsUsed == 1 ? @__HOOK_doReady : .VRDYFXN) : 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: ""
	prop TabName :: "Function Hooks"
    }
    global NUM_HOOKS ::= HOOK.gNumOf {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
    }
    global STSUNITS :: "raw" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "raw,milliseconds,microseconds"
	prop Label :: "Statistics Units"
	prop Visible :: 0
	prop Writable :: .USETSK
	prop NoGen :: 1
    }
    
    global TSKTICK :: "PRD" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "PRD,User"
	prop Label :: "TSK tick driven by"
	prop JSName :: "DRIVETSKTICK"
	prop Visible :: 1
	prop Writable :: .USETSK
	prop NoGen :: 1
	prop Set :: (
	    if ($1 != .TSKTICK) {
		if ($1 == "PRD") {
                    PRD.THOOKFXN = PRD.DEFAULT_THOOKFXN,
                    if (TSK.USETSK == 1) {
                      if (PRD_clock.iIsUsed == 1) {
                        PRD_clock.function = @PRD_F_tick
                      }
                    }
		},
		if ($1 == "User") {
                    PRD.THOOKFXN = @_FXN_F_nop,
                    if (PRD.gNumOf == 0) {
                      if (PRD_clock.iIsUsed == 1) {
                        PRD_clock.function = @FXN_F_nop
                      }
                    }
		},
		if ($1 != "PRD" && $1 != "User") {
		    .error ("Invalid TSK tick driver selection")
		}
	    },
	    .TSKTICK = $1,
	    "ok"
	)
    }
    
    
    prop GetPriority :: (
	.iPRI
    )
    
    
    inst iFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Task function"
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG0 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 0"
	prop JSName :: "arg0"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG1 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 1"
	prop JSName :: "arg1"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG2 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 2"
	prop JSName :: "arg2"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG3 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 3"
	prop JSName :: "arg3"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG4 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 4"
	prop JSName :: "arg4"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG5 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 5"
	prop JSName :: "arg5"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG6 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 6"
	prop JSName :: "arg6"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG7 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 7"
	prop JSName :: "arg7"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    
    inst iAUTOSTK :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Automatically allocate stack"
	prop JSName :: "autoAllocateStack"
        prop Set :: (
            if (($1 == 1) && (.iAUTOSTK == 0)) {
                .iSTKSZ = TSK.STACKSIZE
            },
            .iAUTOSTK = $1,
            "ok"
        )
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
    }
    
    inst iMANSTK :: @null {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Manually allocated stack"
	prop JSName :: "manualStack"
	prop Visible :: 1
	prop Writable :: .iAUTOSTK == 0
    }
    inst iSTKSZ :: TSK.STACKSIZE {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01
	prop Label :: "Stack size (MAUs)"
	prop JSName :: "stackSize"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    $a = $1,
	    if ($a < 32) {
	        if (GBL.DSPSUBTYPE == 62) {
		    .error("Task stack size is too small.")
		}	
		else {
		    if ($a < 32) {
		        .error("Task stack size is too small.")
		    }
		    else {
		        .iSTKSZ = ($1 - ($1 - 1) % 8 + 7),
 	                 GlobalStatus.gDirty = 1,
	                 "ok"
		    }
		}
	    }
	    else {
	        .iSTKSZ = ($1 - ($1 - 1) % 8 + 7),
 	        GlobalStatus.gDirty = 1,
	        "ok"
	    }
	)
    }
   
    
    inst iSTKSEG ::= .OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: $1 == MEM_NULL || MEM.dataMember($1)
	prop Label :: "Stack Memory Segment"
	prop JSName :: "stackMemSeg"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iPRI :: TSK.PRIORITY {
	prop Label :: "Priority"
	prop JSName :: "priority"
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    if (self == TSK_idle) {
		if ($1 == 0) {
		    "ok"
		}
		else {
		    .error("Cannot change the priority of the idle task.")
		}
	    }
	    else {
	    if ($1 == 0) {
		.error("Priority 0 is reserved for the system idle task")
	    }
	    else {
		.iPRI = $1,
		"ok"
	    }
	    }
	)
    }
    inst iENV :: 0 {
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Environment pointer"
	prop JSName :: "envPointer"
	prop Visible :: 1
	prop Writable :: .iDelUser != "TSK"
	prop TabName :: "Advanced"
    }
    inst iEXITFLAG :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Don't shut down system while this task is still running"
	prop JSName :: "exitFlag"
	prop Visible :: 1
	prop Writable :: 1
	prop TabName :: "Advanced"
    }
    inst iUSETSKNAME :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Allocate Task Name on Target"
	prop JSName :: "allocateTaskName"
	prop Visible :: 1
	prop Writable :: 1
	prop TabName :: "Advanced"
    }
    inst iSTATREG ::= GBL.CACHE {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%08x"
	prop Label :: "Initial Status Register value"
	prop Visible :: 0
	prop Writable :: 1
    }
    
    inst Order :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
	prop NoGen :: 1
	prop Writable :: 1
    }
}
object TSK_idle :: TSK {
    param iComment :: "This is the idle task; it only runs when no other task is ready"
    param iDelUser :: "TSK"
    param iDelMsg :: "This task executes all IDL functions and cannot be deleted"
    param iFXN :: GBL.DSPTYPE == 54
		? @_IDL_loop
		: @IDL_F_loop
    param iPRI :: 0
    param iIsUsed :: TSK.USETSK
}
object KNL_swi :: SWI {
    param function :: @_KNL_run
    param iComment :: "This Software Interrupt calls the TSK scheduler"
    param iDelUser :: "TSK"
    param iIsUsed :: TSK.USETSK
    param iDelMsg  :: (
        "This object cannot be deleted in DSP/BIOS."
    )
    param pri :: 0
    param dorta :: 1
}
type IDL {
    isa ObjectMgr
    prop Label :: "IDL - Idle Function Manager"
    prop name :: "IDL"
    prop IsContainedIn :: SCH
    prop GlobalIcon :: 111
    prop InstanceIcon :: 112
    prop GlobalHelpTopic :: (
	106
    )
    prop InstanceHelpTopic :: (
	206
    )
    prop InstancePropertyPage :: (
	"{586735F1-770B-11d0-A61F-0000C070F3E9}"
    )
    
    prop GlobalPropertyPage :: (
	"{586735F0-770B-11d0-A61F-0000C070F3E9}"
    )
    prop GenLinkPrologue :: (
        "SECTIONS {%4t\n.%1L: {%8t\n %1U_A_TABBEG = .;\n %3S\n %1U_A_TABEND = .;\n %1U_A_TABLEN = (. - %1U_A_TABBEG) / %2d;\0, name, _objSize, _linkString"
    )
    prop GenLinkEpilogue :: (
        "%8t %1U_A_CALBEG = .;\n %4S\n %1U_A_CALEND = .;\n %1U_A_CALLEN = (. - %1U_A_CALBEG) / %2d;%4t\n} > %3s%5s%0t\n}\n%6S\n\0, name, _objSize, _memSeg, _linkCalString, _pageString, _nilBusyObj"
    )
    prop _linkString :: "*(.%1L)" 
    prop _linkCalString :: "*(.%1Lcal)"
    prop _pageString :: GBL.DSPTYPE == 62 ? "" : GBL.DSPTYPE == 55 ? "":" PAGE 1"
    prop _nilBusyObj :: ( ((IDL.USEIDLBUSYOBJ == 0) && (GBL.ROM == 1)) ?
         "IDL_busyObj = 0;\n"
        :
         ""
    )
    prop _memSeg :: IDL.OBJMEMSEG
    
    prop _objSize :: GBL.DSPTYPE == 55 ? (2 * (2 * 4)) : (2 * 4)
    prop dataSize :: (
	(2 * 4) * (IDL.gNumOf + 1)	
    )
    prop maxObjs :: (
	32767				
    )
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    
    prop idlFxnSum :: (
	$a = 0,
	scan ($i; IDL) {
	   $a += $i.cycles
	},
	$a
    )
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global AUTOCALCULATE :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Auto calculate idle loop instruction count"
	prop JSName :: "AUTOCALCULATE"
	prop Visible :: 1
	prop Writable :: CLK.USETIMER
	prop Set :: (
	    if ($1 == 1 && CLK.USETIMER == 0) {
		.error("CLK must be enabled to do idle loop intruction count")
	    }
	    else {
		if ($1 == 1 && GBL.ENABLEINST == 0) {
		    .error("Real Time Analysis must be enabled to do idle loop instuction count")
		}
		else {
		    .AUTOCALCULATE = $1,
		    "ok"
		}
	    }
	)
	prop NoGen :: 1
    }
    
    global USECLKIDLTIME ::= IDL.AUTOCALCULATE {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    
    global USEIDLBUSYOBJ ::= 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
 
    global CALIBRFXN :: = (
	if (IDL.AUTOCALCULATE == 1) {
	    TSK.USETSK ? (GBL.DSPSUBTYPE == 5502 ? @IDL_F_stub5502 : @IDL_F_stub) : (GBL.DSPSUBTYPE == 5502) ? 
			 @IDL_F_calibrate5502 : @IDL_F_calibrate
	}
	else {
	    @GBL_NULL
	}
    ) {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Idle Loop Auto-Calibrate Function"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
    }
    
    global CALIBRERROR :: = (
	if (GBL.DSPTYPE == 62 && IDL.CALIBRFXN == @IDL_F_stub) {
	    6
	}
	else {
	    0
	}
    ) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Idle Loop Auto-Calibrate Error"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
  
    global LOOPOVERHEAD :: 0 {
	prop Label :: "Idle Loop Instruction Count"
	prop JSName :: "LOOPINSTCOUNT"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: .AUTOCALCULATE == 0
	prop NoGen :: 1
    }
    inst function :: @_FXN_F_nop {	
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
    inst cycles :: 0 {
	prop Label :: "CPU cycles"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0		
	prop Writable :: (.iDelUser == "USER") ? 1 : 0
	prop NoGen :: 1
    }
    inst calibration :: 1 {
	prop Label :: "Include in CPU load calibration"
	prop JSName :: "calibration"
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1		
	prop Writable :: (.iDelUser == "USER") ? 1 : 0
	prop NoGen :: 0
    }
    
    inst Order :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
	prop NoGen :: 1
	prop Writable :: 1
    }
    
    inst iPri :: 0 {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}
object IDL_cpuLoad :: IDL {
    param iComment :: "This object is required by the system to acquire CPU load data"
    param iId :: 0			
    param iIsUsed :: GBL.ENABLEINST
    param cycles :: 0			
    param iDelUser :: "IDL"
    param iDelMsg :: (
	"This object is required to compute CPU load and can't be deleted"
    )
    param function :: @IDL_F_busy
}
object IDL_busyObj :: STS {
    param iComment :: "This object is required by the system to accumulate CPU load statistics"
    param iIsUsed :: GBL.ENABLEINST
    param iDelUser :: "IDL"
    param iDelMsg :: (
	"This object is required to accumulate CPU load data and can't be deleted"
    )
}
type ISRC {
    isa ObjectMgr
    prop name :: "ISRC"
    prop Label :: "ISRC - Interrupt Sources"
    prop IsConfMod :: 1		
    prop Visible :: 0
    prop InstancePropertyPage :: (
	"{91BA37C0-98C3-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{91BA37C1-98C3-11d1-988B-0020AFEE33C6}"
    )
    inst iHwi :: HWI_UNUSED {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: HWI
	prop MemberTest :: 1
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst iIntrSelectNum :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
}
object Reset :: ISRC {
    param iHwi :: HWI_RESET
    param iIntrSelectNum :: -1
}
object Non_Maskable :: ISRC {
    param iHwi :: HWI_NMI
    param iIntrSelectNum :: -1
}
object Reserved :: ISRC {
    param iHwi :: HWI_RESERVED0
    param iIntrSelectNum :: -1
}
object Host_Port_Host_to_DSP :: ISRC {
    param iHwi :: HWI_INT13
    param iIntrSelectNum :: 0
}
object Timer_0 :: ISRC {
    param iHwi :: HWI_INT14
    param iIntrSelectNum :: 1
}
object Timer_1 :: ISRC {
    param iHwi :: HWI_INT15
    param iIntrSelectNum :: 2
}
object EMIF_SDRAM_Timer :: ISRC {
    param iHwi :: HWI_INT10
    param iIntrSelectNum :: 3
}
object External_Pin_4:: ISRC {
    param iHwi :: HWI_INT4
    param iIntrSelectNum :: 4
}
object External_Pin_5 :: ISRC {
    param iHwi :: HWI_INT5
    param iIntrSelectNum :: 5
}
object External_Pin_6 :: ISRC {
    param iHwi :: HWI_INT6
    param iIntrSelectNum :: 6
}
object External_Pin_7 :: ISRC {
    param iHwi :: HWI_INT7
    param iIntrSelectNum :: 7
}
object EDMA_Controller :: ISRC {
    param iHwi :: HWI_INT8
    param iIntrSelectNum :: 8
}
object HSRTDX11 :: ISRC {
    param iHwi :: HWI_INT11
    param iIntrSelectNum :: 10
}
object HSRTDX12 :: ISRC {
    param iHwi :: HWI_INT12
    param iIntrSelectNum :: 11
}
object MCSP_0_Transmit :: ISRC {
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 12
}
object MCSP_0_Receive :: ISRC {
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 13
}
object MCSP_1_Transmit :: ISRC {
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 14
}
object MCSP_1_Receive :: ISRC { 
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 15
}
object GPIO_Interrupt_0 :: ISRC {
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 16
}
object I2C_Interrupt_0 :: ISRC { 
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 22
}
object I2C_Interrupt_1 :: ISRC { 
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 23
}
object MCASP_0_Transmit :: ISRC {
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 28
}
object MCASP_0_Receive :: ISRC {
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 29
}
object MCASP_1_Transmit :: ISRC {
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 30
}
object MCASP_1_Receive :: ISRC { 
    param iHwi :: HWI_UNUSED
    param iIntrSelectNum :: 31
}
type LOG {
    isa  ObjectMgr
    prop name :: "LOG"
    prop Label :: "LOG - Event Log Manager"
    prop IsContainedIn :: INS
    prop GlobalIcon :: 113
    prop InstanceIcon :: 114
    prop InstanceHelpTopic :: (
	207
    )
    
    prop GlobalHelpTopic :: (
	107
    )
    prop InstancePropertyPage :: (
	"{B7240DE8-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
	"{B7240DE9-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    prop maxObjs :: (32767)
    
    prop AllocType :: (
	"2\0, _globalAllocDesc, _memSeg, _placement, _printfAllocDesc, _memSeg, _placement"
    )
    prop _globalAllocDesc :: (
	"%8t .%1L: {%12t\n  %1U_A_TABBEG = .;\n _%1U_A_TABBEG = .;\n %2S\n %1U_A_TABEND = .;\n _%1U_A_TABEND = .;\n  %1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;\n _%1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;%8t\n }\0, name, _linkString, _objSize"
    )
    
    prop _printfAllocDesc :: (
	"%8t .printf (COPY): {}"
    )
    prop _placement :: (0x7fffffff / 2)
    prop AllocInst :: (
	"1\0, _instAllocDesc, _objMemSeg, _placement"
    )
    prop _fillValue :: GBL.DSPWORDSIZE == 16 ? 0xffff : 0xffffffff
    prop _instAllocDesc :: (
	"%8t /* %0s buffer */\n .%0s$buf: align = 0x%1x fill = 0x%2x {}\0, _objAlign, _fillValue"
    )
    
    prop _objSize :: GBL.DSPTYPE == 55 ? (2 * (6 * 4)) : (6 * 4)
    prop _memSeg :: LOG.OBJMEMSEG
    prop _linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no %1U objects */"
    
    prop _objAlign :: GBL.DSPTYPE == 55 
               ? .buflen * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)*2  
                : .buflen * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)  
    prop _objMemSeg :: .bufseg
    prop LogType :: .iType
    prop LogFormat :: .iFormat
    
    prop cGen :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "log.h" : ""
    
    prop cGenHInst :: (
	if (GBL.DSPTYPE == 62) {
	    "extern far LOG_Obj %0r;\n\0"
	}
	else {
	    "extern LOG_Obj %0r;\n\0"
	}
    )
    prop dataSize :: (
	$d = 0,
	scan ($i; LOG) {
	    if ($i.IsConfObj()) {
		$d += $i.buflen
	    },
	    $d += (6 * 4)	
	},
	$d
    )
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global ENABLED :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Compile in logging"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst bufseg ::= .OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "bufseg"
	prop JSName :: "bufSeg"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst buflen :: 64 {
	prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	
	prop Enum :: "0,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768"
	prop Label :: "buflen (words)"
	prop JSName :: "bufLen"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    GlobalStatus.gDirty = 1,
	    .buflen = $1,
	    "ok"
	)
    }
    inst logtype :: "circular" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "circular,fixed"
	prop Label :: "logtype"
	prop JSName :: "logType"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst iType :: "printf" {
	prop Label :: "datatype"
	prop JSName :: "dataType"
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "printf,raw data"
	prop Visible :: 1
	prop Writable :: .iType == "system" ? 0 : 1
	prop NoGen :: 1
    }
    inst iFormat :: "0x%x, 0x%x, 0x%x" {
	prop Label :: "format"
	prop JSName :: "format"
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: .iType == "raw data" ? 1 : 0
	prop NoGen :: 1
    }
}
object LOG_system :: LOG {
    param iComment :: "This object is required by the system to accumulate execution trace information"
    param iId :: 0
    param iIsUsed :: 1			
    param iType :: "system"
    param iDelUser :: "LOG"
    param iDelMsg :: (
	"LOG_system is a system log and cannot be deleted."
    )
}
type PIP {
    isa  ObjectMgr
    prop Label :: "PIP - Buffered Pipe Manager"
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 117
    prop InstanceIcon :: 118
    prop GlobalHelpTopic :: (
	109
    )
    prop InstanceHelpTopic :: (
	209
    )
    prop name :: "PIP"
    prop maxObjs :: (
	32767				
    )
    prop dataSize :: (
	$b = 0,
	scan ($i; PIP) {
	    if ($i.IsConfObj()) {
		$b += (12 + $i.framesize) * $i.numframes + 100
	    }
	},
	$b
    )
    prop InstancePropertyPage :: (
	    "{B7240DF0-AA51-11cf-9BFE-0000C0AC14C8}"
    )
    
    prop GlobalPropertyPage :: (
	    "{B7240DF1-AA51-11cf-9BFE-0000C0AC14C8}"
    )
    prop localCreate :: (
	"ok"
    )
    prop AllocType :: (
	"1\0, _globalAllocDesc, _memSeg, _placement"
    )
    prop _globalAllocDesc :: (
	"%8t .%1L: {%12t\n  %1U_A_TABBEG = .;\n _%1U_A_TABBEG = .;\n %2S\n %1U_A_TABEND = .;\n _%1U_A_TABEND = .;\n  %1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;\n _%1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;%8t\n }\0, name, _linkString, _objSize"
    )
    prop AllocInst :: (
	"1\0, _instAllocDesc, _objMemSeg, _placement"
    )
    prop _instAllocDesc :: (
	.bufalign > 1 ? "%8t /* %0s buffer */\n .pip%1d: align = 0x%2x {}\0, _objId, _objAlign" : "%8t /* %0s buffer */\n .pip%1d: {}\0, _objId"
    )
    prop _placement :: (0x7fffffff / 2)
    prop _objId :: .iId
    prop _objAlign :: .bufalign * 4
    prop _objMemSeg :: .bufseg
    prop _linkString :: (.gNumOf + .gNumEmbed) > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop _memSeg :: PIP.OBJMEMSEG
    prop _objSize :: 100
    prop mkId :: (
	.iId = .gNextId++,
	.gNumOf++,
	.iId
    )
    
    prop cGen :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "pip.h" : ""
    
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far PIP_Obj %0r;\n\0"
	}
	else {
	    "extern PIP_Obj %0r;\n\0"
	}
    )
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global gNumEmbed :: 0 {	
	prop NoGen :: 0
    }
    global gNextId :: 0
    inst bufseg ::= .OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "bufSeg"
	prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 1
    }
    inst bufalign :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "bufAlign"
	prop Style :: 0x01 | 0x02
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 1
	prop Set :: (
	    $e = "ok",
	    if ($1 == 0) {
		$e = .error("Cannot set align value to 0")
	    }
	    else {
		.bufalign = $1
	    },
	    $e
	)
    }
    inst buf :: "<NULL>" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst framesize :: 8 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "framesize (words)"
	prop JSName :: "frameSize"
	prop Style :: GBL.DSPTYPE == 62 ? 0x02 : 0x01 |0x02
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop Set :: (
	    if ($1 < 1) {
		.error("framesize must be >= 1.")
	    }
	    else {
		GlobalStatus.gDirty = 1,
		.framesize = $1,
		"ok"
	    }
	)
    }
    inst numframes  :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01
	prop JSName :: "numFrames"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop Set :: (
	    if ($1 < 1) {
		.error("Pipes must contain at least 1 frame.")
	    }
	    else {
		GlobalStatus.gDirty = 1,
		.numframes = $1,
		"ok"
	    }
	)
    }
    inst monitor :: "reader" {
    	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "monitor"
	prop Enum :: "reader,writer,none"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst notifyWriter :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyWriterFxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    inst nwarg0 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyWriterArg0"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    inst nwarg1 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyWriterArg1"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    inst notifyReader :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyReaderFxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    inst nrarg0 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyReaderArg0"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    inst nrarg1 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyReaderArg1"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    
    inst bufFrameAlign ::= ._objAlign  {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
}
type SEM {
    isa ObjectMgr
    prop name :: "SEM"
    prop Label :: "SEM - Semaphore Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 137
    prop InstanceIcon :: 138
    prop GlobalHelpTopic :: (
	310
    )
    prop InstanceHelpTopic :: (
	410
    )
    prop InstancePropertyPage :: (
	"{D01ACC04-38DD-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{D01ACC05-38DD-11d1-988B-0020AFEE33C6}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: (
        "%8t .sem: {}"
    )
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: .OBJMEMSEG
    prop dataSize :: (
	(8 + 3) * SEM.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    )
    
    prop cGen :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "sem.h" : ""
    
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far SEM_Obj %0r;\n\0"
	}
	else {
	    "extern SEM_Obj %0r;\n\0"
        }
    )
    
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst iCount :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Label :: "Initial semaphore count"
	prop JSName :: "count"
	prop Visible :: 1
	prop Writable :: 1
    }
}
type MBX {
    isa ObjectMgr
    prop name :: "MBX"
    prop Label :: "MBX - Mailbox Manager"
    prop IsContainedIn :: SYN 
    prop GlobalIcon :: 131
    prop InstanceIcon :: 132
    prop GlobalHelpTopic :: (
	307
    )
    prop InstanceHelpTopic :: (
	407
    )
    prop InstancePropertyPage :: (
	"{0EB45D44-38C1-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{0EB45D45-38C1-11d1-988B-0020AFEE33C6}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0,	_bssAllocDesc, _memSeg, _placement"
	    }
    )
    prop _bssAllocDesc :: (
	    "%8t .mbx: {}"
    )
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: .OBJMEMSEG
    prop AllocInst :: (
	"1\0 _instAllocDesc, _instMemSeg, _placement"
    )
    prop _instAllocDesc :: (
	"%8t .%0s$que: align = 0x4 {%12t\n %0s$queElems = .;\n . += %1d;%8t\n }\0, _qElemSize"
    )
    prop _instMemSeg :: .iMbxSeg
    prop _qElemSize :: (
	if ((GBL.DSPTYPE == 55) || (GBL.DSPTYPE == 28)) {
            
            $a = .iMsgSize,
            if ($a & 0x1) {
                $a += 1
            },
	    
	    (2 + $a) * .iMbxLength * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE) * 2
	}
	else {
	    (2 + .iMsgSize) * .iMbxLength * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
	}
    )
    prop dataSize :: (
	$d = 0,
	scan ($i; MBX) {
	    $d += (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE) * (($i.iMsgSize + 2) * $i.iMbxLength + 29)
	},
	$d
    )
    
    prop cGen :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "mbx.h" : ""
    
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far MBX_Obj %0r;\n\0"
	}
	else {
	    "extern MBX_Obj %0r;\n\0"
	}
    )
    
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst iMsgSize :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Label :: "Message Size"
	prop JSName :: "messageSize"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    if ($1  == 0) {
		.error ("Message size cannot be zero")
	    }
	    else {
	    	GlobalStatus.gDirty = 1,
		.iMsgSize = $1,
		"ok"
	    }
	)
    }
    inst iMbxLength :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Label :: "Mailbox Length"
	prop JSName :: "length"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    if ($1  == 0) {
		.error ("Mailbox length cannot be zero")
	    }
	    else {
	    	GlobalStatus.gDirty = 1,
		.iMbxLength = $1,
		"ok"
	    }
	)
    }
    inst iMbxSeg :: MBX.OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Element memory segment"
	prop JSName :: "elementSeg"
	prop Visible :: 1
	prop Writable :: 1
    }
}
type QUE {
    isa ObjectMgr
    prop name :: "QUE"
    prop Label :: "QUE - Atomic Queue Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 133
    prop InstanceIcon :: 134
    prop IsConfMod :: 1		
    prop GlobalHelpTopic :: (
	309
    )
    prop InstanceHelpTopic :: (
	409
    )
    prop InstancePropertyPage :: (
	"{D01ACC01-38DD-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{D01ACC02-38DD-11d1-988B-0020AFEE33C6}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: (
	"%8t .que: {}"
    )
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: .OBJMEMSEG
    prop dataSize :: (
	2 * QUE.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    )
    
    prop cGen :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "que.h" : ""
    
    prop cGenHInst :: (
	if (GBL.DSPTYPE == 62) {
	    "extern far QUE_Obj %0r;\n\0"
	}
	else {
	    "extern QUE_Obj %0r;\n\0"
	}
    )
    
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
}
type LCK {
    isa ObjectMgr
    prop name :: "LCK"
    prop Label :: "LCK - Resource Lock Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 129
    prop InstanceIcon :: 130
    prop IsConfMod :: 1		
    prop GlobalHelpTopic :: (
	306
    )
    prop InstanceHelpTopic :: (
	406
    )
    prop InstancePropertyPage :: (
	"{0EB45D40-38C1-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{0EB45D41-38C1-11d1-988B-0020AFEE33C6}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _bssAllocDesc, _memSeg, _placement"
	}
    )
    prop _bssAllocDesc :: (
	"%8t .lck: {}"
    )
    prop _objAllocDesc :: (
	"%8t .LCK$obj: {}"
    )
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: .OBJMEMSEG
    prop dataSize :: (
	(8 + 2) * LCK.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    )
    
    prop cGen :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "lck.h" : ""
    
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
            "extern far LCK_Obj %0r;\n\0"
        }
        else {
            "extern LCK_Obj %0r;\n\0"
        }
    )
    
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
}
type SIO {
    isa ObjectMgr
    prop name :: "SIO"
    prop Label :: "SIO - Stream Input and Output Manager"
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 139
    prop InstanceIcon :: 140
    prop GlobalHelpTopic :: (
	311
    )
    prop InstanceHelpTopic :: (
	411
    )
    prop InstancePropertyPage :: (
	"{7C4C9A60-763E-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{7C4C9A61-763E-11d1-988B-0020AFEE33C6}" 
    )
    prop DependsOn :: "DEV,UDEV,DGN,DHL,DPI"
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "2\0, _bssAllocDesc, _memSeg, _placement,
	          _objAllocDesc, _memSeg, _placement"
	}
    )
    prop _bssAllocDesc :: (
        "%8t .SIO$bss: {%12t\n *(.SIO$bss)%8t\n }"
    )
    prop _objAllocDesc :: (
        "%8t .SIO$obj: {%12t\n *(.SIO$obj)%8t\n }"
    )
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: .OBJMEMSEG
    prop AllocInst ::  (
	"1\0, _instBufDesc, _instBufSeg, _placement"
    )
    prop _instBufDesc :: (
	.iAlign > 1? "%8t .%0s$bufs: align = 0x%1x {}\0, _objAlign" : "%8t .%0s$bufs: {}"
    )
    prop _objAlign :: .iAlign
    prop _instBufSeg :: .iBufSegid
    prop defDev :: (
	$h = nil,
	$i = nil,
	$j = nil,
	scan ($h; nil) {
	    if ($h.isDriver == 1) {
		scan ($i; $h) {
	            if ($j == nil
		        && $i.iIsTerminal != 0 && $i.iIsVirtual == 0) {
			
			$j = $i,
			break
		    }
		}
	    }
	},
	$j
    )
    prop devList :: (
	$h = nil,
	$i = nil,
	$j = nil,
	scan ($h; nil) {
	    if ($h.isDriver == 1) {
		scan ($i; $h) {
	            if ($j == nil
			&& $i.iIsTerminal != 0 && $i.iIsVirtual == 0) {
			
			$j = $i,
			scan ($a; DIO) {
			    if ($a == $i) {
				$i.numTimeUse++
			    }
			},
		        break
	            }
		}
	    }
	},
	$j
    )
    
    prop setDev :: (
	$h = nil,
	$i = nil,
	$j = nil,
	scan ($h; nil) {
	    if ($h.isDriver == 1) {
		scan ($i; $h) {
		    if ($i == $1) {
			$j = $i
		    }
		}
	    }
	},
	$j
    )
    prop localCanCreate :: (
	if (.defDev == nil) {
	    .error ("A driver device must be created before creating a stream.")
	}
	else {
	    "ok"
	}
    )
    prop localDelete :: (
	scan ($a; DIO) {
	    if ($a == .iDevice) {
		.iDevice.numTimeUse--
	    }
	},
	"ok"
    )
    
    prop cGen :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "sio.h" : ""
    
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far SIO_Obj %0r;\n\0"
	}
	else {
	    "extern SIO_Obj %0r;\n\0"
        }
    )
    global gNumEmbed :: 0 {  
	prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global USEISSUERECLAIM :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Use Only Issue/Reclaim Model"
	prop JSName :: "USEISSUERECLAIM"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    .USEISSUERECLAIM = $1,
	    if ($1 == 1) {
		scan ($i; SIO) {
		    $i.iModelName = "Issue/Reclaim"
		}
	    },
	    "ok"
	)
    }
    
    inst iDevice :: SIO.devList {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop TypeTest :: $1.isDriver == 1
	prop MemberTest :: $1.driverType != "DEV_IOMTYPE"
	prop Label :: "Device"
	prop JSName :: "deviceName"
	prop Set :: (
	    if (($1.iIsTerminal == 0) && (.iDevCtrlParam == "")) {
		    .error("To select a stacking device, enter first a terminal device in Device Control String")
	    }
	    else {
		if ($1.iIsVirtual == 1) {
		    .error("The device you have selected is a virtual instance, you must select a non-virtual device")
		}
		else {
		    scan($a; DIO) {
			if ($a == .iDevice) {
			    .iDevice.numTimeUse--
			}
		    },
		    scan($b; DIO) {
			if ($b == $1) {
			    $1.numTimeUse++
			}
		    },
		    .iDevice = .setDev($1),
		    "ok"
		}
	    }
	)
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iDevCtrlParam :: "" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Device Control String"
	prop JSName :: "controlParameter"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iDevId ::= .iDevice.iDevId
    inst iFxns  ::= .iDevice.iFxns
    inst iMode :: "input" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "input,output"
	prop Label :: "Mode"
	prop JSName :: "mode"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iBufsize :: 0x80 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Label :: "Buffer size"
	prop JSName :: "bufSize"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iNbufs :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01
	prop Label :: "Number of buffers"
	prop JSName :: "numBufs"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iBufSegid ::= .OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Place buffers in memory segment"
	prop JSName :: "bufSegId"
	prop Visible :: 1
	prop Writable :: .iAllocBuf == 1
    }
    inst iAlign :: 1 {
	prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768"
	prop Label :: "Buffer alignment"
	prop JSName :: "bufAlign"
	prop Visible :: 1
	prop Writable :: .iAllocBuf == 1
    }
    
    inst iFlush :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Flush"
	prop JSName :: "flush"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iModelName :: "Standard" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "Standard,Issue/Reclaim"
	prop Label :: "Model"
	prop JSName :: "modelName"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    $e = "ok",
	    if (.USEISSUERECLAIM == 1) {
		if ($1 == "Standard") {
	    	    $e = .error("SIO Issue/Reclaim model support selected")
	        }
	        else {
		    .iModel = $1 == "Standard"
			? "SIO_STANDARD"
			: "SIO_ISSUERECLAIM",
	            .iModelName = $1
	        }
	    }
	    else {
		.iModel = $1 == "Standard"
		    ? "SIO_STANDARD"
		    : "SIO_ISSUERECLAIM",
	        .iModelName = $1
	    },
	    $e
	)
    }
    inst iAllocBuf ::= .iSaveAllocBuf {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Allocate Static Buffer(s)"
	prop JSName :: "allocStaticBuf"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    .iSaveAllocBuf = $1,
	    "ok"
	)
    }
    inst iSaveAllocBuf :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    inst iModel :: "SIO_STANDARD" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "SIO_STANDARD,SIO_ISSUERECLAIM"
	prop Visible :: 0
	prop Writable :: 0
    }
    inst iTimeout ::= .iModel == "SIO_ISSUERECLAIM" ? .iSaveTimeout : -1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Timeout for I/O operation"
	prop JSName :: "timeout"
	prop Visible :: 1
	prop Writable :: .iModel == "SIO_ISSUERECLAIM"
	prop Set :: (
	    .iSaveTimeout = $1,
	    "ok"
	)
    }
    inst iSaveTimeout :: -1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    
    inst useCallBackFxn :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "use callback function"
	prop JSName :: "useCallBackFxn"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop TabName :: "Callback"
    }
    inst callBackFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "callback function"
	prop JSName :: "callBackFxn"
	prop Visible :: 1
	prop Writable :: .useCallBackFxn
	prop NoGen :: 0
	prop TabName :: "Callback"
    }
    inst arg0 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "argument 0"
	prop JSName :: "arg0"
	prop Visible :: 1
	prop Writable :: .useCallBackFxn
	prop NoGen :: 0
	prop TabName :: "Callback"
    }
    inst arg1 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "argument 1"
	prop JSName :: "arg1"
	prop Visible :: 1
	prop Writable :: .useCallBackFxn
	prop NoGen :: 0
	prop TabName :: "Callback"
    }
}
type STS {
    isa  ObjectMgr
    prop name :: "STS"
    prop Label :: "STS - Statistics Object Manager"
    prop IsContainedIn :: INS
    prop GlobalIcon :: 125
    prop InstanceIcon :: 126
    prop InstanceHelpTopic :: (
	212
    )
    
    prop GlobalHelpTopic :: (
	112
    )
    prop AllocType :: (
	"1\0, _globalAllocDesc, _memSeg, _placement"
    )
    prop _globalAllocDesc :: (
	"%8t .%1L: {%12t\n  %1U_A_TABBEG = .;\n _%1U_A_TABBEG = .;\n %2S\n %1U_A_TABEND = .;\n _%1U_A_TABEND = .;\n  %1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;\n _%1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;%8t\n }\0, name, _linkString, _objSize"
    )
    prop localInit :: (
	if (PRD.CALLBACKOBJ != nil) {
	    .error("STS initialization failure")
	},
	PRD.CALLBACKOBJ = STS
    )
    prop _placement :: (0x7fffffff / 2)
    prop _linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop _memSeg :: STS.OBJMEMSEG
    
    prop _objSize :: GBL.DSPTYPE == 55 ? (2 * (4 * 4)) : (4 * 4)
    prop dataSize :: (
	(4 * 4) * (STS.gNumOf + STS.gNumEmbed)
    )
    prop maxObjs :: (
	32767			
    )
    prop InstancePropertyPage :: (
	"{B7240DEE-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
	"{B7240DEF-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    prop STSGetMaxFmt :: (
	.format
    )
    prop STSGetSumFmt :: (
	.format
    )
    prop STSGetAvgFmt :: (
	"%.2f"
    )
    prop STSFilterSum :: (
	(.iA * $1 + .iB * $2) / (1.0 * .iC)
    )
    prop STSFilterMax :: (
	(.iA * $1 + .iB) / (1.0 * .iC)
    )
    prop HighTimeBased :: (
	.unittype == "High resolution time based" ? 1 : 0
    )
    prop LowTimeBased :: (
	.unittype == "Low resolution time based" ? 1 : 0
    )
    
    prop cGen :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "sts.h" : ""
    
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far STS_Obj %0r;\n\0"
	}
	else {
	    "extern STS_Obj %0r;\n\0"
        }
    )
    prop modifiable :: (
	((.iDelUser == "USER" || .iDelUser == "HWI") ? 1 : 0)
    )
    prop call :: (
	scan($a; STS) {
	    if ($a.unittype == "High resolution time based") {
	        $a.iA = CLK.INSTRPERCLK
	    }
	}
    )
    
    global OBJMEMSEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global gNumEmbed :: 0 {	
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst prev :: 0 {		
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: .modifiable()
	prop JSName :: "previousVal"
	prop NoGen :: GBL.DSPTYPE != 40 && GBL.DSPTYPE != 62
	prop Set :: (
	    .prev = $1,
	    .prevlow = $1 & 0xffff,
	    .prevhigh = ($1 >> 16) & 0xffff,
	    "ok"
	)
    }
    inst format :: "%g" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "format"
	prop NoGen :: 1
    }
    
    inst unittype :: "Not time based" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "Not time based,High resolution time based,Low resolution time based"
	prop Label :: "unit type"
	prop JSName :: "unitType"
	prop Visible :: 1
	prop Writable :: .modifiable()
	prop NoGen :: 1
	prop Set :: (
	    .unittype = $1,
	    if ($1 == "High resolution time based") {
		.iA = CLK.INSTRPERCLK,
		.iB = 0,
		.iC = 1,
		.operation = "A * x"
	    }
	    else {
		if ($1 == "Low resolution time based") {
		    .iA = 1,
		    .iB = 0,
		    .iC = 1,
		    .operation = "A * x"
		}
		else {
		    .iA = 1,
		    .iB = 0,
		    .iC = 1,
		    .operation = "Nothing"
		}
	    },
	    "ok"
	)
    }
    inst operation :: "Nothing" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "Nothing,A * x,A * x + B,(A * x + B) / C"
	prop Label :: "host operation"
	prop JSName :: "operation"
	prop Visible :: 1
	prop Writable :: (
	    (.unittype != "Low resolution time based") && .modifiable()
	)
	prop NoGen :: 1
	prop Set :: (
	    .operation = $1,
	    if ($1 == "Nothing" && .unittype != "High resolution time based") {
		.iA = 1,
		.iB = 0,
		.iC = 1
	    }
	    else {
		if ($1 == "A * x") {
		    .iB = 0,
		    .iC = 1
		}
		else {
		    if ($1 == "A * x + B") {
			.iC = 1
		    }
		}
	    },
	    "ok"
	)
    }
    inst iA :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: (.modifiable() &&
	    !(.unittype != "Not time based" || .operation == "Nothing")
	)
	prop Label :: "A"
	prop JSName :: "numA"
	prop NoGen :: 1
    }
    inst iB :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: (.modifiable() &&
	    !(.unittype == "Low resolution time based" || .operation == "Nothing" || .operation == "A * x")
	)
	prop Label :: "B"
	prop JSName :: "numB"
	prop NoGen :: 1
    }
    inst iC :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: (.modifiable() &&
	    (.unittype == "Not time based" && .operation == "(A * x + B) / C"))
	prop Label :: "C"
	prop JSName :: "numC"
	prop NoGen :: 1
    }
    inst prevhigh :: 0 {	
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: GBL.DSPTYPE == 40 || GBL.DSPTYPE == 62
    }
    
    inst prevlow :: 0 {		
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
}
type SYS {
    isa Module
    prop name :: "SYS"
    prop Label :: "SYS - System Settings"
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 141
    prop InstanceIcon :: 142
    prop IsConfMod :: 1		
    prop GlobalHelpTopic :: (
	313
    )
    prop InstanceHelpTopic :: (
	413
    )
    prop InstancePropertyPage :: (
	"{473C4A62-B1A8-11d0-9885-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{473C4A63-B1A8-11d0-9885-0020AFEE33C6}"
    )
    prop AllocType :: ( .PUTCFXN == @_UTL_doPutc ?
	"2\0, _globalAllocDesc,	_memSeg, _midPlace, \
	      _traceString, _traceSeg, _midPlace"
	:
	"1\0, _globalAllocDesc,	_memSeg, _midPlace"
    )
    prop _globalAllocDesc :: (
	"%8t .sys:     {}"
    )
    prop _traceString   :: (
	"%8t .trace: fill = 0x0 {%12t\n_SYS_PUTCBEG = .;\n. += 0x%1x;\n_SYS_PUTCEND = . - 1;%8t\n }\0, _traceSize"
    )
    prop _midPlace :: (0x7fffffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    prop _traceSeg :: SYS.TRACESEG
    prop _traceSize :: SYS.TRACESIZE
    
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global TRACESIZE :: 512 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "%d"
	prop Style :: 0x01 | 0x02
	prop Label :: "Trace Buffer Size"
	prop JSName :: "TRACESIZE"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global TRACESEG :: IRAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1) 
	prop Label :: "Trace Buffer Memory"
	prop JSName :: "TRACESEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global ABORTFXN :: @_UTL_doAbort {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Abort Function"
	prop JSName :: "ABORTFXN"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    global ERRORFXN :: @_UTL_doError {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Error Function"
	prop JSName :: "ERRORFXN"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    global EXITFXN :: @_UTL_halt {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Exit Function"
	prop JSName :: "EXITFXN"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    global PUTCFXN :: @_UTL_doPutc {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Putc Function"
	prop JSName :: "PUTCFXN"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
}
type GIO {
    isa Module
    prop Visible :: 1
    prop name :: "GIO"
    prop Label :: "GIO - General Input/Output Manager"
    prop IsConfMod :: .USEGIO 
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 141
    prop InstanceIcon :: 142
    prop GlobalHelpTopic :: (
	320
    )
    prop InstanceHelpTopic :: (
	420
    )
    prop InstancePropertyPage :: (
	"{473C4A62-B1A8-11d0-9885-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{473C4A63-B1A8-11d0-9885-0020AFEE33C6}"
    )
    prop DependsOn :: "DEV,UDEV"
    prop AllocType :: (
	"1\0, _globalAllocDesc, _memSeg, _midPlace"
    )
    prop _globalAllocDesc :: (
	"%8t .gio:     {}"
    )
    prop _midPlace :: (0x7fffffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global USEGIO :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable General Input/Output Manager"
	prop JSName :: "ENABLEGIO"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global CREATEFXN ::= .USEGIO == 1 ? @_SEM_create : @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Create Function"
	prop JSName :: "CREATEFXN"
	prop Visible :: 1
	prop Writable :: .USEGIO
	prop NoGen :: 0
    }
    global DELETEFXN ::= .USEGIO == 1 ? @_SEM_delete : @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Delete Function"
	prop JSName :: "DELETEFXN"
	prop Visible :: 1
	prop Writable :: .USEGIO
	prop NoGen :: 0
    }
    global PENDFXN ::= .USEGIO == 1 ? @_SEM_pend : @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Pend Function"
	prop JSName :: "PENDFXN"
	prop Visible :: 1
	prop Writable :: .USEGIO
	prop NoGen :: 0
    }
    global POSTFXN ::= .USEGIO == 1 ? @_SEM_post : @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Post Function"
	prop JSName :: "POSTFXN"
	prop Visible :: 1
	prop Writable :: .USEGIO
	prop NoGen :: 0
    }
}
       
type SIODRIVER {
    isa ModuleFolder
    prop Label :: "Device Drivers"
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 127
    prop GlobalHelpTopic :: (
	BIOSHELP_DEV_FOLDER
    )
    prop GlobalPropertyPage :: (
        "{A2BCEC70-5365-11d4-947C-0050048381B7}"
    )
}
type DEV {
    isa ObjectMgr
    prop name :: "DEV"
    prop Visible :: 0
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _bssAllocDesc, _memSeg, _placement"
	},
	
	if ( DGN.gNumOf || DHL.gNumOf || DPI.gNumOf || DIO.gNumOf || UDEV.gNumOf ){
	    "1\0, _devtableDesc, _memSeg, _placement"
	}
    )
    prop _bssAllocDesc :: (
	"%8t .dev: {}"
    )
    prop _devtableDesc :: (
	"%8t .devtable: {}"
    )
    prop _memSeg :: MEM.CFGOBJSEG
    prop _placement :: (0x7fffffff / 2)
    prop DependsOn :: "HWI"
}
type UDEV {
    isa ObjectMgr
    prop name :: "UDEV"
    prop Label :: "User-Defined Devices"
    prop IsContainedIn :: SIODRIVER
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop GlobalHelpTopic :: (
	315
    )
    prop InstanceHelpTopic :: (
	415
    )
    prop InstancePropertyPage :: (
	"{7AE86AA0-35C0-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{7AE86AA1-35C0-11d1-988B-0020AFEE33C6}"
    )
    prop maxObjs :: (32767)
    prop isDriver :: (
	1
    )
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: (
        "%8t .udev: {}"
    )
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    prop _driverType :: (
	.fxnTableType == "DEV_Fxns" ? "DEV_SIOTYPE" : "DEV_IOMTYPE"
    )
    inst iInit :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"	
	prop Label :: "init function"
	prop JSName :: "initFxn"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    .iInit = $1,
	    .initFxn = .iInit,
	    "ok"
	)
    }
    inst iFxns :: 0 {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"	
	prop Label    :: "function table ptr"
	prop JSName :: "fxnTable"
	prop Visible  :: 1
	prop Writable :: 1
    }
    
    inst fxnTableType :: "DEV_Fxns" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "DEV_Fxns,IOM_Fxns"
	prop Label :: "function table type"
	prop JSName :: "fxnTableType"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    inst driverType ::= ._driverType {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "DEV_SIOTYPE,DEV_IOMTYPE"
	prop Visible :: 0
    }
    
    inst iDevId :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "device id"
	prop JSName :: "deviceId"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    .iDevId = $1,
	    .deviceId = .iDevId,
	    "ok"
	)
    }
    inst iParams :: 0 {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label    :: "device params ptr"
	prop JSName :: "params"
	prop Visible  :: 1
	prop Writable :: 1
    }
    inst deviceId :: 0 {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName   :: ""
	prop Visible  :: 0
    }
    inst initFxn :: 0 {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"	
	prop JSName   :: ""
	prop Visible  :: 0
    }
    inst iIsStacking ::0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Stacking Device"
	prop JSName :: "stackingDevice"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst deviceGlobalDataPtr :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "device global data ptr"
	prop JSName :: "deviceGlobalDataPtr"
	prop Visible :: 1
	prop Writable :: .fxnTableType == "IOM_Fxns"
    }
    inst iIsTerminal ::= .fxnTableType == "DEV_Fxns" ? 1 : 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    inst iIsVirtual :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
}
type DGN {
    isa ObjectMgr
    prop name :: "DGN"
    prop Label :: "DGN - Software Generator Driver"
    prop IsContainedIn :: SIODRIVER
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop GlobalHelpTopic :: (
	302
    )
    prop InstanceHelpTopic :: (
	402
    )
    prop InstancePropertyPage :: (
	"{054FE166-B014-11d0-9885-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{054FE167-B014-11d0-9885-0020AFEE33C6}"
    )
    prop DependsOn :: "DEV"
    prop maxObjs :: (32767)
    prop isDriver :: (
	1
    )
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: (
        "%8t .dgn: {}"
    )
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    inst iDevice :: "user" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: GBL.DSPARITHMETIC == "FLOAT" ?
		"user,sine,random,constant,printFloat,printHex,printInt"
		:"user,sine,random,constant,printHex,printInt"
	prop Label :: "Device category"
	prop JSName :: "device"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    $a = $1,
	    if ($a != .iDevice) {
		.iDevice = $a,
		.iUserFxn = @_FXN_F_nop	
	    },
	    if ($a == "user") {
		.iUserFxn = .iSaveUserFxn
	    },
	    if ($a == "printFloat") {
		.iUserFxn = @_DGN_printFloat
	    },
	    if ($a == "printHex") {
		.iUserFxn = @_DGN_printHex
	    },
	    if ($a == "printInt") {
		.iUserFxn = @_DGN_printInt
	    },
	    "ok"
	)
    }
    inst iUseDefaults :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Use default parameters"
	prop Visible :: 1
	prop JSName :: "useDefaultParam"
	prop Writable :: .iDevice == "sine" || .iDevice == "constant" || .iDevice == "random" || .iDevice == "user"
    }
    inst iDevId ::= .iDevice == "constant" ? @DGN_CONST : .iDevice == "random" ? @DGN_RAND : .iDevice == "sine" ? @DGN_SINE : @DGN_USER {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Device ID"
	prop JSName :: "deviceId"
	prop Visible :: 1
	prop Writable :: 0
    }
    inst iIsTerminal :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    inst iIsVirtual :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    
    inst iConstant :: GBL.DSPARITHMETIC == "FIXED" ? 1 : 1.0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label  :: "Constant value"
	prop JSName :: "constant"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "constant" || .iDevice == "user")
    }
    inst iRandSeed :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Seed value"
	prop JSName :: "seedValue"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "random" || .iDevice == "user")
    }
    inst iRandLower :: GBL.DSPARITHMETIC == "FIXED" ? -32767 : 0.0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label :: "Lower limit"
	prop JSName :: "lowerLimit"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "random" || .iDevice == "user")
    }
    inst iRandUpper :: GBL.DSPARITHMETIC == "FIXED" ? 32767 : 1.0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label :: "Upper limit"
	prop JSName :: "upperLimit"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "random" || .iDevice == "user")
    }
    inst iSineGain :: GBL.DSPARITHMETIC == "FIXED" ? 32767 : 1.0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label :: "Gain"
	prop JSName :: "gain"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "sine" || .iDevice == "user")
    }
    inst iSineFreq :: GBL.DSPARITHMETIC == "FIXED" ? 1 : 1000.0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label :: "Frequency (Hz)"
	prop JSName :: "frequency"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "sine" || .iDevice == "user")
    }
    inst iSinePhase :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0.0{
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label :: "Phase (radians)"
	prop JSName :: "phase"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "sine" || .iDevice == "user")
    }
    inst iSineRate :: GBL.DSPARITHMETIC == "FIXED" ? 256 : 44000 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Sample rate (samples/sec)"
	prop JSName :: "rate"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "sine" || .iDevice == "user")
    }
    inst iUserFxn :: .iDevice == "printFloat" ? @_DGN_printFloat : .iDevice == "printHex" ? @_DGN_printHex : .iDevice == "printInt" ? @_DGN_printInt : @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "User function"
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: .iDevice == "user"
	
	prop Set :: (
	    .iUserFxn = $1,
	    .iSaveUserFxn = .iUserFxn,
	    "ok"
	)
    }
    inst iSaveUserFxn :: @_FXN_F_nop {
	prop Visible :: 0
	prop Writable ::0
	prop NoGen :: 1
    }
    inst iUserArg ::= 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "User function argument"
	prop JSName :: "arg"
	prop Visible :: 1
	prop Writable :: .iDevice == "user"
    }
    
    inst iFxns :: @_DGN_FXNS {
	prop NoGen :: 1
    }
}
type DHL {
    isa ObjectMgr
    prop name :: "DHL"
    prop Label :: "DHL - Host Link Driver"
    prop IsContainedIn :: SIODRIVER
    prop GlobalHelpTopic :: (303)
    prop InstanceHelpTopic :: (403)
    prop InstancePropertyPage :: ("{9C29DA20-90F9-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{9C29DA21-90F9-11d1-988B-0020AFEE33C6}")
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop DependsOn :: "DEV"
    prop Visible :: 1
    prop isDriver :: 1
    prop dataSize :: (
	7 + 11 * DHL.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    )
    global gChannelsAvailable :: (
        $a = 0,
        scan ($i; HST) {
            if ($i.iDHLAvailable == 1) {
                $a++
            }
        },
        $a
    ) 
    prop localCanCreate :: (
        if (.gChannelsAvailable > 0) {
            "ok"
        }
	else {
	    .warning("No HST channels are available for a new DHL device.")
	}
    )
    prop localCreate :: (
        .gChannelsAvailable--,
	.seizeHSTChannel(.iHSTChannel),
        "ok"
    )
       
    prop seizeHSTChannel :: (
	$1.iDelUser = "DHL",
	$1.iDHLAvailable = 0,
	$1.notify = @_DHL_notify,
	$1.arg0 = $1.iId,
	"ok"
    )
    prop localDelete ::(
        .gChannelsAvailable++,
	.releaseHSTChannel(.iHSTChannel),
        "ok"
    )
    prop releaseHSTChannel :: (
	$1.iDelUser = "USER",
	$1.iDHLAvailable = 1,
	$1.notify = @_FXN_F_nop,
	$1.arg0 = 0,
	"ok"
    )
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: "%8t .dhl: {}"
    prop _memSeg :: .OBJMEMSEG
    prop _placement :: (0x7fffffff / 2)
    global OBJMEMSEG :: IRAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iHSTChannel :: (
        scan ($i; HST) {
            if ($i.iDHLAvailable == 1) {
                $a = $i 
            }
        },
        $a
    ) {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Underlying HST Channel"
	prop JSName :: "hstChannel"
        prop MemberType :: HST
	prop MemberTest :: ((($1.iDHLAvailable == 1) || ($1 == .iHSTChannel)) ? 1 : 0)
        prop Set :: (
            if ($1.iDHLAvailable != 1) {
		
                .error("This channel is already in use.")
            }
            else {
                .releaseHSTChannel(.iHSTChannel),
		.seizeHSTChannel($1),
                .iHSTChannel = $1,
                "ok"
            }
        )
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst iMode ::= .iHSTChannel.mode {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Mode"
	prop JSName :: "mode"
	prop Visible :: 1
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst iDevId ::= (.iHSTChannel.iId) {
	prop NoGen :: 0
    }
    
    inst iIsTerminal :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    inst iIsVirtual :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iFxns :: @_DHL_FXNS {
	prop NoGen :: 1
    }
}
type DPI {
    isa ObjectMgr
    prop name :: "DPI"
    prop Label :: "DPI - Pipe Driver"
    prop IsContainedIn :: SIODRIVER
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop GlobalHelpTopic :: (
	304
    )
    prop InstanceHelpTopic :: (
	404
    )
    prop InstancePropertyPage :: (
	"{7FE06FA0-2DE9-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{7FE06FA1-2DE9-11d1-988B-0020AFEE33C6}"
    )
    prop DependsOn :: "DEV"
    prop maxObjs :: (32767)
    prop isDriver :: (
	1
    )
    prop localCreate :: (
	.gCurDevId += 1,
	"ok"
    )
    global gCurDevId :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iDevId :: DPI.gCurDevId {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
	prop Set :: (
	    .error("DPI.iDevId parameter no longer settable, it is now handled automatically")
	)
    }
    inst iIsVirtual :: 0 {
        prop Label :: "Allow virtual instances of this device."
	prop JSName :: "allowVirtual"
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
	prop Set :: (
	    if ($1 == 1) {
		$a = "ok",
		$b = 1,
		scan ($i; SIO) {
		    if ($i.iDevice == self) {
			$a = .error("This DPI instance is being used by one or more SIO instances, cannot reconfigure"),
			$b = 0
		    }
		},
		if ($b == 1) {
		    .iIsVirtual = 1
		},
		$a
	    }
	    else {
		.iIsVirtual = 0,
		"ok"
	    }
	)
    }
    inst iIsTerminal :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    
    inst iFxns :: @_DPI_FXNS {
	prop NoGen :: 1
    }
}
type HOOK {
    isa ObjectMgr
    prop name :: "HOOK"
    prop Label :: "HOOK - Module Hook Manager"
    prop IsContainedIn :: SYSTEM
    prop DependsOn :: "SWI"
    prop InstancePropertyPage :: (
	"{473C4A64-B1A8-11d0-9885-0020AFEE33C6}"
    )
    prop GlobalIcon :: 181
    prop InstanceIcon :: 182
    prop GlobalHelpTopic :: (
	318
    )
    prop InstanceHelpTopic :: (
	418
    )
    prop localCreate :: (
	if (.gNumOf == 0) {
	    HOOK_KNL.iIsUsed = 1,
	    .mkId(0)
	},
	"ok"
    )
    
    prop localDelete :: (
	if (.gNumOf == 2) {
	    HOOK_KNL.iIsUsed = 0,
	    .rmId
	},
	"ok"
    )
    prop maxObjs :: (32767)	
    
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    global KNLID ::= (HOOK_KNL.Order - 1) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    inst initFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Initialization function"
	prop JSName :: "initFxn"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst createFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Create function"
	prop JSName :: "createFxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER"
    }
    inst deleteFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Delete function"
	prop JSName :: "deleteFxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER"
    }
    inst exitFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Exit function"
	prop JSName :: "exitFxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER"
    }
    inst callSwitchFxn :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Call switch function"
	prop JSName :: "callSwitchFxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER"
    }
    inst switchFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Switch function"
	prop JSName :: "switchFxn"
	prop Visible :: 1
	prop Writable :: .callSwitchFxn
    }
    inst callReadyFxn :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Call ready function"
	prop JSName :: "callReadyFxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER"
    }
    inst readyFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Ready function"
	prop JSName :: "readyFxn"
	prop Visible :: 1
	prop Writable :: .callReadyFxn
    }
    
    inst Order :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
	prop NoGen :: 1
	prop Writable :: 1
    }
    
    inst iPri :: 0 {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}
object HOOK_KNL :: HOOK {
    param Order :: 1
    param iComment :: "Used to support TSK function hooks (cannot be deleted)"
    param iIsUsed :: 0
    param iDelUser :: "HOOK"
    param iDelMsg :: "This hook instance is used by TSK and cannot be deleted"
    param initFxn :: @_FXN_F_nop
    param createFxn :: TSK.CREATEFXN
    param deleteFxn :: TSK.DELETEFXN
    param exitFxn :: TSK.EXITFXN
    param callSwitchFxn :: TSK.DOSWITCH
    param switchFxn :: TSK.VSWFXN
    param callReadyFxn :: TSK.DOREADY
    param readyFxn :: TSK.VRDYFXN
}
type DIO {
    isa ObjectMgr
    prop Visible :: 1
    prop Label :: "DIO - Class Driver"
    prop name :: "DIO"
    prop IsContainedIn :: SIODRIVER
    prop GlobalIcon :: 127
    prop InstanceIcon :: 127
    prop GlobalHelpTopic :: (
	319
    )
    prop InstanceHelpTopic :: (
	419	
    )
    prop InstancePropertyPage :: (		
	"{f80273c0-3838-11d2-a32c-006097656921}"
    )
    
    prop GlobalPropertyPage :: (		
	"{050a0600-3839-11d2-a32c-006097656921}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: (
	"%8t .dio: {}"
    )
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: .OBJMEMSEG
    prop isDriver :: (
	1
    )
    prop mdObject :: (
	$h = nil,
	$j = nil,
	scan ($h; UDEV) {
	    if ($h.driverType == "DEV_IOMTYPE" ) {
		$j = $h,
                break
	    }
	},
	$j
    )
    prop localCanCreate :: (
	if (.mdObject == nil) {
	    .error ("An IOM type device must be created first.")
	}
	else {
	    "ok"
	}
    )
    prop numTsk :: (
	$a = 0,
	$h = nil,
	scan ($h; DIO) {
	    if ($h.useCallBackFxn == 0) {
		$a = $a + $h.numTimeUse
	    }
	},
	$a
    )
    prop numSwi :: (
	$a = 0,
	$h = nil,
	scan ($h; DIO) {
	    if ($h.useCallBackFxn == 1) {
		$a = $a + $h.numTimeUse
	    }
	},
	$a
    )
	
    prop functionTablePtr :: (
	if (.STATIC) {
	    if (.useCallBackFxn) {
		@_DIO_cbStaticFxns
	    }
	    else {
		@_DIO_tskStaticFxns
	    }
	}
	else {
	    if (.useCallBackFxn) {
		@_DIO_cbDynamicFxns
	    }
	    else {
		@_DIO_tskDynamicFxns
	    }
	}
    )
    global OBJMEMSEG :: IRAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global STATIC :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Create all DIO Objects Statically"
	prop JSName :: "STATICCREATE"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    global NUMTSKBASE ::= .numTsk  {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "TSK based"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global NUMSWIBASE ::= .numSwi  {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "SWI based"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst useCallBackFxn :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "use callback version of DIO function table"
	prop JSName :: "useCallBackFxn"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    inst fxnsTable ::= .functionTablePtr {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible  :: 1
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst initFxn :: @_DIO_init {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible  :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst deviceName :: .mdObject {
        prop Type     :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: UDEV
	prop MemberTest :: $1.driverType == "DEV_IOMTYPE"
        prop Label    :: "device name"
        prop JSName   :: "deviceName"
        prop Visible  :: 1
        prop Writable :: 1
	prop NoGen :: 0
    }
    inst chanParams :: 0 {
        prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label    :: "channel parameters"
        prop JSName   :: "chanParams"
        prop Visible  :: 1
        prop Writable :: 1
	prop NoGen :: 0
    }
    inst numTimeUse :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iDevId :: 0 {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible  :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iFxns ::= .functionTablePtr {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible  :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iIsTerminal :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iIsVirtual :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
}
 type CSL {
    isa ModuleFolder
    prop name :: "CSL"
    prop Label :: "CSL - Chip Support Library (CSL CDB Removal Warning, see docs/SPRA971.pdf)"
    prop NoGen :: 1
    prop cGen :: 1
    prop cHeaderName:: (
	if ((externDecl.HeaderName() == "csl.h" ) || 
	    (externDecl.HeaderFile != "NULL" ) || 
  	    (dmaCfg.cHeaderName() == "csl_dma.h" && .DMA_SUPPORT) || 
	    (hDma.cHeaderName() == "csl_dma.h" && .DMA_SUPPORT) ||
	    (dmaGblCfg.cHeaderName() == "csl_dma.h" && .DMA_SUPPORT) || 
	    (edmaCfg.cHeaderName() != "" && .EDMA_SUPPORT) ||
	    (hEdma.cHeaderName() == "csl_edma.h" && .EDMA_SUPPORT) ||
	    (hEdmaTbl.cHeaderName() == "csl_edma.h" && .EDMA_SUPPORT) || 
	    (emifCfg.cHeaderName() == "csl_emif.h" && .EMIF_SUPPORT) || 
	    (emifaCfg.cHeaderName() == "csl_emifa.h" && .EMIFA_SUPPORT) || 
	    (emifbCfg.cHeaderName() == "csl_emifb.h" && .EMIFB_SUPPORT) || 
	    (mcbspCfg.cHeaderName() == "csl_mcbsp.h" && .MCBSP_SUPPORT) ||
	    (hMcbsp.cHeaderName() == "csl_mcbsp.h" && .MCBSP_SUPPORT) ||
	    (tcpCfg.cHeaderName() == "csl_tcp.h" && .TCP_SUPPORT) || 
	    (timerCfg.cHeaderName() == "csl_timer.h" && .TIMER_SUPPORT) || 
	    (hTimer.cHeaderName() == "csl_timer.h" && .TIMER_SUPPORT) ||
            (vcpCfg.cHeaderName() == "csl_vcp.h" && .VCP_SUPPORT) || 
	    (xbusCfg.cHeaderName() == "csl_xbus.h" && .XBUS_SUPPORT)) { 
	    "csl.h"
	} else { ""} 
	
    )
    prop GlobalIcon :: 156
    prop GlobalHelpTopic :: (
	1000
    )
   
   prop GlobalPropertyPage :: "{33A68984-598D-11d4-B5CC-0050DA2E2CC0}"
   prop InstancePropertyPage :: "{33A68985-598D-11d4-B5CC-0050DA2E2CC0}"
   
    
global CHIP_6201 ::=(GBL.CHIPTYPE=="6201") {
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: " 6201"
    prop Visible::0
    prop NoGen::1
    }
 global CHIP_6202 ::=(GBL.CHIPTYPE=="6202") {
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: " 6202"
    prop Visible::0
    prop NoGen::1
    }
    global CHIP_6203 ::=(GBL.CHIPTYPE=="6203") {
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: " 6203"
    prop Visible::0
    prop NoGen::1
    }
   global CHIP_6204 ::=(GBL.CHIPTYPE=="6204") {
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: " 6204"
    prop Visible::0
    prop NoGen::1
    }
   global CHIP_6205 ::=(GBL.CHIPTYPE=="6205") {
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: " 6205"
    prop Visible::0
    prop NoGen::1
    }
   global CHIP_6211 ::=(GBL.CHIPTYPE=="6211") {
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: " 6211"
    prop Visible::0
    prop NoGen::1
    }
   global CHIP_6701 ::=(GBL.CHIPTYPE=="6701") {
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: " 6701"
    prop Visible::0
    prop NoGen::1
    }
   global CHIP_6711 ::=(GBL.CHIPTYPE=="6711") {
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: " 6711"
    prop Visible::0
    prop NoGen::1
    }
   global CHIP_6712 ::=(GBL.CHIPTYPE=="6712") {
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: " 6712"
    prop Visible::0
    prop NoGen::1
    }
   global CHIP_6713 ::=(GBL.CHIPTYPE=="6713") {
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: " 6713"
    prop Visible::0
    prop NoGen::1
    }
   global CHIP_DA610 ::=(GBL.CHIPTYPE=="DA610") {
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: " DA610"
    prop Visible::0
    prop NoGen::1
    }
   global CHIP_DM642 ::=(GBL.CHIPTYPE=="DM642") { 
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: " DM642"
    prop Visible:: 0
    prop NoGen::1
    }  
   global CHIP_6412 ::=(GBL.CHIPTYPE=="6412") { 
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: " 6412"
    prop Visible:: 0
    prop NoGen::1
    }
   global CHIP_6414 ::=(GBL.CHIPTYPE=="6414") { 
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: " 6414"
    prop Visible:: 0
    prop NoGen::1
    }
   
   global CHIP_6415 ::=(GBL.CHIPTYPE=="6415") { 
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: " 6400"
    prop Visible:: 0
    prop NoGen::1
    }
   global CHIP_6416 ::=(GBL.CHIPTYPE=="6416") { 
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: " 6400"
    prop Visible:: 0
    prop NoGen::1
    }
   
   global CHIP_6400 ::=(GBL.CHIPTYPE=="6400") { 
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: " 6400"
    prop Visible:: 0
    prop NoGen::1
    }
  global CHIP_NONE ::=(GBL.CHIPTYPE=="other") { 
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: " NONE"
    prop Visible:: 0
    prop NoGen::1
   } 
   
    global C11_SUPPORT::=(.CHIP_6211 || .CHIP_6711 || .CHIP_6712 || .CHIP_6713 || .CHIP_DA610)  {
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: "C11_SUPPORT"
    prop Visible:: 0
    prop NoGen::1
    }
    global C64_SUPPORT::=(.CHIP_6400 || .CHIP_6414 || .CHIP_6415 || .CHIP_6416 || .CHIP_DM642 || .CHIP_6412)  {
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: "C64_SUPPORT"
    prop Visible:: 0
    prop NoGen::1
    }
    global TIMER_SUPPORT:: 1 { 
   
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: "TIMER_SUPPORT"
    prop Visible:: 0
    prop NoGen::1
    }
    
    global TIMER2_SUPPORT::= (.C64_SUPPORT) {
   
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: "TIMER2_SUPPORT"
    prop Visible:: 0
    prop NoGen::1
    }
    
     global MCBSP_SUPPORT:: 1 {
    
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: "MCBSP_SUPPORT"
    prop Visible:: 0
    prop NoGen::1
    }
    
     global MCBSP2_SUPPORT::=(.C64_SUPPORT || .CHIP_6202 || .CHIP_6203)  { 
    
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: "MCBSP2_SUPPORT"
    prop Visible:: 0
    prop NoGen::1
    }
    
    global EMIF_SUPPORT::= (!.CHIP_6400 && !.CHIP_NONE)  {
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: "EMIF_SUPPORT"
    prop Visible:: 0
    prop NoGen::1
    }
    
   global EMIFA_SUPPORT::= (.C64_SUPPORT )  {
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: "EMIFA_SUPPORT"
    prop Visible:: 0
    prop NoGen::1
    }
   global EMIFB_SUPPORT::= (.C64_SUPPORT )  {
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: "EMIFB_SUPPORT"
    prop Visible:: 0
    prop NoGen::1
    }
    
   global DMA_SUPPORT::=(.CHIP_6201 || .CHIP_6202 || .CHIP_6203 || .CHIP_6204 || .CHIP_6205 || .CHIP_6701 ) {
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: "DMA_SUPPORT"
    prop Visible:: 0
    prop NoGen::1
    }
    
    global EDMA_SUPPORT::=(.C11_SUPPORT || .C64_SUPPORT  ) { 
    
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: "EDMA_SUPPORT"
    prop Visible:: 0
    prop NoGen::1
    }
    
  global XBUS_SUPPORT::=(.CHIP_6202 || .CHIP_6203 || .CHIP_6204 ) {
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: "XBUS_SUPPORT"
    prop Visible:: 0
    prop NoGen::1
    }
 global TCP_SUPPORT::= (.CHIP_6416 )  {
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: "TCP_SUPPORT"
    prop Visible:: 0
    prop NoGen::1
    }
 global VCP_SUPPORT::= (.CHIP_6416 )  {
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: "VCP_SUPPORT"
    prop Visible:: 0
    prop NoGen::1
    }
    global L2_SUPPORT::=(.C11_SUPPORT) {
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: "L2_SUPPORT"
    prop Visible:: 0
    prop NoGen::1
    }
 }
type externDecl {
      isa ObjectMgr
      prop name :: "externDecl"
      prop Label :: "CSL Extern Declaration"
      prop JSName :: "ExternDecl"
      prop IsContainedIn :: CSL
      prop GlobalPropertyPage :: "{33A68986-598D-11d4-B5CC-0050DA2E2CC0}"
      prop InstancePropertyPage :: "{33A68987-598D-11d4-B5CC-0050DA2E2CC0}"
      
      prop Vendor :: "vendor1"
      prop Version :: "1.00.00"
      prop HeaderName :: .gNumOf > 0 ? "csl.h" : ""      
       
      prop GlobalHelpTopic :: ( 
         1005 )
      prop InstanceHelpTopic :: ( 
         1005 )
	prop NoGen :: 1
        prop cGen :: 1
      prop localDelete :: (
        .myDelete
      )           
      prop myDelete :: (
        $a=0,
        scan($b; externDecl) { 
             $a = $a + 1
        }, 		
        "ok"
      )           
    
      global HeaderFile ::"NULL" {
       prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
       prop Label :: "Enter header filename between quotes "
       prop JSName :: "HEADER_FILENAME"
       prop Visible :: 1
       prop Writable :: 1
       prop Set :: (
             if ( $1 == "") { 
             .HeaderFile = "NULL",
             "ok" 
           } else { 
             .HeaderFile = $1,
             "ok"
           }
       )     
      } 
     prop HeaderStr :: (.HeaderFile  != "NULL") ? .HeaderFile : ""
     prop IncludeStr :: (.HeaderFile  != "NULL") ? "#include " : ""
     prop IncludeEndStr :: (.HeaderFile  != "NULL") ? "\n" : ""
    
     prop cGenCPrologue :: (
             "%1S%2S%3S\n\0,IncludeStr,HeaderStr,IncludeEndStr"
        )   
       
   
     inst BuffType ::"NULL" {
       prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
       prop Label :: "CSL Symbol Type (ex: Uint32)"
       prop JSName :: "bufType"
       prop Visible :: 1
       prop Writable :: 1
       prop Set :: (
             .BuffType = $1,
             "ok"
       )     
      }
     inst BuffName ::"NULL" {
       prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
       prop Label :: "Symbol Name (ex: BuffA)"
       prop JSName :: "bufName"
       prop Visible :: 1
       prop Writable :: 1
       prop Set :: (
              $a=0,
              scan($b;externDecl) {
                    if ($1 == $b.BuffName) {
                         $a +=1
                    }
                 },
                    if ( $a > 0) {
                      .error(" Symbol Name already used ")
                     } else {
                    .BuffName = $1,
                      "ok"
                     }
       )     
      }
     inst BuffSpec :: "Non-array" {
       prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
       prop Enum :: "Non-array,Array" 
       prop Label :: "Symbol Specification"
       prop JSName :: "bufSpec"
       prop Visible :: 1
       prop Writable :: 1
       prop Set :: (
              .BuffSpec= $1,
             "ok"
       )     
      }
     prop SymType :: (.BuffName != "NULL" && .BuffType != "NULL") ? .BuffType : "" 
     prop SymName :: (.BuffName != "NULL" && .BuffType != "NULL") ? .BuffName : "" 
     prop SymSpec :: ( .BuffName != "NULL" && .BuffType != "NULL" && .BuffSpec == "Array") ? "[]" : ""
            
     prop ExternStr :: (.BuffName != "NULL" && .BuffType != "NULL") ? "extern far " : "" 
     prop EndStr ::  (.BuffName != "NULL" && .BuffType != "NULL") ? ";\n" : ""   
    prop cGenCInst :: (
             "%1S%2S %3S%4S%5S\n\0,ExternStr,SymType,SymName,SymSpec,EndStr"
        )  
  
}
object EXTERN_NOTHING :: externDecl {
      param BuffType :: "NULL" 
      param BuffName :: "NULL" 
      param BuffSpec :: "Non-array" 
       param iIsUsed :: 0
}
object DeclNull :: externDecl {
    param BuffType :: "NULL"
    param BuffName :: "NULL"
    param BuffSpec :: "Non-array"
    param iIsUsed :: 0
}
type DMAFOLDER {
    prop Label :: "DMA Direct Memory Access"
    prop GlobalIcon :: 157
    prop InstanceIcon :: 158
    prop GlobalHelpTopic :: 1020
    prop GlobalPropertyPage :: "{B936FB91-49A5-11d4-967C-0050048381B7}"
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}
    
type dmaCfg {
      isa ObjectMgr
      prop name :: "dmaCfg"
      prop Label :: "DMA Configuration Manager"
      prop JSName :: "DMA"
	prop IsContainedIn :: DMAFOLDER
      prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-00105A98CA0B}"
      prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-0000C070F3E9}"
      prop Vendor :: "vendor1"
      prop Version :: "1.00.00"
      
      prop GlobalIcon :: 157
      prop InstanceIcon :: 158
      prop GlobalHelpTopic :: 1021
      prop InstanceHelpTopic :: 1021
	prop NoGen :: 1
        prop cGen :: CSL.DMA_SUPPORT 
    	prop cStruct :: CSL.DMA_SUPPORT
    	prop cStructType :: "DMA_Config"
	prop cHeaderName :: .gNumOf > 0 ? "csl_dma.h" : ""
	prop cStructQual :: "far"
           
      prop localDelete :: (
        .myDelete
      )           
      prop myDelete :: (
        $a=0,
        scan($b; dmaCfg) { 
             $a = $a + 1
        }, 		
        if($a == 2) {
	     scan($c;hDma) {
                $c.PINIT_ENABLE = 0
           }
        },
        "ok"
      )           
  inst START_SETUP :: "Stop" {
      prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
      prop Enum :: "Stop,Start w/o Autoinit,Pause,Start w/ Autoinit"
      prop Label :: "Start/Autoinit, Pause(START)"
      prop JSName :: "dmaPrictlStart"
      prop Visible :: 1
      prop Writable :: CSL.DMA_SUPPORT
      prop NoGen :: 1
      prop cGen :: 0
      prop TabName :: "Operation Mode"
      prop Set :: (
           .START_SETUP = $1,
           .PRICTL_VALUE = .PRICTL_VALUE_update(),
           "ok"
      )
   }
  prop START_PRICTL :: (
      if (.START_SETUP == "Stop") {
          0x00000000
      } else {
        if (.START_SETUP == "Start w/o Autoinit") {
            0x00000001
        } else {
          if (.START_SETUP == "Pause") {
              0x00000002
          } else {
            if (.START_SETUP == "Start w/ Autoinit") {
                0x00000003
            }
          }
        }
      }
    )
   inst SRCDIR_SETUP :: "None" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,Increment,Decrement,Index"
        prop Label :: "Source Address Modification(SRC DIR)"
	prop JSName :: "dmaPrictlSrcDir"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Source"
        prop Set :: (
             .SRCDIR_SETUP = $1,
             .PRICTL_VALUE = .PRICTL_VALUE_update(),
             "ok"
        )
   }
    prop SRCDIR_PRICTL :: (
        if (.SRCDIR_SETUP == "None") {
            0x00000000
        } else {
		if (.SRCDIR_SETUP == "Increment") {
			0x00000010
		} else {
			if (.SRCDIR_SETUP == "Decrement") {
				0x00000020
			} else {
				if (.SRCDIR_SETUP == "Index") {
					0x00000030
				}
			}
		}
	}
    )
   inst DSTDIR_SETUP :: "None" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,Increment,Decrement,Index"
        prop Label :: "Destination Address Modification(DST DIR)"
	prop JSName :: "dmaPrictlDstDir"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Destination"
        prop Set :: (
             .DSTDIR_SETUP = $1,
             .PRICTL_VALUE = .PRICTL_VALUE_update(),
             "ok"
        )
   }
    prop DSTDIR_PRICTL :: (
        if (.DSTDIR_SETUP == "None") {
            0x00000000
        } else {
		if (.DSTDIR_SETUP == "Increment") {
			0x00000040
		} else {
			if (.DSTDIR_SETUP == "Decrement") {
				0x00000080
			} else {
				if (.DSTDIR_SETUP == "Index") {
					0x000000C0
				}
			}
		}
	}
    )
   inst ESIZE_SETUP :: "32-bit" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "32-bit,16-bit,8-bit"
        prop Label :: "Element Size(ESIZE)"
	prop JSName :: "dmaPrictlEsize"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Operation Mode"
        prop Set :: (
             .ESIZE_SETUP = $1,
             .PRICTL_VALUE = .PRICTL_VALUE_update(),
             "ok"
        )
   }
    prop ESIZE_PRICTL :: (
        if (.ESIZE_SETUP == "32-bit") {
            0x00000000
        } else {
		if (.ESIZE_SETUP == "16-bit") {
			0x00000100
		} else {
                if(.ESIZE_SETUP == "8-bit") {
                     0x00000200
                }
            }
	}
    )
   inst SPLIT_SETUP :: "Disable" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Global Address Register A,Global Address Register B,Global Address Register C"
        prop Label :: "Split Channel Mode(SPLIT)"
	prop JSName :: "dmaPrictlSplit"
        prop Visible :: 1
        prop Writable :: ((CSL.DMA_SUPPORT != 0) && (.RSYNC_SETUP == "None")||(.WSYNC_SETUP == "None")) ? 0 : 1
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Synchronization"
        prop Set :: (
             .SPLIT_SETUP = $1,
             if(   (.RSYNC_SETUP == "None")
                 ||(.WSYNC_SETUP == "None")
                 &&(.SPLIT_SETUP != "Disable")){
                       .SPLIT_SETUP = "Disable"
             }, 
             .PRICTL_VALUE = .PRICTL_VALUE_update(),
             "ok"
        )
    }
    prop SPLIT_PRICTL :: (
        if (.SPLIT_SETUP == "Disable") {
            0x00000000
        } else {
		if (.SPLIT_SETUP == "Global Address Register A") {
			0x00000400
		} else {
			if (.SPLIT_SETUP == "Global Address Register B") {
				0x00000800
			} else {
				if (.SPLIT_SETUP == "Global Address Register C") {
					0x00000C00
				}
			}
		}
	}
    )
   inst CNTRLD_SETUP :: "Count Reload Reg A" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Count Reload Reg A,Count Reload Reg B"
        prop Label :: "Transfer Count Reload(CNT RELOAD)"
	prop JSName :: "dmaPrictlCntReload"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Count/Index"
        prop Set :: (
             .CNTRLD_SETUP = $1,
             .PRICTL_VALUE = .PRICTL_VALUE_update(),
             "ok"
        )
    }
    prop CNTRLD_PRICTL :: (
        if (.CNTRLD_SETUP == "Count Reload Reg A") {
            0x00000000
        } else {
		if (.CNTRLD_SETUP == "Count Reload Reg B") {
			0x00001000
		} 
	  }
    )
   inst INDEX_SETUP :: "Global Index Register A" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Global Index Register A,Global Index Register B"
        prop Label :: "Select Programmable Index(INDEX)"
	prop JSName :: "dmaPrictlIndex"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Count/Index"
        prop Set :: (
             .INDEX_SETUP = $1,
             .PRICTL_VALUE = .PRICTL_VALUE_update(),
             "ok"
        )
   }
    prop INDEX_PRICTL :: (
        if (.INDEX_SETUP == "Global Index Register A") {
            0x00000000
        } else {
		if (.INDEX_SETUP == "Global Index Register B") {
			0x00002000
		} 
	  }
    )
   inst RSYNC_SETUP :: "None" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,Timer 0 Interrupt,Timer 1 Interrupt,EMIF Timer Interrupt,External Interrupt Pin 4,External Interrupt Pin 5,External Interrupt Pin 6,External Interrupt Pin 7,DMA Channel 0 Interrupt,DMA Channel 1 Interrupt,DMA Channel 2 Interrupt,DMA Channel 3 Interrupt,McBSP 0 Transmit Event,McBSP 0 Receive Event,McBSP 1 Transmit Event,McBSP 1 Receive Event,Host to DSP Interrupt,McBSP 2 Transmit Event,McBSP 2 Receive Event"
        prop Label :: "Read Transfer Sync(RSYNC)"
	prop JSName :: "dmaPrictlRsync"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Synchronization"
        prop Set :: (
             .RSYNC_SETUP = $1,
             if(   (.RSYNC_SETUP == "None")
                 &&(.SPLIT_SETUP != "Disable")){
                       .SPLIT_SETUP = "Disable"
             }, 
             .PRICTL_VALUE = .PRICTL_VALUE_update(),
             "ok"
        )
   }
    prop RSYNC_PRICTL :: (
        if(.RSYNC_SETUP == "None"){
            0x00000000
        }else{
	    if(.RSYNC_SETUP == "Timer 0 Interrupt"){
	        0x00004000
	    }else{
             if(.RSYNC_SETUP == "Timer 1 Interrupt"){
		     0x00008000
             }else{
               if(.RSYNC_SETUP == "EMIF Timer Interrupt"){
                   0x0000C000
               }else{
                 if(.RSYNC_SETUP == "External Interrupt Pin 4"){
                     0x00010000
                 }else{
                   if(.RSYNC_SETUP == "External Interrupt Pin 5"){
                       0x00014000
                   }else{
                     if(.RSYNC_SETUP == "External Interrupt Pin 6"){
                         0x00018000
                     }else{
                       if(.RSYNC_SETUP == "External Interrupt Pin 7"){
                           0x0001C000
                       }else{
                         if(.RSYNC_SETUP == "DMA Channel 0 Interrupt"){
                             0x00020000
                         }else{
                           if(.RSYNC_SETUP == "DMA Channel 1 Interrupt"){
                               0x00024000
                           }else{
                             if(.RSYNC_SETUP == "DMA Channel 2 Interrupt"){
                                 0x00028000
                             }else{
                               if(.RSYNC_SETUP == "DMA Channel 3 Interrupt"){
                                   0x0002C000
                               }else{
                                 if(.RSYNC_SETUP == "McBSP 0 Transmit Event"){
                                     0x00030000
                                 }else{
                                   if(.RSYNC_SETUP == "McBSP 0 Receive Event"){
                                       0x00034000
                                   }else{
                                     if(.RSYNC_SETUP == "McBSP 1 Transmit Event"){
                                         0x00038000
                                     }else{
                                       if(.RSYNC_SETUP == "McBSP 1 Receive Event"){
                                           0x0003C000
                                       }else{
                                         if(.RSYNC_SETUP == "Host to DSP Interrupt"){
                                            0x00040000
                                         }else{
                                           if(.RSYNC_SETUP == "McBSP 2 Transmit Event"){
                                               0x00044000
                                           }else{
                                             if(.RSYNC_SETUP == "McBSP 2 Receive Event"){
                                                 0x00048000
                                             }
                                           }
                                         }  
                                       }
                                     }
                                   }
                                 }
                               }
                             }
                           }
                         }
                       }
                     }
                   }
                 }
               }
	       }
          }
        }
    )
   inst WSYNC_SETUP :: "None" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,Timer 0 Interrupt,Timer 1 Interrupt,EMIF Timer Interrupt,External Interrupt Pin 4,External Interrupt Pin 5,External Interrupt Pin 6,External Interrupt Pin 7,DMA Channel 0 Interrupt,DMA Channel 1 Interrupt,DMA Channel 2 Interrupt,DMA Channel 3 Interrupt,McBSP 0 Transmit Event,McBSP 0 Receive Event,McBSP 1 Transmit Event,McBSP 1 Receive Event,Host to DSP Interrupt,McBSP 2 Transmit Event,McBSP 2 Receive Event"
        prop Label :: "Write Transfer Sync(WSYNC)"
	prop JSName :: "dmaPrictlWsync"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Synchronization"
        prop Set :: (
             .WSYNC_SETUP = $1,
             if((.FS_SETUP == "RSYNC") && (.WSYNC_SETUP != "None")) {
                 .WSYNC_SETUP = "None"
             },
             if(   (.WSYNC_SETUP == "None")
                 &&(.SPLIT_SETUP != "Disable")){
                       .SPLIT_SETUP = "Disable"
             }, 
             .PRICTL_VALUE = .PRICTL_VALUE_update(),
             "ok"
        )
   }
    prop WSYNC_PRICTL :: (
        if(.WSYNC_SETUP == "None"){
            0x00000000
        }else{
	    if(.WSYNC_SETUP == "Timer 0 Interrupt"){
	        0x00080000
	    }else{
             if(.WSYNC_SETUP == "Timer 1 Interrupt"){
		     0x00100000
             }else{
               if(.WSYNC_SETUP == "EMIF Timer Interrupt"){
                   0x00180000
               }else{
                 if(.WSYNC_SETUP == "External Interrupt Pin 4"){
                     0x00200000
                 }else{
                   if(.WSYNC_SETUP == "External Interrupt Pin 5"){
                       0x00280000
                   }else{
                     if(.WSYNC_SETUP == "External Interrupt Pin 6"){
                         0x00300000
                     }else{
                       if(.WSYNC_SETUP == "External Interrupt Pin 7"){
                           0x00380000
                       }else{
                         if(.WSYNC_SETUP == "DMA Channel 0 Interrupt"){
                             0x00400000
                         }else{
                           if(.WSYNC_SETUP == "DMA Channel 1 Interrupt"){
                               0x00480000
                           }else{
                             if(.WSYNC_SETUP == "DMA Channel 2 Interrupt"){
                                 0x00500000
                             }else{
                               if(.WSYNC_SETUP == "DMA Channel 3 Interrupt"){
                                   0x00580000
                               }else{
                                 if(.WSYNC_SETUP == "McBSP 0 Transmit Event"){
                                     0x00600000
                                 }else{
                                   if(.WSYNC_SETUP == "McBSP 0 Receive Event"){
                                       0x00680000
                                   }else{
                                     if(.WSYNC_SETUP == "McBSP 1 Transmit Event"){
                                         0x00700000
                                     }else{
                                       if(.WSYNC_SETUP == "McBSP 1 Receive Event"){
                                           0x00780000
                                       }else{
                                         if(.WSYNC_SETUP == "Host to DSP Interrupt"){
                                             0x00800000
                                         }else{
                                           if(.WSYNC_SETUP == "McBSP 2 Transmit Event"){
                                               0x00880000
                                           }else{
                                             if(.WSYNC_SETUP == "McBSP 2 Receive Event"){
                                                 0x00900000
                                             }
                                           }
                                         }  
                                       }
                                     }
                                   }
                                 }
                               }
                             }
                           }
                         }
                       }
                     }
                   }
                 }
               }
	       }
          }
        }
    )
   inst PRI_SETUP :: "CPU" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "CPU,DMA"
        prop Label :: "Priority Mode(PRI)"
	prop JSName :: "dmaPrictlPri"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Operation Mode"
        prop Set :: (
             .PRI_SETUP = $1,
             .PRICTL_VALUE = .PRICTL_VALUE_update(),
             "ok"
        )
   }
    prop PRI_PRICTL :: (
        if (.PRI_SETUP == "CPU") {
            0x00000000
        } else {
		if (.PRI_SETUP == "DMA") {
			0x01000000
		} 
	  }
    )
   inst TCINT_SETUP :: "Disable" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Transfer Controller Interrupt(TCINT)"
	prop JSName :: "dmaPrictlTcint"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Interrupt Enable"
        prop Set :: (
             .TCINT_SETUP = $1,
             .PRICTL_VALUE = .PRICTL_VALUE_update(),
             "ok"
        )
   }
    prop TCINT_PRICTL :: (
        if (.TCINT_SETUP == "Disable") {
            0x00000000
        } else {
		if (.TCINT_SETUP == "Enable") {
			0x02000000
		} 
	  }
    )
   inst FS_SETUP :: "Disable" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,RSYNC"
        prop Label :: "Frame Sync(FS)"
	prop JSName :: "dmaPrictlFs"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Synchronization"
        prop Set :: (
             .FS_SETUP = $1,
             if( .FS_SETUP == "RSYNC" ){
                  .WSYNC_SETUP = "None",
                  .SPLIT_SETUP = "Disable"
             },
             .PRICTL_VALUE = .PRICTL_VALUE_update(),
             "ok"
        )
   }
    prop FS_PRICTL :: (
        if (.FS_SETUP == "Disable") {
            0x00000000
        } else {
		if (.FS_SETUP == "RSYNC") {
			0x04000000
		} 
	  }
    )
   inst EMOD_SETUP :: "Continue" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Continue,Pause"
        prop Label :: "Emulation Mode(EMOD)"
	prop JSName :: "dmaPrictlEmod"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Operation Mode"
        prop Set :: (
             .EMOD_SETUP = $1,
             .PRICTL_VALUE = .PRICTL_VALUE_update(),
             "ok"
        )
   }
    prop EMOD_PRICTL :: (
        if (.EMOD_SETUP == "Continue") {
            0x00000000
        } else {
		if (.EMOD_SETUP == "Pause") {
			0x08000000
		} 
	  }
    )
   inst SRCRLD_SETUP :: "No Reload" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "No Reload,Global Address Register B,Global Address Register C,Global Address Register D"
        prop Label :: "Src. Addr. Reload(SRC RELOAD)"
	prop JSName :: "dmaPrictlSrcReload"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Source"
        prop Set :: (
             .SRCRLD_SETUP = $1,
             .PRICTL_VALUE = .PRICTL_VALUE_update(),
             "ok"
        )
   }
    prop SRCRLD_PRICTL :: (
        if (.SRCRLD_SETUP == "No Reload") {
            0x00000000
        } else {
		if (.SRCRLD_SETUP == "Global Address Register B") {
			0x10000000
		} else {
			if (.SRCRLD_SETUP == "Global Address Register C") {
				0x20000000
			} else {
				if (.SRCRLD_SETUP == "Global Address Register D") {
					0x30000000
				}
			}
		}
	}
    )
   inst DSTRLD_SETUP :: "No Reload" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "No Reload,Global Address Register B,Global Address Register C,Global Address Register D"
        prop Label :: "Dst. Addr. Reload(DST RELOAD)"
	prop JSName :: "dmaPrictlDstReload"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Destination"
        prop Set :: (
             .DSTRLD_SETUP = $1,
             .PRICTL_VALUE = .PRICTL_VALUE_update(),
             "ok"
        )
   }
    prop DSTRLD_PRICTL :: (
        if (.DSTRLD_SETUP == "No Reload") {
            0x00000000
        } else {
		if (.DSTRLD_SETUP == "Global Address Register B") {
			0x40000000
		} else {
			if (.DSTRLD_SETUP == "Global Address Register C") {
				0x80000000
			} else {
				if (.DSTRLD_SETUP == "Global Address Register D") {
					0xC0000000
				}
			}
		}
	}
    )
   inst SXCOND_SETUP :: "Clear" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Clear,No Effect"
        prop Label :: "Split Transmit Overrun Receive Condition(SX COND)"
	prop JSName :: "dmaSecctlSxCond"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Condition"
        prop Set :: (
             .SXCOND_SETUP = $1,
             .SECCTL_VALUE = .SECCTL_VALUE_update(),
             "ok"
        )
   }
   prop SXCOND_SECCTL :: (
       if (.SXCOND_SETUP == "Clear") {
           0x00000000
       } else {
            if (.SXCOND_SETUP == "No Effect") {
                0x00000001
            } 
       }
   )
   inst FRAMECOND_SETUP :: "Clear" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Clear,No Effect"
        prop Label :: "Frame Complete Condition(FRAME COND)"
	prop JSName :: "dmaSecctlFrameCond"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Condition"
        prop Set :: (
             .FRAMECOND_SETUP = $1,
             .SECCTL_VALUE = .SECCTL_VALUE_update(),
             "ok"
	  )
   }
   prop FRAMECOND_SECCTL :: (
       if (.FRAMECOND_SETUP == "Clear") {
           0x00000000
       } else {
            if (.FRAMECOND_SETUP == "No Effect") {
                0x00000004
            } 
       }
   )
   inst LASTCOND_SETUP :: "Clear" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Clear,No Effect"
        prop Label :: "Last Frame Condition(LAST COND)"
	prop JSName :: "dmaSecctlLastCond"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Condition"
        prop Set :: (
             .LASTCOND_SETUP = $1,
             .SECCTL_VALUE = .SECCTL_VALUE_update(),
             "ok"
        )
   }
   prop LASTCOND_SECCTL :: (
       if (.LASTCOND_SETUP == "Clear") {
           0x00000000
       } else {
            if (.LASTCOND_SETUP == "No Effect") {
                0x00000010
            } 
       }
     )
   inst BLOCKCOND_SETUP :: "Clear" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Clear,No Effect"
        prop Label :: "Block Transfer Finished Condition(BLOCK COND)"
	prop JSName :: "dmaSecctlBlockCond"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Condition"
        prop Set :: (
             .BLOCKCOND_SETUP = $1,
             .SECCTL_VALUE = .SECCTL_VALUE_update(),
             "ok"
        )
   }
   prop BLOCKCOND_SECCTL :: (
       if (.BLOCKCOND_SETUP == "Clear") {
           0x00000000
       } else {
            if (.BLOCKCOND_SETUP == "No Effect") {
                0x00000040
            } 
       }
     )
   inst RDROPCOND_SETUP :: "Clear" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Clear,No Effect"
        prop Label :: "Dropped Read Synchronization Condition(RDROP COND)"
	prop JSName :: "dmaSecctlRdropCond"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Condition"
        prop Set :: (
             .RDROPCOND_SETUP = $1,
             .SECCTL_VALUE = .SECCTL_VALUE_update(),
             "ok"
        )
   }
   prop RDROPCOND_SECCTL :: (
       if (.RDROPCOND_SETUP == "Clear") {
           0x00000000
       } else {
            if (.RDROPCOND_SETUP == "No Effect") {
                0x00000100
            } 
       }
     )
   inst WDROPCOND_SETUP :: "Clear" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Clear,No Effect"
        prop Label :: "Dropped Write Synchronization Condition(RDROP COND)"
	prop JSName :: "dmaSecctlWdropCond"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Condition"
        prop Set :: (
             .WDROPCOND_SETUP = $1,
             .SECCTL_VALUE = .SECCTL_VALUE_update(),
             "ok"
	)
   }
   prop WDROPCOND_SECCTL :: (
       if (.WDROPCOND_SETUP == "Clear") {
           0x00000000
       } else {
            if (.WDROPCOND_SETUP == "No Effect") {
                0x00000400
            } 
       }
     )
   inst SXIE_SETUP :: "Disable" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Split Transmit Overrun Receive IE(SX IE)"
	prop JSName :: "dmaSecctlSxIe"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Interrupt Enable"
        prop Set :: (
             .SXIE_SETUP = $1,
             .SECCTL_VALUE = .SECCTL_VALUE_update(),
             "ok"
        )
   }
   prop SXIE_SECCTL :: (
       if (.SXIE_SETUP == "Disable") {
           0x00000000
       } else {
            if (.SXIE_SETUP == "Enable") {
                0x00000002
            } 
       }
     )
   inst FRAMEIE_SETUP :: "Disable" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Frame Complete IE(FRAME IE)"
	prop JSName :: "dmaSecctlFrameIe"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Interrupt Enable"
        prop Set :: (
             .FRAMEIE_SETUP = $1,
             .SECCTL_VALUE = .SECCTL_VALUE_update(),
             "ok"
        )
   }
   prop FRAMEIE_SECCTL :: (
       if (.FRAMEIE_SETUP == "Disable") {
           0x00000000
       } else {
            if (.FRAMEIE_SETUP == "Enable") {
                0x00000008
            } 
       }
     )
   inst LASTIE_SETUP :: "Disable" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Last Frame IE(LAST IE)"
	prop JSName :: "dmaSecctlLastIe"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Interrupt Enable"
        prop Set :: (
             .LASTIE_SETUP = $1,
             .SECCTL_VALUE = .SECCTL_VALUE_update(),
             "ok"
        )
   }
   prop LASTIE_SECCTL :: (
       if (.LASTIE_SETUP == "Disable") {
           0x00000000
       } else {
            if (.LASTIE_SETUP == "Enable") {
                0x00000020
            } 
       }
     )
   inst BLOCKIE_SETUP :: "Enable" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Enable,Disable"
        prop Label :: "Block Transfer Finished IE(BLOCK IE)"
	prop JSName :: "dmaSecctlBlockIe"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Interrupt Enable"
        prop Set :: (
             .BLOCKIE_SETUP = $1,
             .SECCTL_VALUE = .SECCTL_VALUE_update(),
             "ok"
        )
   }
   prop BLOCKIE_SECCTL :: (
       if (.BLOCKIE_SETUP == "Enable") {
           0x00000080
       } else {
            if (.BLOCKIE_SETUP == "Disable") {
                0x00000000
            } 
       }
     )
   inst RDROPIE_SETUP :: "Disable" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Dropped Read Synchronization IE(RDROP IE)"
	prop JSName :: "dmaSecctlRdropIe"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Interrupt Enable"
        prop Set :: (
             .RDROPIE_SETUP = $1,
             .SECCTL_VALUE = .SECCTL_VALUE_update(),
             "ok"
        )
   }
   prop RDROPIE_SECCTL :: (
       if (.RDROPIE_SETUP == "Disable") {
           0x00000000
       } else {
            if (.RDROPIE_SETUP == "Enable") {
                0x00000200
            } 
       }
     )
   inst WDROPIE_SETUP :: "Disable" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Dropped Write Synchronization IE(WDROP IE)"
	prop JSName :: "dmaSecctlWdropIe"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Interrupt Enable"
        prop Set :: (
             .WDROPIE_SETUP = $1,
             .SECCTL_VALUE = .SECCTL_VALUE_update(),
             "ok"
        )
   }
   prop WDROPIE_SECCTL :: (
       if (.WDROPIE_SETUP == "Disable") {
           0x00000000
       } else {
            if (.WDROPIE_SETUP == "Enable") {
                0x00000800
            } 
       }
     )
   inst RSYNCSTAT_SETUP :: "Not Received" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Not Received,Received"
        prop Label :: "Read Sync Status(RSYNC STAT)"
	prop JSName :: "dmaSecctlRsyncStat"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Synchronization"
        prop Set :: (
             .RSYNCSTAT_SETUP = $1,
             .SECCTL_VALUE = .SECCTL_VALUE_update(),
             "ok"
        )
   }
   prop RSYNCSTAT_SECCTL :: (
       if (.RSYNCSTAT_SETUP == "Not Received") {
           0x00000000
       } else {
            if (.RSYNCSTAT_SETUP == "Received") {
                0x00001000
            } 
       }
     )
   inst WSYNCSTAT_SETUP :: "Not Received" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Not Received,Received"
        prop Label :: "Write Sync Status(WSYNC STAT)"
	prop JSName :: "dmaSecctlWsyncStat"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Synchronization"
        prop Set :: (
             .WSYNCSTAT_SETUP = $1,
             .SECCTL_VALUE = .SECCTL_VALUE_update(),
             "ok"
        )
   }
   prop WSYNCSTAT_SECCTL :: (
       if (.WSYNCSTAT_SETUP == "Not Received") {
           0x00000000
       } else {
            if (.WSYNCSTAT_SETUP == "Received") {
                0x00004000
            } 
       }
     )
   inst RSYNCCLR_SETUP :: "None" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,Clear"
        prop Label :: "Read Sync Status Clear(RSYNC CLR)"
	prop JSName :: "dmaSecctlRsyncClr"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Synchronization"
        prop Set :: (
             .RSYNCCLR_SETUP = $1,
             .SECCTL_VALUE = .SECCTL_VALUE_update(),
             "ok"
        )
   }
   prop RSYNCCLR_SECCTL :: (
       if (.RSYNCCLR_SETUP == "None") {
           0x00000000
       } else {
            if (.RSYNCCLR_SETUP == "Clear") {
                0x00002000
            } 
       }
     )
   inst WSYNCCLR_SETUP :: "None" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,Clear"
        prop Label :: "Write Sync Status Clear(WSYNC CLR)"
	prop JSName :: "dmaSecctlWsyncClr"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Synchronization"
        prop Set :: (
             .WSYNCCLR_SETUP = $1,
             .SECCTL_VALUE = .SECCTL_VALUE_update(),
             "ok"
        )
   }
 
   prop WSYNCCLR_SECCTL :: (
       if (.WSYNCCLR_SETUP == "None") {
           0x00000000
       } else {
            if (.WSYNCCLR_SETUP == "Clear") {
                0x00008000
            } 
       }
     )
  inst DMACEN_SETUP :: "Low" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Low,High,RSYNC STAT,WSYNC STAT,FRAME COND,BLOCK COND"
        prop Label :: "DMA Action Complete(DMAC EN)"
	prop JSName :: "dmaSecctlDmacEn"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Operation Mode"
        prop Set :: (
             .DMACEN_SETUP = $1,
             .SECCTL_VALUE = .SECCTL_VALUE_update(),
             "ok"
        )
   }
   prop DMACEN_SECCTL :: (
       if (.DMACEN_SETUP == "Low") {
           0x00000000
       } else {
            if (.DMACEN_SETUP == "High") {
                0x00010000
            } else {
                 if (.DMACEN_SETUP == "RSYNC STAT") {
                     0x00020000
                 } else {
                      if (.DMACEN_SETUP == "WSYNC STAT") {
                          0x00030000
                      } else {
                           if (.DMACEN_SETUP == "FRAME COND") {
                               0x00040000
                           } else {
                                if (.DMACEN_SETUP == "BLOCK COND") {
                                    0x00050000
                                }
                           }
                      }
                 }
            }
       }
     )
  inst FSIG_SETUP :: "None" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,Ignore"
        prop Label :: "Frame Sync Ignore(FSIG, C6202 only)"
	prop JSName :: "dmaSecctlFsig"
        prop Visible :: 1
        prop Writable :: ((CSL.DMA_SUPPORT != 0) && (CSL.CHIP_6202 == 1) ? 1 : 0) 
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Synchronization"
        prop Set :: (
             .FSIG_SETUP = $1,
             .SECCTL_VALUE = .SECCTL_VALUE_update(),
             "ok"
        )
   }
   prop FSIG_SECCTL :: (
       if (.FSIG_SETUP == "None") {
           0x00000000
       } else {
            if (.FSIG_SETUP == "Ignore") {
                0x00080000
            } 
       }
     )
   inst RSPOL_SETUP ::= "Active Low" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Active Low,Active High"
        prop Label :: "Read Sync Event Polarity(RSPOL, C6202 only)"
	prop JSName :: "dmaSecctlRspol"
        prop Visible :: 1
        prop Writable :: ((CSL.DMA_SUPPORT != 0) && (CSL.CHIP_6202 == 1) 
                          && ((.RSYNC_SETUP == "External Interrupt Pin 4") 
                              || (.RSYNC_SETUP == "External Interrupt Pin 5") 
                              || (.RSYNC_SETUP == "External Interrupt Pin 6") 
                              || (.RSYNC_SETUP == "External Interrupt Pin 7"))
                          ? 1 : 0) 
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Synchronization"
        prop Set :: (
             .RSPOL_SETUP = $1,
             .SECCTL_VALUE = .SECCTL_VALUE_update(),
             "ok"
        )
    	}
   prop RSPOL_SECCTL :: (
       if (.RSPOL_SETUP == "Active Low") {
           0x00000000
       } else {
            if (.RSPOL_SETUP == "Active High") {
                0x00100000
            } 
       }
   )
   inst WSPOL_SETUP ::= "Active Low" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Active Low,Active High"
        prop Label :: "Write Sync Event Polarity(WSPOL, C6202 only)"
	prop JSName :: "dmaSecctlWspol"
        prop Visible :: 1
        prop Writable :: ((CSL.DMA_SUPPORT != 0) && (CSL.CHIP_6202 == 1) 
                          && ((.WSYNC_SETUP == "External Interrupt Pin 4") 
                              || (.WSYNC_SETUP == "External Interrupt Pin 5") 
                              || (.WSYNC_SETUP == "External Interrupt Pin 6") 
                              || (.WSYNC_SETUP == "External Interrupt Pin 7"))
                          ? 1 : 0) 
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Synchronization"
        prop Set :: (
             .WSPOL_SETUP = $1,
             .SECCTL_VALUE = .SECCTL_VALUE_update(),
             "ok"
        )
   }
 
   prop WSPOL_SECCTL :: (
       if (.WSPOL_SETUP == "Active Low") {
           0x00000000
       } else {
            if (.WSPOL_SETUP == "Active High") {
                0x00200000
            } 
       }
     )
    
    inst SRCADDR_FORMAT :: "Numeric" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Extern Decl. Obj.,User's Header file,McBSP handle (DRR)"
        prop Label:: "Source Address Format"
	prop JSName :: "dmaSrcAddrFormat"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Source"
	prop Set :: (
		$a = 0,
		scan ($b; externDecl) {
			$a += 1
		},
		if ($a == 1 && $1 == "Extern Decl. Obj." ) {
                  .SRCADDR_FORMAT = "Numeric",
        		.error("You must create a Symbol Address - See CSL extern Declaration")
		} else {
              if ( $1 == "User's Header file" && externDecl.HeaderFile == "NULL" ) {
                  .SRCADDR_FORMAT = "Numeric",
       		.error("You must enter a Header file name - See CSL extern Declaration")
		} else {
                  .SRCADDR_FORMAT = $1 ,
                  .SRCADDR_FORMAT_ADV = .SRCADDR_FORMAT,
                  if ($1 == "Numeric") {
		      .SRCADDR_SYM = "NULL",
                  .SRCADDR_HANDLE = "NULL",
                  .SRCADDR_HEADER = "NULL"
                  },
                  if ($1 == "User's Header file" ) {
                  .SRCADDR_HANDLE = "NULL",
		      .SRCADDR_SYM = "NULL" 
                  },
                  if ($1 == "Extern Decl. Obj." ) {
                  .SRCADDR_HANDLE = "NULL",
		      .SRCADDR_HEADER = "NULL" 
                  },
                  if ($1 == "McBSP handle (DRR)") {
                  .SRCADDR_SYM = "NULL",
		      .SRCADDR_HEADER = "NULL" 
                  },
                  "ok"
                } 
		}
	)
    } 
       
    inst SRCADDR_NUM :: 0x00000000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop Label :: "Source Address - Numeric "
	prop JSName :: "dmaSrcAddrNumeric"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT && .SRCADDR_FORMAT == "Numeric" 
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Source"
	prop Set :: (
	    if ( 0 ) {
		.error("Invalid Number")
	    }
	    else {
		.SRCADDR_NUM = $1,
		.SRCADDR_NUM_VALUE = .SRCADDR_NUM,
            .SRCADDR_HANDLE = "NULL",
            .SRCADDR_HEADER = "NULL",
            .SRCADDR_HEADER_VALUE = .SRCADDR_HEADER,
            .SRCADDR_SYM = "NULL",
		.SRCADDR_SYM_VALUE = .SRCADDR_SYM,
            "ok"
	    }
	)
    }
   inst SRCADDR_SYM :: "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "   Src Addr - Extern Decl. Symbol name "
	prop JSName :: "dmaSrcAddrSymbol"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT && .SRCADDR_FORMAT == "Extern Decl. Obj." 
	prop NoGen :: 1
      prop TabName :: "Source"
      prop Set :: ( 
                    $a = 0, 
		   scan($b; externDecl) {
                    if (  $1 != "NULL"  &&  $1 == $b.BuffName ) {
                          if ( $b.BuffType == "NULL" )  {
                                $a = 1
                          } else {
                             if ( $1 == .DSTADDR_SYM) {
                              $a = 2
                              } else {
                              $a = 3
                             } 
                          }
                      }
                   },
                    if ($a == 0 ) { 
                          .error("Symbolic Address  Not declared  - See CSL Extern Declaration")
                     } else {
                         if ( $a == 1) { 
                           .error("Symbol Type of this object is incorrect - See CSL Extern Declaration")
                           } else {
                             if ($a == 2 ) {
                              .error("Source and Destination must be different")
                             } else {
                             .SRCADDR_SYM = $1, 
                             .SRCADDR_SYM_VALUE = .SRCADDR_SYM, 
                              "ok"
                             }
                         }
                      }
                        
                   ) 
       }  
     inst SRCADDR_HEADER :: "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "   Src Addr - Enter full address "
	prop JSName :: "dmaSrcAddrFull"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT && .SRCADDR_FORMAT == "User's Header file" 
	prop NoGen :: 1
        prop TabName :: "Source"
        prop Set :: ( 
                    .SRCADDR_HEADER = $1, 
                    .SRCADDR_HEADER_VALUE = .SRCADDR_HEADER, 
                    "ok"
                   ) 
       }
 inst SRCADDR_HANDLE :: "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "   Src Addr - Enter Handle Name "
	prop JSName :: "dmaSrcAddrHandle"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT && .SRCADDR_FORMAT == "McBSP handle (DRR)" 
	prop NoGen :: 1
        prop TabName :: "Source"
        prop Set :: ( 
                   $a = 0, 
                   $c = 0, 
		   scan($b;hMcbsp) {
          if (  $1 == $b.HandleName && $b.MCBSP_HANDLE_ENABLE == 1 ) {
                       $a = 1
                      }  
                  },
                 if ( $a == 0) {
                       .error("Handle object Name has to be declared and defined (open)  - ")
                     } else {
                    .SRCADDR_HANDLE = $1, 
                    "ok"
                     }   
                   ) 
       }
    inst DSTADDR :: 0x00000000 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Label :: "Destination Address (Old - should not be visible)"
        prop Visible :: 0
        prop Writable :: CSL.EDMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Destination"
        prop Set :: (
            if ( 0 ) {
                .error("Invalid Number")
            }
            else {
                .DSTADDR = $1,
		.DSTADDR_FORMAT = "Numeric",
		.DSTADDR_FORMAT_ADV = .DSTADDR_FORMAT,
                .DSTADDR_NUM = .DSTADDR,
		.DSTADDR_NUM_VALUE = .DSTADDR_NUM,
		.DSTADDR_SYM = "NULL",
		.DSTADDR_SYM_VALUE = .DSTADDR_SYM,
                "ok"
            }
        )
    }
      inst DSTADDR_FORMAT :: "Numeric" {
      prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
      prop Enum :: "Numeric,Extern Decl. Obj.,User's Header file,McBSP handle (DXR)"
      prop Label:: "Dst Address Format"
      prop JSName :: "dmaDstAddrFormat"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Destination"
	prop Set :: (
		$a = 0,
		scan ($b; externDecl) {
			$a += 1
		},
		if ($a == 1 && $1 == "Extern Decl. Obj." ) {
                  .DSTADDR_FORMAT = "Numeric",
        		.error("You must create a Symbol Address - See CSL Extern Declaration")
		} else {
                if ($1 == "User's Header file" && externDecl.HeaderFile == "NULL" ) {
                  .DSTADDR_FORMAT = "Numeric",
               	.error("You must enter a Header file name - See CSL Extern Declaration")
		  } else {
                  .DSTADDR_FORMAT = $1 ,
                  .DSTADDR_FORMAT_ADV = $1,
                  if ($1 == "Numeric") {
                      .DSTADDR_SYM = "NULL",
                      .DSTADDR_HANDLE = "NULL",
		          .DSTADDR_HEADER = "NULL" 
                  },
                 if ($1 == "User's Header file" ) {
                  .DSTADDR_HANDLE = "NULL",
		      .DSTADDR_SYM = "NULL" 
                  },
                  if ($1 == "Extern Decl. Obj." ) {
                  .DSTADDR_HANDLE = "NULL",
		      .DSTADDR_HEADER = "NULL" 
                  },
                  if ($1 == "McBSP handle (DXR)") {
                  .DSTADDR_SYM = "NULL",
		      .DSTADDR_HEADER = "NULL" 
                  },
                  "ok"
                } 
		}
	)
    } 
    inst DSTADDR_NUM :: 0x00000000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop Label :: "   Dst Addr - Enter Numeric value "
	prop JSName :: "dmaDstAddrNumeric"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT && .DSTADDR_FORMAT == "Numeric" 
	prop NoGen :: 1
      prop cGen :: 0
      prop TabName :: "Destination"
	prop Set :: (
	    if ( 0 ) {
		.error("Invalid Number")
	    }
	    else {
		.DSTADDR_NUM = $1,
            .DSTADDR_NUM_VALUE = .DSTADDR_NUM,
            .DSTADDR_HANDLE = "NULL",
            .DSTADDR_HEADER = "NULL",
            .DSTADDR_HEADER_VALUE = .DSTADDR_HEADER,
            .DSTADDR_SYM = "NULL",
		.DSTADDR_SYM_VALUE = .DSTADDR_SYM,
		"ok"
	    }
	)
    }
   
   inst DSTADDR_SYM :: "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "   Dst Addr - Extern Decl. Symbol Name "
	prop JSName :: "dmaDstAddrSymbol"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT && .DSTADDR_FORMAT == "Extern Decl. Obj." 
	prop NoGen :: 1
        prop TabName :: "Destination"
        prop Set :: ( 
                    $a = 0, 
		   scan($b; externDecl) {
                    if (  $1 != "NULL"  &&  $1 == $b.BuffName ) {
                          if ( $b.BuffType == "NULL" )  {
                                $a = 1
                          } else {
                             if ( $1 == .SRCADDR_SYM) {
                              $a = 2
                              } else {
                              $a = 3
                             } 
                          }
                      }
                   },
                    if ($a == 0 ) { 
                          .error("Symbolic Address  Not declared  - See CSL Extern Declaration")
                     } else {
                         if ( $a == 1) { 
                           .error("Symbol Type of this object is incorrect - See CSL Extern Declaration")
                           } else {
                             if ($a == 2 ) {
                              .error("Source and Destination must be different")
                             } else {
                             .DSTADDR_SYM = $1, 
                             .DSTADDR_SYM_VALUE = .DSTADDR_SYM, 
                              "ok"
                             }
                         }
                      }
                        
                   ) 
       }  
    
   inst DSTADDR_HEADER :: "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "   Dst Addr - Enter full address "
	prop JSName :: "dmaDstAddrFull"
	prop Visible :: 1
	prop Writable :: (CSL.DMA_SUPPORT && .DSTADDR_FORMAT == "User's Header file") 
	prop NoGen :: 1
        prop TabName :: "Destination"
        prop Set :: ( 
                    .DSTADDR_HEADER = $1, 
                    .DSTADDR_NUM_VALUE = 0x00000000, 
                    .DSTADDR_HEADER_VALUE = .DSTADDR_HEADER, 
                    "ok"
                   ) 
       }
   inst DSTADDR_HANDLE :: "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "   Dst Addr - Enter Handle Name "
	prop JSName :: "dmaDstAddrHandle"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT && .DSTADDR_FORMAT == "McBSP handle (DXR)" 
	prop NoGen :: 1
        prop TabName :: "Destination"
        prop Set :: ( 
                   $a = 0, 
                   $c = 0, 
		   scan($b;hMcbsp) {
          if (  $1 == $b.HandleName && $b.MCBSP_HANDLE_ENABLE == 1 ) {
                       $a = 1
                      }  
                  },
                 if ( $a == 0) {
                       .error("Handle object Name has to be declared and defined (open)  - ")
                     } else {
                    .DSTADDR_HANDLE = $1, 
                    "ok"
                     }   
                   ) 
       }
    
    
    inst FRAMECNT :: 0x0000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04X"
	prop Style :: 0x02
	prop Label :: "Frame Count"
	prop Visible :: 0
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
      prop cGen :: 0
      prop TabName :: "Count/Index"
	prop Set :: (
	    if ( ($1 > 0x65535) | ($1 < 0)) {
		.error("Invalid Number")
	    }
	    else {
		.FRAMECNT = $1,
		.FRAMECNT_NUM = $1,
		.FRAMECNT_HEADER = "NULL",
		.XFRCNT_NUM_VALUE &= 0x0000FFFF,
		.XFRCNT_NUM_VALUE |= (.FRAMECNT_NUM << 16),
		"ok"
	    }
	)
    }
    
    
    inst ELMCNT :: 0x0000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04X"
	prop Style :: 0x02
	prop Label :: "Element Count"
	prop Visible :: 0
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
      prop cGen :: 0
      prop TabName :: "Count/Index"
	prop Set :: (
	    if ( ($1 > 65535) | ($1 < 0)) {
		.error("Invalid Number")
	    }
	    else {
		.ELMCNT = $1,
		.ELMCNT_NUM = $1,
		.ELMCNT_HEADER = "NULL",
		.XFRCNT_NUM_VALUE &= 0xFFFF0000,
		.XFRCNT_NUM_VALUE |= .ELMCNT_NUM,
		"ok"
	    }
	)
    }
    inst XFRCNT_FORMAT :: "Numeric" {
      prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
      prop Enum :: "Numeric,User's Header file"
      prop Label:: " Transfer Counter Format"
      prop JSName :: "dmaXfrcntFormat"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
      prop cGen :: 0
      prop TabName :: "Count/Index"
	prop Set :: (
                  if ($1 == "User's Header file" && externDecl.HeaderFile == "NULL") {
                  .XFRCNT_FORMAT = "Numeric",
       		.error("You must enter a Header file name  - See CSL Extern Declaration") 
             }  else {
                      .XFRCNT_FORMAT = $1 ,
                      .XFRCNT_FORMAT_ADV = .XFRCNT_FORMAT,
                      if ($1 == "Numeric") {
                      .ELMCNT_HEADER = "NULL", 
                      .FRAMECNT_HEADER = "NULL" 
                      } else { 
                       .FRAMECNT_NUM = 0x0000,   
                       .ELMCNT_NUM = 0x0000,   
                       .XFRCNT_NUM_VALUE = 0x00000000
                       },    
                  "ok"
                 }
		
	)
    }  
    inst FRAMECNT_NUM :: 0x0000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04X"
	prop Style :: 0x02
	prop Label :: "   Frame Count(FC) - Enter 16-bit value"
	prop JSName :: "dmaXfrcntFrameCountNumeric"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT  && .XFRCNT_FORMAT == "Numeric"
	prop NoGen :: 1
      prop cGen :: 0
      prop TabName :: "Count/Index"
	prop Set :: (
	    if ( ($1 > 65535) || ($1 < 0)) {
		.error("Invalid Number [0..65535]")
	    }
	    else {
		.FRAMECNT_NUM = $1,
            .FRAMECNT_HEADER = "NULL", 
            .XFRCNT_NUM_VALUE &= 0x0000FFFF,
            .XFRCNT_NUM_VALUE |= (.FRAMECNT_NUM << 16),
		"ok"
	    }
	)
    }
     inst FRAMECNT_HEADER ::= "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "   Frame Count(FC) - Enter Num or Symbol value  "
	prop JSName :: "dmaXfrcntFrameCountSymbol"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT && .XFRCNT_FORMAT != "Numeric" 
	prop NoGen :: 1
      prop TabName :: "Count/Index"
      prop Set :: ( 
                    .FRAMECNT_HEADER = $1,
                    .FRAMECNT_NUM = 0x0000, 
                    .XFRCNT_NUM_VALUE = (.XFRCNT_NUM_VALUE & 0x0000FFFF),
                     "ok"
                   ) 
       } 
 
    inst ELMCNT_NUM :: 0x0000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04X"
	prop Style :: 0x02
	prop Label :: "   Elt Counter (EC) - Enter 16-bit value"
	prop JSName :: "dmaXfrcntElementCountNumeric"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT  && .XFRCNT_FORMAT == "Numeric"
	prop NoGen :: 1
      prop cGen :: 0
      prop TabName :: "Count/Index"
	prop Set :: (
	    if ( ($1 > 65535) || ($1 < 0)) {
		.error("Invalid Number [0..65535]")
	    }
	    else {
        	.ELMCNT_NUM = $1,
            .ELMCNT_HEADER = "NULL", 
            .XFRCNT_NUM_VALUE &= 0xFFFF0000,
            .XFRCNT_NUM_VALUE |= .ELMCNT_NUM,
		"ok"
	    }
	)
    }
    inst ELMCNT_HEADER :: "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "    Elt Count(EC) - Enter  Num or Sym value "
	prop JSName :: "dmaXfrcntElementCountSymbol"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT && .XFRCNT_FORMAT != "Numeric" 
	prop NoGen :: 1
        prop TabName :: "Count/Index"
        prop Set :: ( 
                    .ELMCNT_HEADER = $1, 
                    .ELMCNT_NUM = 0x0000,         
                    .XFRCNT_NUM_VALUE = ((.XFRCNT_NUM_VALUE & 0xFFFF0000) ),
                    "ok"
                   ) 
       } 
    prop PRICTL_VALUE_update :: (  .START_PRICTL() 
                                 | .SRCDIR_PRICTL() 
                                 | .DSTDIR_PRICTL() 
                                 | .ESIZE_PRICTL()
                                 | .SPLIT_PRICTL()
                                 | .CNTRLD_PRICTL()
                                 | .INDEX_PRICTL()
                                 | .RSYNC_PRICTL()
                                 | .WSYNC_PRICTL()
                                 | .PRI_PRICTL()
                                 | .TCINT_PRICTL()
                                 | .FS_PRICTL()
                                 | .EMOD_PRICTL()
                                 | .SRCRLD_PRICTL()
                                 | .DSTRLD_PRICTL()
                                )
    prop PRICTL_SETUP_update :: (
       .START_SETUP =  ($a = ($1 & 0x00000003),
	                 ($a == 0x00000001) ? "Start w/o Autoinit" :
	                 ($a == 0x00000002) ? "Pause" :
	                 ($a == 0x00000003) ? "Start w/ Autoinit" : "Stop"),
       .SRCDIR_SETUP = ($a = ($1 & 0x00000030),
	                 ($a == 0x00000010) ? "Increment" :
	                 ($a == 0x00000020) ? "Decrement" :
	                 ($a == 0x00000030) ? "Index" : "None"),
       .DSTDIR_SETUP = ($a = ($1 & 0x000000C0),
	                 ($a == 0x00000040) ? "Increment" :
	                 ($a == 0x00000080) ? "Decrement" :
	                 ($a == 0x000000C0) ? "Index" : "None"),
       .ESIZE_SETUP =  ($a = ($1 & 0x00000300),
	                 ($a == 0x00000100) ? "16-bit" :
	                 ($a == 0x00000200) ? "8-bit" : "32-bit"),
       .SPLIT_SETUP =  ($a = ($1 & 0x00000C00),
                       ($a == 0x00000400) ? "Global Address Register A" :
	                 ($a == 0x00000800) ? "Global Address Register B" :
	                 ($a == 0x00000C00) ? "Global Address Register C" : "Disable"),
	.CNTRLD_SETUP =  ($1 & 0x00001000) ? "Count Reload Reg B" : "Count Reload Reg A",
	.INDEX_SETUP =   ($1 & 0x00002000) ? "Global Index Register B" : "Global Index Register A",
      .RSYNC_SETUP =   ($a = ($1 & 0x0007C000),
	                 ($a == 0x00004000) ? "Timer 0 Interrupt" :
	                 ($a == 0x00008000) ? "Timer 1 Interrupt" :
	                 ($a == 0x0000C000) ? "EMIF Timer Interrupt" :
	                 ($a == 0x00010000) ? "External Interrupt Pin 4" :
	                 ($a == 0x00014000) ? "External Interrupt Pin 5" :
	                 ($a == 0x00018000) ? "External Interrupt Pin 6" :
	                 ($a == 0x0001C000) ? "External Interrupt Pin 7" :
	                 ($a == 0x00020000) ? "DMA Channel 0 Interrupt" :
	                 ($a == 0x00024000) ? "DMA Channel 1 Interrupt" :
	                 ($a == 0x00028000) ? "DMA Channel 2 Interrupt" :
	                 ($a == 0x0002C000) ? "DMA Channel 3 Interrupt" :
	                 ($a == 0x00030000) ? "McBSP 0 Transmit Event" :
	                 ($a == 0x00034000) ? "McBSP 0 Receive Event" :
	                 ($a == 0x00038000) ? "McBSP 1 Transmit Event" :
	                 ($a == 0x0003C000) ? "McBSP 1 Receive Event" :
	                 ($a == 0x00040000) ? "Host to DSP Interrupt" :
	                 ($a == 0x00044000) ? "McBSP 2 Transmit Event" :
	                 ($a == 0x00048000) ? "McBSP 2 Receive Event" : "None"),
      .WSYNC_SETUP =   ($a = ($1 & 0x00F80000),
	                 ($a == 0x00080000) ? "Timer 0 Interrupt" :
	                 ($a == 0x00100000) ? "Timer 1 Interrupt" :
	                 ($a == 0x00180000) ? "EMIF Timer Interrupt" :
	                 ($a == 0x00200000) ? "External Interrupt Pin 4" :
	                 ($a == 0x00280000) ? "External Interrupt Pin 5" :
	                 ($a == 0x00300000) ? "External Interrupt Pin 6" :
	                 ($a == 0x00380000) ? "External Interrupt Pin 7" :
	                 ($a == 0x00400000) ? "DMA Channel 0 Interrupt" :
	                 ($a == 0x00480000) ? "DMA Channel 1 Interrupt" :
	                 ($a == 0x00500000) ? "DMA Channel 2 Interrupt" :
	                 ($a == 0x00580000) ? "DMA Channel 3 Interrupt" :
	                 ($a == 0x00600000) ? "McBSP 0 Transmit Event" :
	                 ($a == 0x00680000) ? "McBSP 0 Receive Event" :
	                 ($a == 0x00700000) ? "McBSP 1 Transmit Event" :
	                 ($a == 0x00780000) ? "McBSP 1 Receive Event" :
	                 ($a == 0x00800000) ? "Host to DSP Interrupt" :
	                 ($a == 0x00880000) ? "McBSP 2 Transmit Event" :
	                 ($a == 0x00900000) ? "McBSP 2 Receive Event" : "None"),
	.PRI_SETUP =     ($1 & 0x01000000) ? "DMA" : "CPU",
	.TCINT_SETUP =   ($1 & 0x02000000) ? "Enable" : "Disable",
	.FS_SETUP =      ($1 & 0x04000000)? "RSYNC" : "Disable",
	.EMOD_SETUP =    ($1 & 0x08000000) ? "Pause" : "Continue",
      .SRCRLD_SETUP =  ($a = ($1 & 0x30000000),
	                 ($a == 0x10000000) ? "Global Address Register B" :
	                 ($a == 0x20000000) ? "Global Address Register C" :
	                 ($a == 0x30000000) ? "Global Address Register D" : "No Reload"),
      .DSTRLD_SETUP =  ($a = ($1 & 0xC0000000),
	                 ($a == 0x40000000) ? "Global Address Register B" :
	                 ($a == 0x80000000) ? "Global Address Register C" :
                       ($a == 0xC0000000) ? "Global Address Register D" : "No Reload")
    )
    inst PRICTL_VALUE :: .PRICTL_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Primary Control Register"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop JSName :: "dmaPrictl"
      prop Visible :: 1
      prop Writable :: CSL.DMA_SUPPORT
      prop NoGen :: 1
      prop cGen :: 1
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
        $a = $1 & 0x04000000,
        $b = $1 & 0x00F80000,
        $c = $1 & 0x0007C000,
        $d = $1 & 0x00000C00,
        if (($a != 0) && ($b != 0)) {
               .error("Conflict Setting between FS(bit26) and WSYNC(bit[19..24])")
        } else {
	     if (($c == 0) && ($d != 0)) {
               .error("Conflict Setting between SPLIT(bit[10..11]) and RSYNC(bit[14..18])")
	     } else {
	     if (($b == 0) && ($d != 0)) {
               .error("Conflict Setting between SPLIT(bit[10..11]) and WSYNC(bit[19..24])")
	        } else {
                 if(($1 & 0x00000300) == 0x00000300){
                    .error("No such option for bit field ESIZE(bit[8..9])")
                 } else {
                    if(($1 & 0x0000000C) != 0){
                       .error("Bit field STATUS(bit[2..3]) is reserved")
                    } else {
                       if(($1 & 0x00F80000) > 0x00900000){
                          .error("No such option for bit field WSYNC(bit[19..24])")
                       } else {
                          if(($1 & 0x0007C000) > 0x00048000){
                             .error("No such option for bit field RSYNC(bit[14..18])")
                          } else {
                             .PRICTL_VALUE = $1,
		                 .PRICTL_SETUP_update($1),
		                 "ok"
                          }
                       }
                    }
                 }
		  }
	     }
        }
	)
    }
    prop SECCTL_VALUE_update :: (
	  .SXCOND_SECCTL()
	| .FRAMECOND_SECCTL()
	| .LASTCOND_SECCTL()
	| .BLOCKCOND_SECCTL()
	| .RDROPCOND_SECCTL()
	| .WDROPCOND_SECCTL()
	| .SXIE_SECCTL()
	| .FRAMEIE_SECCTL()
	| .LASTIE_SECCTL()
	| .BLOCKIE_SECCTL()
	| .RDROPIE_SECCTL()
	| .WDROPIE_SECCTL()
	| .RSYNCSTAT_SECCTL()
	| .WSYNCSTAT_SECCTL()
	| .DMACEN_SECCTL()
	| .RSYNCCLR_SECCTL()
	| .WSYNCCLR_SECCTL()
	| (GBL.SUBTYPE == 6700 ? .FSIG_SECCTL() : 0)
	| (GBL.SUBTYPE == 6700 ? .RSPOL_SECCTL() : 0)
	| (GBL.SUBTYPE == 6700 ? .WSPOL_SECCTL() : 0) 
    )
    prop SECCTL_SETUP_update :: (
	.SXCOND_SETUP = ($1 & 0x00000001) ? "No Effect" : "Clear",
	.FRAMECOND_SETUP = ($1 & 0x00000004) ? "No Effect" : "Clear",
	.LASTCOND_SETUP  = ($1 & 0x00000010) ? "No Effect" : "Clear",
	.BLOCKCOND_SETUP = ($1 & 0x00000040) ? "No Effect" : "Clear",
	.RDROPCOND_SETUP = ($1 & 0x00000100) ? "No Effect" : "Clear",
	.WDROPCOND_SETUP = ($1 & 0x00000400) ? "No Effect" : "Clear",
	.SXIE_SETUP = ($1 & 0x00000002) ? "Enable" : "Disable",
	.FRAMEIE_SETUP = ($1 & 0x00000008) ? "Enable" : "Disable",
	.LASTIE_SETUP = ($1 & 0x00000020) ? "Enable" : "Disable",
	.BLOCKIE_SETUP = ($1 & 0x00000080) ? "Enable" : "Disable",
	.RDROPIE_SETUP = ($1 & 0x00000200) ? "Enable" : "Disable",
	.WDROPIE_SETUP = ($1 & 0x00000800) ? "Enable" : "Disable",
	.RSYNCSTAT_SETUP = ($1 & 0x00001000) ? "Received" : "Not Received",
	.WSYNCSTAT_SETUP = ($1 & 0x00004000) ? "Received" : "Not Received",
	.RSYNCCLR_SETUP = ($1 & 0x00002000) ? "Clear" : "None",
	.WSYNCCLR_SETUP = ($1 & 0x00008000) ? "Clear" : "None",
	.DMACEN_SETUP = ($a = ($1 & 0x00070000),
	                 ($a == 0x00010000) ? "High" :
	                 ($a == 0x00020000) ? "RSYNC STAT" :
	                 ($a == 0x00030000) ? "WSYNC STAT" :
	                 ($a == 0x00040000) ? "FRAME COND" :
	                 ($a == 0x00050000) ? "BLOCK COND" : "Low"),
	if (GBL.SUBTYPE == 6700) {
		.FSIG_SETUP = ($1 & 0x00080000) ? "Ignore" : "None",
		if ((.RSYNC_SETUP == "External Interrupt Pin 4") ||
		    (.RSYNC_SETUP == "External Interrupt Pin 5") ||
		    (.RSYNC_SETUP == "External Interrupt Pin 6") ||
		    (.RSYNC_SETUP == "External Interrupt Pin 7")) {
			.RSPOL_SETUP = ($1 & 0x00100000) ?
				"Active High" : "Active Low"
		},
		if ((.WSYNC_SETUP == "External Interrupt Pin 4") ||
		    (.WSYNC_SETUP == "External Interrupt Pin 5") ||
		    (.WSYNC_SETUP == "External Interrupt Pin 6") ||
		    (.WSYNC_SETUP == "External Interrupt Pin 7")) {
			.WSPOL_SETUP = ($1 & 0x00200000) ?
				"Active High" : "Active Low"
		}
	}
    )
    inst SECCTL_VALUE :: .SECCTL_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Secondary Control Register"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop JSName :: "dmaSecctl"
      prop Visible :: 1
      prop Writable :: CSL.DMA_SUPPORT
      prop NoGen :: 1
      prop cGen :: 1
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
        $a = $1 & 0xFFF80000,
        $b = $1 & 0xFFC00000,
        $c = $1 & 0x00070000,
        if (($a != 0) && (GBL.DSPSUBTYPE != 6700)) {
               .error("Bit field(bit[19..31]) is reserved")
        } else {
	     if (($b != 0) && (GBL_CHIPTYPE == "6211")) {
               .error("Bit field(bit[22..31]) is reserved")
	     } else {
	     if ($c > 0x00050000) {
               .error("No such option for bit field DMAC EN(bit[16..18])")
	        } else {
                 if((($1 & 0x00100000) == 0x00100000) && ((.RSYNC_PRICTL < 0x00200000)||(.RSYNC_PRICTL > 0x00380000))){
                    .error("Bit field RSPOL(bit20) only valid if EXT_INTx is selected")
                 } else {
                    if((($1 & 0x00200000) == 0x00200000) && ((.WSYNC_PRICTL < 0x00010000)||(.WSYNC_PRICTL > 0x0001C000))){
                       .error("Bit field WSPOL(bit21) only valid if EXT_INTx is selected")
                    } else {
                       .SECCTL_VALUE = $1,
                       .SECCTL_SETUP_update($1),
                       "ok"
                    }
                 }
		  }
	     }
        }
	)
    }
     
    inst SRCADDR_VALUE ::= 0x00000000{
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Source Address (Old - should not be visible)"
	prop Format :: "0x%08X"
	prop Style :: 0x02
      prop Visible :: 0
      prop Writable :: (CSL.EDMA_SUPPORT != 0) ? 1 : 0
      prop NoGen :: 1
      prop cGen :: 0
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
                     .SRCADDR_VALUE = $1,
		     .SRCADDR_FORMAT = "Numeric",
		     .SRCADDR_FORMAT_ADV = .SRCADDR_FORMAT,
                     .SRCADDR_NUM = .SRCADDR_VALUE,
		     .SRCADDR_NUM_VALUE = .SRCADDR_NUM,
		     .SRCADDR_SYM = "NULL",
		     .SRCADDR_SYM_VALUE = .SRCADDR_SYM,
                     "ok"
                   )
    } 
       inst SRCADDR_FORMAT_ADV :: "Numeric" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Extern Decl. Obj.,User's Header file,McBSP handle (DRR)"
        prop Label:: "Source Address Format"
	prop JSName :: "dmaSrcAddrFormatAdv"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Advanced"
	prop Set :: (
		$a = 0,
		scan ($b; externDecl) {
			$a += 1
		},
		if ($a == 1 && $1 == "Extern Decl. Obj." ) {
                  .SRCADDR_FORMAT_ADV = "Numeric",
        		.error("You must create a Symbolic object - See CSL extern Declaration")
		} else {
               if ($1 == "User's Header file" && externDecl.HeaderFile == "NULL") {
                  .SRCADDR_FORMAT_ADV = "Numeric",
        		.error("You must enter a Header file name  - See CSL extern Declartion")
		} else {
                  .SRCADDR_FORMAT_ADV = $1 ,
                  .SRCADDR_FORMAT = $1,
                  if ($1 == "Numeric") {
                      .SRCADDR_SYM_VALUE = "NULL" 
                  } else {
                   .SRCADDR_NUM_VALUE = 0x00000000   
                  },
                  "ok"
               }
		}
	)
    } 
      
    inst SRCADDR_NUM_VALUE ::= 0x00000000{
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Source Address - Numeric"
      prop Format :: "0x%08X"
      prop Style :: 0x02
      prop JSName :: "dmaSrcAddrNumericAdv"
      prop Visible :: 1
      prop Writable :: CSL.DMA_SUPPORT && .SRCADDR_FORMAT_ADV == "Numeric" 
      prop NoGen :: 1
      prop cGen :: CSL.DMA_SUPPORT  && 
                     (.SRCADDR_FORMAT_ADV == "Numeric"  
                      || .SRCADDR_FORMAT_ADV == "McBSP handle (DRR)" 
                      || (.SRCADDR_FORMAT_ADV == "User's Header file" && .SRCADDR_HEADER_VALUE == "NULL")
                      || (.SRCADDR_FORMAT_ADV == "Extern Decl. Obj." && .SRCADDR_SYM_VALUE == "NULL")
                         )
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
                     .SRCADDR_NUM_VALUE = $1,
                     .SRCADDR_NUM = $1,
                     "ok"
                   )
    } 
    inst SRCADDR_SYM_VALUE ::= "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "Source Address - Extern Decl.Obj"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
      prop cGen :: CSL.DMA_SUPPORT && .SRCADDR_FORMAT_ADV == "Extern Decl. Obj." && .SRCADDR_SYM_VALUE != "NULL"
        prop TabName :: "Advanced"
        prop cType :: "char[]" 
        prop cPreVal :: ( 
                   $a="",
		   scan ($b; externDecl) {
                       if (.SRCADDR_SYM_VALUE == $b.BuffName) {
                            if ($b.BuffSpec == "Array" )  {
                             $a = "(Uint32) "
                            } else {
                              $a = "(Uint32) &"
                            }
                        }     
		    }, 
                     $a
                 )    
        prop Set :: ( 
                    $a = 0, 
		   scan($b; externDecl) {
                    if (  $1 != "NULL"  &&  $1 == $b.BuffName ) {
                          if ( $b.BuffType == "NULL" )  {
                                $a = 1
                          } else {
                             if ( $1 == .DSTADDR_SYM_VALUE) {
                              $a = 2
                              } else {
                              $a = 3
                             } 
                          }
                      }
                   },
                    if ($a == 0 ) { 
                          .error("Symbolic Address  Not declared  - See CSL Extern Declaration")
                     } else {
                         if ( $a == 1) { 
                           .error("Symbol Type of this object is incorrect - See CSL Extern Declaration")
                           } else {
                             if ($a == 2 ) {
                              .error("Source and Destination must be different")
                             } else {
                             .SRCADDR_SYM = $1, 
                             .SRCADDR_SYM_VALUE = $1, 
                              "ok"
                             }
                         }
                      }
                        
                   ) 
       }  
     inst SRCADDR_HEADER_VALUE :: "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "Source Address - From User's Header File"
	prop Visible :: 0
	prop Writable :: 0 
	prop NoGen :: 1
      prop cGen :: CSL.DMA_SUPPORT && .SRCADDR_FORMAT_ADV == "User's Header file" && .SRCADDR_HEADER_VALUE != "NULL"
      prop TabName :: "Advanced"
      prop cType :: "char[]" 
      prop cPreVal :: ("(Uint32) ") 
       }
  
   
    inst DSTADDR_VALUE ::= 0x00000000{
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Destination Address (Old - should not be visible)"
	prop Format :: "0x%08X"
	prop Style :: 0x02
      prop Visible :: 0
      prop Writable :: (CSL.EDMA_SUPPORT != 0) ? 1 : 0
      prop NoGen :: 1
      prop cGen :: 0
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
                     .DSTADDR_VALUE = $1,
		     .DSTADDR_FORMAT = "Numeric",
		     .DSTADDR_FORMAT_ADV = .DSTADDR_FORMAT,
                 .DSTADDR_NUM = .DSTADDR_VALUE,
		     .DSTADDR_NUM_VALUE = .DSTADDR_NUM,
		     .DSTADDR_SYM = "NULL",
		     .DSTADDR_SYM_VALUE = .DSTADDR_SYM,
                     "ok"
                   )
    } 
    inst DSTADDR_FORMAT_ADV :: "Numeric" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Extern Decl. Obj.,User's Header file,McBSP handle (DXR)"
        prop Label:: "Destination Address Format"
	prop JSName :: "dmaDstAddrFormatAdv"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Advanced"
	prop Set :: (
		$a = 0,
		scan ($b; externDecl) {
			$a += 1
		},
		if ($a == 1 && $1 == "Extern Decl. Obj." ) {
                  .DSTADDR_FORMAT_ADV = "Numeric",
        		.error("You must create a Symbolic Object - See CSL extern Declaration")
		} else {
               if ($1 == "User's Header file" && externDecl.HeaderFile == "NULL") {
                  .DSTADDR_FORMAT_ADV = "Numeric",
        		.error("You must enter a Header file name  - See CSL extern Declartion")
		} else {
                  .DSTADDR_FORMAT_ADV = $1 ,
                  .DSTADDR_FORMAT = $1,
                  if ($1 == "Numeric") {
                      .DSTADDR_SYM_VALUE = "NULL" 
                  } else {
                   .DSTADDR_NUM_VALUE = 0x00000000   
                  },
                  "ok"
               }
		}
	)
    } 
        
    inst DSTADDR_NUM_VALUE ::= 0x00000000{
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Destination Address - Numeric"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop JSName :: "dmaDstAddrNumericAdv"
      prop Visible :: 1
      prop Writable :: CSL.DMA_SUPPORT && .DSTADDR_FORMAT_ADV == "Numeric" 
      prop NoGen :: 1 
      prop cGen ::  CSL.DMA_SUPPORT && 
                    ( .DSTADDR_FORMAT_ADV == "Numeric" 
                      || .DSTADDR_FORMAT_ADV == "McBSP handle (DXR)" 
                      || (.DSTADDR_FORMAT_ADV == "User's Header file" && .DSTADDR_HEADER_VALUE == "NULL")
                      || (.DSTADDR_FORMAT_ADV == "Extern Decl. Obj." && .DSTADDR_SYM_VALUE == "NULL")
                     )
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
                     .DSTADDR_NUM_VALUE = $1,
                     .DSTADDR_NUM = $1,
                     .DSTADDR_HANDLE = "NULL",
                     .DSTADDR_SYM = "NULL",
		         .DSTADDR_SYM_VALUE = .DSTADDR_SYM,
                     .DSTADDR_HEADER = "NULL",
		         .DSTADDR_HEADER_VALUE = .DSTADDR_HEADER,
                     "ok"
                   )
    } 
      
    inst DSTADDR_SYM_VALUE ::= "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "Destination Address - Extern Decl. Obj"
	prop Visible :: 0
	prop Writable ::  0 
	prop NoGen :: 1
      prop cGen :: CSL.DMA_SUPPORT && (.DSTADDR_FORMAT_ADV == "Extern Decl. Obj." && .DSTADDR_SYM_VALUE != "NULL")
      prop TabName :: "Advanced"
      prop cType :: "char[]" 
      prop cPreVal :: ( 
                  $a="",
		   scan ($b; externDecl) {
                       if (.DSTADDR_SYM_VALUE == $b.BuffName) {
                            if ($b.BuffSpec == "Array")  {
                             $a = "(Uint32) "
                            } else {
                              $a = "(Uint32) &"
                            }
                        }     
		    }, 
                     $a
                      
                      )    
        prop Set :: ( 
                    $a = 0, 
		   scan($b; externDecl) {
                    if (  $1 != "NULL"  &&  $1 == $b.BuffName ) {
                          if ( $b.BuffType == "NULL" )  {
                                $a = 1
                          } else {
                             if ( $1 == .SRCADDR_SYM_VALUE) {
                              $a = 2
                              } else {
                              $a = 3
                             } 
                          }
                      }
                   },
                    if ($a == 0 ) { 
                          .error("Symbolic Address  Not declared  - See CSL Extern Declaration")
                     } else {
                         if ( $a == 1) { 
                           .error("Symbol Type of this object is incorrect - See CSL Extern Declaration")
                           } else {
                             if ($a == 2 ) {
                              .error("Source and Destination must be different")
                             } else {
                             .DSTADDR_SYM = $1, 
                             .DSTADDR_SYM_VALUE = $1, 
                              "ok"
                             }
                         }
                      }
                        
                   ) 
       }  
  
 inst DSTADDR_HEADER_VALUE :: "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "Destination Address - From User's Header file"
	prop Visible :: 0
	prop Writable :: 0 
	prop NoGen :: 1
      prop cGen :: CSL.DMA_SUPPORT && .DSTADDR_FORMAT_ADV == "User's Header file" && .DSTADDR_HEADER_VALUE != "NULL"
      prop TabName :: "Advanced"
      prop cType :: "char[]" 
      prop cPreVal :: ("(Uint32) ") 
       }
  
 
    inst XFRCNT_FORMAT_ADV :: "Numeric" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,User's Header file"
        prop Label:: "Transfer Counter Format"
        prop JSName :: "dmaXfrcntFormatAdv"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Advanced"
	prop Set :: (
                  if ( $1 == "User's Header file" && externDecl.HeaderFile == "NULL")     {
                  .XFRCNT_FORMAT_ADV = "Numeric",
       		.error("You must enter a Header file name  - See CSL Extern Declaration") 
             }  else {
                      if ($1 == "Numeric") {
                         .ELMCNT_HEADER = "NULL", 
                         .FRAMECNT_HEADER = "NULL" 
                      } else {
                         .XFRCNT_NUM_VALUE = 0x00000001,
                         .ELMCNT_NUM = 0x0001,
                         .FRAMECNT_NUM = 0x0000 
                      },    
                      .XFRCNT_FORMAT_ADV = $1 ,
                      .XFRCNT_FORMAT = .XFRCNT_FORMAT_ADV,
                      "ok"
                   }
		
	)
    }
    
    inst XFRCNT_VALUE :: 0x00000000 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Transfer Counter Register"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Visible :: 0
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (
                .XFRCNT_VALUE = $1,
                  .XFRCNT_NUM_VALUE = $1,
                  .FRAMECNT_NUM = $1 >> 16,
                  .ELMCNT_NUM = ($1 & 0x0000FFFF),
                "ok"
        )
    }
 
    inst XFRCNT_NUM_VALUE ::= 0x00000000 {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Transfer Counter - Numeric"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop JSName :: "dmaXfrcnt"
      prop Visible :: 1
      prop Writable :: CSL.DMA_SUPPORT  && .XFRCNT_FORMAT_ADV == "Numeric" 
      prop NoGen :: 1
      prop cGen :: CSL.DMA_SUPPORT  
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: ( 
                     .XFRCNT_NUM_VALUE = $1,
                     .FRAMECNT_NUM = $1 >> 16,
                     .ELMCNT_NUM = ($1 & 0x0000FFFF),
                     "ok"
                   )
    }
 
 
   prop configStruct :: self
   prop cfgStrCNT   :: (.XFRCNT_FORMAT == "User's Header file" ) ? "%5t%3s.xfrcnt = DMA_XFRCNT_RMK(" : ""
   prop FramecntStr :: (
              if (.XFRCNT_FORMAT == "User's Header file" && .FRAMECNT_HEADER == "NULL" ) {
                        "0"
               } else { 
                  if (.XFRCNT_FORMAT == "User's Header file" && .FRAMECNT_HEADER != "NULL" ) {
                     .FRAMECNT_HEADER
                  } else {
                        ""
                  }      
               }
         )
   prop ElmcntStr   :: (
         if (.XFRCNT_FORMAT == "User's Header file" && .ELMCNT_HEADER == "NULL" ) {
                        "0"
               } else { 
                  if (.XFRCNT_FORMAT == "User's Header file" && .ELMCNT_HEADER != "NULL" ) {
                     .ELMCNT_HEADER
                  } else {
                        ""
                  }      
               }
             )
 
   prop XfrCntStr   :: (.XFRCNT_FORMAT == "User's Header file" ) ? "%4s,%5s);\n%0t" : ""  
 
 prop cfgStrSRC   :: (.SRCADDR_FORMAT == "McBSP handle (DRR)" && .SRCADDR_HANDLE != "NULL") ? "%5t%3s.src = DMA_SRC_RMK(" : ""
 prop SrcHandle :: (.SRCADDR_FORMAT == "McBSP handle (DRR)" && .SRCADDR_HANDLE != "NULL") ? .SRCADDR_HANDLE : ""
 prop SrcStr :: (.SRCADDR_FORMAT == "McBSP handle (DRR)" && .SRCADDR_HANDLE != "NULL") ? "%8s->drrAddr);\n%0t" : ""
 prop cfgStrDST   :: (.DSTADDR_FORMAT == "McBSP handle (DXR)" && .DSTADDR_HANDLE != "NULL") ? "%5t%3s.dst = DMA_DST_RMK(" : ""
 prop DstHandle :: (.DSTADDR_FORMAT == "McBSP handle (DXR)" && .DSTADDR_HANDLE != "NULL") ? .DSTADDR_HANDLE : ""
 prop DstStr :: (.DSTADDR_FORMAT == "McBSP handle (DXR)" && .DSTADDR_HANDLE != "NULL") ? "%11s->dxrAddr);\n%0t" : ""
   prop cGenFxnPostInst :: (
         "%1S%2S%6S%7S%9S%10S\0,cfgStrCNT,XfrCntStr,configStruct,FramecntStr,ElmcntStr,cfgStrSRC,SrcStr,SrcHandle,cfgStrDST,DstStr,DstHandle"
    )
}
type hDma {
	isa ObjectMgr
	prop name :: "hDma"
	prop Label :: "DMA Resource Manager"
	prop JSName :: "HDMA"
	prop IsContainedIn :: DMAFOLDER
 	prop GlobalPropertyPage :: "{1E62DD10-59A8-11d4-947D-0050048381B7}"
      prop InstancePropertyPage :: "{1E62DD11-59A8-11d4-947D-0050048381B7}"
      
      prop GlobalIcon :: 157
      prop InstanceIcon :: 158
      
      prop GlobalHelpTopic :: 1022
      prop InstanceHelpTopic :: 1023
	prop maxObjs :: 4
	prop NoGen :: 1
	prop cGen :: CSL.DMA_SUPPORT
	prop cHandle ::  .cOpenGen
	prop cHeaderName :: (
	    $a = "",
	    scan ($b; hDma) {
		if ($b.DMA_HANDLE_ENABLE == 1) {
		    $a = "csl_dma.h"
		}
	    },
	    $a
        )
	prop cHandleType :: "DMA_Handle"
	prop cOpenName :: "DMA_open"
	prop cConfigName :: "DMA_config"
	prop cHandleName :: .HandleName 
	prop cStructQual :: "far"
  
      prop localCanCreate :: (
                .error("New DMA handle objects cannot be created")
      )
      prop localCanDelete :: (
                .error("DMA handle objects cannot be deleted")
      )
 
   inst DEVICE:: "DMACHA0"
        {
	 prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	 prop Enum :: "DMACHA0,DMACHA1,DMACHA2,DMACHA3"
         prop Label :: "DMA channel"
         prop Visible :: 0
         prop Writable :: CSL.DMA_SUPPORT
         prop NoGen :: 1
	 }
	inst cOpenGen ::= ((.DMA_HANDLE_ENABLE != 0)&&(CSL.DMA_SUPPORT != 0) && (.HandleName != ""))   {
	    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Label :: "Open Handle"
	    prop Visible :: 0
	    prop Writable :: CSL.DMA_SUPPORT
	    prop NoGen :: 1
	    prop cGen :: 1
	}
	inst cOpenArg0 :: "DMA_CHAANY" {
	     prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	     prop Label :: "Open Arg 0"
	     prop Visible :: 0
	     prop Writable :: CSL.DMA_SUPPORT
	     prop NoGen :: 1
	}
	inst cOpenArg1 :: "DMA_OPEN_RESET" {
	     prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	     prop Label :: "Open Arg 1"
	     prop Visible :: 0
	     prop Writable :: CSL.DMA_SUPPORT
	     prop NoGen :: 1
	}
  inst DMA_HANDLE_ENABLE ::= 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Open DMA Channel"
	  prop JSName :: "dmaHandleEnable"
	  prop Visible :: 1
	  prop Writable :: CSL.DMA_SUPPORT
	  prop NoGen :: 1
	  prop Set ::  (
                          .DMA_HANDLE_ENABLE = $1,
                       if( $1 == 0 ){
                          .DMA_HANDLE_ENABLE = $1,
                          .PINIT_ENABLE = $1,
                          .cOpenArg0 = "DMA_None",
                          .PINIT = DMA_NOTHING,
                          "ok"
                       } else {
                       if (.DEVICE == "DMACHA0") {
                           .cOpenArg0 = "DMA_CHA0",
                           "ok"
                       } else { 
                         if (.DEVICE == "DMACHA1") {
                             .cOpenArg0 = "DMA_CHA1",
                             "ok"
                         } else { 
                            if (.DEVICE == "DMACHA2") {
                                .cOpenArg0 = "DMA_CHA2",
                                "ok"
                            } else { 
                               if (.DEVICE == "DMACHA3") {
                                   .cOpenArg0 = "DMA_CHA3",
                                   "ok"
                               }
                            }
                         }
                       }
                       }
			)		
    	}
     inst HandleName ::= self {
       prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
       prop Label :: "Handle"
       prop JSName :: "dmaHandleName"
       prop Visible :: 1
       prop Writable :: CSL.DMA_SUPPORT & .DMA_HANDLE_ENABLE
    }
    inst PINIT_ENABLE ::= 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable Pre-Initialization"
	prop JSName :: "dmaEnablePreInit"
	prop Visible :: 1
	prop Writable :: ((CSL.DMA_SUPPORT != 0) && (.DMA_HANDLE_ENABLE != 0) )? 1 : 0
	prop NoGen :: 1
	prop Set :: (
		$a = 0,
		scan ($b; dmaCfg) {
			$a += 1
		},
		if ($a == 1) {
                  .PINIT_ENABLE = 0,
			.error("You must create a DMA configuration object first")
		} else {
			.PINIT_ENABLE = $1,
                  if ($1 == 0) {
                      .PINIT = DMA_NOTHING
                  },
                  "ok"
		}
	)
    }
     inst PINIT :: DMA_NOTHING {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: dmaCfg
	prop Label :: "Pre-Initialize with"
	prop JSName :: "dmaPreInit"
	prop Visible :: 1
	prop Writable :: (CSL.DMA_SUPPORT != 0) & (.PINIT_ENABLE == 1) & (.DMA_HANDLE_ENABLE != 0) 
	prop NoGen :: 1
    }
     inst cConfigGen ::= (   (CSL.DMA_SUPPORT != 0) 
                          && (.DMA_HANDLE_ENABLE == 1)
                          && (.HandleName != "")    
                          && (.PINIT_ENABLE == 1) 
                          && (.PINIT != DMA_NOTHING)
                          && (.HandleName != "")) {
	    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Label :: "Enable Pre-Configuration"
	    prop Visible :: 0
	    prop Writable :: (CSL.DMA_SUPPORT != 0) & (.cConfigGen == 1) ? 1 : 0
	    prop NoGen :: 1
	    prop cGen :: 1
	}
	inst cConfigArg0 ::= .cHandleName {
	    prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Label :: "Config argument 0"
	    prop Visible :: 0
	    prop Writable :: (CSL.DMA_SUPPORT != 0) & (.cConfigGen == 1) ? 1 : 0
          prop Set :: (
            .cConfigArg0 = .HandleName,
            "ok"
          )
	}
	inst cConfigArg1 ::= .PINIT {
          prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
          prop Label :: "Config argument 1"
	    prop Visible :: 0
	    prop Writable :: (CSL.DMA_SUPPORT != 0) & (.cConfigGen == 1) ? 1 : 0
          prop cPreVal :: "&"
	}
}
object DMA_Channel0 :: hDma {
	 param iComment :: "DMA channel 0"  
         param iIsUsed :: 1
         param iDelUser :: "hDma"
         param iDelMsg :: (
	"This DMA Handle object cannot be deleted"
	)
         param HandleName :: "hDma0"  
         param DEVICE :: "DMACHA0"
         param PINIT :: DMA_NOTHING
       }
object DMA_Channel1 :: hDma {
	 param iComment :: "DMA channel 1"  
         param iIsUsed :: 1
         param iDelUser :: "hDma"
         param iDelMsg :: (
	"This DMA Handle object cannot be deleted"
	)
         param HandleName :: "hDma1"  
         param DEVICE :: "DMACHA1"
         param PINIT :: DMA_NOTHING
       }
object DMA_Channel2 :: hDma {
	 param iComment :: "DMA channel 2"  
         param iIsUsed :: 1
         param iDelUser :: "hDma"
         param iDelMsg :: (
	"This DMA Handle object cannot be deleted"
	)
         param HandleName :: "hDma2"  
         param DEVICE :: "DMACHA2"
         param PINIT :: DMA_NOTHING
       }
object DMA_Channel3 :: hDma {
	 param iComment :: "DMA channel 3"  
         param iIsUsed :: 1
         param iDelUser :: "hDma"
         param iDelMsg :: (
	"This DMA Handle object cannot be deleted"
	)
         param HandleName :: "hDma3"  
         param DEVICE :: "DMACHA3"
         param PINIT :: DMA_NOTHING
       }
object DMA_NOTHING :: dmaCfg {
       param iIsUsed :: 0
}
type dmaGblCfg {
      isa ObjectMgr
      prop name :: "dmaGblCfg"
      prop Label :: "DMA Global Register Manager"
      prop JSName :: "GDMA"
	prop IsContainedIn :: DMAFOLDER
      prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-00105A98CA0B}"
      prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-0000C070F3E9}"
      prop Vendor :: "vendor1"
      prop Version :: "1.00.00"
      
      prop GlobalIcon :: 157
      prop InstanceIcon :: 158
      prop GlobalHelpTopic :: 1024
      prop InstanceHelpTopic :: 1025
	prop NoGen :: 1
      prop cGen :: CSL.DMA_SUPPORT 
	prop cHandleType :: "Uint32"
	prop cOpenName :: "DMA_globalAlloc"
	prop cConfigName :: "DMA_globalConfig"
	prop cHandleName :: .HandleName
    	prop cStruct :: CSL.DMA_SUPPORT
    	prop cStructType :: "DMA_GlobalConfig"
	prop cHeaderName :: .gNumOf > 0 ? "csl_dma.h" : ""
	prop cStructQual :: "far"
      prop localDelete :: (
        .myDelete
      )           
      prop myDelete :: (
        $a=0,
        scan($b; dmaGblCfg) { 
             $a = $a + 1
        }, 		
        if($a == 2) {
            .PINIT_ENABLE = 0
        },
        "ok"
      )           
    prop gblRegMask :: .GBLREG_MASK
    prop pinitName :: .PINIT
    prop cGenFxnPrologue :: (
	if (.GBLREG_MASK != 0 && .PINIT_ENABLE == 1) {
	    "%5t%1s = %2s(0x%3x);\n%4s(%5s, &%6s);%0t\n\0, cHandleName, cOpenName, gblRegMask, cConfigName, cHandleName, pinitName"
	}
	else {
	    if (.GBLREG_MASK != 0) {
		"%5t%1s = %2s(0x%3x);%0t\n\0, cHandleName, cOpenName, gblRegMask"
	    }
	    else {
		if (.PINIT_ENABLE == 1) {
	    	    "%5t%1s(%2s, &%3s);%0t\n\0, cConfigName, cHandleName, pinitName"
		}
		else {
	    	    ""
		}
	    }
	}
    )
    prop cGenCEpilogue :: (
	if (.GBLREG_MASK != 0) {
	    "%1s %2s;\n\0, cHandleType, cHandleName"
	}
	else {
	    ""
	}
    )
    prop cGenHEpilogue :: (
	if (.GBLREG_MASK != 0) {
	    "extern far %1s %2s;\n\0, cHandleType, cHandleName"
	}
	else {
	    ""
	}
    )
    global GBLADDRA_ALLOC :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Pre-allocation Global Address Reload Register A"
	prop JSName :: "DMA_PRE_ALLOC_GBLADDRA"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
	prop Set :: (
            .GBLADDRA_ALLOC = $1,
            .GBLREG_MASK = (.GBLREG_MASK & 0xFFFFFFFE) | .GBLADDRA_ALLOC,
            "ok"
           )
    }
    global GBLADDRB_ALLOC :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Pre-allocation Global Address Reload Register B"
	prop JSName :: "DMA_PRE_ALLOC_GBLADDRB"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
	prop Set :: (
            .GBLADDRB_ALLOC = $1,
            .GBLREG_MASK = (.GBLREG_MASK & 0xFFFFFFFD) | (.GBLADDRB_ALLOC << 1),
            "ok"
           )
    }
    global GBLADDRC_ALLOC :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Pre-allocation Global Address Reload Register C"
	prop JSName :: "DMA_PRE_ALLOC_GBLADDRC"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
	prop Set :: (
            .GBLADDRC_ALLOC = $1,
            .GBLREG_MASK = (.GBLREG_MASK & 0xFFFFFFFB) | (.GBLADDRC_ALLOC << 2),
            "ok"
           )
    }
    global GBLADDRD_ALLOC :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Pre-allocation Global Address Reload Register D"
	prop JSName :: "DMA_PRE_ALLOC_GBLADDRD"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
	prop Set :: (
            .GBLADDRD_ALLOC = $1,
            .GBLREG_MASK = (.GBLREG_MASK & 0xFFFFFFF7) | (.GBLADDRD_ALLOC << 3),
            "ok"
           )
    }
    global GBLIDXA_ALLOC :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Pre-allocation Global Index Register A"
	prop JSName :: "DMA_PRE_ALLOC_GBLIDXA"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
	prop Set :: (
            .GBLIDXA_ALLOC = $1,
            .GBLREG_MASK = (.GBLREG_MASK & 0xFFFFFFEF) | (.GBLIDXA_ALLOC << 4),
            "ok"
           )
    }
    global GBLIDXB_ALLOC :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Pre-allocation Global Index Register B"
	prop JSName :: "DMA_PRE_ALLOC_GBLIDXB"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
	prop Set :: (
            .GBLIDXB_ALLOC = $1,
            .GBLREG_MASK = (.GBLREG_MASK & 0xFFFFFFDF) | (.GBLIDXB_ALLOC << 5),
            "ok"
           )
    }
    global GBLCNTA_ALLOC :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Pre-allocation Global Count Reload Register A"
	prop JSName :: "DMA_PRE_ALLOC_GBLCNTA"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
	prop Set :: (
            .GBLCNTA_ALLOC = $1,
            .GBLREG_MASK = (.GBLREG_MASK & 0xFFFFFFBF) | (.GBLCNTA_ALLOC << 6),
            "ok"
           )
    }
    global GBLCNTB_ALLOC :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Pre-allocation Global Count Reload Register B"
	prop JSName :: "DMA_PRE_ALLOC_GBLCNTB"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
	prop Set :: (
            .GBLCNTB_ALLOC = $1,
            .GBLREG_MASK = (.GBLREG_MASK & 0xFFFFFF7F) | (.GBLCNTB_ALLOC << 7),
            "ok"
           )
    }
    global GBLREG_MASK ::= 0x00000000 {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Global Register Mask"
	prop Format :: "0x%08X"
	prop Style :: 0x02
      prop Visible :: 0
      prop Writable :: CSL.DMA_SUPPORT
      prop NoGen :: 1
      prop cGen :: 1
    }
    global HandleName :: "dmaGblRegId" {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DMA Global Register ID"
	prop JSName :: "DMA_HANDLE_NAME"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && .GBLREG_MASK
        prop Set :: (
             .HandleName = $1,
             "ok"
        )
    }
    global PINIT_ENABLE ::= 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable Pre-Initialization"
	prop JSName :: "DMA_ENABLE_PRE_INIT"
	prop Visible :: 1
	prop Writable :: ((.GBLREG_MASK != 0) && (CSL.DMA_SUPPORT != 0))
	prop NoGen :: 1
	prop Set :: (
		$a = 0,
		scan ($b; dmaGblCfg) {
			$a += 1
		},
		if ($a == 1) {
                  .PINIT_ENABLE = 0,
			.error("You must create a global register configuration object first")
		} else {
			.PINIT_ENABLE = $1,
                  if ($1 == 0) {
                      .PINIT = DMAGBL_NOTHING
                  },
                  "ok"
		}
	)
    }
    global PINIT ::= DMAGBL_NOTHING {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: dmaGblCfg
	prop Label :: "Pre-Initialize with"
	prop JSName :: "DMA_PRE_INIT"
	prop Visible :: 1
	prop Writable :: (.PINIT_ENABLE == 1) && (.GBLREG_MASK != 0) && (CSL.DMA_SUPPORT != 0)
	prop NoGen :: 1
    }
    inst GBLADDRA :: 0x00000000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop Label :: "Global Address Reload Register A (Old - should not be visible)"
	prop Visible :: 0
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
      prop cGen :: 0
      prop TabName :: "Global Address"
	prop Set :: (
	    if ( 0 ) {
		.error("Invalid Number")
	    }
	    else {
		.GBLADDRA = $1,
		.GBLADDRA_FORMAT = "Numeric",
		.GBLADDRA_FORMAT_ADV = .GBLADDRA_FORMAT,
                .GBLADDRA_NUM = .GBLADDRA,
		.GBLADDRA_NUM_VALUE = .GBLADDRA_NUM,
		.GBLADDRA_SYM = "NULL",
		.GBLADDRA_SYM_VALUE = .GBLADDRA_SYM,
            "ok"
	    }
	)
    }
    inst GBLADDRA_FORMAT ::="Numeric" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Symbolic"
        prop Label:: "Global Address Reload Register A Format"
	prop JSName :: "dmaGbladdrAFormat"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Address"
        prop Set :: (
		$a = 0,
		scan ($b; externDecl) {
			$a += 1
		},
		if ($a == 1 && $1 == "Symbolic" ) {
                  .GBLADDRA_FORMAT = "Numeric",
        		.error("You must create a Symbol Address - See CSL extern Declaration")
		} else {
                  .GBLADDRA_FORMAT = $1 ,
                  .GBLADDRA_FORMAT_ADV = $1,
                  if ($1 == "Numeric") {
                      .GBLADDRA_SYM = "NULL" 
                  },
                  "ok"
		}
	     )
        }
    inst GBLADDRA_NUM :: 0x00000000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop Label :: "    Reload Register A - Numeric "
	prop JSName :: "dmaGbladdrANumeric"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT && .GBLADDRA_FORMAT == "Numeric"
	prop NoGen :: 1
      prop cGen :: 0
      prop TabName :: "Global Address"
	prop Set :: (
	    if ( 0 ) {
		.error("Invalid Number")
	    }
	    else {
		.GBLADDRA_NUM = $1,
		.GBLADDRA_NUM_VALUE = .GBLADDRA_NUM,
            "ok"
	    }
	)
    }
  
  inst GBLADDRA_SYM :: "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "    Reload Register A - Symbolic "
	prop JSName :: "dmaGbladdrASymbolic"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT && .GBLADDRA_FORMAT == "Symbolic" 
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Address"
        prop Set :: (
                    $a = 0, 
		   scan($b; externDecl) {
                    if (  $1 != "NULL"  &&  $1 == $b.BuffName )  {
                           if ( $b.BuffType == "NULL") {
                              $a = 1
                            } else {
                               $a = 2
                            }  
                        } 
                   },
                    if ($a == 0 ) { 
                          .error("Symbolic Address Not declared - See CSL Extern Declaration")
                     } else {
                       if ($a == 1 ) { 
                          .error("Symbol Type of this object is incorrect - See CSL Extern Declaration")
                        } else {
                   
                            .GBLADDRA_SYM =  $1, 
                             .GBLADDRA_SYM_VALUE = .GBLADDRA_SYM, 
                            "ok"
                      }
                    } 
            )
       } 
                    
    
    inst GBLADDRB :: 0x00000000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop Label :: "Global Address Reload Register B (Old - should not be visible)"
	prop Visible :: 0
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
      prop cGen :: 0
      prop TabName :: "Global Address"
	prop Set :: (
	    if ( 0 ) {
		.error("Invalid Number")
	    }
	    else {
		.GBLADDRB = $1,
		.GBLADDRB_FORMAT = "Numeric",
		.GBLADDRB_FORMAT_ADV = .GBLADDRB_FORMAT,
                .GBLADDRB_NUM = .GBLADDRB,
		.GBLADDRB_NUM_VALUE = .GBLADDRB_NUM,
		.GBLADDRB_SYM = "NULL",
		.GBLADDRB_SYM_VALUE = .GBLADDRB_SYM,
            "ok"
	    }
	)
    }
    inst GBLADDRB_FORMAT ::="Numeric" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Symbolic"
        prop Label:: "Global Address Reload Register B Format"
	prop JSName :: "dmaGbladdrBFormat"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Address"
        prop Set :: (
		$a = 0,
		scan ($b; externDecl) {
			$a += 1
		},
		if ($a == 1 && $1 == "Symbolic" ) {
                  .GBLADDRB_FORMAT = "Numeric",
        		.error("You must create a Symbol Address - See CSL extern Declaration")
		} else {
                  .GBLADDRB_FORMAT = $1 ,
                  .GBLADDRB_FORMAT_ADV = $1,
                  if ($1 == "Numeric") {
                      .GBLADDRB_SYM = "NULL" 
                  },
                  "ok"
		}
	     )
        }
   
    inst GBLADDRB_NUM :: 0x00000000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop Label :: "    Reload Register B - Numeric "
	prop JSName :: "dmaGbladdrBNumeric"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT && .GBLADDRB_FORMAT == "Numeric"
	prop NoGen :: 1
      prop cGen :: 0
      prop TabName :: "Global Address"
	prop Set :: (
	    if ( 0 ) {
		.error("Invalid Number")
	    }
	    else {
		.GBLADDRB_NUM = $1,
		.GBLADDRB_NUM_VALUE = .GBLADDRB_NUM,
            "ok"
	    }
	)
    }
  inst GBLADDRB_SYM :: "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "    Reload Register B - Symbolic "
	prop JSName :: "dmaGbladdrBSymbolic"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT && .GBLADDRB_FORMAT == "Symbolic" 
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Address"
        prop Set :: (
                    $a = 0, 
		   scan($b; externDecl) {
                    if (  $1 != "NULL"  &&  $1 == $b.BuffName )  {
                           if ( $b.BuffType == "NULL") {
                              $a = 1
                            } else {
                               $a = 2
                            }  
                        } 
                   },
                    if ($a == 0 ) { 
                          .error("Symbolic Address Not declared - See CSL Extern Declaration")
                     } else {
                       if ($a == 1 ) { 
                          .error("Symbol Type of this object is incorrect - See CSL Extern Declaration")
                        } else {
                   
                            .GBLADDRB_SYM =  $1, 
                             .GBLADDRB_SYM_VALUE = .GBLADDRB_SYM, 
                            "ok"
                      }
                    } 
            )
       } 
    
    inst GBLADDRC :: 0x00000000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop Label :: "Global Address Reload Register C (Old - should not be visible)"
	prop Visible :: 0
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
      prop cGen :: 0
      prop TabName :: "Global Address"
	prop Set :: (
	    if ( 0 ) {
		.error("Invalid Number")
	    }
	    else {
		.GBLADDRC = $1,
		.GBLADDRC_FORMAT = "Numeric",
		.GBLADDRC_FORMAT_ADV = .GBLADDRC_FORMAT,
                .GBLADDRC_NUM = .GBLADDRC,
		.GBLADDRC_NUM_VALUE = .GBLADDRC_NUM,
		.GBLADDRC_SYM = "NULL",
		.GBLADDRC_SYM_VALUE = .GBLADDRC_SYM,
            "ok"
	    }
	)
    }
    inst GBLADDRC_FORMAT ::="Numeric" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Symbolic"
        prop Label:: "Global Address Reload Register C Format"
	prop JSName :: "dmaGbladdrCFormat"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Address"
        prop Set :: (
		$a = 0,
		scan ($b; externDecl) {
			$a += 1
		},
		if ($a == 1 && $1 == "Symbolic" ) {
                  .GBLADDRC_FORMAT = "Numeric",
        		.error("You must create a Symbol Address - See CSL extern Declaration")
		} else {
                  .GBLADDRC_FORMAT = $1 ,
                  .GBLADDRC_FORMAT_ADV = $1,
                  if ($1 == "Numeric") {
                      .GBLADDRC_SYM = "NULL" 
                  },
                  "ok"
		}
	     )
        }
   
    inst GBLADDRC_NUM :: 0x00000000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop Label :: "    Reload Register C - Numeric "
	prop JSName :: "dmaGbladdrCNumeric"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT && .GBLADDRC_FORMAT == "Numeric"
	prop NoGen :: 1
      prop cGen :: 0
      prop TabName :: "Global Address"
	prop Set :: (
	    if ( 0 ) {
		.error("Invalid Number")
	    }
	    else {
		.GBLADDRC_NUM = $1,
		.GBLADDRC_NUM_VALUE = .GBLADDRC_NUM,
            "ok"
	    }
	)
    }
  inst GBLADDRC_SYM :: "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "    Reload Register C - Symbolic "
	prop JSName :: "dmaGbladdrCSymbolic"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT && .GBLADDRC_FORMAT == "Symbolic" 
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Address"
        prop Set :: (
                    $a = 0, 
		   scan($b; externDecl) {
                    if (  $1 != "NULL"  &&  $1 == $b.BuffName )  {
                           if ( $b.BuffType == "NULL") {
                              $a = 1
                            } else {
                               $a = 2
                            }  
                        } 
                   },
                    if ($a == 0 ) { 
                          .error("Symbolic Address Not declared - See CSL Extern Declaration")
                     } else {
                       if ($a == 1 ) { 
                          .error("Symbol Type of this object is incorrect - See CSL Extern Declaration")
                        } else {
                   
                            .GBLADDRC_SYM =  $1, 
                             .GBLADDRC_SYM_VALUE = .GBLADDRC_SYM, 
                            "ok"
                      }
                    } 
            )
       } 
    inst GBLADDRD :: 0x00000000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop Label :: "Global Address Reload Register D (Old - should not be visible)"
	prop Visible :: 0
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
      prop cGen :: 0
      prop TabName :: "Global Address"
	prop Set :: (
	    if ( 0 ) {
		.error("Invalid Number")
	    }
	    else {
		.GBLADDRD = $1,
		.GBLADDRD_FORMAT = "Numeric",
		.GBLADDRD_FORMAT_ADV = .GBLADDRD_FORMAT,
                .GBLADDRD_NUM = .GBLADDRD,
		.GBLADDRD_NUM_VALUE = .GBLADDRD_NUM,
		.GBLADDRD_SYM = "NULL",
		.GBLADDRD_SYM_VALUE = .GBLADDRD_SYM,
            "ok"
	    }
	)
    }
    inst GBLADDRD_FORMAT ::="Numeric" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Symbolic"
        prop Label:: "Global Address Reload Register D Format"
	prop JSName :: "dmaGbladdrDFormat"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Address"
        prop Set :: (
		$a = 0,
		scan ($b; externDecl) {
			$a += 1
		},
		if ($a == 1 && $1 == "Symbolic" ) {
                  .GBLADDRD_FORMAT = "Numeric",
        		.error("You must create a Symbol Address - See CSL extern Declaration")
		} else {
                  .GBLADDRD_FORMAT = $1 ,
                  .GBLADDRD_FORMAT_ADV = $1,
                  if ($1 == "Numeric") {
                      .GBLADDRD_SYM = "NULL" 
                  },
                  "ok"
		}
	     )
        }
   
    inst GBLADDRD_NUM :: 0x00000000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop Label :: "    Reload Register D - Numeric "
	prop JSName :: "dmaGbladdrDNumeric"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT && .GBLADDRD_FORMAT == "Numeric"
	prop NoGen :: 1
      prop cGen :: 0
      prop TabName :: "Global Address"
	prop Set :: (
	    if ( 0 ) {
		.error("Invalid Number")
	    }
	    else {
		.GBLADDRD_NUM = $1,
		.GBLADDRD_NUM_VALUE = .GBLADDRD_NUM,
            "ok"
	    }
	)
    }
  inst GBLADDRD_SYM :: "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "    Reload Register D - Symbolic "
	prop JSName :: "dmaGbladdrDSymbolic"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT && .GBLADDRD_FORMAT == "Symbolic" 
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Address"
        prop Set :: (
                    $a = 0, 
		   scan($b; externDecl) {
                    if (  $1 != "NULL"  &&  $1 == $b.BuffName )  {
                           if ( $b.BuffType == "NULL") {
                              $a = 1
                            } else {
                               $a = 2
                            }  
                        } 
                   },
                    if ($a == 0 ) { 
                          .error("Symbolic Address Not declared - See CSL Extern Declaration")
                     } else {
                       if ($a == 1 ) { 
                          .error("Symbol Type of this object is incorrect - See CSL Extern Declaration")
                        } else {
                   
                            .GBLADDRD_SYM =  $1, 
                             .GBLADDRD_SYM_VALUE = .GBLADDRD_SYM, 
                            "ok"
                      }
                    } 
            )
       } 
    
    inst IDXA_FRAME :: 0x0000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04X"
	prop Style :: 0x02
	prop Label :: "Frame Index for Index Register A"
	prop JSName :: "dmaGblidxAFrameIndex"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Index"
	prop Set :: (
	    if ( ($1 > 32767) | ($1 < -32768)) {
		.error("Invalid Number, [-32768..32767]")
	    }
	    else {
		.IDXA_FRAME = $1,
            .IDXA_VALUE &= 0x0000FFFF,
            .IDXA_VALUE |= ((.IDXA_FRAME & 0xFFFF) << 16),
		"ok"
	    }
	)
    }
    inst IDXA_ELM :: 0x0000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04X"
	prop Style :: 0x02
	prop Label :: "Element Index for Index Register A"
	prop JSName :: "dmaGblidxAElementIndex"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Index"
	prop Set :: (
	    if ( ($1 > 32767) | ($1 < -32768)) {
		.error("Invalid Number, [-32768..32767]")
	    }
	    else {
		.IDXA_ELM = $1,
            .IDXA_VALUE &= 0xFFFF0000,
            .IDXA_VALUE |= (.IDXA_ELM & 0xFFFF),
		"ok"
	    }
	)
    }
    inst IDXB_FRAME :: 0x0000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04X"
	prop Style :: 0x02
	prop Label :: "Frame Index for Index Register B"
	prop JSName :: "dmaGblidxBFrameIndex"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Index"
	prop Set :: (
	    if ( ($1 > 32767) | ($1 < -32768)) {
		.error("Invalid Number, [-32768..32767]")
	    }
	    else {
		.IDXB_FRAME = $1,
            .IDXB_VALUE &= 0x0000FFFF,
            .IDXB_VALUE |= ((.IDXB_FRAME & 0xFFFF) << 16),
		"ok"
	    }
	)
    }
    inst IDXB_ELM :: 0x0000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04X"
	prop Style :: 0x02
	prop Label :: "Element Index for Index Register B"
	prop JSName :: "dmaGblidxBElementIndex"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Index"
	prop Set :: (
	    if ( ($1 > 32767) | ($1 < -32768)) {
		.error("Invalid Number, [-32768..32767]")
	    }
	    else {
		.IDXB_ELM = $1,
            .IDXB_VALUE &= 0xFFFF0000,
            .IDXB_VALUE |= .IDXB_ELM & 0xFFFF,
		"ok"
	    }
	)
    }
    inst CNTA_FRAME :: 0x0000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04X"
	prop Style :: 0x02
	prop Label :: "Frame Count for Global Count Reload Register A"
	prop JSName :: "dmaGblcntAFrameCountReload"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Counter"
	prop Set :: (
	    if ( ($1 > 0x65535) | ($1 < 0)) {
		.error("Invalid Number, [0..65535]")
	    }
	    else {
		.CNTA_FRAME = $1,
            .CNTA_VALUE &= 0x0000FFFF,
            .CNTA_VALUE |= (.CNTA_FRAME << 16),
		"ok"
	    }
	)
    }
    inst CNTA_ELM :: 0x0000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04X"
	prop Style :: 0x02
	prop Label :: "Element Count for Global Count Reload Register A"
	prop JSName :: "dmaGblcntAElementCountReload"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Counter"
	prop Set :: (
	    if ( ($1 > 65535) | ($1 < 0)) {
		.error("Invalid Number, [0..65535]")
	    }
	    else {
		.CNTA_ELM = $1,
            .CNTA_VALUE &= 0xFFFF0000,
            .CNTA_VALUE |= .CNTA_ELM,
		"ok"
	    }
	)
    }
    inst CNTB_FRAME :: 0x0000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04X"
	prop Style :: 0x02
	prop Label :: "Frame Count for Global Count Reload Register B"
	prop JSName :: "dmaGblcntBFrameCountReload"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Counter"
	prop Set :: (
	    if ( ($1 > 0x65535) | ($1 < 0)) {
		.error("Invalid Number, [0..65535]")
	    }
	    else {
		.CNTB_FRAME = $1,
            .CNTB_VALUE &= 0x0000FFFF,
            .CNTB_VALUE |= (.CNTB_FRAME << 16),
		"ok"
	    }
	)
    }
    inst CNTB_ELM :: 0x0000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04X"
	prop Style :: 0x02
	prop Label :: "Element Count for Global Count Reload Register B"
	prop JSName :: "dmaGblcntBElementCountReload"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Counter"
	prop Set :: (
	    if ( ($1 > 65535) | ($1 < 0)) {
		.error("Invalid Number, [0..65535]")
	    }
	    else {
		.CNTB_ELM = $1,
            .CNTB_VALUE &= 0xFFFF0000,
            .CNTB_VALUE |= .CNTB_ELM,
		"ok"
	    }
	)
    }
       
    inst GBLADDRA_VALUE ::= 0x00000000{
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Global Address Reload Register A (Old - should not be visible)"
	prop Format :: "0x%08X"
	prop Style :: 0x02
        prop Visible :: 0
        prop Writable :: CSL.DMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (
                     .GBLADDRA_VALUE = $1,
		     .GBLADDRA_FORMAT = "Numeric",
		     .GBLADDRA_FORMAT_ADV = .GBLADDRA_FORMAT,
                     .GBLADDRA_NUM = .GBLADDRA,
		     .GBLADDRA_NUM_VALUE = .GBLADDRA_NUM,
		     .GBLADDRA_SYM = "NULL",
		     .GBLADDRA_SYM_VALUE = .GBLADDRA_SYM,
                     "ok"
                   )
    } 
    inst GBLADDRA_FORMAT_ADV :: "Numeric" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Symbolic"
        prop Label:: "Global Address Reload Reg A (GBLADDRA) Format"
	prop JSName :: "dmaGbladdrAFormatAdv"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Advanced"
        prop Set :: ( .GBLADDRA_FORMAT_ADV = $1,
                      .GBLADDRA_FORMAT = $1,
                        "ok"
                     )
        }
    inst GBLADDRA_NUM_VALUE ::= 0x00000000{
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Reload Register A - Numeric"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop JSName :: "dmaGbladdrANumericAdv"
        prop Visible :: 1
        prop Writable :: CSL.DMA_SUPPORT && .GBLADDRA_FORMAT_ADV == "Numeric"
        prop NoGen :: 1
        prop cGen :: CSL.DMA_SUPPORT && .GBLADDRA_FORMAT_ADV == "Numeric"
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (
                     .GBLADDRA_NUM_VALUE = $1,
                     .GBLADDRA_NUM = $1,
                     "ok"
                   )
    }
 
   inst GBLADDRA_SYM_VALUE :: "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "Reload Register A - Symbolic "
	prop JSName :: "dmaGbladdrASymbolicAdv"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT && .GBLADDRA_FORMAT_ADV == "Symbolic" 
	prop NoGen :: 1
	prop cGen :: CSL.DMA_SUPPORT && .GBLADDRA_FORMAT_ADV == "Symbolic" 
        prop TabName :: "Advanced"
        prop cPreVal :: ( 
                   $a="",
		   scan ($b; externDecl) {
                       if (.GBLADDRA_SYM_VALUE == $b.BuffName) {
                            if ($b.BuffSpec == "Array" )  {
                             $a = "(Uint32) "
                            } else {
                              $a = "(Uint32) &"
                            }
                        }     
		    }, 
                     $a
                 )    
        prop Set :: (
                    $a = 0, 
		   scan($b; externDecl) {
                    if (  $1 != "NULL"  &&  $1 == $b.BuffName )  {
                           if ( $b.BuffType == "NULL") {
                              $a = 1
                            } else {
                               $a = 2
                            }  
                        } 
                   },
                    if ($a == 0 ) { 
                          .error("Symbolic Address Not declared - See CSL Extern Declaration")
                     } else {
                       if ($a == 1 ) { 
                          .error("Symbol Type of this object is incorrect - See CSL Extern Declaration")
                        } else {
                   
                            .GBLADDRA_SYM =  $1, 
                             .GBLADDRA_SYM_VALUE = $1, 
                            "ok"
                      }
                    } 
            )
        }
    
    inst GBLADDRB_VALUE ::= 0x00000000{
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Global Address Reload Register B (Old - should not be visible)"
	prop Format :: "0x%08X"
	prop Style :: 0x02
      prop Visible :: 0
      prop Writable :: CSL.DMA_SUPPORT
      prop NoGen :: 1
      prop cGen :: 0
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
                     .GBLADDRB_VALUE = $1,
		     .GBLADDRB_FORMAT = "Numeric",
		     .GBLADDRB_FORMAT_ADV = .GBLADDRB_FORMAT,
                     .GBLADDRB_NUM = .GBLADDRB,
		     .GBLADDRB_NUM_VALUE = .GBLADDRB_NUM,
		     .GBLADDRB_SYM = "NULL",
		     .GBLADDRB_SYM_VALUE = .GBLADDRB_SYM,
                     "ok"
                   )
    } 
    inst GBLADDRB_FORMAT_ADV :: "Numeric" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Symbolic"
        prop Label:: "Global Address Reload Reg B (GBLADDRB) Format"
	prop JSName :: "dmaGbladdrBFormatAdv"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Advanced"
        prop Set :: ( .GBLADDRB_FORMAT_ADV = $1,
                      .GBLADDRB_FORMAT = $1,
                        "ok"
                     )
        }
    inst GBLADDRB_NUM_VALUE ::= 0x00000000{
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Reload Register B - Numeric"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop JSName :: "dmaGbladdrBNumericAdv"
      prop Visible :: 1
      prop Writable :: CSL.DMA_SUPPORT && .GBLADDRB_FORMAT_ADV == "Numeric"
      prop NoGen :: 1
      prop cGen :: CSL.DMA_SUPPORT && .GBLADDRB_FORMAT_ADV == "Numeric"
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
                     .GBLADDRB_NUM_VALUE = $1,
                     .GBLADDRB_NUM = $1,
                     "ok"
                   )
    }
 
   inst GBLADDRB_SYM_VALUE :: "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "Reload Register B - Symbolic "
	prop JSName :: "dmaGbladdrBSymbolicAdv"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT && .GBLADDRB_FORMAT_ADV == "Symbolic" 
	prop NoGen :: 1
	prop cGen :: CSL.DMA_SUPPORT && .GBLADDRB_FORMAT_ADV == "Symbolic" 
        prop TabName :: "Advanced"
        prop cPreVal :: ( 
                   $a="",
		   scan ($b; externDecl) {
                       if (.GBLADDRB_SYM_VALUE == $b.BuffName) {
                            if ($b.BuffSpec == "Array" )  {
                             $a = "(Uint32) "
                            } else {
                              $a = "(Uint32) &"
                            }
                        }     
		    }, 
                     $a
                 )    
        prop Set :: (
                    $a = 0, 
		   scan($b; externDecl) {
                    if (  $1 != "NULL"  &&  $1 == $b.BuffName )  {
                           if ( $b.BuffType == "NULL") {
                              $a = 1
                            } else {
                               $a = 2
                            }  
                        } 
                   },
                    if ($a == 0 ) { 
                          .error("Symbolic Address Not declared - See CSL Extern Declaration")
                     } else {
                       if ($a == 1 ) { 
                          .error("Symbol Type of this object is incorrect - See CSL Extern Declaration")
                        } else {
                   
                            .GBLADDRB_SYM =  $1, 
                             .GBLADDRB_SYM_VALUE = $1, 
                            "ok"
                      }
                    } 
            )
        }
    
    inst GBLADDRC_VALUE ::= 0x00000000{
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Global Address Reload Register C (Old - should not be visible)"
	prop Format :: "0x%08X"
	prop Style :: 0x02
      prop Visible :: 0
      prop Writable :: CSL.DMA_SUPPORT
      prop NoGen :: 1
      prop cGen :: 0
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
                     .GBLADDRC_VALUE = $1,
		     .GBLADDRC_FORMAT = "Numeric",
		     .GBLADDRC_FORMAT_ADV = .GBLADDRC_FORMAT,
                     .GBLADDRC_NUM = .GBLADDRC,
		     .GBLADDRC_NUM_VALUE = .GBLADDRC_NUM,
		     .GBLADDRC_SYM = "NULL",
		     .GBLADDRC_SYM_VALUE = .GBLADDRC_SYM,
                     "ok"
                   )
    } 
    inst GBLADDRC_FORMAT_ADV :: "Numeric" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Symbolic"
        prop Label:: "Global Address Reload Reg C (GBLADDRC) Format"
	prop JSName :: "dmaGbladdrCFormatAdv"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Advanced"
        prop Set :: ( .GBLADDRC_FORMAT_ADV = $1,
                      .GBLADDRC_FORMAT = $1,
                        "ok"
                     )
        }
    inst GBLADDRC_NUM_VALUE ::= 0x00000000{
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Reload Register C - Numeric"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop JSName :: "dmaGbladdrCNumericAdv"
      prop Visible :: 1
      prop Writable :: CSL.DMA_SUPPORT && .GBLADDRC_FORMAT_ADV == "Numeric"
      prop NoGen :: 1
      prop cGen :: CSL.DMA_SUPPORT && .GBLADDRC_FORMAT_ADV == "Numeric"
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
                     .GBLADDRC_NUM_VALUE = $1,
                     .GBLADDRC_NUM = $1,
                     "ok"
                   )
    }
 
   inst GBLADDRC_SYM_VALUE :: "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "Reload Register C - Symbolic "
	prop JSName :: "dmaGbladdrCSymbolicAdv"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT && .GBLADDRC_FORMAT_ADV == "Symbolic" 
	prop NoGen :: 1
	prop cGen :: CSL.DMA_SUPPORT && .GBLADDRC_FORMAT_ADV == "Symbolic" 
        prop TabName :: "Advanced"
        prop cPreVal :: ( 
                   $a="",
		   scan ($b; externDecl) {
                       if (.GBLADDRC_SYM_VALUE == $b.BuffName) {
                            if ($b.BuffSpec == "Array" )  {
                             $a = "(Uint32) "
                            } else {
                              $a = "(Uint32) &"
                            }
                        }     
		    }, 
                     $a
                 )    
        prop Set :: (
                    $a = 0, 
		   scan($b; externDecl) {
                    if (  $1 != "NULL"  &&  $1 == $b.BuffName )  {
                           if ( $b.BuffType == "NULL") {
                              $a = 1
                            } else {
                               $a = 2
                            }  
                        } 
                   },
                    if ($a == 0 ) { 
                          .error("Symbolic Address Not declared - See CSL Extern Declaration")
                     } else {
                       if ($a == 1 ) { 
                          .error("Symbol Type of this object is incorrect - See CSL Extern Declaration")
                        } else {
                   
                            .GBLADDRC_SYM =  $1, 
                             .GBLADDRC_SYM_VALUE = $1, 
                            "ok"
                      }
                    } 
            )
        }
    inst GBLADDRD_VALUE ::= 0x00000000{
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Global Address Reload Register D (Old - should not be visible)"
	prop Format :: "0x%08X"
	prop Style :: 0x02
      prop Visible :: 0
      prop Writable :: CSL.DMA_SUPPORT
      prop NoGen :: 1
      prop cGen :: 0
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
                     .GBLADDRD_VALUE = $1,
		     .GBLADDRD_FORMAT = "Numeric",
		     .GBLADDRD_FORMAT_ADV = .GBLADDRD_FORMAT,
                     .GBLADDRD_NUM = .GBLADDRD,
		     .GBLADDRD_NUM_VALUE = .GBLADDRD_NUM,
		     .GBLADDRD_SYM = "NULL",
		     .GBLADDRD_SYM_VALUE = .GBLADDRD_SYM,
                     "ok"
                   )
    } 
    inst GBLADDRD_FORMAT_ADV :: "Numeric" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Symbolic"
        prop Label:: "Global Address Reload Reg D (GBLADDRD) Format"
	prop JSName :: "dmaGbladdrDFormatAdv"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Advanced"
        prop Set :: ( .GBLADDRD_FORMAT_ADV = $1,
                      .GBLADDRD_FORMAT = $1,
                        "ok"
                     )
        }
    inst GBLADDRD_NUM_VALUE ::= 0x00000000{
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Reload Register D - Numeric"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop JSName :: "dmaGbladdrDNumericAdv"
      prop Visible :: 1
      prop Writable :: CSL.DMA_SUPPORT && .GBLADDRD_FORMAT_ADV == "Numeric"
      prop NoGen :: 1
      prop cGen :: CSL.DMA_SUPPORT && .GBLADDRD_FORMAT_ADV == "Numeric"
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
                     .GBLADDRD_NUM_VALUE = $1,
                     .GBLADDRD_NUM = $1,
                     "ok"
                   )
    }
 
   inst GBLADDRD_SYM_VALUE :: "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "Reload Register D - Symbolic "
	prop JSName :: "dmaGbladdrDSymbolicAdv"
	prop Visible :: 1
	prop Writable :: CSL.DMA_SUPPORT && .GBLADDRD_FORMAT_ADV == "Symbolic" 
	prop NoGen :: 1
	prop cGen :: CSL.DMA_SUPPORT && .GBLADDRD_FORMAT_ADV == "Symbolic" 
        prop TabName :: "Advanced"
        prop cPreVal :: ( 
                   $a="",
		   scan ($b; externDecl) {
                       if (.GBLADDRD_SYM_VALUE == $b.BuffName) {
                            if ($b.BuffSpec == "Array" )  {
                             $a = "(Uint32) "
                            } else {
                              $a = "(Uint32) &"
                            }
                        }     
		    }, 
                     $a
                 )    
        prop Set :: (
                    $a = 0, 
		   scan($b; externDecl) {
                    if (  $1 != "NULL"  &&  $1 == $b.BuffName )  {
                           if ( $b.BuffType == "NULL") {
                              $a = 1
                            } else {
                               $a = 2
                            }  
                        } 
                   },
                    if ($a == 0 ) { 
                          .error("Symbolic Address Not declared - See CSL Extern Declaration")
                     } else {
                       if ($a == 1 ) { 
                          .error("Symbol Type of this object is incorrect - See CSL Extern Declaration")
                        } else {
                   
                            .GBLADDRD_SYM =  $1, 
                             .GBLADDRD_SYM_VALUE = $1, 
                            "ok"
                      }
                    } 
            )
        }
    
  inst IDXA_VALUE ::= 0x00000000{
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Global Index Reg A (GBLIDXA)"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop JSName :: "dmaGblidxAAdv"
      prop Visible :: 1
      prop Writable :: CSL.DMA_SUPPORT
      prop NoGen :: 1
      prop cGen :: 1
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: ( 
                     .IDXA_VALUE = $1,
                     .IDXA_FRAME = ($1 >> 16)&0x0000FFFF,
                     .IDXA_ELM = ($1 & 0x0000FFFF),
                     "ok"
                   )
     } 
    inst IDXB_VALUE ::= 0x00000000{
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Global Index Reg B (GBLIDXB)"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop JSName :: "dmaGblidxBAdv"
      prop Visible :: 1
      prop Writable :: CSL.DMA_SUPPORT
      prop NoGen :: 1
      prop cGen :: 1
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: ( 
                     .IDXB_VALUE = $1,
                     .IDXB_FRAME = ($1 >> 16)&0x0000FFFF,
                     .IDXB_ELM = ($1 & 0x0000FFFF),
                     "ok"
                   )
    } 
    inst CNTA_VALUE ::= 0x00000000{
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Global Count Reload Reg A (GBLCNTA)"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop JSName :: "dmaGblcntAAdv"
      prop Visible :: 1
      prop Writable :: CSL.DMA_SUPPORT
      prop NoGen :: 1
      prop cGen :: 1
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: ( 
                     .CNTA_VALUE = $1,
                     .CNTA_FRAME = ($1 >> 16)&0x0000FFFF,
                     .CNTA_ELM = ($1 & 0x0000FFFF),
                     "ok"
                   )
    } 
    inst CNTB_VALUE ::= 0x00000000{
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Global Count Reload Reg B (GBLCNTB)"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop JSName :: "dmaGblcntBAdv"
      prop Visible :: 1
      prop Writable :: CSL.DMA_SUPPORT
      prop NoGen :: 1
      prop cGen :: 1
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: ( 
                     .CNTB_VALUE = $1,
                     .CNTB_FRAME = ($1 >> 16)&0x0000FFFF,
                     .CNTB_ELM = ($1 & 0x0000FFFF),
                     "ok"
                   )
    } 
}
object DMAGBL_NOTHING :: dmaGblCfg {
       param iIsUsed :: 0
}
type EDMAFOLDER {
    prop Label :: "EDMA Enhanced Direct Memory Access"
    prop GlobalIcon :: 165
    prop InstanceIcon :: 166
    prop GlobalHelpTopic :: 1030
    prop GlobalPropertyPage :: "{B936FB91-49A5-11d4-967C-0050048381B7}"
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}
type edmaCfg {
      isa ObjectMgr
      prop name :: "edmaCfg"
      prop Label :: "EDMA Configuration Manager"
      prop JSName :: "EDMA"
      prop IsContainedIn :: EDMAFOLDER 
      prop GlobalIcon :: 165
      prop InstanceIcon :: 166
      prop GlobalHelpTopic :: 1031
      prop InstanceHelpTopic :: 1031
      prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-00105A98CA0B}"
      prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-0000C070F3E9}"
      prop Vendor :: "vendor1"
      prop Version :: "1.00.00"
	
	prop NoGen :: 1
      prop cGen :: CSL.EDMA_SUPPORT 
    	prop cStruct :: CSL.EDMA_SUPPORT
    	prop cStructType :: "EDMA_Config"
	prop cHeaderName :: .gNumOf > 0 ? "csl_edma.h" : ""
 
	prop cStructQual :: "far"
      prop localDelete :: (
        .myDelete
      )           
      prop myDelete :: (
        $a=0,
        scan($b; edmaCfg) { 
             $a += 1
        }, 		
        if($a == 2 ) {
	     scan($c;hEdma) {
                $c.PINIT_ENABLE = 0
           },
           scan($d; hEdmaTbl) {
                $d.PINIT_ENABLE = 0
           }
        },
        "ok"
      )           
  inst FSYNC_SETUP :: "None" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,Enable"
        prop Label :: "Frame Sync(FS)"
	prop JSName :: "edmaOptionsFS"
        prop Visible :: 1
        prop Writable :: (CSL.EDMA_SUPPORT != 0) ? 1 : 0
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Operation Mode"
        prop Set :: (
             .FSYNC_SETUP = $1,
             .OPTION_VALUE = .OPTION_VALUE_update(),
             "ok"
        )
   }
   prop FSYNC_OPTION :: (
       if (.FSYNC_SETUP == "None") {
           0x00000000
       } else {
            if (.FSYNC_SETUP == "Enable") {
                0x00000001
            } 
       }
     )
  inst TDS_SETUP :: "Disable" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Two Dimensional Source Transfer(2DS)"
	prop JSName :: "edmaOptions2ds"
        prop Visible :: 1
        prop Writable :: (CSL.EDMA_SUPPORT != 0) ? 1 : 0
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Source"
        prop Set :: (
             .TDS_SETUP = $1,
             .OPTION_VALUE = .OPTION_VALUE_update(),
             "ok"
        )
   }
   prop TDS_OPTION :: (
       if (.TDS_SETUP == "Disable") {
           0x00000000
       } else {
            if (.TDS_SETUP == "Enable") {
                0x04000000
            } 
       }
     )
  inst TDD_SETUP :: "Disable" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Two Dimensional Destination Transfer(2DD)"
        prop Visible :: 1
	prop JSName :: "edmaOptions2dd"
        prop Writable :: (CSL.EDMA_SUPPORT != 0) ? 1 : 0
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Destination"
        prop Set :: (
             .TDD_SETUP = $1,
             .OPTION_VALUE = .OPTION_VALUE_update(),
             "ok"
        )
   }
   prop TDD_OPTION :: (
       if (.TDD_SETUP == "Disable") {
           0x00000000
       } else {
            if (.TDD_SETUP == "Enable") {
                0x00800000
            } 
       }
     )
   inst DUM_SETUP :: "None" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,Increment,Decrement,Index"
        prop Label :: "Destination Address Update Mode(DUM)"
        prop Visible :: 1
	prop JSName :: "edmaOptionsDum"
        prop Writable :: (CSL.EDMA_SUPPORT != 0) ? 1 : 0
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Destination"
        prop Set :: (
             .DUM_SETUP = $1,
             .OPTION_VALUE = .OPTION_VALUE_update(),
             "ok"
        )
   }
    prop DUM_OPTION :: (
        if (.DUM_SETUP == "None") {
            0x00000000
        } else {
		if (.DUM_SETUP == "Increment") {
			0x00200000
		} else {
			if (.DUM_SETUP == "Decrement") {
				0x00400000
			} else {
				if (.DUM_SETUP == "Index") {
					0x00600000
				}
			}
		}
	}
    )
   inst SUM_SETUP :: "None" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,Increment,Decrement,Index"
        prop Label :: "Source Address Update Mode(SUM)"
        prop Visible :: 1
	prop JSName :: "edmaOptionsSum"
        prop Writable :: (CSL.EDMA_SUPPORT != 0) ? 1 : 0
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Source"
        prop Set :: (
             .SUM_SETUP = $1,
             .OPTION_VALUE = .OPTION_VALUE_update(),
             "ok"
        )
   }
    prop SUM_OPTION :: (
        if (.SUM_SETUP == "None") {
            0x00000000
        } else {
		if (.SUM_SETUP == "Increment") {
			0x01000000
		} else {
			if (.SUM_SETUP == "Decrement") {
				0x02000000
			} else {
				if (.SUM_SETUP == "Index") {
					0x03000000
				}
			}
		}
	}
    )
   
  inst PDTS_SETUP :: "Disable" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Peripheral Device Transfer Srce(PDTS)"
        prop Visible :: 1
        prop Writable :: ((CSL.EDMA_SUPPORT != 0) && CSL.C64_SUPPORT) ? 1 : 0
        prop JSName :: "edmaOptionsPdts"
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Source"
        prop Set :: (
             .PDTS_SETUP = $1,
             .OPTION_VALUE = .OPTION_VALUE_update(),
             "ok"
        )
   }
   prop PDTS_OPTION :: (
       if (.PDTS_SETUP == "Disable") {
           0x00000000
       } else {
            if (.PDTS_SETUP == "Enable") {
                0x00000008
            } 
       }
     )
                                                               
   inst ESIZE_SETUP :: "32-bit" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "32-bit,16-bit,8-bit"
        prop Label :: "Element Size(ESIZE)"
        prop Visible :: 1
	prop JSName :: "edmaOptionsEsize"
        prop Writable :: (CSL.EDMA_SUPPORT != 0) ? 1 : 0
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Operation Mode"
        prop Set :: (
             .ESIZE_SETUP = $1,
             .OPTION_VALUE = .OPTION_VALUE_update(),
             "ok"
        )
   }
    prop ESIZE_OPTION :: (
        if (.ESIZE_SETUP == "32-bit") {
            0x00000000
        } else {
		if (.ESIZE_SETUP == "16-bit") {
			0x08000000
		} else {
                if(.ESIZE_SETUP == "8-bit") {
                     0x10000000
                }
            }
	}
    )
   inst PRI_SETUP :: "Urgent(64x)" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Low,Medium,High,Urgent(64x)"
        prop Label :: "Priority Levels(PRI)"
        prop Visible :: 1
	  prop JSName :: "edmaOptionsPri"
        prop Writable :: (CSL.EDMA_SUPPORT != 0) ? 1 : 0
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Operation Mode"
        prop Set :: (                                
             if (!CSL.C64_SUPPORT){
                  if ($1 == "Medium" || $1 == "Urgent(64x)") {
                     .error("Invalid Selection, For C64x only") 
                  }
                  else{
                 .PRI_SETUP = $1,
                 .OPTION_VALUE = .OPTION_VALUE_update(),
                 "ok"
                  }
               
              }
             else{
             .PRI_SETUP = $1,
             .OPTION_VALUE = .OPTION_VALUE_update(),
             "ok"
              }
        )
   }
    prop PRI_OPTION :: (
         if(CSL.C64_SUPPORT){
              if(.PRI_SETUP == "Urgent(64x)") {
                  0x00000000
              } else {
		      if (.PRI_SETUP == "High") {
		      	0x20000000
		     } else {
                     if(.PRI_SETUP == "Medium") {
                          0x40000000
                     } else {
                         if(.PRI_SETUP == "Low") {
                              0x60000000
                         }
                     }
                 }
             }
         }
         else { 
           if (.PRI_SETUP == "High") {
			0x20000000
		} else {
                if(.PRI_SETUP == "Low") {
                     0x40000000
                }
              }
         }
    )                                          
  inst TCINT_SETUP :: "Disable" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Transfer Complete Interrupt(TCINT)"
	prop JSName :: "edmaOptionsTcint"
        prop Visible :: 1
        prop Writable :: (CSL.EDMA_SUPPORT != 0) ? 1 : 0
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Transfer Complete"
        prop Set :: (
             .TCINT_SETUP = $1,
             .OPTION_VALUE = .OPTION_VALUE_update(),
             "ok"
        )
   }
   prop TCINT_OPTION :: (
       if (.TCINT_SETUP == "Disable") {
           0x00000000
       } else {
            if (.TCINT_SETUP == "Enable") {
                0x00100000
            } 
       }
     )
   inst TCC_SETUP :: "Host to DSP Interrupt" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Host to DSP Interrupt,Timer 0 Interrupt,Timer 1 Interrupt,EMIF Timer Interrupt,External Interrupt Pin 4,External Interrupt Pin 5,External Interrupt Pin 6,External Interrupt Pin 7,EDMA_TCC 1000b Interrupt,EDMA_TCC 1001b Interrupt,EDMA_TCC 1010b Interrupt,EDMA_TCC 1011b Interrupt,McBSP 0 Transmit Event,McBSP 0 Receive Event,McBSP 1 Transmit Event,McBSP 1 Receive Event"
        prop Label :: "Transfer Complete Code(TCC)"
        prop Visible :: 0
        prop Writable :: (((CSL.EDMA_SUPPORT != 0)&&(.TCINT_SETUP != "Disable")) ? 1 : 0) 
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Transfer Complete"
        prop Set :: (
             .TCC_SETUP = $1,
             .TCC_SETUP_NEW = .TCC_OPTION_OLD(),
             .OPTION_VALUE = .OPTION_VALUE_update(),
             "ok"
            )
        }
   inst TCC_SETUP_NEW :: 0  {
        prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: 0x01 | 0x02
        prop Label :: "Transfer Complete Code(TCC)"
        prop Visible :: 1
	prop JSName :: "edmaOptionsTcc"
        prop Writable :: (((CSL.EDMA_SUPPORT != 0)&&(.TCINT_SETUP != "Disable")) ? 1 : 0) 
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Transfer Complete"
        prop Set :: (
                if ( $1 < 0 || $1 > 15) {
                    .error(" TCC value has to be set between 0 and 15")
                 } else {
                  .TCC_SETUP_NEW = $1,
                  .OPTION_VALUE = .OPTION_VALUE_update(),
                  "ok"
                 }
            )
         }
    
   prop TCC_OPTION :: (
        .TCC_SETUP_NEW << 16
       ) 
   prop TCC_OPTION_OLD :: (
        if(.TCC_SETUP == "Host to DSP Interrupt"){
            0x00000000 >> 16
        }else{
	    if(.TCC_SETUP == "Timer 0 Interrupt"){
	        0x00010000 >> 16
	    }else{
             if(.TCC_SETUP == "Timer 1 Interrupt"){
		     0x00020000 >> 16
             }else{
               if(.TCC_SETUP == "EMIF Timer Interrupt"){
                   0x00030000 >> 16
               }else{
                 if(.TCC_SETUP == "External Interrupt Pin 4"){
                     0x00040000 >> 16
                 }else{
                   if(.TCC_SETUP == "External Interrupt Pin 5"){
                       0x00050000 >> 16
                   }else{
                     if(.TCC_SETUP == "External Interrupt Pin 6"){
                         0x00060000 >> 16
                     }else{
                       if(.TCC_SETUP == "External Interrupt Pin 7"){
                           0x00070000 >> 16
                       }else{
                         if(.TCC_SETUP == "EDMA_TCC 1000b Interrupt"){
                             0x00080000 >> 16
                         }else{
                           if(.TCC_SETUP == "EDMA_TCC 1001b Interrupt"){
                               0x00090000 >> 16
                           }else{
                             if(.TCC_SETUP == "EDMA_TCC 1010b Interrupt"){
                                 0x000A0000 >> 16
                             }else{
                               if(.TCC_SETUP == "EDMA_TCC 1011b Interrupt"){
                                   0x000B0000 >> 16
                               }else{
                                 if(.TCC_SETUP == "McBSP 0 Transmit Event"){
                                     0x000C0000 >> 16
                                 }else{
                                   if(.TCC_SETUP == "McBSP 0 Receive Event"){
                                       0x000D0000 >> 16
                                   }else{
                                     if(.TCC_SETUP == "McBSP 1 Transmit Event"){
                                         0x000E0000 >> 16
                                     }else{
                                       if(.TCC_SETUP == "McBSP 1 Receive Event"){
                                           0x000F0000 >> 16
                                       }
                                     }
                                   }
                                 }
                               }
                             }
                           }
                         }
                       }
                     }
                   }
                 }
               }
             }
          }
        }
    )
  inst TCCM_SETUP :: 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
      prop Format :: 0x01 | 0x02
	prop Style :: 0x01
	prop Label :: "Most Significant Bits of Transfer Complete Code(TCCM)"
	prop Visible :: 1
	prop Writable :: ((CSL.EDMA_SUPPORT != 0)&&(.TCINT_SETUP != "Disable")&& CSL.C64_SUPPORT) ? 1 : 0
	prop JSName :: "edmaOptionsTccm"
      prop NoGen :: 1
      prop cGen :: 0
      prop TabName :: "Transfer Complete"
	prop Set :: (
	    if ( $1 > 3 ) {
		.error("Invalid Number, Should be between 0 and 3")
	    }
	    else {
		.TCCM_SETUP = $1,
            .OPTION_VALUE = .OPTION_VALUE_update(),
            "ok"
	    }
	)
    }
    prop TCCM_OPTION :: (
      .TCCM_SETUP << 13     )
                                                                  
                                                                  
 inst ATCINT_SETUP :: "Disable" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Alternate Transfer Complete Interrupt(ATCINT)"
        prop Visible :: 1
        prop Writable :: ((CSL.EDMA_SUPPORT != 0) && CSL.C64_SUPPORT) ? 1 : 0
        prop JSName :: "edmaOptionsAtcint"
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Transfer Complete"
        prop Set :: (
             .ATCINT_SETUP = $1,
             .OPTION_VALUE = .OPTION_VALUE_update(),
             "ok"
        )
   }
   prop ATCINT_OPTION :: (
       if (.ATCINT_SETUP == "Disable") {
           0x00000000
       } else {
            if (.ATCINT_SETUP == "Enable") {
                0x00001000
            } 
       }
     )
                                                                  
                                                                  
  inst ATCC_SETUP :: 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
      prop Format :: 0x01 | 0x02
	prop Label :: "Alternate Transfer Complete Code(ATCC)"
	prop Visible :: 1
	prop Writable :: ((CSL.EDMA_SUPPORT != 0)&&(.ATCINT_SETUP != "Disable")&& CSL.C64_SUPPORT) ? 1 : 0
	prop JSName :: "edmaOptionsAtcc"
      prop NoGen :: 1
      prop cGen :: 0
      prop TabName :: "Transfer Complete"
	prop Set :: (
	    if ( $1 > 63 ) {
		.error("Invalid Number, Should be between 0 and 63")
	    }
	    else {
		.ATCC_SETUP = $1,
            .OPTION_VALUE = .OPTION_VALUE_update(),
            "ok"
	    }
	)
    }
    prop ATCC_OPTION :: (
      .ATCC_SETUP << 5     )
                                                                  
    inst SRCADDR :: 0x00000000 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Label :: "Source Address (Old - should not be visible)"
        prop Visible :: 0
        prop Writable :: CSL.EDMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Source"
        prop Set :: (
            if ( 0 ) {
                .error("Invalid Number")
            }
            else {
                .SRCADDR = $1,
		.SRCADDR_FORMAT = "Numeric",
		.SRCADDR_FORMAT_ADV = .SRCADDR_FORMAT,
                .SRCADDR_NUM = .SRCADDR,
		.SRCADDR_NUM_VALUE = .SRCADDR_NUM,
		.SRCADDR_SYM = "NULL",
		.SRCADDR_SYM_VALUE = .SRCADDR_SYM,
                "ok"
            }
        )
    }
     inst SRCADDR_FORMAT :: "Numeric" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Extern Decl. Obj.,User's Header file,McBSP handle (DRR)"
        prop Label:: "Source Address Format"
	prop JSName :: "edmaSrcAddrFormat"
	prop Visible :: 1
	prop Writable :: CSL.EDMA_SUPPORT
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Source"
	prop Set :: (
		$a = 0,
		scan ($b; externDecl) {
			$a += 1
		},
		if ($a == 1 && $1 == "Extern Decl. Obj." ) {
                  .SRCADDR_FORMAT = "Numeric",
        		.error("You must create a Symbol Address - See CSL extern Declaration")
		} else {
		if ( $1 == "User's Header file" && externDecl.HeaderFile == "NULL" ) {
                  .SRCADDR_FORMAT = "Numeric",
       		.error("You must enter a Header file name - See CSL extern Declaration")
		} else {
                  .SRCADDR_FORMAT = $1 ,
                  .SRCADDR_FORMAT_ADV = $1,
                  if ($1 == "Numeric") {
                  .SRCADDR_HANDLE = "NULL",
		      .SRCADDR_SYM = "NULL", 
                  .SRCADDR_HEADER = "NULL" 
                  },
                  if ($1 == "User's Header file" ) {
                  .SRCADDR_HANDLE = "NULL",
		      .SRCADDR_SYM = "NULL" 
                  },
                  if ($1 == "Extern Decl. Obj." ) {
                  .SRCADDR_HANDLE = "NULL",
		      .SRCADDR_HEADER = "NULL" 
                  },
                  if ($1 == "McBSP handle (DRR)") {
                  .SRCADDR_SYM = "NULL",
		      .SRCADDR_HEADER = "NULL" 
                  },
                  "ok"
		}
              }
	)
    } 
    inst SRCADDR_NUM :: 0x00000000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop Label :: "   Src Addr - Enter Numeric value "
	prop JSName :: "edmaSrcAddrNumeric"
	prop Visible :: 1
	prop Writable :: CSL.EDMA_SUPPORT  && .SRCADDR_FORMAT == "Numeric" 
	prop NoGen :: 1
      prop cGen :: 0
      prop TabName :: "Source"
	prop Set :: (
	    if ( 0 ) {
		.error("Invalid Number")
	    }
	    else {
		.SRCADDR_NUM = $1,
		.SRCADDR_NUM_VALUE = .SRCADDR_NUM,
                .SRCADDR_HANDLE = "NULL", 
                .SRCADDR_HEADER = "NULL",
                .SRCADDR_HEADER_VALUE = .SRCADDR_HEADER,
                .SRCADDR_SYM = "NULL",
		.SRCADDR_SYM_VALUE = .SRCADDR_SYM,
            "ok"
	    }
	)
    }
     inst SRCADDR_SYM :: "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "   Src Addr - Extern Decl. Symbol name "
	prop JSName :: "edmaSrcAddrSymbol"
	prop Visible :: 1
	prop Writable :: CSL.EDMA_SUPPORT && .SRCADDR_FORMAT == "Extern Decl. Obj." 
	prop NoGen :: 1
        prop TabName :: "Source"
        prop Set :: ( 
                    $a = 0, 
		   scan($b; externDecl) {
                    if (  $1 != "NULL"  &&  $1 == $b.BuffName ) {
                          if ( $b.BuffType == "NULL" )  {
                                $a = 1
                          } else {
                             if ( $1 == .DSTADDR_SYM) {
                              $a = 2
                              } else {
                              $a = 3
                             } 
                          }
                      }
                   },
                    if ($a == 0) { 
                          .error("Symbolic object Name not declared  - See CSL Extern Declaration")
                     } else {
                         if ( $a == 1 ) { 
                           .error("Symbol Type of this object is incorrect - See CSL Extern Declaration")
                           } else {
                             if ($a == 2 ) {
                              .error("Source and Destination must be different")
                             } else {
                             .SRCADDR_HANDLE = "NULL",
                             .SRCADDR_SYM = $1, 
                             .SRCADDR_SYM_VALUE = .SRCADDR_SYM, 
                              "ok"
                             }
                         }
                      }
                        
                   ) 
       }  
     inst SRCADDR_HEADER :: "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "   Src Addr - Enter full address "
	prop JSName :: "edmaSrcAddrFull"
	prop Visible :: 1
	prop Writable :: CSL.EDMA_SUPPORT && .SRCADDR_FORMAT == "User's Header file" 
	prop NoGen :: 1
        prop TabName :: "Source"
        prop Set :: ( 
                    .SRCADDR_HANDLE = "NULL",
                    .SRCADDR_SYM = "NULL",
                    .SRCADDR_HEADER = $1, 
                    .SRCADDR_HEADER_VALUE = .SRCADDR_HEADER, 
                    "ok"
                   ) 
       }
     
   inst SRCADDR_HANDLE :: "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "   Src Addr - Enter Handle Name "
	prop JSName :: "edmaSrcAddrHandle"
	prop Visible :: 1
	prop Writable :: CSL.EDMA_SUPPORT && .SRCADDR_FORMAT == "McBSP handle (DRR)" 
	prop NoGen :: 1
        prop TabName :: "Source"
        prop Set :: ( 
                   $a = 0, 
                   $c = 0, 
		   scan($b;hMcbsp) {
          if (  $1 == $b.HandleName && $b.MCBSP_HANDLE_ENABLE == 1 ) {
                       $a = 1
                      }  
                  },
                 if ( $a == 0) {
                       .error("Handle object Name has to be declared and defined (open)  - ")
                     } else {
                    .SRCADDR_HANDLE = $1, 
                    "ok"
                     }   
                   ) 
       }
                 
                                                    
 inst PDTD_SETUP :: "Disable" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Peripheral Device Transfer Dest.(PDTD)"
        prop Visible :: 1
        prop Writable :: ((CSL.EDMA_SUPPORT != 0) && CSL.C64_SUPPORT) ? 1 : 0
        prop NoGen :: 1
        prop JSName :: "edmaOptionsPdtd"
        prop cGen :: 0
        prop TabName :: "Destination"
        prop Set :: (
             .PDTD_SETUP = $1,
             .OPTION_VALUE = .OPTION_VALUE_update(),
             "ok"
        )
   }
   prop PDTD_OPTION :: (
       if (.PDTD_SETUP == "Disable") {
           0x00000000
       } else {
            if (.PDTD_SETUP == "Enable") {
                0x00000004
            } 
       }
     )
                                                               
    inst DSTADDR :: 0x00000000 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Style :: 0x02
        prop Label :: "Destination Address (Old - should not be visible)"
        prop Visible :: 0
        prop Writable :: CSL.EDMA_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Destination"
        prop Set :: (
            if ( 0 ) {
                .error("Invalid Number")
            }
            else {
                .DSTADDR = $1,
		.DSTADDR_FORMAT = "Numeric",
		.DSTADDR_FORMAT_ADV = .DSTADDR_FORMAT,
            .DSTADDR_NUM = .DSTADDR,
		.DSTADDR_NUM_VALUE = .DSTADDR_NUM,
		.DSTADDR_SYM = "NULL",
		.DSTADDR_SYM_VALUE = .DSTADDR_SYM,
                "ok"
            }
        )
    }
    inst DSTADDR_FORMAT :: "Numeric" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Extern Decl. Obj.,User's Header file,McBSP handle (DXR)"
        prop Label:: "Destination Address Format"
	prop JSName :: "edmaDstAddrFormat"
	prop Visible :: 1
	prop Writable :: CSL.EDMA_SUPPORT
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Destination"
	prop Set :: (
		$a = 0,
		scan ($b; externDecl) {
			$a += 1
		},
		if ($a == 1 && $1 == "Extern Decl. Obj." ) {
                  .DSTADDR_FORMAT = "Numeric",
        		.error("You must create a Symbol Address - See CSL Extern Declaration")
		} else {
		if ($1 == "User's Header file" && externDecl.HeaderFile == "NULL" ) {
                  .DSTADDR_FORMAT = "Numeric",
               	.error("You must enter a Header file name - See CSL Extern Declaration")
		} else {
                  .DSTADDR_FORMAT = $1 ,
                  .DSTADDR_FORMAT_ADV = $1,
                  if ($1 == "Numeric") {
                  .DSTADDR_SYM = "NULL" ,
                  .DSTADDR_HANDLE = "NULL",
		      .DSTADDR_HEADER = "NULL" 
                  },
                 if ($1 == "User's Header file" ) {
                  .DSTADDR_HANDLE = "NULL",
		      .DSTADDR_SYM = "NULL" 
                  },
                  if ($1 == "Extern Decl. Obj." ) {
                  .DSTADDR_HANDLE = "NULL",
		      .DSTADDR_HEADER = "NULL" 
                  },
                  if ($1 == "McBSP handle (DXR)") {
                  .DSTADDR_SYM = "NULL",
		      .DSTADDR_HEADER = "NULL" 
                  },
                  "ok"
		}
             }
	)
    } 
    inst DSTADDR_NUM :: 0x00000000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop Label :: "   Dst Addr - Enter Numeric value "
	prop JSName :: "edmaDstAddrNumeric"
	prop Visible :: 1
	prop Writable :: (CSL.EDMA_SUPPORT != 0 && .DSTADDR_FORMAT == "Numeric" ) ? 1 : 0
	prop NoGen :: 1
      prop cGen :: 0
      prop TabName :: "Destination"
	prop Set :: (
	    if ( 0 ) {
		.error("Invalid Number")
	    }
	    else {
		.DSTADDR_NUM = $1,
                .DSTADDR_NUM_VALUE = .DSTADDR_NUM,
                .DSTADDR_HANDLE = "NULL", 
                .DSTADDR_HEADER = "NULL",
                .DSTADDR_HEADER_VALUE = .DSTADDR_HEADER,
                .DSTADDR_SYM = "NULL",
		.DSTADDR_SYM_VALUE = .DSTADDR_SYM,
		"ok"
	    }
	)
    }
  inst DSTADDR_SYM :: "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "   Dst Addr - Extern Decl. Symbol Name "
	prop JSName :: "edmaDstAddrSymbol"
	prop Visible :: 1
	prop Writable :: CSL.EDMA_SUPPORT && .DSTADDR_FORMAT == "Extern Decl. Obj." 
	prop NoGen :: 1
        prop TabName :: "Destination"
        prop Set :: ( 
                    $a = 0, 
		   scan($b; externDecl) {
                    if (  $1 != "NULL"  &&  $1 == $b.BuffName ) {
                          if ( $b.BuffType == "NULL" )  {
                                $a = 1
                          } else {
                             if ( $1 == .SRCADDR_SYM) {
                              $a = 2
                              } else {
                              $a = 3
                             } 
                          }
                      }
                   },
                    if ($a == 0 ) { 
                          .error("Symbolic Object Name not declared  - See CSL Extern Declaration")
                     } else {
                         if ( $a == 1) { 
                           .error("Symbol Type of this object is incorrect - See CSL Extern Declaration")
                           } else {
                             if ($a == 2 ) {
                              .error("Source and Destination must be different")
                             } else {
                             .DSTADDR_SYM = $1, 
                             .DSTADDR_SYM_VALUE = .DSTADDR_SYM, 
                              "ok"
                             }
                         }
                      }
                        
                   ) 
       } 
 
     inst DSTADDR_HEADER :: "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "   Dst Addr - Enter full address "
	prop JSName :: "edmaDstAddrFull"
	prop Visible :: 1
	prop Writable :: (CSL.EDMA_SUPPORT && .DSTADDR_FORMAT == "User's Header file") 
	prop NoGen :: 1
        prop TabName :: "Destination"
        prop Set :: ( 
                    .DSTADDR_HEADER = $1, 
                    .DSTADDR_NUM_VALUE = 0x00000000, 
                    .DSTADDR_HEADER_VALUE = .DSTADDR_HEADER, 
                    "ok"
                   ) 
       }
   inst DSTADDR_HANDLE :: "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "   Dst Addr - Enter Handle Name "
	prop JSName :: "edmaDstAddrHandle"
	prop Visible :: 1
	prop Writable :: CSL.EDMA_SUPPORT && .DSTADDR_FORMAT == "McBSP handle (DXR)" 
	prop NoGen :: 1
        prop TabName :: "Destination"
        prop Set :: ( 
                   $a = 0, 
                   $c = 0, 
		   scan($b;hMcbsp) {
          if (  $1 == $b.HandleName && $b.MCBSP_HANDLE_ENABLE == 1 ) {
                       $a = 1
                      }  
                  },
                 if ( $a == 0) {
                       .error("Handle object Name has to be declared and defined (open)  - ")
                     } else {
                    .DSTADDR_HANDLE = $1, 
                    "ok"
                     }   
                   ) 
       }
    
    
    inst FRAMECNT :: 0x0000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04X"
	prop Style :: 0x02
	prop Label :: "Frame Count(FC)"
	prop Visible :: 0
	prop Writable :: (CSL.EDMA_SUPPORT != 0) ? 1 : 0
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Transfer Count"
	prop Set :: (
	    if ( ($1 > 65535) || ($1 < 0)) {
		.error("Invalid Number [0..65535]")
	    }
	    else {
		.FRAMECNT = $1,
		.FRAMECNT_NUM = $1,
		.FRAMECNT_HEADER = "NULL",
            	.XFRCNT_NUM_VALUE &= 0x0000FFFF,
            	.XFRCNT_NUM_VALUE |= (.FRAMECNT_NUM << 16),
		"ok"
	    }
	)
    }
      inst XFRCNT_FORMAT :: "Numeric" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,User's Header file"
        prop Label:: " Transfer Counter Format"
	prop JSName :: "edmaTransferCounterFormat"
	prop Visible :: 1
	prop Writable :: CSL.EDMA_SUPPORT
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Transfer Count"
	prop Set :: (
                  if ($1 == "User's Header file" && externDecl.HeaderFile == "NULL") {
                  .XFRCNT_FORMAT = "Numeric",
       		.error("You must enter a Header file name  - See CSL Extern Declaration") 
             }  else {
                      .XFRCNT_FORMAT = $1 ,
                      .XFRCNT_FORMAT_ADV = .XFRCNT_FORMAT,
                      if ($1 == "Numeric") {
                      .ELMCNT_HEADER = "NULL", 
                      .FRAMECNT_HEADER = "NULL" 
                      } else { 
                       .FRAMECNT_NUM = 0x0000,   
                       .ELMCNT_NUM = 0x0000,   
                       .XFRCNT_NUM_VALUE = 0x00000000
                       },    
                  "ok"
                 }
		
	)
    }  
 
    inst FRAMECNT_NUM :: 0x0000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04X"
	prop Style :: 0x02
	prop Label :: "   Frame Cnt(FC) - Enter 16-bit value"
	prop JSName :: "edmaFrameCountNumeric"
	prop Visible :: 1
	prop Writable :: CSL.EDMA_SUPPORT  && .XFRCNT_FORMAT == "Numeric"
	prop NoGen :: 1
      prop cGen :: 0
      prop TabName :: "Transfer Count"
	prop Set :: (
	    if ( ($1 > 65535) || ($1 < 0)) {
		.error("Invalid Number [0..65535]")
	    }
	    else {
		.FRAMECNT_NUM = $1,
            .FRAMECNT_HEADER = "NULL", 
            .XFRCNT_NUM_VALUE &= 0x0000FFFF,
            .XFRCNT_NUM_VALUE |= (.FRAMECNT_NUM << 16),
		"ok"
	    }
	)
    }
     inst FRAMECNT_HEADER ::= "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "   Frame Cnt(FC) - Enter Num or Symbol value  "
	prop JSName :: "edmaFrameCountSymbol"
	prop Visible :: 1
	prop Writable :: CSL.EDMA_SUPPORT && .XFRCNT_FORMAT != "Numeric" 
	prop NoGen :: 1
      prop TabName :: "Transfer Count"
      prop Set :: ( 
                    .FRAMECNT_HEADER = $1,
                    .FRAMECNT_NUM = 0x0000, 
                    .XFRCNT_NUM_VALUE = (.XFRCNT_NUM_VALUE & 0x0000FFFF),
                     "ok"
                   ) 
       } 
  
    inst ELMCNT :: 0x0001 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04X"
	prop Style :: 0x02
	prop Label :: "Element Count(EC)"
	prop Visible :: 0
	prop Writable :: (CSL.EDMA_SUPPORT != 0) ? 1 : 0
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Transfer Count"
	prop Set :: (
	    if ( ($1 > 65535) || ($1 < 1)) {
		.error("Invalid Number [1..65535]")
	    }
	    else {
		.ELMCNT = $1,
		.ELMCNT_NUM = $1,
		.ELMCNT_HEADER = "NULL",
            	.XFRCNT_NUM_VALUE &= 0xFFFF0000,
            	.XFRCNT_NUM_VALUE |= .ELMCNT_NUM,
		"ok"
	    }
	)
    }
    inst ELMCNT_NUM :: 0x0000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04X"
	prop Style :: 0x02
	prop Label :: "   Elt Counter(EC) - Enter 16-bit value"
	prop JSName :: "edmaElementCountNumeric"
	prop Visible :: 1
	prop Writable :: CSL.EDMA_SUPPORT  && .XFRCNT_FORMAT == "Numeric"
	prop NoGen :: 1
      prop cGen :: 0
      prop TabName :: "Transfer Count"
	prop Set :: (
	    if ( ($1 > 65535) || ($1 < 0)) {
		.error("Invalid Number [1..65535]")
	    }
	    else {
        	.ELMCNT_NUM = $1,
            .ELMCNT_HEADER = "NULL", 
            .XFRCNT_NUM_VALUE &= 0xFFFF0000,
            .XFRCNT_NUM_VALUE |= .ELMCNT_NUM,
		"ok"
	    }
	)
    }
     inst ELMCNT_HEADER :: "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "   Elt Count(EC) - Enter  Num or Sym value "
	prop JSName :: "edmaElementCountSymbol"
	prop Visible :: 1
	prop Writable :: CSL.EDMA_SUPPORT && .XFRCNT_FORMAT != "Numeric" 
	prop NoGen :: 1
        prop TabName :: "Transfer Count"
        prop Set :: ( 
                    .ELMCNT_HEADER = $1, 
                    .ELMCNT_NUM = 0x0000,         
                    .XFRCNT_NUM_VALUE = (.XFRCNT_NUM_VALUE & 0xFFFF0000),
                    "ok"
                   ) 
       }
  
      inst XFRIDX_FORMAT :: "Numeric" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,User's Header file"
        prop Label:: " Index Format"
	prop JSName :: "edmaIndexFormat"
	prop Visible :: 1
	prop Writable :: CSL.EDMA_SUPPORT
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Index"
	prop Set :: (
                  if ($1 == "User's Header file" && externDecl.HeaderFile == "NULL") {
                  .XFRIDX_FORMAT = "Numeric",
       		.error("You must enter a Header file name  - See CSL Extern Declaration") 
             }  else {
                      .XFRIDX_FORMAT = $1 ,
                      .XFRIDX_FORMAT_ADV = .XFRIDX_FORMAT,
                      if ($1 == "Numeric") {
                      .FRAMEIDX_HEADER = "NULL", 
                      .ELMIDX_HEADER = "NULL" 
                      } else { 
                       .FRAMEIDX_NUM = 0x0000,   
                       .ELMIDX_NUM = 0x0000,   
                       .XFRIDX_NUM_VALUE = 0x00000000                  
                     },   
                  "ok"
                 }
		
	)
    }  
    
    inst FRAMEIDX :: 0x0000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04X"
	prop Style :: 0x02
	prop Label :: "Frame Index(FIX)"
	prop Visible :: 0
	prop Writable :: (CSL.EDMA_SUPPORT != 0) ? 1 : 0
	prop NoGen :: 1
	prop cGen :: 0
	prop TabName :: "Index"
	prop Set :: (
		if ( ($1 > 0x7FFF) || ($1 < 0xFFFF8000)) {
		    .error("Invalid Number")
		}
		else {
		    .FRAMEIDX = $1,
		    .FRAMEIDX_NUM = $1,
		    .FRAMEIDX_HEADER = "NULL",
		    .XFRIDX_NUM_VALUE &= 0x0000FFFF,
		    .XFRIDX_NUM_VALUE |= (.FRAMEIDX_NUM << 16),
		    "ok"
		}
	)
    }
    inst FRAMEIDX_NUM :: 0x0000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04X"
	prop Style :: 0x02
	prop Label :: "Frame Index(FIX)- 16-bit"
	prop JSName :: "edmaFrameIndexNumeric"
	prop Visible :: 1
	prop Writable :: (CSL.EDMA_SUPPORT  && .XFRIDX_FORMAT == "Numeric")
	prop NoGen :: 1
      prop cGen :: 0
      prop TabName :: "Index"
	prop Set :: (
	    if ( ($1 > 0x7FFF) || ($1 < 0xFFFF8000)) {
		.error("Invalid Number")
	    }
	    else {
		.FRAMEIDX_NUM = $1,
            .FRAMEIDX_HEADER = "NULL",
            .XFRIDX_NUM_VALUE &= 0x0000FFFF,
            .XFRIDX_NUM_VALUE |= (.FRAMEIDX_NUM << 16),
		"ok"
	    }
	)
    }
    inst FRAMEIDX_HEADER ::= "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "   Frame Index(FIX) - Enter Num or Symbol value  "
	prop JSName :: "edmaFrameIndexSymbol"
	prop Visible :: 1
	prop Writable :: CSL.EDMA_SUPPORT && .XFRIDX_FORMAT != "Numeric" 
	prop NoGen :: 1
      prop TabName :: "Index"
      prop Set :: ( 
                    .FRAMEIDX_HEADER = $1,
                    .FRAMEIDX_NUM = 0x0000,   
                    .XFRIDX_NUM_VALUE = (.XFRIDX_NUM_VALUE & 0x0000FFFF),
                    "ok"
                   ) 
       } 
    
    inst ELMIDX :: 0x0000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04X"
	prop Style :: 0x02
	prop Label :: "Element Index(EIX)"
	prop Visible :: 0
	prop Writable :: (CSL.EDMA_SUPPORT != 0) ? 1 : 0
	prop NoGen :: 1
	prop cGen :: 0
	prop TabName :: "Index"
	prop Set :: (
	    if ( ($1 > 0x7FFF) || ($1 < 0xFFFF8000)) {
		.error("Invalid Number")
	    }
	    else {
		.ELMIDX = $1,
		.ELMIDX_NUM = $1,
		.ELMIDX_HEADER = "NULL",
		.XFRIDX_NUM_VALUE &= 0xFFFF0000,
		.XFRIDX_NUM_VALUE |= .ELMIDX_NUM,
		"ok"
	    }
	)
    }
    inst ELMIDX_NUM :: 0x0000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04X"
	prop Style :: 0x02
	prop Label :: "Element Index(EIX) - 16-bit"
	prop JSName :: "edmaElementIndexNumeric"
	prop Visible :: 1
	prop Writable :: (CSL.EDMA_SUPPORT  && .XFRIDX_FORMAT == "Numeric")
	prop NoGen :: 1
      prop cGen :: 0
      prop TabName :: "Index"
	prop Set :: (
	    if ( ($1 > 0x7FFF) || ($1 < 0xFFFF8000)) {
		.error("Invalid Number")
	    }
	    else {
		.ELMIDX_NUM = $1,
            .ELMIDX_HEADER = "NULL",
            .XFRIDX_NUM_VALUE &= 0xFFFF0000,
            .XFRIDX_NUM_VALUE |= .ELMIDX_NUM,
		"ok"
	    }
	)
    }
     inst ELMIDX_HEADER :: "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "   Element Index(EIX) - Enter  Num or Sym value "
	prop JSName :: "edmaElementIndexSymbol"
	prop Visible :: 1
	prop Writable :: CSL.EDMA_SUPPORT && .XFRIDX_FORMAT != "Numeric" 
	prop NoGen :: 1
        prop TabName :: "Index"
        prop Set :: ( 
                    .ELMIDX_HEADER = $1, 
                    .ELMIDX_NUM =0x0000,
                    .XFRIDX_NUM_VALUE = (.XFRIDX_NUM_VALUE & 0xFFFF0000),
                    "ok"
                   ) 
       }
    inst ECRLD :: 0x0000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04X"
	prop Style :: 0x02
	prop Label :: "Element Count Reload(ECRLD)"
	prop JSName :: "edmaElementCountReload"
	prop Visible :: 1
	prop Writable :: (CSL.EDMA_SUPPORT != 0) ? 1 : 0
	prop NoGen :: 1
      prop cGen :: 0
      prop TabName :: "Transfer Count"
	prop Set :: (
	    if ( ($1 > 65535) || ($1 < 1)) {
		.error("Invalid Number")
	    }
	    else {
		.ECRLD = $1,
            .RLD_LNK_VALUE &= 0x0000FFFF,
            .RLD_LNK_VALUE |= (.ECRLD << 16),
		"ok"
	    }
	)
    }
  inst LINK_SETUP :: "Disable" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Linking Event(LINK)"
	prop JSName :: "edmaLink"
        prop Visible :: 1
        prop Writable :: (CSL.EDMA_SUPPORT != 0) ? 1 : 0
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Link"
        prop Set :: (
             .LINK_SETUP = $1,
             .OPTION_VALUE = .OPTION_VALUE_update(),
             "ok"
        )
   }
   prop LINK_OPTION :: (
       if (.LINK_SETUP == "Disable") {
           0x00000000
       } else {
            if (.LINK_SETUP == "Enable") {
                0x00000002
            } 
       }
     )
    inst LINK_FORMAT ::= "Table Number" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Table Number,Table Handle"
	prop Label :: "Link Format"
	prop JSName :: "edmaLinkFormat"
	prop Visible :: 1
	prop Writable :: (((.LINK_SETUP == "Enable") && (CSL.EDMA_SUPPORT != 0)) ? 1 : 0) 
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Link"
	prop Set :: (
                  $a=0,
                  scan ($b; hEdmaTbl) {
                        $a += 1
                  },
                      if ($a == 1 && $1 == "Table Handle") {
                           .LINK_FORMAT = "Table Number",
                           .error(" A table object has to be created AND ALLOCATED under Param Table Entry")
                       } else {
                               .LINK_FORMAT= $1,
                               if ( $1 == "Table Number") {
                               .LINK_TBLHANDLE = PARAMTBL_NOTHING
                             },
                              "ok"
                         }
                  )
             } 
                    
     
  
    inst LINK_TBLHANDLE :: PARAMTBL_NOTHING {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: hEdmaTbl
        prop Label :: "Link Handle Table"
	prop JSName :: "edmaLinkHandle"
        prop Visible :: 1
	prop Writable :: (((.LINK_SETUP == "Enable") && (CSL.EDMA_SUPPORT != 0) && (.LINK_FORMAT == "Table Handle")) ? 1 : 0) 
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Link"
       }
  
   
         
    inst LINKADDR :: 0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "%2d"
	prop Style :: 0x02
	prop Label :: "Link to Table Number"
	prop JSName :: "edmaLinkNumber"
	prop Visible :: 1
	prop Writable :: (((.LINK_SETUP == "Enable") && (CSL.EDMA_SUPPORT != 0) && (.LINK_FORMAT == "Table Number")) ? 1 : 0) 
	prop NoGen :: 1
      prop cGen :: 0
      prop TabName :: "Link"
	prop Set :: (
         if ( !CSL.C64_SUPPORT) { 
	    if ( ($1 > 64) || ($1 < 0)) {
		.error("Invalid Number, valid number range [0..64]")
	    }
	    else {
		.LINKADDR = $1,
            .RLD_LNK_VALUE &= 0xFFFF0000,
            .RLD_LNK_VALUE |= (.LINKADDR * 24)+0x01B0,
		"ok"
	    }
         } else {  
              if ( ($1 > 16) || ($1 < 0)) {
		.error("Invalid Number, valid number range [0..16]")
	    }
	    else {
		.LINKADDR = $1,
            .RLD_LNK_VALUE &= 0xFFFF0000,
            .RLD_LNK_VALUE |= (.LINKADDR * 24)+0x0630,
		"ok"
	    }
        }
	)
    }
    prop OPTION_VALUE_update :: (  .FSYNC_OPTION() 
                                 | .LINK_OPTION() 
                                 | .TCC_OPTION() 
                                 | ((CSL.C64_SUPPORT)? .TCCM_OPTION(): 0)      
                                 | .TCINT_OPTION()
                                 | ((CSL.C64_SUPPORT)? .ATCINT_OPTION(): 0)   
                                 | ((CSL.C64_SUPPORT)? .ATCC_OPTION(): 0)     
                                 | ((CSL.C64_SUPPORT)? .PDTS_OPTION(): 0)     
                                 | ((CSL.C64_SUPPORT)? .PDTD_OPTION(): 0)                                                              
                                 | .DUM_OPTION()
                                 | .TDD_OPTION()
                                 | .SUM_OPTION()
                                 | .TDS_OPTION()
                                 | .ESIZE_OPTION()
                                 | .PRI_OPTION()
                                )
    inst OPTION_VALUE :: .OPTION_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Option"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop JSName :: "edmaOptions"
      prop Visible :: 1
      prop Writable :: (CSL.EDMA_SUPPORT != 0) ? 1 : 0
      prop NoGen :: 1
      prop cGen :: 1
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
      if(!CSL.C64_SUPPORT){
        $a = $1 & 0x0000FFFC,
        $b = $1 & 0x18000000,
        $c = $1 & 0xE0000000,
        if ($a != 0) {
               .error("Bit field(bit[2..15]) is reserved")
        } else {
	     if ($b == 0x18000000) {
               .error("No such option for bit field ESIZE(bit[27..28])")
	     } else {
	     if (($c != 0x20000000) && ($c != 0x40000000)) {
               .error("Option selected is not available for EDMA in bit field PRI(bit[29..31])")
	        } else {
                 .OPTION_VALUE = $1,
                 .OPTION_SETUP_update($1),
	           "ok"
		  }
	     }
        }
      }
	else{                                                               
         $a = $1 & 0x00000010, 
         $b = $1 & 0x00000800,  
         $c = $1 & 0x00008000, 
         $d = $1 & 0x18000000, 
         $e = $1 & 0x80000000, 
         $f = $1 & 0xE0000000, 
         if ($a != 0) {
                  .error("Bit field 4 is reserved")
         } else {
            if ($b !=0) {
                  .error("Bit field 11 is reserved")
            } else{
                if ($c != 0) {
                  .error("Bit field 15 is reserved")
                } else {     
                  if ($d == 0x18000000) {
                       .error("No such option for bit field ESIZE(bit[27..28])")
                   } else {
                   if(($f != 0x00000000) && ($f != 0x20000000) && ($f != 0x40000000) && ($f != 0x60000000)) {
                       .error("Option selected is not available for EDMA in bit field PRI(bit[29..31])")
                   } else {
                     .OPTION_VALUE = $1,
                     .OPTION_SETUP_update($1),
	               "ok"
                  }
                }
             }
             
          }
         }
       }                                                                     
      )
  }
    
    prop OPTION_SETUP_update :: (
       .FSYNC_SETUP =  ($1 & 0x00000001) ? "Enable" : "None",
       if(CSL.C64_SUPPORT){
       .PDTS_SETUP =   ($1 & 0x00000008) ? "Enable" : "Disable", 
       .PDTD_SETUP =   ($1 & 0x00000004) ? "Enable" : "Disable" 
        },
       .LINK_SETUP =   ($1 & 0x00000002) ? "Enable" : "Disable",
      if(CSL.C64_SUPPORT){
       .TCCM_SETUP =   ($1 & 0x00006000) >> 13 
       },
       .TCC_SETUP_NEW =    ($1 & 0x000F0000) >> 16,
       .TCINT_SETUP =  ($1 & 0x00100000) ? "Enable" : "Disable",
       if(CSL.C64_SUPPORT){
       .ATCINT_SETUP = ($1 & 0x00001000) ? "Enable" : "Disable",           
       .ATCC_SETUP =   ($1 & 0x000007E0) >> 5                              
       },
       .DUM_SETUP =    ($a = ($1 & 0x00600000),
                       ($a == 0x00200000) ? "Increment" :
	                 ($a == 0x00400000) ? "Decrement" :
	                 ($a == 0x00600000) ? "Index" : "None"),
	 .TDD_SETUP =    ($1 & 0x00800000) ? "Enable" : "Disable",
       .SUM_SETUP =    ($a = ($1 & 0x03000000),
                       ($a == 0x01000000) ? "Increment" :
	                 ($a == 0x02000000) ? "Decrement" :
	                 ($a == 0x03000000) ? "Index" : "None"),
	 .TDS_SETUP =    ($1 & 0x04000000) ? "Enable" : "Disable",
       .ESIZE_SETUP =  ($a = ($1 & 0x18000000),
                       ($a == 0x08000000) ? "16-bit" :
	                 ($a == 0x10000000) ? "8-bit" : "32-bit"),
        if(CSL.C64_SUPPORT){                                         
         .PRI_SETUP =     ( $a = ($1 & 0xE0000000),
                         ($a == 0x00000000) ? "Urgent(64x)" :
                         ($a == 0x40000000) ? "Medium" :
                         ($a == 0x20000000) ? "High" : "Low")
                
         }else{
           .PRI_SETUP =    ($a = ($1 & 0xE0000000),
                           ($a == 0x20000000) ? "High" : "Low")
          }
    )
    inst SRCADDR_VALUE ::= 0x00000000{
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Source Address (Old - should not be visible)"
	prop Format :: "0x%08X"
	prop Style :: 0x02
      prop Visible :: 0
      prop Writable :: (CSL.EDMA_SUPPORT != 0) ? 1 : 0
      prop NoGen :: 1
      prop cGen :: 0
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
                     .SRCADDR_VALUE = $1,
		     .SRCADDR_FORMAT = "Numeric",
		     .SRCADDR_FORMAT_ADV = .SRCADDR_FORMAT,
                 .SRCADDR_NUM = .SRCADDR_VALUE,
		     .SRCADDR_NUM_VALUE = .SRCADDR_NUM,
		     .SRCADDR_SYM = "NULL",
		     .SRCADDR_SYM_VALUE = .SRCADDR_SYM,
                     "ok"
                   )
    } 
       inst SRCADDR_FORMAT_ADV :: "Numeric" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Extern Decl. Obj.,User's Header file,McBSP handle (DRR)"
        prop Label:: "Source Address Format"
	prop JSName :: "edmaSrcAddrFormatAdv"
	prop Visible :: 1
	prop Writable :: CSL.EDMA_SUPPORT
	prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Advanced"
	prop Set :: (
		$a = 0,
		scan ($b; externDecl) {
			$a += 1
		},
		if ($a == 1 && $1 == "Extern Decl. Obj." ) {
                  .SRCADDR_FORMAT_ADV = "Numeric",
               	.error("You must create a Symbolic Address - See CSL Extern Declaration")
		} else {
                  if ( $1 == "User's Header file" && externDecl.HeaderFile == "NULL")     {
                  .SRCADDR_FORMAT_ADV = "Numeric",
       		.error("You must enter a Header file name  - See CSL Extern Declaration") 
             }  else {
                  .SRCADDR_FORMAT_ADV = $1 ,
                  .SRCADDR_FORMAT = $1,
                  if ($1 == "Numeric") {
                      .SRCADDR_SYM_VALUE = "NULL", 
                      .SRCADDR_HEADER_VALUE = "NULL" 
                  } else {
                        .SRCADDR_NUM_VALUE = 0x00000000
                  }, 
                  "ok"
		}
            }
	)
    } 
  inst SRCADDR_NUM_VALUE ::= 0x00000000{
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Source Address - Numeric "
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop JSName :: "edmaSrcAddrNumericAdv"
      prop Visible :: 1
      prop Writable ::CSL.EDMA_SUPPORT  && .SRCADDR_FORMAT_ADV == "Numeric"   
      prop NoGen :: 1
      prop cGen :: CSL.EDMA_SUPPORT  && 
                  (   .SRCADDR_FORMAT_ADV == "Numeric"  
                   || .SRCADDR_FORMAT_ADV == "McBSP handle (DRR)" 
                   || (.SRCADDR_FORMAT_ADV == "User's Header file" && .SRCADDR_HEADER_VALUE == "NULL")
                   || (.SRCADDR_FORMAT_ADV == "Extern Decl. Obj."  && .SRCADDR_SYM_VALUE == "NULL") 
                   )
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
                     .SRCADDR_NUM_VALUE = $1,
                     .SRCADDR_NUM = $1,
                     "ok"
                   )
    } 
   inst SRCADDR_SYM_VALUE ::= "NULL" {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	  prop Label :: "Source Address - Extern Decl.Obj"
	 
         prop Writable ::  0 
	  prop Visible :: 0
         prop NoGen :: 1
         prop cGen :: CSL.EDMA_SUPPORT && .SRCADDR_FORMAT_ADV == "Extern Decl. Obj." && .SRCADDR_SYM_VALUE != "NULL" 
         prop TabName :: "Advanced"
         prop cType :: "char[]" 
         prop cPreVal :: ( 
                   $a="",
		   scan ($b; externDecl) {
                       if (.SRCADDR_SYM_VALUE == $b.BuffName) {
                            if ($b.BuffSpec == "Array" )  {
                             $a = "(Uint32) "
                            } else {
                              $a = "(Uint32) &"
                            }
                        }     
		    }, 
                     $a
                 )   
        prop Set :: ( 
                    $a = 0, 
		   scan($b; externDecl) {
                    if (  $1 != "NULL"  &&  $1 == $b.BuffName ) {
                          if ( $b.BuffType == "NULL" )  {
                                $a = 1
                          } else {
                             if ( $1 == .DSTADDR_SYM_VALUE) {
                              $a = 2
                              } else {
                              $a = 3
                             } 
                          }
                      }
                   },
                    if ($a == 0 ) { 
                          .error("Symbolic Address  Not declared  - See CSL Extern Declaration")
                     } else {
                         if ( $a == 1) { 
                           .error("Symbol Type of this object is incorrect - See CSL Extern Declaration")
                           } else {
                             if ($a == 2 ) {
                              .error("Source and Destination must be different")
                             } else {
                             .SRCADDR_SYM = $1, 
                             .SRCADDR_SYM_VALUE = $1, 
                              "ok"
                             }
                         }
                      }
                        
                   ) 
       }  
    
     inst SRCADDR_HEADER_VALUE :: "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "Source Address - From User's Header File"
	prop Visible :: 0
	prop Writable :: 0 
	prop NoGen :: 1
      prop cGen :: CSL.EDMA_SUPPORT && .SRCADDR_FORMAT_ADV == "User's Header file" && .SRCADDR_HEADER_VALUE != "NULL"
      prop TabName :: "Advanced"
      prop cType :: "char[]" 
      prop cPreVal :: ("(Uint32) ") 
       }
    inst XFRCNT_VALUE :: 0x00000001{
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Transfer Counter"
	prop Format :: "0x%08X"
	prop Style :: 0x02
      prop Visible :: 0
      prop Writable :: (CSL.EDMA_SUPPORT != 0) ? 1 : 0
      prop NoGen :: 1
      prop cGen :: 0
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: ( 
                     .XFRCNT_VALUE = $1,
                     .FRAMECNT_NUM = $1 >> 16,
                     .ELMCNT_NUM = ($1 & 0x0000FFFF),
                     "ok"
                   )
    } 
    inst XFRCNT_FORMAT_ADV :: "Numeric" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,User's Header file"
      prop Label:: "Transfer Counter Format"
      prop JSName :: "edmaTransferCounterFormatAdv"
	prop Visible :: 1
	prop Writable :: CSL.EDMA_SUPPORT
	prop NoGen :: 1
      prop cGen :: 0
      prop TabName :: "Advanced"
	prop Set :: (
                  if ( $1 == "User's Header file" && externDecl.HeaderFile == "NULL")     {
                  .XFRCNT_FORMAT_ADV = "Numeric",
       		.error("You must enter a Header file name  - See CSL Extern Declaration") 
             }  else {
                      if ($1 == "Numeric") {
                         .ELMCNT_HEADER = "NULL", 
                         .FRAMECNT_HEADER = "NULL" 
                      } else {
                         .XFRCNT_NUM_VALUE = 0x00000000,
                         .ELMCNT_NUM = 0x0000,
                         .FRAMECNT_NUM = 0x0000 
                      },    
                      .XFRCNT_FORMAT_ADV = $1 ,
                      .XFRCNT_FORMAT = .XFRCNT_FORMAT_ADV,
                      "ok"
                   }
		
	)
    }
 
    inst XFRCNT_NUM_VALUE ::= 0x00000000 {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Transfer Counter - Numeric"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop JSName :: "edmaTransferCounterNumeric"
      prop Visible :: 1
      prop Writable :: CSL.EDMA_SUPPORT  && .XFRCNT_FORMAT_ADV == "Numeric" 
      prop NoGen :: 1
      prop cGen :: CSL.EDMA_SUPPORT  
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: ( 
                     .XFRCNT_NUM_VALUE = $1,
                     .FRAMECNT_NUM = $1 >> 16,
                     .ELMCNT_NUM = ($1 & 0x0000FFFF),
                     "ok"
                   )
    }
 
    inst DSTADDR_VALUE ::= 0x00000000{
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Destination Address (Old - should not be visible)"
	prop Format :: "0x%08X"
	prop Style :: 0x02
      prop Visible :: 0
      prop Writable :: (CSL.EDMA_SUPPORT != 0) ? 1 : 0
      prop NoGen :: 1
      prop cGen :: 0
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
                     .DSTADDR_VALUE = $1,
		     .DSTADDR_FORMAT = "Numeric",
		     .DSTADDR_FORMAT_ADV = .DSTADDR_FORMAT,
                     .DSTADDR_NUM = .DSTADDR_VALUE,
		     .DSTADDR_NUM_VALUE = .DSTADDR_NUM,
		     .DSTADDR_SYM = "NULL",
		     .DSTADDR_SYM_VALUE = .DSTADDR_SYM,
                     "ok"
                   )
    } 
 inst DSTADDR_FORMAT_ADV :: "Numeric" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Numeric,Extern Decl. Obj.,User's Header file,McBSP handle (DXR)"
        prop Label:: "Destination Address Format"
	prop JSName :: "edmaDstAddrFormatAdv"
	  prop Visible :: 1
	  prop Writable :: CSL.EDMA_SUPPORT
	  prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Advanced"
	  prop Set :: (
		$a = 0,
		scan ($b; externDecl) {
			$a += 1
		},
		if ($a == 1 && $1 == "Extern Decl. Obj." ) {
                  .DSTADDR_FORMAT_ADV = "Numeric",
        		.error("You must create a Symbolic object - See CSL Extern Declaration.")
		} else {
		if ($1 == "User's Header file" && externDecl.HeaderFile == "NULL") {
                  .DSTADDR_FORMAT_ADV = "Numeric",
        		.error("You must enter a Header file name  - See CSL Extern Declaration.")
		} else {
                  .DSTADDR_FORMAT_ADV = $1 ,
                  .DSTADDR_FORMAT = $1,
                  if ($1 == "Numeric") {
                      .DSTADDR_SYM_VALUE = "NULL" 
                  } else {
                   .DSTADDR_NUM_VALUE = 0x00000000   
                  },
                  "ok"
		}
            }
	)
    } 
    inst DSTADDR_NUM_VALUE ::= 0x00000000{
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Destination Address - Numeric "
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop JSName :: "edmaDstAddrNumericAdv"
      prop Visible :: 1
      prop Writable :: (CSL.EDMA_SUPPORT != 0 && .DSTADDR_FORMAT_ADV == "Numeric") ? 1 : 0
      prop NoGen :: 1
      prop cGen ::  CSL.EDMA_SUPPORT && 
                     ( .DSTADDR_FORMAT_ADV == "Numeric" 
                       || .DSTADDR_FORMAT_ADV == "McBSP handle (DXR)" 
                       || (.DSTADDR_FORMAT_ADV == "User's Header file" && .DSTADDR_HEADER_VALUE == "NULL")
                       || (.DSTADDR_FORMAT_ADV == "Extern Decl. Obj." && .DSTADDR_SYM_VALUE == "NULL")
                     )
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
                     .DSTADDR_NUM_VALUE = $1,
                     .DSTADDR_NUM = .DSTADDR_NUM_VALUE,
                     .DSTADDR_SYM = "NULL",
		     .DSTADDR_SYM_VALUE = .DSTADDR_SYM,
                     .DSTADDR_HEADER = "NULL",
		     .DSTADDR_HEADER_VALUE = .DSTADDR_HEADER,
                     "ok"
                   )
    } 
  inst DSTADDR_SYM_VALUE ::= "NULL" {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	  prop Label :: "Destination Address - Extern Decl. Obj"
	  
	  prop Visible :: 0
	  prop Writable ::  0 
	  prop NoGen :: 1
        prop cGen :: CSL.EDMA_SUPPORT && (.DSTADDR_FORMAT_ADV == "Extern Decl. Obj." && .DSTADDR_SYM_VALUE != "NULL")
        prop TabName :: "Advanced"
        prop cType :: "char[]" 
        prop cPreVal :: ( 
                  $a="",
		   scan ($b; externDecl) {
                       if (.DSTADDR_SYM_VALUE == $b.BuffName) {
                            if ($b.BuffSpec == "Array")  {
                             $a = "(Uint32) "
                            } else {
                              $a = "(Uint32) &"
                            }
                        }     
		    }, 
                     $a
                      
                      )    
        prop Set :: ( 
                    $a = 0, 
		   scan($b; externDecl) {
                    if (  $1 != "NULL"  &&  $1 == $b.BuffName ) {
                          if ( $b.BuffType == "NULL" )  {
                                $a = 1
                          } else {
                             if ( $1 == .SRCADDR_SYM_VALUE) {
                              $a = 2
                              } else {
                              $a = 3
                             } 
                          }
                      }
                   },
                    if ($a == 0 ) { 
                          .error("Symbolic Address  Not declared  - See CSL Extern Declaration")
                     } else {
                         if ( $a == 1) { 
                           .error("Symbol Type of this object is incorrect - See CSL Extern Declaration")
                           } else {
                             if ($a == 2 ) {
                              .error("Source and Destination must be different")
                             } else {
                             .DSTADDR_SYM = $1, 
                             .DSTADDR_SYM_VALUE = $1, 
                              "ok"
                             }
                         }
                      }
                        
                   ) 
       }  
    
     inst DSTADDR_HEADER_VALUE :: "NULL" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Label :: "Destination Address - From User's Header file"
	prop Visible :: 0
	prop Writable :: 0 
	prop NoGen :: 1
      prop cGen :: CSL.EDMA_SUPPORT && .DSTADDR_FORMAT_ADV == "User's Header file" && .DSTADDR_HEADER_VALUE != "NULL"
      prop TabName :: "Advanced"
      prop cType :: "char[]" 
      prop cPreVal :: ("(Uint32) ") 
       }
    
    inst INDEX_VALUE ::= 0x00000000{
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Transfer Index -Old stuff "
	prop Format :: "0x%08X"
	prop Style :: 0x02
        prop Visible :: 0
        prop Writable :: (CSL.EDMA_SUPPORT != 0) ? 1 : 0
        prop NoGen :: 1
        prop cGen :: 0
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: ( 
	    .INDEX_VALUE = $1,
	    .XFRIDX_NUM_VALUE = $1,
	    .FRAMEIDX_NUM = $1 >> 16,
	    .ELMIDX_NUM = ($1 & 0x0000FFFF),
	    "ok"
        )
    }
  inst XFRIDX_FORMAT_ADV :: "Numeric" {
      prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
      prop Enum :: "Numeric,User's Header file"
      prop Label:: "Index Format"
      prop JSName :: "edmaIndexFormatAdv"
	prop Visible :: 1
	prop Writable :: CSL.EDMA_SUPPORT
	prop NoGen :: 1
      prop cGen :: 0
      prop TabName :: "Advanced"
	prop Set :: (
                  if ( $1 == "User's Header file" && externDecl.HeaderFile == "NULL")     {
                  .XFRIDX_FORMAT_ADV = "Numeric",
       		.error("You must enter a Header file name  - See CSL Extern Declaration") 
             }  else {
                      if ($1 == "Numeric") {
                         .ELMIDX_HEADER = "NULL", 
                         .FRAMEIDX_HEADER = "NULL" 
                      } else {
                         .XFRIDX_NUM_VALUE = 0x0000,
                         .ELMIDX_NUM =0x0000 ,
                         .FRAMEIDX_NUM =0x0000
                      },    
                      .XFRIDX_FORMAT_ADV = $1 ,
                      .XFRIDX_FORMAT = .XFRIDX_FORMAT_ADV,
                      "ok"
                   }
		
	)
    }
  inst XFRIDX_NUM_VALUE ::= 0x00000000 {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Index register - Numeric"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop JSName :: "edmaIndexNumeric"
      prop Visible :: 1
      prop Writable :: CSL.EDMA_SUPPORT  && .XFRIDX_FORMAT_ADV == "Numeric" 
      prop NoGen :: 1
      prop cGen :: CSL.EDMA_SUPPORT  
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: ( 
                     .XFRIDX_NUM_VALUE = $1,
                     .FRAMEIDX_NUM = $1 >> 16,
                     .ELMIDX_NUM = ($1 & 0x0000FFFF),
                     
                     "ok"
                   )
    }
    inst RLD_LNK_VALUE ::= (
       if (.LINK_SETUP == "Enable" && .LINK_FORMAT == "Table Number" && !CSL.C64_SUPPORT ) { 0x000001B0 }
         else {
             if (.LINK_SETUP == "Enable" && .LINK_FORMAT == "Table Number" && CSL.C64_SUPPORT ) { 0x00000630 }
   
             else { 0x00000000
                  }
             }
        ) 
        {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Element Count Reload and Link Address"
	prop Format :: "0x%08X"
	prop Style :: 0x02
	prop JSName :: "edmaEcrldLinkAddr"
      prop Visible :: 1
      prop Writable :: (CSL.EDMA_SUPPORT != 0 ) ? 1 : 0
      prop NoGen :: 1
      prop cGen :: (CSL.EDMA_SUPPORT != 0 ) ? 1 : 0
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
                    $a=($1 & 0x0000FFFF) ,
              if ( !CSL.C64_SUPPORT) {
                    if ( .LINK_FORMAT == "Table Number" && ($a > 0x07E0 ||  $a < 0x01B0)) { 
                              .error(" Link Address wrong : Table 0 (0x01B0) - Table 68 (0x07E0)")
                   } else {  
                  if (.LINK_FORMAT == "Table Number") {   
                     .ECRLD = $1 >> 16,
                     .LINKADDR = (($1 & 0x0000FFFF)-0x01B0)/24,
                     .RLD_LNK_VALUE = ($1 & 0xFFFF000) | ((.LINKADDR * 24)+0x01B0),
                     "ok"
                 } else {
                     .RLD_LNK_VALUE = ($1 & 0xFFFF0000), 
                     .ECRLD = $1 >> 16,
                     .LINKADDR = (($1 & 0x0000FFFF)-0x01B0)/24,
                      "ok"
                     }
                   }
               }else { 
          if ( .LINK_FORMAT == "Table Number" && ($a > 0x07E0 ||  $a < 0x0630)) { 
                              .error(" Link Address wrong : Table 0 (0x0630) - Table 17 (0x07E0)")
                   } else {  
                  if (.LINK_FORMAT == "Table Number") {   
                     .ECRLD = $1 >> 16,
                     .LINKADDR = (($1 & 0x0000FFFF)-0x0630)/24,
                     .RLD_LNK_VALUE = ($1 & 0xFFFF000) | ((.LINKADDR * 24)+0x0630),
                     "ok"
                 } else {
                     .RLD_LNK_VALUE = ($1 & 0xFFFF0000), 
                     .ECRLD = $1 >> 16,
                     .LINKADDR = (($1 & 0x0000FFFF)-0x0630)/24,
                      "ok"
                     }
                   }
             }
           )
    }
 prop CheckAllocateTable :: (
                $a=0,
                scan($b;hEdmaTbl) {
                     if (.LINK_TBLHANDLE == $b) {
                            if ($b.EDMA_PRAMTABLE_ALLOC == 1) {
                              $a+=1
                            }
                        }
                  }, 
                    if ($a == 0 ) {
                               .LINK_PARAMTBL = PARAMTBL_NOTHING,
                               "Allocate Table first"   
                             } else  {
                                   "done"
                             }
                               
  )
   prop configStruct :: self
   prop cfgStrRLD:: (.LINK_FORMAT == "Table Handle" && .LINK_TBLHANDLE !=PARAMTBL_NOTHING && .CheckAllocateTable == "done") ? "%5t%3s.rld = (%3s.rld & 0xFFFF0000) | (EDMA_RLD_RMK(0," : ""
   prop TblHandle :: (.LINK_FORMAT == "Table Handle" && .LINK_TBLHANDLE != PARAMTBL_NOTHING && .CheckAllocateTable == "done" ) ? .LINK_TBLHANDLE : ""
   prop TblMaskStr :: (.LINK_FORMAT == "Table Handle"&& .LINK_TBLHANDLE != PARAMTBL_NOTHING && .CheckAllocateTable == "done" ) ? "%4s));\n%0t" : ""
 
   prop cfgStrCNT   :: (.XFRCNT_FORMAT == "User's Header file" ) ? "%5t%3s.cnt = EDMA_CNT_RMK(" : ""
   prop FramecntStr :: (
              if (.XFRCNT_FORMAT == "User's Header file" && .FRAMECNT_HEADER == "NULL" ) {
                        "0"
               } else { 
                  if (.XFRCNT_FORMAT == "User's Header file" && .FRAMECNT_HEADER != "NULL" ) {
                     .FRAMECNT_HEADER
                  } else {
                        ""
                  }      
               }
         )
   prop ElmcntStr   :: (
         if (.XFRCNT_FORMAT == "User's Header file" && .ELMCNT_HEADER == "NULL" ) {
                        "0"
               } else { 
                  if (.XFRCNT_FORMAT == "User's Header file" && .ELMCNT_HEADER != "NULL" ) {
                     .ELMCNT_HEADER
                  } else {
                        ""
                  }      
               }
             )
 
   prop XfrCntStr   :: (.XFRCNT_FORMAT == "User's Header file" ) ? "%7s,%8s);\n%0t" : ""  
 
 prop cfgStrIDX   :: (.XFRIDX_FORMAT == "User's Header file" ) ? "%5t%3s.idx = EDMA_IDX_RMK(" : ""
 prop FrameidxStr :: (
              if (.XFRIDX_FORMAT == "User's Header file" && .FRAMEIDX_HEADER == "NULL" ) {
                        "0"
               } else { 
                  if (.XFRIDX_FORMAT == "User's Header file" && .FRAMEIDX_HEADER != "NULL" ) {
                     .FRAMEIDX_HEADER
                  } else {
                        ""
                  }      
               }
         )
 prop ElmidxStr   :: (
         if (.XFRIDX_FORMAT == "User's Header file" && .ELMIDX_HEADER == "NULL" ) {
                        "0"
               } else { 
                  if (.XFRIDX_FORMAT == "User's Header file" && .ELMIDX_HEADER != "NULL" ) {
                     .ELMIDX_HEADER
                  } else {
                        ""
                  }      
               }
             )
 
   prop XfrIdxStr   :: (.XFRIDX_FORMAT == "User's Header file" ) ? "%11s,%12s);\n%0t" : ""  
 prop cfgStrSRC   :: (.SRCADDR_FORMAT == "McBSP handle (DRR)" && .SRCADDR_HANDLE != "NULL") ? "%5t%3s.src = EDMA_SRC_RMK(" : ""
 prop SrcHandle :: (.SRCADDR_FORMAT == "McBSP handle (DRR)" && .SRCADDR_HANDLE != "NULL") ? .SRCADDR_HANDLE : ""
 prop SrcStr :: (.SRCADDR_FORMAT == "McBSP handle (DRR)" && .SRCADDR_HANDLE != "NULL") ? "%15s->drrAddr);\n%0t" : ""
 prop cfgStrDST   :: (.DSTADDR_FORMAT == "McBSP handle (DXR)" && .DSTADDR_HANDLE != "NULL") ? "%5t%3s.dst = EDMA_DST_RMK(" : ""
 prop DstHandle :: (.DSTADDR_FORMAT == "McBSP handle (DXR)" && .DSTADDR_HANDLE != "NULL") ? .DSTADDR_HANDLE : ""
 prop DstStr :: (.DSTADDR_FORMAT == "McBSP handle (DXR)" && .DSTADDR_HANDLE != "NULL") ? "%18s->dxrAddr);\n%0t" : ""
prop cGenFxnPostInst :: (
         "%1S%2S%5S%6S%9S%10S%13S%14S%16S%17S\0,cfgStrRLD,TblMaskStr,configStruct,TblHandle,cfgStrCNT,XfrCntStr,FramecntStr,ElmcntStr,cfgStrIDX,XfrIdxStr,FrameidxStr,ElmidxStr,cfgStrSRC,SrcStr,SrcHandle,cfgStrDST,DstStr,DstHandle"
  )
 
}
type hEdma {
	isa ObjectMgr
	prop name :: "hEdma"
	prop Label :: "EDMA Resource Manager"
	prop JSName :: "HEDMA"
      prop SortChildHierView :: 0 
      prop IsContainedIn :: EDMAFOLDER 
      prop GlobalIcon :: 165
      prop InstanceIcon :: 166
      prop GlobalHelpTopic :: 1032
      prop InstanceHelpTopic :: 1033
	prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-00105A98CA0B}"
      prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-0000C070F3E9}"
    	prop Vendor :: "vendor1"
    	prop Version :: "1.00.00"
	prop maxObjs :: 64
	prop NoGen :: 1
	prop cGen :: CSL.EDMA_SUPPORT
	prop cHandle :: .cOpenGen
	prop cHeaderName :: (
	    $a = "",
	    scan ($b;hEdma) {
		if ($b.EDMA_HANDLE_ENABLE) {
		    $a = "csl_edma.h"
		}
	    },
	    $a
	)
	prop cHandleType :: "EDMA_Handle"
	prop cOpenName :: "EDMA_open"
	prop cConfigName :: "EDMA_config"
	prop cHandleName :: .HandleName 
	prop cStructQual :: "far"
  
      prop localCanCreate :: (
                .error("New EDMA handle objects cannot be created")
      )
      prop localCanDelete :: (
                .error("EDMA handle objects cannot be deleted")
      )
    prop cGenFxnPostInst :: (
        if ((.CHA_ENABLE == 1) && (.HandleName != "")) { 
                "%5tEDMA_enableChannel(%1s);%0t\n\0, cHandleName"
        }
        else {
                ""
        }
    )
 
  
	inst cOpenGen ::= ((.EDMA_HANDLE_ENABLE != 0)&&(CSL.EDMA_SUPPORT != 0) && (.HandleName != ""))  {
	    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Label :: "Open Handle"
	    prop Visible :: 0
	    prop Writable :: 1
	    prop NoGen :: 1
	    prop cGen :: 1
	}
	inst cOpenArg0 :: "EDMA_CHA_ANY" {
	     prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	     prop Label :: "Open Arg 0"
	     prop Visible :: 0
	     prop Writable :: CSL.EDMA_SUPPORT
	     prop NoGen :: 1
	}
	inst cOpenArg1 :: "EDMA_OPEN_RESET" {
	     prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	     prop Label :: "Open Arg 1"
	     prop Visible :: 0
	     prop Writable :: CSL.EDMA_SUPPORT
	     prop NoGen :: 1
	}
   inst DEVICE :: "EDMA_none" {
       prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
       prop Label :: "device"
       prop Visible :: 0
       prop Writable ::CSL.EDMA_SUPPORT
      }
     inst EDMA_HANDLE_ENABLE :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Open EDMA Channel"
	  prop JSName :: "edmaHandleEnable"
	  prop Visible :: 1
        prop Writable :: ( ((CSL.EDMA_SUPPORT && CSL.C64_SUPPORT) || ( !CSL.C64_SUPPORT && ( .DEVICE == "EDMA_CHA_DSPINT" || .DEVICE == "EDMA_CHA_TINT0" || .DEVICE == "EDMA_CHA_TINT1" || .DEVICE == "EDMA_CHA_SDINT" || .DEVICE == "EDMA_CHA_EXTINT4" || .DEVICE == "EDMA_CHA_EXTINT5" || .DEVICE == "EDMA_CHA_EXTINT6" || .DEVICE == "EDMA_CHA_EXTINT7" || .DEVICE == "EDMA_CHA_TCC8" || .DEVICE == "EDMA_CHA_TCC9" || .DEVICE == "EDMA_CHA_TCC10" || .DEVICE == "EDMA_CHA_TCC11" || .DEVICE == "EDMA_CHA_XEVT0" || .DEVICE == "EDMA_CHA_REVT0" || .DEVICE == "EDMA_CHA_XEVT1" || .DEVICE == "EDMA_CHA_REVT1") ))&& CSL.EDMA_SUPPORT) ? 1: 0
        prop NoGen :: 1 
        prop Set ::  (
                       .EDMA_HANDLE_ENABLE = $1,
                       if( $1 == 0 ){
                          .EDMA_HANDLE_ENABLE = $1,
                          .PINIT_ENABLE = $1,
                          .cOpenArg0 = "EDMA_None",
                          .PINIT = EDMA_NOTHING,
                          "ok"
                       } else { 
                         if ( CSL.C64_SUPPORT && .DEVICE == "EDMA_CHA_TCC8") {  
                               .cOpenArg0 = "EDMA_CHA_GPINT0",
                               "ok"  }
                         else {
                          if (CSL.C64_SUPPORT && .DEVICE == "EDMA_CHA_TCC9") { 
                                .cOpenArg0 = "EDMA_CHA_GPINT1",
                                 "ok" }
                            else {
                              if (CSL.C64_SUPPORT && .DEVICE == "EDMA_CHA_TCC10") { 
                                .cOpenArg0  = "EDMA_CHA_GPINT2",
                                 "ok" }
                               else {
                                   if (CSL.C64_SUPPORT && .DEVICE == "EDMA_CHA_TCC11") 
                                   { .cOpenArg0  = "EDMA_CHA_GPINT3", 
                                     "ok"  }
                                     else {
                                      .cOpenArg0 = .DEVICE,
                                       "ok"
                                     }
                                }
                             }
                          }
                       }     
                   )
          }
     inst HandleName ::= self {
       prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
       prop Label :: "Handle"
       prop JSName :: "edmaHandleName"
       prop Visible :: 1
       prop Writable :: CSL.EDMA_SUPPORT & .EDMA_HANDLE_ENABLE
     }
     inst PINIT_ENABLE ::= 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable Pre-Initialization"
	prop JSName :: "edmaEnablePreInit"
	prop Visible :: 1
	prop Writable :: ((CSL.EDMA_SUPPORT != 0) && (.EDMA_HANDLE_ENABLE == 1) ) ? 1 : 0
	prop NoGen :: 1
	prop Set :: (
		$a = 0,
		scan ($b; edmaCfg) {
			$a += 1
		},
		if ($a == 1) {
                  .PINIT_ENABLE = 0,
			"You must create a EDMA configuration object first"
		} else {
                  .PINIT_ENABLE = $1,
                  if ($1 == 0) {
                      .PINIT = EDMA_NOTHING,
                      .CHA_ENABLE = 0
                  },
                  "ok"
		}
	)
    }
     inst PINIT :: EDMA_NOTHING {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: edmaCfg
	prop Label :: "Pre-Initialize with"
	prop JSName :: "edmaPreInit"
	prop Visible :: 1
	prop Writable :: (  (.PINIT_ENABLE == 1) 
                        &&(CSL.EDMA_SUPPORT != 0) 
                        &&(.EDMA_HANDLE_ENABLE == 1)
                         )? 1 : 0
	prop NoGen :: 1
    }
     inst cConfigGen ::= (  (.PINIT_ENABLE == 1) 
                          &&(CSL.EDMA_SUPPORT != 0) 
                          &&(.EDMA_HANDLE_ENABLE == 1) 
                          &&(.PINIT != EDMA_NOTHING) 
                          && (.HandleName != "") 
                              ) {
	    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Label :: "Enable Pre-Configuration"
	    prop Visible :: 0
	    prop Writable :: ((CSL.EDMA_SUPPORT != 0) & (.cConfigGen == 1)) ? 1 : 0
	    prop NoGen :: 1
	    prop cGen :: 1
	}
	inst cConfigArg0 ::= .cHandleName  {
	    prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Label :: "Config argument 0"
	    prop Visible :: 0
	    prop Writable :: ((CSL.EDMA_SUPPORT != 0) & (.cConfigGen == 1)) ? 1 : 0
          prop Set :: (
            .cConfigArg0 = .HandleName,
            "ok"
          )
	}
	inst cConfigArg1 ::= .PINIT {
          prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Label :: "Config argument 1"
	    prop Visible :: 0
	    prop Writable :: ((CSL.EDMA_SUPPORT != 0) & (.cConfigGen == 1)) ? 1 : 0
          prop cPreVal :: "&"
	}
    
    inst CHA_ENABLE :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable Selected Channel"
	prop JSName :: "edmaEnableChannel"
	prop Visible :: 1
	prop Writable :: (  (CSL.EDMA_SUPPORT != 0) 
                        &&(.PINIT_ENABLE == 1)
                        &&(.PINIT != EDMA_NOTHING)
                        &&( CSL.C64_SUPPORT || (!CSL.C64_SUPPORT && (   
                               .cOpenArg0 != "EDMA_CHA_TCC8"   
                           &&  .cOpenArg0 != "EDMA_CHA_TCC9"   
                           &&  .cOpenArg0 != "EDMA_CHA_TCC10"   
                           &&  .cOpenArg0 != "EDMA_CHA_TCC11"))
   
                                                ) ? 1 : 0 )
	prop NoGen :: 1
  
    }
}
object EDMA_Channel0_DSPINT :: hEdma {
	 param iComment :: "Host to DSP Interrupt"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha0"
        
          param DEVICE :: "EDMA_CHA_DSPINT"
          param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel1_TINT0 :: hEdma {
	 param iComment :: "Timer 0 Interrupt"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha1"
         
         param DEVICE :: "EDMA_CHA_TINT0"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel2_TINT1 :: hEdma {
	 param iComment :: "Timer 1 Interrupt"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha2"
         param DEVICE :: "EDMA_CHA_TINT1"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel3_SDINT :: hEdma {
	 param iComment :: "EMIF Timer Interrupt"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha3"
         param DEVICE :: "EDMA_CHA_SDINT"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel4_EXTINT4_GPINT4 :: hEdma {
	 param iComment :: "External Interrupt Pin 4/ GPIO Evt 4 (64x only)"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha4"
         param DEVICE :: "EDMA_CHA_EXTINT4"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel5_EXTINT5_GPINT5 :: hEdma {
	 param iComment :: "External Interrupt Pin 5/GPIO Evt 5 (64x only)"   
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha5"
         param DEVICE :: "EDMA_CHA_EXTINT5"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel6_EXTINT6_GPINT6  :: hEdma {
	 param iComment :: "External Interrupt Pin 6/GPIO Evt 6 (64x only)"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha6"
         param DEVICE :: "EDMA_CHA_EXTINT6"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel7_EXTINT7_GPINT7 :: hEdma {
	 param iComment :: "External Interrupt Pin 7/GPIO Evt 7 (64x only)"   
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha7"
         param DEVICE :: "EDMA_CHA_EXTINT7"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel8_TCC8_GPINT0 :: hEdma {
	   param iComment :: "C621x/C671x EDMA_TCC 1000b Interrupt, C64x GPIO Evt 0"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha8"
         param DEVICE :: "EDMA_CHA_TCC8"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel9_TCC9_GPINT1 :: hEdma {
	   param iComment :: "C621x/C671x EDMA_TCC 1001b Interrupt, C64x GPIO Evt 1"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha9"
         param DEVICE :: "EDMA_CHA_TCC9"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel10_TCC10_GPINT2  :: hEdma {
	  param iComment :: "C621x/C67x EDMA_TCC 1010b Interrupt, C64x GPIO Evt 2"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha10"
         param DEVICE :: "EDMA_CHA_TCC10"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel11_TCC11_GPINT3  :: hEdma {
	 param iComment :: "C621x/C671x EDMA_TCC 1011b Interrupt, C64x GPIO Evt 3"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha11"
         param DEVICE :: "EDMA_CHA_TCC11"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel12_XEVT0 :: hEdma {
	 param iComment :: "McBSP 0 Transmit Event"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha12"
         param DEVICE :: "EDMA_CHA_XEVT0"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel13_REVT0 :: hEdma {
	 param iComment :: "McBSP 0 Receive Event"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha13"
         param DEVICE :: "EDMA_CHA_REVT0"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel14_XEVT1 :: hEdma {
	 param iComment :: "McBSP 1 Transmit Event"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha14"
         param DEVICE :: "EDMA_CHA_XEVT1"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel15_REVT1 :: hEdma {
	 param iComment :: "McBSP 1 Receive Event"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha15"
         param DEVICE :: "EDMA_CHA_REVT1"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel16 :: hEdma {                                    
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha16"
         
         param DEVICE :: "16"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel17_XEVT2 :: hEdma {                                    
	 param iComment :: "C64x only! McBSP 2 Transmit Event"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha17"
         param DEVICE :: "EDMA_CHA_XEVT2"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel18_REVT2 :: hEdma {
	 param iComment :: "C64x only! McBSP 2 Receive Event"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha18"
         param DEVICE :: "EDMA_CHA_REVT2"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel19_TINT2 :: hEdma {
	 param iComment :: "C64x only! TIMER 2 Interrupt"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha19"
         param DEVICE :: "EDMA_CHA_TINT2"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel20_SDINTB :: hEdma {
	 param iComment :: "C64x only! EMIFB SDRAM timer interrupt"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha20"
         param DEVICE :: "EDMA_CHA_SDINTB"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel21_PCI :: hEdma {
	 param iComment :: "C64x only! PCI Wakeup Interrupt"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha21"
         param DEVICE :: "EDMA_CHA_PCI"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel22 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha22"
         param DEVICE :: "22"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel23 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha23"
         param DEVICE :: "23"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel24 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha24"
         param DEVICE :: "24"
         param PINIT :: EDMA_NOTHING
       }
  
object EDMA_Channel25 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha25"
         param DEVICE :: "25"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel26 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha26"
         param DEVICE :: "26"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel27 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha27"
         param DEVICE :: "27"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel28_VCPREVT :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha28"
         param DEVICE :: "EDMA_CHA_VCPREVT"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel29_VCPXEVT :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha29"
         param DEVICE :: "EDMA_CHA_VCPXEVT"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel30_TCPREVT :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha30"
         param DEVICE :: "EDMA_CHA_TCPREVT"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel31_TCPXEVT :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha31"
         param DEVICE :: "EDMA_CHA_TCPXEVT"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel32_UREVT :: hEdma {
	 param iComment :: "C64x only! Utopia Receive Event"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha32"
         param DEVICE :: "EDMA_CHA_UREVT"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel33 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha33"
         param DEVICE :: "33"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel34 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha34"
         param DEVICE :: "34"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel35 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha35"
         param DEVICE :: "35"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel36 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha36"
         param DEVICE :: "36"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel37 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha37"
         param DEVICE :: "37"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel38 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha38"
         param DEVICE :: "38"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel39 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha39"
         param DEVICE :: "39"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel40_UXEVT :: hEdma {
	 param iComment :: "C64x only! UTOPIA transmit event"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha40"
         param DEVICE :: "EDMA_CHA_UXEVT"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel41 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha41"
         param DEVICE :: "41"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel42 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha42"
         param DEVICE :: "42"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel43 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha43"
         param DEVICE :: "43"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel44 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha44"
         param DEVICE :: "44"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel45 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha45"
         param DEVICE :: "45"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel46 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha46"
         param DEVICE :: "46"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel47 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha47"
         param DEVICE :: "47"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel48_GPINT8 :: hEdma {
	 param iComment :: "C64x only! GPIO event 8"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha48"
         param DEVICE :: "EDMA_CHA_GPINT8"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel49_GPINT9 :: hEdma {
	 param iComment :: "C64x only! GPIO event 9"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha49"
         param DEVICE :: "EDMA_CHA_GPINT9"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel50_GPINT10 :: hEdma {
	 param iComment :: "C64x only! GPIO event 10"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha50"
         param DEVICE :: "EDMA_CHA_GPINT10"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel51_GPINT11 :: hEdma {
	 param iComment :: "C64x only! GPIO event 11"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha51"
         param DEVICE :: "EDMA_CHA_GPINT11"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel52_GPINT12 :: hEdma {
	 param iComment :: "C64x only! GPIO event 12"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha52"
         param DEVICE :: "EDMA_CHA_GPINT12"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel53_GPINT13 :: hEdma {
	 param iComment :: "C64x only! GPIO event 13"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha53"
         param DEVICE :: "EDMA_CHA_GPINT13"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel54_GPINT14 :: hEdma {
	 param iComment :: "C64x only! GPIO event 14"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha54"
         param DEVICE :: "EDMA_CHA_GPINT14"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel55_GPINT15 :: hEdma {
	 param iComment :: "C64x only! GPIO event 15"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha55"
         param DEVICE :: "EDMA_CHA_GPINT15"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel56 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha56"
         param DEVICE :: "56"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel57 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha57"
         param DEVICE :: "57"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel58 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha58"
         param DEVICE :: "58"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel59 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha59"
         param DEVICE :: "59"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel60 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha60"
         param DEVICE :: "60"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel61 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha61"
         param DEVICE :: "61"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel62 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha62"
         param DEVICE :: "62"
         param PINIT :: EDMA_NOTHING
       }
object EDMA_Channel63 :: hEdma {
	 param iComment :: "None"  
         param iIsUsed :: 1
         param iDelUser :: "hEdma"
         param iDelMsg :: (
	"This EDMA Handle object cannot be deleted"
	)
         param HandleName :: "hEdmaCha63"
         param DEVICE :: "63"
         param PINIT :: EDMA_NOTHING
       }
type hEdmaTbl {
	isa ObjectMgr
	prop name :: "hEdma Table"
	prop Label :: "Parameter RAM Table Entry"
	prop JSName :: "EdmaTable"
      prop IsContainedIn :: EDMAFOLDER 
      prop GlobalIcon :: 165
      prop InstanceIcon :: 166
      prop GlobalHelpTopic :: 1034
      prop InstanceHelpTopic :: 1035
	prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-00105A98CA0B}"
      prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-0000C070F3E9}"
    	prop Vendor :: "vendor1"
    	prop Version :: "1.00.00"
	prop maxObjs :: 69
	prop NoGen :: 1
	prop cGen :: CSL.EDMA_SUPPORT
	prop cHandle :: .cOpenGen
	prop cHeaderName :: .gNumOf > 0 ? "csl_edma.h" : ""
	prop cHandleType :: "EDMA_Handle"
	prop cOpenName :: "EDMA_allocTable"
	prop cConfigName :: "EDMA_config"
	prop cHandleName :: self
	prop cStructQual :: "far"
	inst cOpenGen ::= ((.EDMA_PRAMTABLE_ALLOC != 0) && (CSL.EDMA_SUPPORT != 0)) {
	    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Label :: "Table Allocation"
	    prop Visible :: 0
	    prop Writable :: CSL.EDMA_SUPPORT
	    prop NoGen :: 1
	    prop cGen :: 1
	}
	inst cOpenArg0 ::= .TBL_NUM{
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "%2d"
        prop Style :: 0x02
	  prop Label :: "Open Arg 0"
	  prop Visible :: 0
	  prop Writable :: CSL.EDMA_SUPPORT
	  prop NoGen :: 1
	}
  inst EDMA_PRAMTABLE_ALLOC ::=( if (self==PARAMTBL_NOTHING) { 0 } else { 1 }) {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Allocate Parameter RAM Table"
	  prop JSName :: "edmaAllocPramTable"
	  prop Visible :: 1
	  prop Writable :: CSL.EDMA_SUPPORT
	  prop NoGen :: 1
	  prop Set ::  (
                       if( $1 == 0 ){
                          .EDMA_PRAMTABLE_ALLOC = 0,
                          .PINIT_ENABLE = $1,
                          .cOpenArg0 = 0,
                          .PINIT = EDMA_NOTHING
                       } else {
                          .EDMA_PRAMTABLE_ALLOC = $1
                       },
                       "ok"
			)		
    	}
	inst TBL_NUM ::= -1  {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: "Allocate Table Number"
	prop JSName :: "edmaTableNumber"
        prop Visible :: 1
        prop Writable :: ((.EDMA_PRAMTABLE_ALLOC == 1) && (CSL.EDMA_SUPPORT != 0))
        prop NoGen :: 1
	  prop Set ::  (
                       if(($1 < -1) || ($1 > 66) && CSL.C11_SUPPORT){
                          .error("Invalid Table Number,  table number range [0..66] and -1 for any available table")
                       } else {
                           if(($1 < -1) || ($1 > 18) && CSL.C64_SUPPORT){
                          .error("Invalid Table Number,  table number range [0..18] and -1 for any available table")
                          }else { 
                          .TBL_NUM = $1,
                          "ok"
                          }
                       }
        )
    	}
    inst PINIT_ENABLE ::= 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable Pre-Initialization"
	prop JSName :: "edmaEnablePreInit"
	prop Visible :: 1
	prop Writable :: ((.EDMA_PRAMTABLE_ALLOC == 1) && (CSL.EDMA_SUPPORT != 0)) ? 1 : 0
	prop NoGen :: 1
	prop Set :: (
		$a = 0,
		scan ($b; edmaCfg) {
			$a += 1
		},
		if ($a == 1) {
                  .PINIT_ENABLE = 0,
			.error("You must create a EDMA configuration object first")
		} else {
			.PINIT_ENABLE = $1,
                  if ($1 == 0) {
                      .PINIT = EDMA_NOTHING
                  },
                  "ok"
		}
	)
    }
     inst PINIT :: EDMA_NOTHING {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: edmaCfg
	prop Label :: "Pre-Initialize with"
	prop JSName :: "edmaPreInit"
	prop Visible :: 1
	prop Writable :: ((CSL.EDMA_SUPPORT != 0)&&(.PINIT_ENABLE == 1)) ? 1 : 0
	prop NoGen :: 1
    }
     inst cConfigGen ::= (   (.PINIT_ENABLE == 1) 
                          && (.PINIT != EDMA_NOTHING) 
                          && (CSL.EDMA_SUPPORT != 0))  {
	    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Label :: "Enable Pre-Configuration"
	    prop Visible :: 0
	    prop Writable :: ((CSL.EDMA_SUPPORT != 0) && (.cConfigGen == 1)) ? 1 : 0
	    prop NoGen :: 1
	    prop cGen :: 1
	}
	inst cConfigArg0 :: self {
	    prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Label :: "Config argument 0"
	    prop Visible :: 0
	    prop Writable :: ((CSL.EDMA_SUPPORT != 0) && (.cConfigGen == 1)) ? 1 : 0
	}
	inst cConfigArg1 ::= .PINIT {
          prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
          prop Label :: "Config argument 1"
	    prop Visible :: 0
	    prop Writable :: ((CSL.EDMA_SUPPORT != 0) && (.cConfigGen == 1)) ? 1 : 0
          prop cPreVal :: "&"
	}
}
	
object EDMA_NOTHING :: edmaCfg {
    param iIsUsed :: 0
}
object PARAMTBL_NOTHING :: hEdmaTbl {
    param iIsUsed :: 0
    param EDMA_PRAMTABLE_ALLOC :: 0  
}
type EMIFFOLDER {
    isa ModuleFolder
    prop IsContainedIn :: CSL 
       	    	
   prop name :: "EMIF"
   prop Label :: "EMIF - External Memory Interface"
   prop NoGen :: 1
   prop GlobalPropertyPage :: "{980E6524-6246-11d4-B5CC-0050DA2E2CC0}"
   prop InstancePropertyPage :: "{980E6525-6246-11d4-B5CC-0050DA2E2CC0}"
   prop GlobalIcon :: 163
   prop InstanceIcon :: 164
   prop GlobalHelpTopic :: (
	   1040
   )
}   
  
type emifCfg {
    isa ObjectMgr
    prop Name :: "emifCfg"
    prop Label :: "EMIF Configuration Manager"
    prop JSName :: "EMIF"
    prop IsContainedIn :: EMIFFOLDER
    prop NoGen :: 1
    prop maxObjs :: (32767)
    prop GlobalPropertyPage :: "{980E6522-6246-11d4-B5CC-0050DA2E2CC0}"
    prop InstancePropertyPage :: "{980E6523-6246-11d4-B5CC-0050DA2E2CC0}"
    prop GlobalIcon :: 163
    prop InstanceIcon :: 164
    prop GlobalHelpTopic :: (
	   1041
   )
    
   prop InstanceHelpTopic :: (
   1041
   )
        prop cGen :: 1
    	prop cStruct :: 1
    	prop cStructType :: "EMIF_Config"
	prop cHeaderName :: .gNumOf > 0 ? "csl_emif.h" : ""
	prop cStructQual :: "far"
        prop cStructName :: self
           	
	prop cConfigName :: "EMIF_config"
        prop localDelete :: (
         .myDelete
           )           
        prop myDelete :: (
         $a=0,
          scan($b; emifCfg) { 
               $a = $a + 1
           }, 		
	  if ($a == 2) {
                hEmif.EMIF_INIT_ENABLE = 0
		},
		"ok"
           )           
    
    inst cConfigGen ::= ((hEmif.EMIF_INIT_ENABLE == 1) && (hEmif.EMIF_INIT == self) && (hEmif.EMIF_INIT != EMIF_NOTHING)) {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
    }
 	
 
    inst cConfigArg0 ::= hEmif.EMIF_INIT {
         prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop MemberType :: emifCfg
	  prop Label :: "Pre-initialize Config"
	  prop Visible :: 0
	  prop Writable :: (CSL.EMIF_SUPPORT) &&  1
          prop NoGen :: 0
	  prop cPreVal :: "&"
    }
    inst NOHOLD_SETUP :: "Enable Hold" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Enable Hold,Disable Hold"
        prop Label :: "External HOLD disable (NOHOLD)"
	prop JSName :: "emifGblctlNoHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "Global Control"
	prop Set :: (
		.NOHOLD_SETUP = $1,
		.GBLCTL_VALUE = .GBLCTL_VALUE_update(),
		"ok"
	     )
	 }
    prop NOHOLD_GBLCTL :: (
         if (.NOHOLD_SETUP == "Disable Hold") {
            0x00000080
        }
	else {
            0x00000000
	}
    ) 
    
    inst RBTR8_SETUP :: "until High-Priority" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "until High-Priority,8 accesses Minimum"
        prop Label :: "Requester Arbitration (RBTR8)"
	prop JSName :: "emifGblctlRbtr8"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  ((CSL.C11_SUPPORT) ? 0: 1)
        prop NoGen :: 1
        prop TabName :: "Global Control"
        prop Set :: (
		.RBTR8_SETUP = $1,
		.GBLCTL_VALUE = .GBLCTL_VALUE_update(),
		"ok"
	    )
	 }
    prop RBTR8_GBLCTL :: (
         if (.RBTR8_SETUP == "until High-Priority") {
            0x00000000
        }
	else {
            0x00000002
	}
    ) 
   inst SSCRT_SETUP :: "1/2 CPU clock" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "1/2 CPU clock,1 CPU clock"
        prop Label :: "SBSRAM Clock Rate (SSCRT)"
	prop JSName :: "emifGblctlSscrt"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  (CSL.CHIP_6201 || CSL.CHIP_6701)
        prop NoGen :: 1
        prop TabName :: "Global Control"
	prop Set :: (
		.SSCRT_SETUP = $1,
		.GBLCTL_VALUE = .GBLCTL_VALUE_update(),
		"ok"
	  )
	}
    prop SSCRT_GBLCTL :: (
         if (.SSCRT_SETUP == "1/2 CPU clock") {
            0x00000000
        }
	else {
            0x00000004
		}
    ) 
    
   inst CLK2EN_SETUP :: "Enabled to clock" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Held high,Enabled to clock"
        prop Label :: "CLKOUT2 Enable (CLK2EN)"
	prop JSName :: "emifGblctlClk2En"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) && (CSL.CHIP_6201 || CSL.CHIP_6701 || CSL.C11_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Global Control"
	prop Set :: (
		.CLK2EN_SETUP = $1,
		.GBLCTL_VALUE = .GBLCTL_VALUE_update(),
		"ok"
	)
      }
    prop CLK2EN_GBLCTL :: (
         if (.CLK2EN_SETUP == "Held high") {
            0x00000000
        }
	else {
            0x00000008
		}
    ) 
   inst CLK1EN_SETUP :: "Enabled to clock" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Held high,Enabled to clock"
        prop Label :: "CLKOUT1 Enable (CLK1EN)"
	prop JSName :: "emifGblctlClk1En"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Global Control"
	prop Set :: (
		.CLK1EN_SETUP = $1,
		.GBLCTL_VALUE = .GBLCTL_VALUE_update(),
		"ok"
	        )
	}
    prop CLK1EN_GBLCTL :: (
         if (.CLK1EN_SETUP == "Held high") {
            0x00000000
        }
	else {
            0x00000010
		}
    ) 
   
   inst SSCEN_SETUP :: "Enabled to clock" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Held high,Enabled to clock"
        prop Label :: "SBSRAM CLK Enable (SSCEN)"
	prop JSName :: "emifGblctlSscen"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  (!CSL.C11_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Global Control"
	prop Set :: (
		.SSCEN_SETUP = $1,
		.GBLCTL_VALUE = .GBLCTL_VALUE_update(),
		"ok"
	        )
	 }
    prop SSCEN_GBLCTL :: (
         if (.SSCEN_SETUP == "Held high") {
            0x00000000
        } else {
            0x00000020
		}
    ) 
  inst SDCEN_SETUP :: "Enabled to clock" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Held high,Enabled to clock"
        prop Label :: "SDRAM CLK Enable (SDCEN)"
	prop JSName :: "emifGblctlSdcen"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&   (!CSL.C11_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Global Control"
	prop Set :: (
		.SDCEN_SETUP = $1,
		.GBLCTL_VALUE = .GBLCTL_VALUE_update(),
		"ok"
	        )
	 }
    prop SDCEN_GBLCTL :: (
         if (.SDCEN_SETUP == "Held high") {
            0x00000000
        } else {
            0x00000040
		}
    ) 
 
   inst MTYPE0_SETUP ::= ( if (!CSL.CHIP_6712)  { "32-bit async. interf." } else { " 8-bit async. interf." }) {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: " 8-bit async. interf.,16-bit async. interf.,32-bit async. interf., 8-bit SDRAM,16-bit SDRAM,32-bit SDRAM, 8-bit SBSRAM,16-bit SBSRAM,32-bit SBSRAM"
        prop Label :: "Memory Type (MTYPE)"
	prop JSName :: "emifCectl0Mtype"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	  prop Set :: (
           if (( !CSL.C11_SUPPORT)) {
               if ( $1 == " 8-bit async. interf." || $1 == "16-bit async. interf.") {
                .error("Memory type available for 6211/671x only")
                } else {
                     if ( $1 == " 8-bit SDRAM" || $1 == "16-bit SDRAM") {
                     .error("Memory type available for 6211/671x only")
                   } else  {
                        if ( $1 == " 8-bit SBSRAM" || $1 == "16-bit SBSRAM") {
                         .error("Memory type available for 6211/671x only")
                       } else  {                
		.MTYPE0_SETUP = $1,
		.CECTL0_VALUE = .CECTL0_VALUE_update(),
		"ok"
                         }
                    }
               } 
          } else    {
          if ( CSL.CHIP_6712 && ($1 == "32-bit SBSRAM" || $1 == "32-bit SDRAM" || $1 == "32-bit async. interf.")) {
             .error(" 6712 supports 16-bit EMIF only")
            } else  {
		.MTYPE0_SETUP = $1,
		.CECTL0_VALUE = .CECTL0_VALUE_update(),
		"ok"
           }    
       } 
	)
   }
    prop MTYPE0_CECTL0 :: (
     if (.MTYPE0_SETUP == "32-bit async. interf.") {
            0x00000020
        } else {
            if (.MTYPE0_SETUP == "32-bit SDRAM") {
            0x00000030
		} else {
            if ((!CSL.C11_SUPPORT)) {
                 0x00000040
                 } else {     
                 if ( .MTYPE0_SETUP == "32-bit SBSRAM") {
                 0x00000040 
                   } else {
                       if ( .MTYPE0_SETUP == " 8-bit async. interf.") {
                         0x00000000 
                        } else {
                            if ( .MTYPE0_SETUP == " 8-bit SDRAM") {
                             0x00000080 
                             } else {
                                if ( .MTYPE0_SETUP == " 8-bit SBSRAM") {
                                 0x000000a0 
                                   } else {
                                      if ( .MTYPE0_SETUP == "16-bit async. interf.") {
                                        0x00000010 
                                       } else {
                                           if ( .MTYPE0_SETUP == "16-bit SDRAM") {
                                            0x00000090 
                                            } else {
                                                   0x000000b0 
                                 
                                               }
                                          }
                                     }
                                }       
                           }
                       }
                 }
            }   
         }       
    ) 
 
 
 
 inst  RDSTRB0_SETUP :: 63{
    	prop Label :: "Read Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl0ReadStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 63 ) {
		.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycles")
	    }
	    else {
              .RDSTRB0_SETUP = $1,
              .CECTL0_VALUE = .CECTL0_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSTRB0_CECTL0 :: (
          ((.RDSTRB0_SETUP) << 8)
       )   
       
 inst  RDSETUP0_SETUP :: 15{
    	prop Label :: "Read Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl0ReadSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")
	    } else {
              .RDSETUP0_SETUP = $1,
              .CECTL0_VALUE = .CECTL0_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSETUP0_CECTL0 :: (
          ((.RDSETUP0_SETUP  )<< 16)
       )   
  inst  RDHLD0_SETUP :: 3 {
    	prop Label :: "Read Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl0ReadHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	prop Set :: (
        if ((!CSL.C11_SUPPORT)) { 
	    if ( $1 < 0 || $1 > 3 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")
                    } else {
                     .RDHLD0_SETUP = $1,
                     .CECTL0_VALUE = .CECTL0_VALUE_update(),
		      "ok"
	            }
	   }  else {
	          if ( $1 < 0 || $1 > 7 ) {
		     .error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")
                       } else {
                      .RDHLD0_SETUP = $1,
                       .CECTL0_VALUE = .CECTL0_VALUE_update(),
		        "ok"
	               }
           }    
	)
      }
      
   prop RDHLD0_CECTL0 :: (
          (.RDHLD0_SETUP)
       )   
       
      
  
   inst  WRSTRB0_SETUP :: 63{
    	prop Label :: "Write Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl0WriteStobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 63 ) {
		.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycles")
	    } else {
              .WRSTRB0_SETUP = $1,
              .CECTL0_VALUE = .CECTL0_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop WRSTRB0_CECTL0 :: (
          ((.WRSTRB0_SETUP )<< 22)
       )   
       
 inst  WRSETUP0_SETUP :: 15{
    	prop Label :: "Write Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl0WriterSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")
	    } else {
              .WRSETUP0_SETUP = $1,
              .CECTL0_VALUE = .CECTL0_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop WRSETUP0_CECTL0 :: (
          ((.WRSETUP0_SETUP ) << 28) 
       )   
    inst  WRHLD0_SETUP :: 3 {
    	prop Label :: "Write Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl0WriteHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	prop Set :: (
        if ((!CSL.C11_SUPPORT)) { 
	    if ( $1 < 0 || $1 > 3 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")
                    } else {
                     .WRHLD0_SETUP = $1,
                     .CECTL0_VALUE = .CECTL0_VALUE_update(),
		      "ok"
	            }
	   }  else {
	          if ( $1 < 0 || $1 > 3 ) {
		     .error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")
                       } else {
                      .WRHLD0_SETUP = $1,
                       .CECTL0_VALUE = .CECTL0_VALUE_update(),
		        "ok"
	               }
           }    
	)
      }
      
   prop WRHLD0_CECTL0 :: (
       if ( .WRHLD0_SETUP > 3 ) {
         ( (.WRHLD0_SETUP - 4) << 20)
      } else {   
           ((.WRHLD0_SETUP << 20) )
       }    
     )   
  
  
        
 
  
 inst TA0_SETUP :: 3 {
    	prop Label :: "Turn around time (TA) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl0Ta"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  ((CSL.C11_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	prop Set :: (
	    if ( $1 < 1 || $1 > 3 ) {
		.error(" Minimum: 1 ECLKOUT cycle - Maximum : 3 ECLKOUT cycles")
	    } else {
              .TA0_SETUP = $1,
              .CECTL0_VALUE = .CECTL0_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop TA0_CECTL0 :: (
          (.TA0_SETUP << 14) 
       )   
 
   inst MTYPE1_SETUP ::= ( if (!CSL.CHIP_6712)  { "32-bit async. interf." } else { " 8-bit async. interf." }) {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: " 8-bit ROM,16-bit ROM, 8-bit async. interf.,16-bit async. interf.,32-bit async. interf., 8-bit SDRAM,16-bit SDRAM,32-bit SDRAM, 8-bit SBSRAM,16-bit SBSRAM,32-bit SBSRAM"
        prop Label :: "Memory Type (MTYPE)"
	prop JSName :: "emifCectl1Mtype"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	  prop Set :: (
           if (( !CSL.C11_SUPPORT )) {
               if ( $1 == " 8-bit async. interf." || $1 == "16-bit async. interf.") {
                .error("Memory type available for 6211/671x only")
                } else {
                     if ( $1 == " 8-bit SDRAM" || $1 == "16-bit SDRAM") {
                     .error("Memory type available for 6211/671x only")
                   } else  {
                        if ( $1 == " 8-bit SBSRAM" || $1 == "16-bit SBSRAM") {
                         .error("Memory type available for 6211/671x only")
                        } else  {
                            if ( $1 == "32-bit SDRAM") {
                               .error("Memory type not available for CE1 Space")                         
                              } else  {                
	                	.MTYPE1_SETUP = $1,
		                .CECTL1_VALUE = .CECTL1_VALUE_update(),
	                	"ok"
                               }
                         }  
                    }
               }
          } else {
         if ( CSL.CHIP_6712 && ($1 == "32-bit SBSRAM" || $1 == "32-bit SDRAM" || $1 == "32-bit async. interf.")) {
             .error(" 6712 supports 16-bit EMIF only")
            } else  {
               if ( $1 == " 8-bit ROM" || $1 == "16-bit ROM") {
                     .error("Memory type not available for 6211/671x only")
                     } else  {
           	         .MTYPE1_SETUP = $1,
	        	 .CECTL1_VALUE = .CECTL1_VALUE_update(),
	        	  "ok"
                    }   
                }   
           }   
        )	
   }
    prop MTYPE1_CECTL1 :: (
  if (.MTYPE1_SETUP == " 8-bit ROM") {
            0x00000000
        } else {
     if (.MTYPE1_SETUP == "16-bit ROM") {
            0x00000010
           } else {
         if (.MTYPE1_SETUP == "32-bit async. interf.") {
               0x00000020
            } else {
              if ((!CSL.C11_SUPPORT)) {
                 0x00000040
                 } else {
                 
          if ( .MTYPE1_SETUP == "32-bit SDRAM") {   
              0x00000030 
                } else {
                 if ( .MTYPE1_SETUP == "32-bit SBSRAM") {
                 0x00000040 
                   } else {
                       if ( .MTYPE1_SETUP == " 8-bit async. interf.") {
                         0x00000000 
                        } else {
                            if ( .MTYPE1_SETUP == " 8-bit SDRAM") {
                             0x00000080 
                             } else {
                                if ( .MTYPE1_SETUP == " 8-bit SBSRAM") {
                                 0x000000a0 
                                   } else {
                                      if ( .MTYPE1_SETUP == "16-bit async. interf.") {
                                        0x00000010 
                                       } else {
                                           if ( .MTYPE1_SETUP == "16-bit SDRAM") {
                                            0x00000090 
                                            } else {
                                                   0x000000b0 
                                               }
                                          }
                                     }
                                }       
                           }
                       }
                 }
            }   
         }    
       }
     }   
    ) 
 
 
 
 inst  RDSTRB1_SETUP :: 63{
    	prop Label :: "Read Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl1ReadStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 63 ) {
		.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycles")
	    } else {
              .RDSTRB1_SETUP = $1,
              .CECTL1_VALUE = .CECTL1_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSTRB1_CECTL1 :: (
          ((.RDSTRB1_SETUP) << 8)
       )   
       
 inst  RDSETUP1_SETUP :: 15{
    	prop Label :: "Read Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl1ReadSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")
	    } else {
              .RDSETUP1_SETUP = $1,
              .CECTL1_VALUE = .CECTL1_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSETUP1_CECTL1 :: (
          ((.RDSETUP1_SETUP) << 16)
       )   
  inst  RDHLD1_SETUP :: 3 {
    	prop Label :: "Read Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl1ReadHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	prop Set :: (
        if ((!CSL.C11_SUPPORT)) { 
	    if ( $1 < 0 || $1 > 3 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")
                    } else {
                     .RDHLD1_SETUP = $1,
                     .CECTL1_VALUE = .CECTL1_VALUE_update(),
		      "ok"
	            }
	   }  else {
	          if ( $1 < 0 || $1 > 7 ) {
		     .error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")
                       } else {
                      .RDHLD1_SETUP = $1,
                       .CECTL1_VALUE = .CECTL1_VALUE_update(),
		        "ok"
	               }
           }    
	)
      }
      
   prop RDHLD1_CECTL1 :: (
          (.RDHLD1_SETUP)
       )   
       
      
  
   inst  WRSTRB1_SETUP :: 63{
    	prop Label :: "Write Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl1WriteStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 63 ) {
		.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycles")
	    } else {
              .WRSTRB1_SETUP = $1,
              .CECTL1_VALUE = .CECTL1_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop WRSTRB1_CECTL1 :: (
          ((.WRSTRB1_SETUP ) << 22)
       )   
       
 inst  WRSETUP1_SETUP :: 15{
    	prop Label :: "Write Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl1WriteSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")
	    } else {
              .WRSETUP1_SETUP = $1,
              .CECTL1_VALUE = .CECTL1_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop WRSETUP1_CECTL1 :: (
          ((.WRSETUP1_SETUP ) << 28)
       )   
    inst  WRHLD1_SETUP :: 3 {
    	prop Label :: "Write Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl1WriteHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	prop Set :: (
        if ((!CSL.C11_SUPPORT)) { 
	    if ( $1 < 0 || $1 > 3 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")
                    } else {
                     .WRHLD1_SETUP = $1,
                     .CECTL1_VALUE = .CECTL1_VALUE_update(),
		      "ok"
	            }
	   }  else {
	          if ( $1 < 0 || $1 > 3 ) {
		     .error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")
                       } else {
                      .WRHLD1_SETUP = $1,
                       .CECTL1_VALUE = .CECTL1_VALUE_update(),
		        "ok"
	               }
           }    
	)
      }
      
   prop WRHLD1_CECTL1 :: (
       if ( .WRHLD1_SETUP > 3 ) {
         ( (.WRHLD1_SETUP - 4) << 20)
      } else {   
           ((.WRHLD1_SETUP << 20) )
       }    
     )   
  
 
  
        
 
 inst TA1_SETUP ::  3 {
    	prop Label :: "Turn around time (TA) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl1Ta"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  ((CSL.C11_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	prop Set :: (
	    if ( $1 < 1 || $1 > 3 ) {
		.error(" Minimum: 1 ECLKOUT cycle - Maximum : 3 ECLKOUT cycles")
	    } else {
              .TA1_SETUP = $1,
              .CECTL1_VALUE = .CECTL1_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop TA1_CECTL1 :: (
          (.TA1_SETUP << 14) 
    )
          
 
   inst MTYPE2_SETUP ::=( if (!CSL.CHIP_6712)  { "32-bit async. interf." } else { " 8-bit async. interf." }) {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: " 8-bit async. interf.,16-bit async. interf.,32-bit async. interf., 8-bit SDRAM,16-bit SDRAM,32-bit SDRAM, 8-bit SBSRAM,16-bit SBSRAM,32-bit SBSRAM"
        prop Label :: "Memory Type (MTYPE)"
	prop JSName :: "emifCectl2Mtype"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	  prop Set :: (
           if (( !CSL.C11_SUPPORT)) {
               if ( $1 == " 8-bit async. interf." || $1 == "16-bit async. interf.") {
                .error("Memory type available for 6211/671x only")
                } else {
                     if ( $1 == " 8-bit SDRAM" || $1 == "16-bit SDRAM") {
                     .error("Memory type available for 6211/671x only")
                   } else  {
                        if ( $1 == " 8-bit SBSRAM" || $1 == "16-bit SBSRAM") {
                         .error("Memory type available for 6211/671x only")
                       } else  {                
		.MTYPE2_SETUP = $1,
		.CECTL2_VALUE = .CECTL2_VALUE_update(),
		"ok"
                         }
                    }
               } 
          } else    {
  if ( CSL.CHIP_6712 && ($1 == "32-bit SBSRAM" || $1 == "32-bit SDRAM" || $1 == "32-bit async. interf.")) {
             .error(" 6712 supports 16-bit EMIF only")
              } else  {
		.MTYPE2_SETUP = $1,
		.CECTL2_VALUE = .CECTL2_VALUE_update(),
		"ok"
           }    
        } 
	)
   }
    prop MTYPE2_CECTL2 :: (
     if (.MTYPE2_SETUP == "32-bit async. interf.") {
            0x00000020
        } else {
            if (.MTYPE2_SETUP == "32-bit SDRAM") {
            0x00000030
		} else {
            if ((!CSL.C11_SUPPORT)) {
                 0x00000040
                 } else {
                 
                 if ( .MTYPE2_SETUP == "32-bit SBSRAM") {
                 0x00000040 
                   } else {
                       if ( .MTYPE2_SETUP == " 8-bit async. interf.") {
                         0x00000000 
                        } else {
                            if ( .MTYPE2_SETUP == " 8-bit SDRAM") {
                             0x00000080 
                             } else {
                                if ( .MTYPE2_SETUP == " 8-bit SBSRAM") {
                                 0x000000a0 
                                   } else {
                                      if ( .MTYPE2_SETUP == "16-bit async. interf.") {
                                        0x00000010 
                                       } else {
                                           if ( .MTYPE2_SETUP == "16-bit SDRAM") {
                                            0x00000090 
                                            } else {
                                                   0x000000b0 
                                 
                                               }
                                          }
                                     }
                                }       
                           }
                       }
                 }
            }   
         }       
    ) 
 
 
 
 inst  RDSTRB2_SETUP :: 63{
    	prop Label :: "Read Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl2ReadStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 63 ) {
		.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycles")
	    } else {
              .RDSTRB2_SETUP = $1,
              .CECTL2_VALUE = .CECTL2_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSTRB2_CECTL2 :: (
          ((.RDSTRB2_SETUP ) << 8)
       )   
       
 inst  RDSETUP2_SETUP :: 15{
    	prop Label :: "Read Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl2ReadSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")
	    } else {
              .RDSETUP2_SETUP = $1,
              .CECTL2_VALUE = .CECTL2_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSETUP2_CECTL2 :: (
          ((.RDSETUP2_SETUP )<< 16)
       )   
  inst  RDHLD2_SETUP :: 3 {
    	prop Label :: "Read Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl2ReadHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	prop Set :: (
        if ((!CSL.C11_SUPPORT)) { 
	    if ( $1 < 0 || $1 > 3 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")
                    } else {
                     .RDHLD2_SETUP = $1,
                     .CECTL2_VALUE = .CECTL2_VALUE_update(),
		      "ok"
	            }
	   }  else {
	          if ( $1 < 0 || $1 > 7 ) {
		     .error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")
                       } else {
                      .RDHLD2_SETUP = $1,
                       .CECTL2_VALUE = .CECTL2_VALUE_update(),
		        "ok"
	               }
           }    
	)
      }
      
   prop RDHLD2_CECTL2 :: (
          (.RDHLD2_SETUP)
       )   
       
      
  
   inst  WRSTRB2_SETUP :: 63{
    	prop Label :: "Write Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl2WriteStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 63 ) {
		.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycles")
	    } else {
              .WRSTRB2_SETUP = $1,
              .CECTL2_VALUE = .CECTL2_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop WRSTRB2_CECTL2 :: (
          ((.WRSTRB2_SETUP )<< 22)
       )   
       
 inst  WRSETUP2_SETUP :: 15{
    	prop Label :: "Write Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl2WriteSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")
	    } else {
              .WRSETUP2_SETUP = $1,
              .CECTL2_VALUE = .CECTL2_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop WRSETUP2_CECTL2 :: (
          ((.WRSETUP2_SETUP )<< 28)
       )   
    inst  WRHLD2_SETUP :: 3 {
    	prop Label :: "Write Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl2WriteHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	prop Set :: (
        if ((!CSL.C11_SUPPORT)) { 
	    if ( $1 < 0 || $1 > 3 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")
                    } else {
                     .WRHLD2_SETUP = $1,
                     .CECTL2_VALUE = .CECTL2_VALUE_update(),
		      "ok"
	            }
	   }  else {
	          if ( $1 < 0 || $1 > 3 ) {
		     .error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")
                       } else {
                      .WRHLD2_SETUP = $1,
                       .CECTL2_VALUE = .CECTL2_VALUE_update(),
		        "ok"
	               }
           }    
	)
      }
      
   prop WRHLD2_CECTL2 :: (
       if ( .WRHLD2_SETUP > 3 ) {
         ( (.WRHLD2_SETUP - 4) << 20)
      } else {   
           ((.WRHLD2_SETUP << 20) )
       }    
     )   
  
 
   
        
 
 inst TA2_SETUP :: 3 {
    	prop Label :: "Turn around time (TA) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl2Ta"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  ((CSL.C11_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	prop Set :: (
	    if ( $1 < 1 || $1 > 3 ) {
		.error(" Minimum: 1 ECLKOUT cycle - Maximum : 3 ECLKOUT cycles")
	    } else {
              .TA2_SETUP = $1,
              .CECTL2_VALUE = .CECTL2_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop TA2_CECTL2 :: (
          (.TA2_SETUP << 14) 
       )   
 
   inst MTYPE3_SETUP ::= ( if (!CSL.CHIP_6712)  { "32-bit async. interf." } else { " 8-bit async. interf." }) {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: " 8-bit async. interf.,16-bit async. interf.,32-bit async. interf., 8-bit SDRAM,16-bit SDRAM,32-bit SDRAM, 8-bit SBSRAM,16-bit SBSRAM,32-bit SBSRAM"
        prop Label :: "Memory Type (MTYPE)"
	prop JSName :: "emifCectl3Mtype"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	  prop Set :: (
           if (( !CSL.C11_SUPPORT)) {
               if ( $1 == " 8-bit async. interf." || $1 == "16-bit async. interf.") {
                .error("Memory type available for 6211/671x only")
                } else {
                     if ( $1 == " 8-bit SDRAM" || $1 == "16-bit SDRAM") {
                     .error("Memory type available for 6211/671x only")
                   } else  {
                        if ( $1 == " 8-bit SBSRAM" || $1 == "16-bit SBSRAM") {
                         .error("Memory type available for 6211/671x only")
                       } else  {                
		.MTYPE3_SETUP = $1,
		.CECTL3_VALUE = .CECTL3_VALUE_update(),
		"ok"
                         }
                    }
               } 
          } else    {
     if ( CSL.CHIP_6712 && ($1 == "32-bit SBSRAM" || $1 == "32-bit SDRAM" || $1 == "32-bit async. interf.")) {
             .error(" 6712 supports 16-bit EMIF only")
              } else  {
		.MTYPE3_SETUP = $1,
		.CECTL3_VALUE = .CECTL3_VALUE_update(),
		"ok"
           }    
        } 
	)
   }
    prop MTYPE3_CECTL3 :: (
     if (.MTYPE3_SETUP == "32-bit async. interf.") {
            0x00000020
        } else {
            if (.MTYPE3_SETUP == "32-bit SDRAM") {
            0x00000030
		} else {
            if ((!CSL.C11_SUPPORT)) {
                 0x00000040
                 } else {
                 
                 if ( .MTYPE3_SETUP == "32-bit SBSRAM") {
                 0x00000040 
                   } else {
                       if ( .MTYPE3_SETUP == " 8-bit async. interf.") {
                         0x00000000 
                        } else {
                            if ( .MTYPE3_SETUP == " 8-bit SDRAM") {
                             0x00000080 
                             } else {
                                if ( .MTYPE3_SETUP == " 8-bit SBSRAM") {
                                 0x000000a0 
                                   } else {
                                      if ( .MTYPE3_SETUP == "16-bit async. interf.") {
                                        0x00000010 
                                       } else {
                                           if ( .MTYPE3_SETUP == "16-bit SDRAM") {
                                            0x00000090 
                                            } else {
                                                   0x000000b0 
                                 
                                               }
                                          }
                                     }
                                }       
                           }
                       }
                 }
            }   
         }       
    ) 
 
 
 
 inst  RDSTRB3_SETUP :: 63{
    	prop Label :: "Read Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl3ReadStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 63 ) {
		.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycles")
	    } else {
              .RDSTRB3_SETUP = $1,
              .CECTL3_VALUE = .CECTL3_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSTRB3_CECTL3 :: (
          ((.RDSTRB3_SETUP ) << 8)
       )   
       
 inst  RDSETUP3_SETUP :: 15{
    	prop Label :: "Read Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl3ReadSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")
	    } else {
              .RDSETUP3_SETUP = $1,
              .CECTL3_VALUE = .CECTL3_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSETUP3_CECTL3 :: (
          ((.RDSETUP3_SETUP )<< 16)
       )   
  inst  RDHLD3_SETUP :: 3 {
    	prop Label :: "Read Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl3ReadHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	prop Set :: (
        if ((!CSL.C11_SUPPORT)) { 
	    if ( $1 < 0 || $1 > 3 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")
                    } else {
                     .RDHLD3_SETUP = $1,
                     .CECTL3_VALUE = .CECTL3_VALUE_update(),
		      "ok"
	            }
	   }  else {
	          if ( $1 < 0 || $1 > 7 ) {
		     .error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")
                       } else {
                      .RDHLD3_SETUP = $1,
                       .CECTL3_VALUE = .CECTL3_VALUE_update(),
		        "ok"
	               }
           }    
	)
      }
      
   prop RDHLD3_CECTL3 :: (
          (.RDHLD3_SETUP)
       )   
       
      
  
   inst  WRSTRB3_SETUP :: 63{
    	prop Label :: "Write Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl3WriteStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 63 ) {
		.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycles")
	    } else {
              .WRSTRB3_SETUP = $1,
              .CECTL3_VALUE = .CECTL3_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop WRSTRB3_CECTL3 :: (
          ((.WRSTRB3_SETUP )<< 22)
       )   
       
 inst  WRSETUP3_SETUP :: 15{
    	prop Label :: "Write Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl3WriteSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")
	    } else {
              .WRSETUP3_SETUP = $1,
              .CECTL3_VALUE = .CECTL3_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop WRSETUP3_CECTL3 :: (
          ((.WRSETUP3_SETUP) << 28)
       )   
    inst  WRHLD3_SETUP :: 3 {
    	prop Label :: "Write Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl3WriteHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	prop Set :: (
        if ((!CSL.C11_SUPPORT)) { 
	       if ( $1 < 0 || $1 > 3 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")
                    } else {
                     .WRHLD3_SETUP = $1,
                     .CECTL3_VALUE = .CECTL3_VALUE_update(),
		      "ok"
	            }
	   }  else {
	          if ( $1 < 0 || $1 > 3 ) {
		     .error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")
                       } else {
                      .WRHLD3_SETUP = $1,
                       .CECTL3_VALUE = .CECTL3_VALUE_update(),
		        "ok"
	               }
           }    
	)
      }
      
   prop WRHLD3_CECTL3 :: (
       if ( .WRHLD3_SETUP > 3 ) {
         ( (.WRHLD3_SETUP - 4) << 20)
      } else {   
           ((.WRHLD3_SETUP << 20) )
       }    
     )   
  
  
   
        
 
 inst TA3_SETUP :: 3 {
    	prop Label :: "Turn around time (TA) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifCectl3Ta"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  ((CSL.C11_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	prop Set :: (
	    if ( $1 < 1 || $1 > 3 ) {
		.error(" Minimum: 1 ECLKOUT cycle - Maximum : 3 ECLKOUT cycles")
	    } else {
              .TA3_SETUP = $1,
              .CECTL3_VALUE = .CECTL3_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop TA3_CECTL3 :: (
          (.TA3_SETUP << 14) 
       )   
 
 inst TRC_SETUP :: 15 {
    	prop Label :: "TRC = trc/(clk period-1) (TRC) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifSdctlTrc"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error("Minimum TRC = 0 - Maximum TRC = 15 ")
	    } else {
              .TRC_SETUP = $1,
              .SDCTL_VALUE = .SDCTL_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop TRC_SDCTL :: (
          (.TRC_SETUP << 12) 
       )   
 inst TRP_SETUP :: 8 {
    	prop Label :: "TRP = trp/(clk period-1) (TRP) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifSdctlTrp"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error("Minimum TRP = 0 - Maximum TRP= 15 ")
	    } else {
              .TRP_SETUP = $1,
              .SDCTL_VALUE = .SDCTL_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop TRP_SDCTL :: (
          (.TRP_SETUP << 16) 
       )   
  
 prop TRCD_Init :: (
        if (( CSL.C11_SUPPORT))
        { 4
          } else { 8
                 }
        )
 inst TRCD_SETUP :: .TRCD_Init {
    	prop Label :: "TRCD = trcd/(clk period-1) (TRCD) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifSdctlTrcd"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error("Minimum TRCD = 0 - Maximum TRCD= 15 ")
	    } else {
              .TRCD_SETUP = $1,
              .SDCTL_VALUE = .SDCTL_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop TRCD_SDCTL :: (
          (.TRCD_SETUP << 20) 
       )   
  
 inst INIT_SETUP :: "Initialize" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Initialize,No effect"
    	prop Label :: "Initialization of all SDRAMs (INIT)"
	prop JSName :: "emifSdctlInit"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
              .INIT_SETUP = $1,
              .SDCTL_VALUE = .SDCTL_VALUE_update(),
		"ok"
	)
      }
      
   prop INIT_SDCTL :: (
         if  (.INIT_SETUP == "Initialize") {
          0x01000000
          } else {
          0x00000000
          }
       )   
 inst RFEN_SETUP :: "Enable" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Enable,Disable"
    	prop Label :: "SDRAM Refresh Enable (RFEN)"
	prop JSName :: "emifSdctlRfen"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
              .RFEN_SETUP = $1,
              .SDCTL_VALUE = .SDCTL_VALUE_update(),
		"ok"
	)
      }
      
   prop RFEN_SDCTL :: (
         if  (.RFEN_SETUP == "Enable") {
          0x02000000
          } else {
          0x00000000
          }
       )   
  
  
  
 inst SDWID_SETUP :: "Four 8-bit SDRAMs" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Four 8-bit SDRAMs,Two 16-bit SDRAMs"
    	prop Label :: "Width Select (SDWID)"
	prop JSName :: "emifSdctlSdwid"
        prop Visible :: ((!CSL.C11_SUPPORT))? 1:0
        prop Writable :: (CSL.EMIF_SUPPORT) &&  ((!CSL.C11_SUPPORT))? 1:0
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
              .SDWID_SETUP = $1,
              .SDCTL_VALUE = .SDCTL_VALUE_update(),
		"ok"
        )
      }
      
   prop SDWID_SDCTL :: (
         if  (.SDWID_SETUP == "Two 16-bit SDRAMs") {
          0x04000000
          } else {
          0x00000000
          }
       )   
  inst PERIOD_SETUP1 :: 64 {
    	prop Label :: "Refresh Period (CLKOUT2 cycles)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifSdtimClk2Period"
        prop Visible :: ((!CSL.C11_SUPPORT))? 1:0
        prop Writable :: (CSL.EMIF_SUPPORT) &&  ((!CSL.C11_SUPPORT))? 1:0
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
	    if ( $1 < 1 || $1 > 4095 ) {
		.error("Refresh Period range [1..4095] clk. cycl.")
	    } else {
              .PERIOD_SETUP1 = $1,
              .SDTIM_VALUE = .SDTIM_VALUE_update(),
		"ok"
	    }
	)
      }
   prop PERIOD_SDTIM1 :: (
          (.PERIOD_SETUP1)
        )   
 
 
 inst SDCSZ_SETUP :: " 9 addresses" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: " 9 addresses, 8 addresses,10 addresses"
    	prop Label :: "Column Size (SDCSZ)"
	prop JSName :: "emifSdctlSdcsz"
        prop Visible :: ((CSL.C11_SUPPORT))? 1:0
        prop Writable :: (CSL.EMIF_SUPPORT) &&  ((CSL.C11_SUPPORT))? 1:0
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
              .SDCSZ_SETUP = $1,
              .SDCTL_VALUE = .SDCTL_VALUE_update(),
		"ok"
	)
      }
      
   prop SDCSZ_SDCTL :: (
         if  (.SDCSZ_SETUP == " 8 addresses") {
          0x04000000
          } else {
             if  (.SDCSZ_SETUP == "10 addresses") {
              0x08000000
             } else {
             0x00000000
             } 
         }  
       )   
inst SDRSZ_SETUP :: "11 addresses" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "11 addresses,12 addresses,13 addresses"
    	prop Label :: "Row Size (SDRSZ)"
	prop JSName :: "emifSdctlSdrsz"
        prop Visible :: ((CSL.C11_SUPPORT))? 1:0
        prop Writable :: (CSL.EMIF_SUPPORT) &&  ((CSL.C11_SUPPORT))? 1:0
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
              .SDRSZ_SETUP = $1,
              .SDCTL_VALUE = .SDCTL_VALUE_update(),
		"ok"
	)
      }
      
   prop SDRSZ_SDCTL :: (
         if  (.SDRSZ_SETUP == "12 addresses") {
          0x10000000
          } else {
             if  (.SDRSZ_SETUP == "13 addresses") {
              0x20000000
             } else {
             0x00000000
             } 
         }  
       )   
inst SDBSZ_SETUP :: "Two banks" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Two banks,Four banks"
    	prop Label :: "Bank Size (SDBSZ)"
	prop JSName :: "emifSdctlSdbsz"
        prop Visible :: ((CSL.C11_SUPPORT))? 1:0
        prop Writable :: (CSL.EMIF_SUPPORT) &&  ((CSL.C11_SUPPORT))? 1:0
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
              .SDBSZ_SETUP = $1,
              .SDCTL_VALUE = .SDCTL_VALUE_update(),
		"ok"
	)
      }
      
   prop SDBSZ_SDCTL :: (
         if  (.SDBSZ_SETUP == "Four banks") {
          0x40000000
          } else {
              0x00000000
             } 
       )   
 
inst PERIOD_SETUP2 :: 1500 {
    	prop Label :: "Refresh Period (ECLKOUT cycles)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifSdtimEclkPeriod"
        prop Visible :: ((CSL.C11_SUPPORT))? 1:0
        prop Writable :: (CSL.EMIF_SUPPORT) &&  ((CSL.C11_SUPPORT))? 1:0
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
	    if ( $1 < 1 || $1 > 4096 ) {
		.error("1 cyc. < PERIOD < 4096 cyc. ")
	    } else {
              .PERIOD_SETUP2 = $1,
              .SDTIM_VALUE = .SDTIM_VALUE_update(),
		"ok"
	    }
	)
      }
      
      
      
   prop PERIOD_SDTIM2 :: (
          (.PERIOD_SETUP2)
        )   
inst XRFR_SETUP :: 1 {
    	prop Label :: "Extra Refreshes Ctrl. (XRFR)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifSdctlXrfr"
        prop Visible :: ((CSL.C11_SUPPORT))? 1:0
        prop Writable :: (CSL.EMIF_SUPPORT) &&  ((CSL.C11_SUPPORT))? 1:0
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
	    if ( $1 < 1 || $1 > 4 ) {
		.error("1 < Extra refreshes < 4 ")
	    } else {
              .XRFR_SETUP = $1,
              .SDTIM_VALUE = .SDTIM_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop XRFR_SDTIM :: (
          ((.XRFR_SETUP - 1) << 24)
        )   
 
 inst TCL_SETUP :: 3  {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    	prop Label :: "CAS Latency (TCL)"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifSdextTcl"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  ((CSL.C11_SUPPORT))? 1:0
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 2 || $1 > 3 ) {
		.error("TCL : 2 or 3 ECLKOUT cycles ")
	    } else {
              .TCL_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
            }    
        )
      }
      
   prop TCL_SDEXT :: (
         (.TCL_SETUP - 2)   
       )   
       
 inst TRAS_SETUP :: 8 {
    	prop Label :: "tras = TRAS + 1 (ECLKOUT cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifSdextTras"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  ((CSL.C11_SUPPORT))? 1:0
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 8 ) {
		.error("1 ECLKOUT cycle < tras < 8 ECLKOUT cycles ")
	    } else {
              .TRAS_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop TRAS_SDEXT :: (
          ((.TRAS_SETUP - 1) << 1)
        )   
       
 inst TRRD_SETUP :: 3 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
    	prop Label :: "trrd = TRRD (2 or 3 ECLKOUT cyc.)"
	prop JSName :: "emifSdextTrrd"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  ((CSL.C11_SUPPORT))? 1:0
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 2 || $1 > 3 ) {
		.error("TRRD : 2 or 3 ECLKOUT cycles ")
	    } else {
              .TRRD_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
              }  
        )
      }
      
   prop TRRD_SDEXT :: (
         (.TRRD_SETUP - 2) << 4  
       )   
 inst TWR_SETUP :: 2 {
    	prop Label :: "twr  = TWR + 1 (ECLKOUT cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifSdextTwr"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  ((CSL.C11_SUPPORT))? 1:0
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 4 ) {
		.error("1 ECLKOUT cycle < twr < 4 ECLKOUT cycles ")
	    } else {
              .TWR_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop TWR_SDEXT :: (
          ((.TWR_SETUP - 1) << 5)
        )   
 inst THZP_SETUP :: 3 {
    	prop Label :: "thzp = THZP + 1 (ECLKOUT cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifSdextThzp"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  ((CSL.C11_SUPPORT))? 1:0
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 4 ) {
		.error("1 ECLKOUT cycle < thzp < 4 ECLKOUT cycles ")
	    } else {
              .THZP_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop THZP_SDEXT :: (
          ((.THZP_SETUP - 1) << 7)
        )   
       
  inst RD2RD_SETUP :: 2 {
    	prop Label :: "READ-To-READ (ECLKOUT cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifSdextRd2rd"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  ((CSL.C11_SUPPORT))? 1:0
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 2 ) {
		.error("1 < # of ECLKOUT cycles < 2  ")
	    } else {
              .RD2RD_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }           
      
   prop RD2RD_SDEXT :: (
          ((.RD2RD_SETUP - 1) << 9)
        )   
       
  
  inst RD2DEAC_SETUP :: 4 {
    	prop Label :: "READ-To-DEAC/DEAB (ECLKOUT cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifSdextRd2deac"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  ((CSL.C11_SUPPORT))? 1:0
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 4 ) {
		.error("1 < # of ECLKOUT cycles < 4  ")
	    } else {
              .RD2DEAC_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }           
      
   prop RD2DEAC_SDEXT :: (
          ((.RD2DEAC_SETUP - 1) << 10)
        )   
 inst RD2WR_SETUP :: 6 {
    	prop Label :: "READ-To-WRITE (ECLKOUT cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifSdextRd2wr"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  ((CSL.C11_SUPPORT))? 1:0
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 8 ) {
		.error("1 < # of ECLKOUT cycles < 8  ")
	    } else {
              .RD2WR_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }           
      
   prop RD2WR_SDEXT :: (
          ((.RD2WR_SETUP - 1) << 12)
        )   
 inst R2WDQM_SETUP :: 4 {
    	prop Label :: "READ-To-WRITE with Interrupt (BEx cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifSdextR2wdqm"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  ((CSL.C11_SUPPORT))? 1:0
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 4 ) {
		.error("1 < # of Bex cycles < 4  ")
	    } else {
              .R2WDQM_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }           
      
   prop R2WDQM_SDEXT :: (
          ((.R2WDQM_SETUP - 1) << 15)
        )   
  
   
  inst WR2WR_SETUP :: 2 {
    	prop Label :: "WRITE-To-WRITE (ECLKOUT cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifSdextWr2wr"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  ((CSL.C11_SUPPORT))? 1:0
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 2 ) {
		.error("1 < # of ECLKOUT cycles < 2  ")
	    } else {
              .WR2WR_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }           
      
   prop WR2WR_SDEXT :: (
          ((.WR2WR_SETUP - 1) << 17)
        )   
        
  inst WR2DEAC_SETUP :: 2 {
    	prop Label :: "WRITE-To-DEAC/DEAB (ECLKOUT cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifSdextWr2deac"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  ((CSL.C11_SUPPORT))? 1:0
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 4 ) {
		.error("1 < # of ECLKOUT cycles < 4  ")
	    } else {
              .WR2DEAC_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }           
      
   prop WR2DEAC_SDEXT :: (
          ((.WR2DEAC_SETUP - 1) << 18)
        )   
 inst WR2RD_SETUP :: 2 {
    	prop Label :: "WRITE-To-READ (# of ECLKOUT cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifSdextWr2rd"
        prop Visible :: 1
        prop Writable :: (CSL.EMIF_SUPPORT) &&  ((CSL.C11_SUPPORT))? 1:0
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 2 ) {
		.error("1 < # of ECLKOUT cycles < 2  ")
	    } else {
              .WR2RD_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }           
   prop WR2RD_SDEXT :: (
          ((.WR2RD_SETUP - 1) << 20)
        )   
      
 
 
prop GBLCTL_VALUE_update :: (
     0x00003000
   |.RBTR8_GBLCTL()
   |.SSCRT_GBLCTL()
   |.CLK2EN_GBLCTL()
   |.CLK1EN_GBLCTL()
   |.SSCEN_GBLCTL()
   |.SDCEN_GBLCTL()
   |.NOHOLD_GBLCTL()
 )  
    
prop GBLCTL_SETUP_update :: (
    .RBTR8_SETUP = ($1 & 0x00000002) ? "8 accesses Minimum" : "until High-Priority",
    .SSCRT_SETUP = ($1 & 0x00000004) ? "1 CPU clock" : "1/2 CPU clock",
    .CLK2EN_SETUP = ($1 & 0x00000008) ? "Enabled to clock" : "Held high",
    .CLK1EN_SETUP = ($1 & 0x00000010) ? "Enabled to clock" : "Held high",
    .SSCEN_SETUP = ($1 & 0x00000020) ? "Enabled to clock" : "Held high",
    .SDCEN_SETUP = ($1 & 0x00000040) ? "Enabled to clock" : "Held high",
    .NOHOLD_SETUP = ($1 & 0x00000080) ? "Disable Hold" : "Enable Hold"
  )
  
   inst GBLCTL_VALUE :: .GBLCTL_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Global Control Reg. (GBLCTL) "
	prop Format :: "0x%08X"
	prop JSName :: "emifGblctl"
	prop Visible :: 1
	prop Writable :: (CSL.EMIF_SUPPORT) &&  1
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (
             if (CSL.C11_SUPPORT) {        
               $a = $1 & 0xFFFFC000,
               if ( $a != 0) {
                  .error("Bit field(bit[14..31]) is reserved")
                 } else {
                    $b = $1 & 0x00000007,
                    if ( $b != 0) {
                       .error("Bit field(bit[0..2]) is reserved")
                    } else {
        
                    .GBLCTL_VALUE = $1 | 0x0003000 | 0x00000060,
                    .GBLCTL_SETUP_update($1 | 0x0003000 | 0x00000060 ),
 		        "ok"
                        } 
                   }
            } else {
             if (CSL.CHIP_6202 || CSL.CHIP_6203 || CSL.CHIP_6204 || CSL.CHIP_6205) {
                 $c = $1 & 0xFFFFC000,
                 if( $c != 0) {
                     .error("Bit field(bit[14..31]) is reserved")
                    } else {
                       $d = $1 & 0x00000800,
                       if( $d != 0) {
                          .error("Bit field 11 is reserved")
                       } else {
                           $e = $1 & 0x00000004,
                           if( $e != 0) {
                              .error("Bit field 2 is reserved")
                            } else {   
                                .GBLCTL_VALUE = $1 | 0x0003000,
                                .GBLCTL_SETUP_update($1 | 0x0003000),
 		                    "ok"
                              }
                          }
                      }
                 
            } else {
                 if (CSL.CHIP_6201 || CSL.CHIP_6701) {
                  $f = $1 & 0xFFFFC000,
                   if( $f != 0) {
                     .error("Bit field(bit[14..31]) is reserved")
                    } else {
                       $g = $1 & 0x00000800,
                       if( $g != 0) {
                          .error("Bit field 11 is reserved")        
                       } else {
                        .GBLCTL_VALUE = $1 | 0x0003000,
                        .GBLCTL_SETUP_update($1 | 0x0003000  ),
 		            "ok"
                         }
                   }
               }
           }
        }
      )
   }
   
 prop CECTL0_VALUE_update :: (
     .MTYPE0_CECTL0()
  |  .RDHLD0_CECTL0()
  |  .RDSTRB0_CECTL0()
  |  .RDSETUP0_CECTL0()
  |  .WRHLD0_CECTL0()
  
  |  .WRSETUP0_CECTL0()
  |  .WRSTRB0_CECTL0()
  | (((!CSL.C11_SUPPORT)) ? 0 : .TA0_CECTL0()) 
  )
  prop CECTL0_SETUP_update :: (
    if ((CSL.CHIP_6211) || (CSL.CHIP_6711) || (CSL.CHIP_6713) || (CSL.CHIP_DA610)) {
     .MTYPE0_SETUP = ( $a = ( $1 & 0x000000f0),
                      ($a == 0x00000000) ? " 8-bit async. interf." :
                      ($a == 0x00000010) ? "16-bit async. interf." :
                      ($a == 0x00000020) ? "32-bit async. interf." :
                      ($a == 0x00000030) ? "32-bit SDRAM" :
                      ($a == 0x00000040) ? "32-bit SBSRAM" :
                      ($a == 0x00000080) ? " 8-bit SDRAM" :
                      ($a == 0x00000090) ? "16-bit SDRAM" :
                      ($a == 0x000000a0) ? " 8-bit SBSRAM" : "16-bit SBSRAM")
     } else {  
     if (CSL.CHIP_6712) {
     .MTYPE0_SETUP = ( $a = ( $1 & 0x000000f0),
                      ($a == 0x00000000) ? " 8-bit async. interf." :
                      ($a == 0x00000010) ? "16-bit async. interf." :
                      ($a == 0x00000080) ? " 8-bit SDRAM" :
                      ($a == 0x00000090) ? "16-bit SDRAM" :
                      ($a == 0x000000a0) ? " 8-bit SBSRAM" : "16-bit SBSRAM")
      } else {
     .MTYPE0_SETUP = ( $a = ( $1 & 0x00000070),
                      ($a == 0x00000020) ? "32-bit async. interf." :
                      ($a == 0x00000030) ? "32-bit SDRAM" : "32-bit SBSRAM")
    }  
  }, 
   if (CSL.C11_SUPPORT){  
       .RDHLD0_SETUP = ( $1 & 0x00000007)  
       } else { 
       .RDHLD0_SETUP = ( $1 & 0x00000003)
     },  
   .RDSTRB0_SETUP =  ( ( $1 & 0x00003F00) >> 8 ) ,
   .RDSETUP0_SETUP =  ( ($1 & 0x000F0000) >> 16) ,
   if (CSL.C11_SUPPORT){
       
       .WRHLD0_SETUP =  ( $1 & 0x00300000) >> 20
       } else {   
       .WRHLD0_SETUP =  ( $1 & 0x00300000) >> 20
     }, 
   .WRSTRB0_SETUP =   ( ($1 & 0x0FC00000) >> 22) ,
   .WRSETUP0_SETUP =  ( ($1 >> 28) & 0xF) ,
   if (CSL.C11_SUPPORT){
   .TA0_SETUP =  ($1 & 0x0000c000) >> 14
    }  
    )   
    
    
   inst CECTL0_VALUE :: .CECTL0_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE0 Space Control Reg. (CECTL0) "
	prop Format :: "0x%08X"
	prop JSName :: "emifCectl0"
	prop Visible :: 1
	prop Writable :: (CSL.EMIF_SUPPORT) &&  1
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (    
          $a = $1 & 0x00000070,
          if ( $a == 0x00000070 || $a == 0x00000050 || $a == 0x00000060)  {
               .error("Undefined Memory type for CE Spaces - See CEx Space Pages") 
              } else {   
             
              if (CSL.C11_SUPPORT){
                $b =  $1 & 0x000000F0,
                  if ( $b == 0x000000C0 || $b == 0x000000D0 || $b == 0x000000E0 || $b == 0x000000F0) {
                  .error("Undefined Memory type for CEx Spaces - See CEx Space Pages") 
                  }  else {
                    $g = $1 & 0x00000008,
                     if ( $g != 0) {
                       .error("Bit field 3 is reserved")    
                      } else { 
                         .CECTL0_VALUE = $1,
                         .CECTL0_SETUP_update($1),
                         "ok"
                        }                     
                    }
             } else {      
                 $c = $1 & 0x00000070,
                   if ( $c == 0x00000000 || $c == 0x00000010) {            
                    .error("Undefined Memory type for CE0 Space - See CE0 Space Page") 
                     }  else { 
                     $d = $1 & 0x0000C000,                            
                     if ( $d != 0) {            
                       .error ("Bit field(bit[14..15]) is reserved")
                     } else {
                        $e = $1 & 0x00000080,
                        if ( $e != 0) {
                           .error("Bit field 7 is reserved")
                        } else {
                            $f = $1 & 0x0000000C,
                            if ( $f != 0) {
                             .error("Bit field(bit[2..3]) is reserved") 
                            } else {              
                              .CECTL0_VALUE = $1,
                              .CECTL0_SETUP_update($1),
 		                  "ok"
                             }
                        }
                   }
                }   
            }
         }  
      )
   }
   
 prop CECTL1_VALUE_update :: (
     .MTYPE1_CECTL1()
  |  .RDHLD1_CECTL1()
  |  .RDSTRB1_CECTL1()
  |  .RDSETUP1_CECTL1()
  |  .WRHLD1_CECTL1()
   
  |  .WRSETUP1_CECTL1()
  |  .WRSTRB1_CECTL1()
  | (((!CSL.C11_SUPPORT)) ? 0 : .TA1_CECTL1()) 
  )
  prop CECTL1_SETUP_update :: (
    if((CSL.CHIP_6211) || (CSL.CHIP_6711) || (CSL.CHIP_6713) || (CSL.CHIP_DA610)){
     .MTYPE1_SETUP = ( $a = ( $1 & 0x000000f0),
                      ($a == 0x00000000) ? " 8-bit async. interf." :
                      ($a == 0x00000010) ? "16-bit async. interf." :
                      ($a == 0x00000020) ? "32-bit async. interf." :
                      ($a == 0x00000030) ? "32-bit SDRAM" :
                      ($a == 0x00000040) ? "32-bit SBSRAM" :
                      ($a == 0x00000080) ? " 8-bit SDRAM" :
                      ($a == 0x00000090) ? "16-bit SDRAM" :
                      ($a == 0x000000a0) ? " 8-bit SBSRAM" : "16-bit SBSRAM")
     } else {  
      if (CSL.CHIP_6712) {
     .MTYPE0_SETUP = ( $a = ( $1 & 0x000000f0),
                      ($a == 0x00000000) ? " 8-bit async. interf." :
                      ($a == 0x00000010) ? "16-bit async. interf." :
                      ($a == 0x00000080) ? " 8-bit SDRAM" :
                      ($a == 0x00000090) ? "16-bit SDRAM" :
                      ($a == 0x000000a0) ? " 8-bit SBSRAM" : "16-bit SBSRAM")
         } else {
         .MTYPE1_SETUP = ( $a = ( $1 & 0x00000070),
                      ($a == 0x00000000) ? " 8-bit ROM" : 
                      ($a == 0x00000010) ? "16-bit ROM" :
                      ($a == 0x00000020) ? "32-bit async. interf." : "32-bit SBSRAM")
       }
    }, 
   if (CSL.C11_SUPPORT){  
       .RDHLD1_SETUP = ( $1 & 0x00000007)  
       } else { 
       .RDHLD1_SETUP = ( $1 & 0x00000003)
     },  
   .RDSTRB1_SETUP =  ( ($1 & 0x00003F00) >> 8)  ,
   .RDSETUP1_SETUP =  ( ($1 & 0x000F0000) >> 16) ,
   if (CSL.C11_SUPPORT){
       .WRHLD1_SETUP =  ( $1 & 0x00300000) >> 20
       } else {   
       .WRHLD1_SETUP =  ( $1 & 0x00300000) >> 20
     }, 
   .WRSTRB1_SETUP =   ( ( $1 & 0x0FC00000) >> 22 ),
   .WRSETUP1_SETUP =  (( $1 >> 28) & 0xF) ,
   if (CSL.C11_SUPPORT){
   .TA1_SETUP =  ($1 & 0x0000c000) >> 14
    }  
    )   
    
    
   inst CECTL1_VALUE :: .CECTL1_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE1 Space Control Reg. (CECTL1) "
	prop Format :: "0x%08X"
	prop JSName :: "emifCectl1"
	prop Visible :: 1
	prop Writable :: (CSL.EMIF_SUPPORT) &&  1
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (    
          $a = $1 & 0x00000070,
          if ( $a == 0x00000070 || $a == 0x00000050 || $a == 0x00000060)  {
               .error("Undefined Memory type for CE Spaces - See CEx Space Pages") 
              } else {   
             
              if (CSL.C11_SUPPORT){
                $b =  $1 & 0x000000F0,
                  if ( $b == 0x000000C0 || $b == 0x000000D0 || $b == 0x000000E0 || $b == 0x000000F0) {
                  .error("Undefined Memory type for CEx Spaces - See CEx Space Pages") 
                  } else {
                     $g = $1 & 0x00000008,
                     if ( $g != 0) {
                       .error("Bit field 3 is reserved")    
                      } else { 
                        .CECTL1_VALUE = $1,
                        .CECTL1_SETUP_update($1),
                        "ok"
                       }
                    }
             } else {      
                 $c = $1 & 0x00000070,
                   if ( $c == 0x00000030 ) {            
                    .error("Undefined Memory type for CE1 Space - See CE1 Space Page") 
                     } else { 
                          $d = $1 & 0x0000C000,                            
                     if ( $d != 0) {            
                       .error ("Bit field(bit[14..15]) is reserved")
                     } else {
                        $e = $1 & 0x00000080,
                        if ( $e != 0) {
                           .error("Bit field 7 is reserved")
                        } else {
                            $f = $1 & 0x0000000C,
                            if ( $f != 0) {
                             .error("Bit field(bit[2..3]) is reserved") 
                            }  else {         
                              .CECTL1_VALUE = $1,
                              .CECTL1_SETUP_update($1),
 		                  "ok"
                              }
                          }
                     }
                  }
                }   
            }
      )
   }
   
 prop CECTL2_VALUE_update :: (
     .MTYPE2_CECTL2()
  |  .RDHLD2_CECTL2()
  |  .RDSTRB2_CECTL2()
  |  .RDSETUP2_CECTL2()
  |  .WRHLD2_CECTL2()
   
  |  .WRSETUP2_CECTL2()
  |  .WRSTRB2_CECTL2()
  | (((!CSL.C11_SUPPORT)) ? 0 : .TA2_CECTL2()) 
  )
  prop CECTL2_SETUP_update :: (
    if ((CSL.CHIP_6211) || (CSL.CHIP_6711) || (CSL.CHIP_6713) || (CSL.CHIP_DA610)) {
     .MTYPE2_SETUP = ( $a = ( $1 & 0x000000f0),
                      ($a == 0x00000000) ? " 8-bit async. interf." :
                      ($a == 0x00000010) ? "16-bit async. interf." :
                      ($a == 0x00000020) ? "32-bit async. interf." :
                      ($a == 0x00000030) ? "32-bit SDRAM" :
                      ($a == 0x00000040) ? "32-bit SBSRAM" :
                      ($a == 0x00000080) ? " 8-bit SDRAM" :
                      ($a == 0x00000090) ? "16-bit SDRAM" :
                      ($a == 0x000000a0) ? " 8-bit SBSRAM" : "16-bit SBSRAM")
     } else {  
     if (CSL.CHIP_6712) {
     .MTYPE0_SETUP = ( $a = ( $1 & 0x000000f0),
                      ($a == 0x00000000) ? " 8-bit async. interf." :
                      ($a == 0x00000010) ? "16-bit async. interf." :
                      ($a == 0x00000080) ? " 8-bit SDRAM" :
                      ($a == 0x00000090) ? "16-bit SDRAM" :
                      ($a == 0x000000a0) ? " 8-bit SBSRAM" : "16-bit SBSRAM")
      } else {
     .MTYPE2_SETUP = ( $a = ( $1 & 0x00000070),
                      ($a == 0x00000020) ? "32-bit async. interf." :
                      ($a == 0x00000030) ? "32-bit SDRAM" : "32-bit SBSRAM")
     }
    }, 
   if (CSL.C11_SUPPORT){  
       .RDHLD2_SETUP = ( $1 & 0x00000007)  
       } else { 
       .RDHLD2_SETUP = ( $1 & 0x00000003)
     },  
   .RDSTRB2_SETUP =  ( ($1 & 0x00003F00) >> 8) ,
   .RDSETUP2_SETUP =  ( ($1 & 0x000F0000) >> 16) ,
   if (CSL.C11_SUPPORT){
       
       .WRHLD2_SETUP =  ( $1 & 0x00300000) >> 20
       } else {   
       .WRHLD2_SETUP =  ( $1 & 0x00300000) >> 20
     }, 
   .WRSTRB2_SETUP =   (( $1 & 0x0FC00000) >> 22) ,
   .WRSETUP2_SETUP =  (( $1 >> 28) & 0xF) ,
   if (CSL.C11_SUPPORT){
   .TA2_SETUP =  ($1 & 0x0000c000) >> 14
    }  
    )   
    
    
   inst CECTL2_VALUE :: .CECTL2_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE2 Space Control Reg. (CECTL2) "
	prop Format :: "0x%08X"
	prop JSName :: "emifCectl2"
	prop Visible :: 1
	prop Writable :: (CSL.EMIF_SUPPORT) &&  1
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (    
          $a = $1 & 0x00000070,
          if ( $a == 0x00000070 || $a == 0x00000050 || $a == 0x00000060)  {
               .error("Undefined Memory type for CE Spaces - See CEx Space Pages") 
              } else {   
             
              if (CSL.C11_SUPPORT){
                $b =  $1 & 0x000000F0,
                  if ( $b == 0x000000C0 || $b == 0x000000D0 || $b == 0x000000E0 || $b == 0x000000F0) {
                  .error("Undefined Memory type for CEx Spaces - See CEx Space Pages") 
                  } else {
                     $g = $1 & 0x00000008,
                     if ( $g != 0) {
                       .error("Bit field 3 is reserved")    
                      } else { 
                         .CECTL2_VALUE = $1,
                         .CECTL2_SETUP_update($1),
                         "ok"
                         }
                     }
             } else {      
                 $c = $1 & 0x00000070,
                   if ( $c == 0x00000000 || $c == 0x00000010) {            
                    .error("Undefined Memory type for CE2 Space - See CE2 Space Page") 
                     }  else {    
                             $d = $1 & 0x0000C000,                            
                             if ( $d != 0) {            
                             .error ("Bit field(bit[14..15]) is reserved")
                           } else {
                              $e = $1 & 0x00000080,
                              if ( $e != 0) {
                                 .error("Bit field 7 is reserved")
                              } else {
                                  $f = $1 & 0x0000000C,
                                  if ( $f != 0) {
                                   .error("Bit field(bit[2..3]) is reserved") 
                                  }  else {                      
                              .CECTL2_VALUE = $1,
                              .CECTL2_SETUP_update($1),
 		              "ok"
                               }
                        }
                    }
                  }
                }   
            }
      )
   }
   
   
 prop CECTL3_VALUE_update :: (
     .MTYPE3_CECTL3()
  |  .RDHLD3_CECTL3()
  |  .RDSTRB3_CECTL3()
  |  .RDSETUP3_CECTL3()
  |  .WRHLD3_CECTL3()
  
  |  .WRSETUP3_CECTL3()
  |  .WRSTRB3_CECTL3()
  | (((!CSL.C11_SUPPORT)) ? 0 : .TA3_CECTL3()) 
  )
  prop CECTL3_SETUP_update :: (
    if ((CSL.CHIP_6211) || (CSL.CHIP_6711) || (CSL.CHIP_6713) || (CSL.CHIP_DA610)) {
     .MTYPE3_SETUP = ( $a = ( $1 & 0x000000f0),
                      ($a == 0x00000000) ? " 8-bit async. interf." :
                      ($a == 0x00000010) ? "16-bit async. interf." :
                      ($a == 0x00000020) ? "32-bit async. interf." :
                      ($a == 0x00000030) ? "32-bit SDRAM" :
                      ($a == 0x00000040) ? "32-bit SBSRAM" :
                      ($a == 0x00000080) ? " 8-bit SDRAM" :
                      ($a == 0x00000090) ? "16-bit SDRAM" :
                      ($a == 0x000000a0) ? " 8-bit SBSRAM" : "16-bit SBSRAM")
     } else {  
    if (CSL.CHIP_6712) {
     .MTYPE0_SETUP = ( $a = ( $1 & 0x000000f0),
                      ($a == 0x00000000) ? " 8-bit async. interf." :
                      ($a == 0x00000010) ? "16-bit async. interf." :
                      ($a == 0x00000080) ? " 8-bit SDRAM" :
                      ($a == 0x00000090) ? "16-bit SDRAM" :
                      ($a == 0x000000a0) ? " 8-bit SBSRAM" : "16-bit SBSRAM")
      } else {
     .MTYPE3_SETUP = ( $a = ( $1 & 0x00000070),
                      ($a == 0x00000020) ? "32-bit async. interf." :
                      ($a == 0x00000030) ? "32-bit SDRAM" : "32-bit SBSRAM")
     }
    }, 
   if (CSL.C11_SUPPORT){  
       .RDHLD3_SETUP = ( $1 & 0x00000007)  
       } else { 
       .RDHLD3_SETUP = ( $1 & 0x00000003)
     },  
   .RDSTRB3_SETUP =  ( ($1 & 0x00003F00) >> 8)  ,
   .RDSETUP3_SETUP =  ( ($1 & 0x000F0000) >> 16) ,
   if (CSL.C11_SUPPORT){
       
       .WRHLD3_SETUP =  ( $1 & 0x00300000) >> 20
       } else {   
       .WRHLD3_SETUP =  ( $1 & 0x00300000) >> 20
     }, 
   .WRSTRB3_SETUP =   ( ($1 & 0x0FC00000) >> 22 ),
   .WRSETUP3_SETUP =  ( ($1 >> 28) & 0xF) ,
   if (CSL.C11_SUPPORT){
   .TA3_SETUP =  ($1 & 0x0000c000) >> 14
    }  
    )   
    
    
   inst CECTL3_VALUE :: .CECTL3_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE3 Space Control Reg. (CECTL3) "
	prop Format :: "0x%08X"
	prop JSName :: "emifCectl3"
	prop Visible :: 1
	prop Writable :: (CSL.EMIF_SUPPORT) &&  1
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (    
          $a = $1 & 0x00000070,
          if ( $a == 0x00000070 || $a == 0x00000050 || $a == 0x00000060)  {
               .error("Undefined Memory type for CE Spaces - See CEx Space Pages") 
              } else {   
             
              if (CSL.C11_SUPPORT){
                $b =  $1 & 0x000000F0,
                  if ( $b == 0x000000C0 || $b == 0x000000D0 || $b == 0x000000E0 || $b == 0x000000F0) {
                  .error("Undefined Memory type for CEx Spaces - See CEx Space Pages") 
                  } else {
                     $g = $1 & 0x00000008,
                     if ( $g != 0) {
                       .error("Bit field 3 is reserved")    
                      } else { 
                         .CECTL3_VALUE = $1,
                         .CECTL3_SETUP_update($1),
                          "ok"
                        }
                     }
             } else {      
                 $c = $1 & 0x00000070,
                   if ( $c == 0x00000000 || $c == 0x00000010) {            
                    .error("Undefined Memory type for CE3 Space - See CE3 Space Page") 
                     } else {  
                           $d = $1 & 0x0000C000,                            
                           if ( $d != 0) {            
                             .error ("Bit field(bit[14..15]) is reserved")
                           } else {
                              $e = $1 & 0x00000080,
                             if ( $e != 0) {
                                 .error("Bit field 7 is reserved")
                              } else {
                                  $f = $1 & 0x0000000C,
                                  if ( $f != 0) {
                                   .error("Bit field(bit[2..3]) is reserved") 
                                  }  else {                        
                                     .CECTL3_VALUE = $1,
                                     .CECTL3_SETUP_update($1),
 		                         "ok"
                                  }
                              }
                           }
                       }
                }   
            }
      )
   }
   
 prop SDCTL_VALUE_update :: (
     .TRC_SDCTL()
  |  .TRP_SDCTL()
  |  .TRCD_SDCTL()
  |  .INIT_SDCTL()
  |  .RFEN_SDCTL()
  | (((!CSL.C11_SUPPORT)) ? .SDWID_SDCTL() : .SDCSZ_SDCTL() )
  | (((!CSL.C11_SUPPORT)) ? 0 : .SDRSZ_SDCTL() )
  | (((!CSL.C11_SUPPORT)) ? 0 : .SDBSZ_SDCTL() )
  )
  prop SDCTL_SETUP_update :: (
   .TRC_SETUP = ($1 & 0x0000F000) >> 12,
   .TRP_SETUP = ($1 & 0x000F0000) >> 16,
   .TRCD_SETUP = ($1 & 0x00F00000) >> 20,
   .INIT_SETUP = ( $a = ($1 & 0x01000000),
                         ($a == 0x01000000 ) ? "Initialize" : "No effect"),
   .RFEN_SETUP = ( $a = ($1 & 0x02000000),
                         ($a == 0x02000000 ) ? "Enable" : "Disable"),
   if ((!CSL.C11_SUPPORT )) {
     .SDWID_SETUP = ( $a = ( $1 & 0x04000000),
                         ($a == 0x04000000 ) ? "Two 16-bit SDRAMs" : "Four 8-bit SDRAMs")
   },
   if (CSL.C11_SUPPORT){
   
   .SDCSZ_SETUP = ( $a = ($1 & 0x0c000000),
                         ($a == 0x04000000 ) ? " 8 addresses" : 
                         ($a == 0x08000000 ) ? "10 addresses" : " 9 addresses"),                         
   .SDRSZ_SETUP = ( $a = ($1 & 0x30000000),
                         ($a == 0x10000000 ) ? "12 addresses" : 
                         ($a == 0x20000000 ) ? "13 addresses" : "11 addresses"),
   .SDBSZ_SETUP = ( $a = ($1 & 0x40000000),
                         ($a == 0x40000000 ) ? "Four banks" : "Two banks")
    }                  
  )  
   inst SDCTL_VALUE :: .SDCTL_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "SDRAM Control Reg.(SDCTL) "
	prop Format :: "0x%08X"
	prop JSName :: "emifSdctl"
	prop Visible :: 1
	prop Writable :: (CSL.EMIF_SUPPORT) &&  1
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (    
             $a =  $1 & 0x0c000000,
             if ( $a == 0x0c000000 ) {
              .error("Undefined Value for Colum Size field SDCSZ")
              } else {
               $b = $1 & 0x30000000,
               if ( $b == 0x30000000) {
                 .error("Undefined Value for Row Size field SDRSZ")
              } else {
                        .SDCTL_VALUE = $1,
                        .SDCTL_SETUP_update($1),
 		        "ok"
                      } 
              }        
        )              
              
       }           
       
   
 prop SDTIM_VALUE_update :: (
   (((!CSL.C11_SUPPORT)) ? .PERIOD_SDTIM1(): .PERIOD_SDTIM2() )
  | (((!CSL.C11_SUPPORT)) ? 0 : .XRFR_SDTIM() )
  )
  prop SDTIM_SETUP_update :: (
   if (CSL.C11_SUPPORT){
   .PERIOD_SETUP2 = ($1 & 0x00000FFF)
   },
 if  ((!CSL.C11_SUPPORT)) {
   .PERIOD_SETUP1 = ($1 & 0x00000FFF)
   },
   if (CSL.C11_SUPPORT){
   .XRFR_SETUP = (($1 & 0x03000000) >> 24) + 1
   }                        
  )
   inst SDTIM_VALUE :: .SDTIM_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "SDRAM Timing Reg.(SDTIM) "
	prop Format :: "0x%08X"
	prop JSName :: "emifSdtim"
	prop Visible :: 1
	prop Writable :: (CSL.EMIF_SUPPORT) &&  1
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (    
                        .SDTIM_VALUE = $1,
                        .SDTIM_SETUP_update($1),
 		        "ok"
        )              
              
       }           
 prop SDEXT_VALUE_update :: (
     .TCL_SDEXT()
  |  .TRAS_SDEXT()
  |  .TRRD_SDEXT()
  |  .TWR_SDEXT()
  |  .THZP_SDEXT()
  |  .RD2RD_SDEXT()
  |  .RD2DEAC_SDEXT()
  |  .RD2WR_SDEXT()
  |  .R2WDQM_SDEXT()
  |  .WR2WR_SDEXT()
  |  .WR2DEAC_SDEXT()
  |  .WR2RD_SDEXT()
  )
  prop SDEXT_SETUP_update :: (
   .TCL_SETUP =   ($1 & 0x00000001) + 2,
   .TRAS_SETUP = (($1 & 0x0000000E) >> 1 ) + 1 ,
   .TRRD_SETUP = (($1 & 0x00000010) >> 4 ) + 2 ,
   .TWR_SETUP =  (($1 & 0x00000060) >> 5 ) + 1 ,
   .THZP_SETUP = (($1 & 0x00000180) >> 7 ) + 1 ,
   .RD2RD_SETUP =  (($1 & 0x00000200) >> 9 ) + 1 ,
   .RD2DEAC_SETUP =(($1 & 0x00000c00) >> 10 ) + 1 ,
   .RD2WR_SETUP =  (($1 & 0x00007000) >> 12 ) + 1 ,
   .R2WDQM_SETUP = (($1 & 0x00018000) >> 15 ) + 1 ,
   .WR2WR_SETUP =  (($1 & 0x00020000) >> 17 ) + 1 ,
   .WR2DEAC_SETUP =(($1 & 0x000c0000) >> 18 ) + 1 ,
   .WR2RD_SETUP =  (($1 & 0x00100000) >> 20 ) + 1 
   )
   inst SDEXT_VALUE :: .SDEXT_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "SDRAM Extended Reg.(SDEXT) "
	prop Format :: "0x%08X"
	prop JSName :: "emifSdext"
	prop Visible :: 1
	prop Writable :: (CSL.EMIF_SUPPORT) &&  (CSL.C11_SUPPORT)? 1 :0
	prop NoGen :: 0
	prop cGen :: (CSL.C11_SUPPORT)? 1 :0
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (    
	                .SDEXT_VALUE = $1,
                        .SDEXT_SETUP_update($1),
 		        "ok"
                   )              
       }        
       
 
           
       
}
type hEmif {
   prop IsContainedIn :: EMIFFOLDER
   prop name :: "hEmif"     	    	
   prop Label :: "EMIF Resource Manager"
   prop JSName :: "HEMIF"     	    	
   prop NoGen :: 1
   prop GlobalPropertyPage :: "{980E6520-6246-11d4-B5CC-0050DA2E2CC0}"
   prop InstancePropertyPage :: "{980E6521-6246-11d4-B5CC-0050DA2E2CC0}"
   prop GlobalIcon :: 163
   prop InstanceIcon :: 164
    prop GlobalHelpTopic :: (
	   1042
   )
     
   prop cGen :: 1
 
   global EMIF_INIT_ENABLE :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Enable Pre-Initialization"
	  prop JSName :: "emifEnablePreInit"
	  prop Visible :: 1
	  prop Writable :: (CSL.EMIF_SUPPORT) &&  1
	  prop NoGen :: 0
          prop Set :: (
          $a = 0,
            scan ($b ; emifCfg) { $a = $a + 1},
                  if ( $1 == 1 && $a ==1 &&  .EMIF_INIT == EMIF_NOTHING ) 
                 {         
                 " You must create a new configuration object"
                 } else { 
                      .EMIF_INIT_ENABLE = $1,
		      if ( $1 == 0) {
		      .EMIF_INIT = EMIF_NOTHING
		      },
			"ok"
                  }      
	  )      
    	}
	global EMIF_INIT :: EMIF_NOTHING {
	    prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	    prop MemberType :: emifCfg
	    prop Label :: " Pre-Initialize with"
	    prop JSName :: "emifPreInit"
	    prop Visible :: 1
	    prop Writable :: (CSL.EMIF_SUPPORT) &&  (.EMIF_INIT_ENABLE == 1) ? 1 :0 
    }
 
}
object EMIF_NOTHING :: emifCfg {
       param iIsUsed :: 0
}
type EMIFAFOLDER {
    isa ModuleFolder
    prop IsContainedIn :: CSL 
       	    	
   prop name :: "EMIFA"
   prop Label :: "EMIFA - External Memory Interface A (64x devices only)"
   prop NoGen :: 1
   prop GlobalPropertyPage :: "{980E6530-6246-11d4-B5CC-0050DA2E2CC0}"
   prop InstancePropertyPage :: "{980E6531-6246-11d4-B5CC-0050DA2E2CC0}"
   prop GlobalIcon :: 163
   prop InstanceIcon :: 164
   prop GlobalHelpTopic :: (
	   1043
   )
}   
  
type emifaCfg {
    isa ObjectMgr
    prop Name :: "emifaCfg"
    prop Label :: "EMIFA Configuration Manager"
    prop JSName :: "EMIFA"
    prop IsContainedIn :: EMIFAFOLDER
    prop NoGen :: 1
    prop maxObjs :: (32767)
    prop GlobalPropertyPage :: "{980E6532-6246-11d4-B5CC-0050DA2E2CC0}"
    prop InstancePropertyPage :: "{980E6533-6246-11d4-B5CC-0050DA2E2CC0}"
    prop GlobalIcon :: 163
    prop InstanceIcon :: 164
    prop GlobalHelpTopic :: (
	   1044
   )
    
   prop InstanceHelpTopic :: (
   1044
   )
      prop cGen :: CSL.EMIFA_SUPPORT
    	prop cStruct :: 1
    	prop cStructType :: "EMIFA_Config"
	prop cHeaderName :: .gNumOf > 0 ? "csl_emifa.h" : ""
	prop cStructQual :: "far"
        prop cStructName :: self
           	
	prop cConfigName :: "EMIFA_config"
        prop localDelete :: (
         .myDelete
           )           
        prop myDelete :: (
         $a=0,
          scan($b; emifaCfg) { 
               $a = $a + 1
           }, 		
	  if ($a == 2) {
                hEmifa.EMIFA_INIT_ENABLE = 0
		},
		"ok"
           )           
    
    inst cConfigGen ::= ((hEmifa.EMIFA_INIT_ENABLE == 1) && (hEmifa.EMIFA_INIT == self) && (hEmifa.EMIFA_INIT != EMIFA_NOTHING)) {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
    }
 	
 
    inst cConfigArg0 ::= hEmifa.EMIFA_INIT {
         prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop MemberType :: emifaCfg
	  prop Label :: "Pre-initialize Config"
	  prop Visible :: 0
	  prop Writable :: (CSL.EMIFA_SUPPORT) 
          prop NoGen :: 0
	  prop cPreVal :: "&"
    }
    inst NOHOLD_SETUP :: "Enable Hold" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Enable Hold,Disable Hold"
        prop Label :: "External HOLD disable (NOHOLD)"
	prop JSName :: "emifaGblctlNoHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "Global Control"
	prop Set :: (
		.NOHOLD_SETUP = $1,
		.GBLCTL_VALUE = .GBLCTL_VALUE_update(),
		"ok"
	     )
	 }
    prop NOHOLD_GBLCTL :: (
         if (.NOHOLD_SETUP == "Disable Hold") {
            0x00000080
        }
	else {
            0x00000000
	}
    ) 
    
   inst CLK4EN_SETUP :: "Enabled to clock" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Held high,Enabled to clock"
        prop Label :: "CLKOUT4 Enable (CLK4EN)"
        prop JSName :: "emifaGblctlClk4en"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT != 0) ? 1 : 0
        prop NoGen :: 1
        prop TabName :: "Global Control"
	prop Set :: (
		.CLK4EN_SETUP = $1,
		.GBLCTL_VALUE = .GBLCTL_VALUE_update(),
		"ok"
	        )
	}
    prop CLK4EN_GBLCTL :: (
         if (.CLK4EN_SETUP == "Held high") {
            0x00000000
        }
	else {
            0x00000010
		}
    ) 
   
 inst CLK6EN_SETUP :: "Enabled to clock" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Held high,Enabled to clock"
        prop Label :: "CLKOUT6 Enable (CLK6EN)"
        prop JSName :: "emifaGblctlClk6en"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT != 0) ? 1 : 0
        prop NoGen :: 1
        prop TabName :: "Global Control"
	prop Set :: (
		.CLK6EN_SETUP = $1,
		.GBLCTL_VALUE = .GBLCTL_VALUE_update(),
		"ok"
	        )
	}
    prop CLK6EN_GBLCTL :: (
         if (.CLK6EN_SETUP == "Held high") {
            0x00000000
        }
	else {
            0x00000008
		}
    ) 
 
    inst EK1EN_SETUP :: "Enabled to clock" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Held low,Enabled to clock"
        prop Label :: "ECLKOUT1 Enable (EK1EN)"
        prop JSName :: "emifaGblctlEk1en"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT != 0) ? 1 : 0
        prop NoGen :: 1
        prop TabName :: "Global Control"
	prop Set :: (
		.EK1EN_SETUP = $1,
		.GBLCTL_VALUE = .GBLCTL_VALUE_update(),
		"ok"
	        )
	}
    prop EK1EN_GBLCTL :: (
         if (.EK1EN_SETUP == "Held low") {
            0x00000000
        }
	else {
            0x00000020
		}
    ) 
   
inst EK2EN_SETUP :: "Enabled to clock" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Held low,Enabled to clock"
        prop Label :: "ECLKOUT2 Enable (EK2EN)"
        prop JSName :: "emifaGblctlEk2en"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT != 0) ? 1 : 0
        prop NoGen :: 1
        prop TabName :: "Global Control"
	prop Set :: (
		.EK2EN_SETUP = $1,
		.GBLCTL_VALUE = .GBLCTL_VALUE_update(),
		"ok"
	        )
	}
    prop EK2EN_GBLCTL :: (
         if (.EK2EN_SETUP == "Held low") {
            0x00000000
        }
	else {
            0x00010000
		}
    ) 
inst EK1HZ_SETUP :: "High-Z during hold" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Clock during hold,High-Z during hold"
        prop Label :: "ECLKOUT1 High-Z Control (EK1HZ)"
        prop JSName :: "emifaGblctlEk1hz"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT != 0) ? 1 : 0
        prop NoGen :: 1
        prop TabName :: "Global Control"
	prop Set :: (
		.EK1HZ_SETUP = $1,
		.GBLCTL_VALUE = .GBLCTL_VALUE_update(),
		"ok"
	        )
	}
    prop EK1HZ_GBLCTL :: (
         if (.EK1HZ_SETUP == "Clock during hold") {
            0x00000000
        }
	else {
            0x00000040
		}
    ) 
inst EK2HZ_SETUP :: "Clock during hold" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Clock during hold,High-Z during hold"
        prop Label :: "ECLKOUT2 High-Z Control (EK2HZ)"
        prop JSName :: "emifaGblctlEk2hz"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT != 0) ? 1 : 0
        prop NoGen :: 1
        prop TabName :: "Global Control"
	prop Set :: (
		.EK2HZ_SETUP = $1,
		.GBLCTL_VALUE = .GBLCTL_VALUE_update(),
		"ok"
	        )
	}
    prop EK2HZ_GBLCTL :: (
         if (.EK2HZ_SETUP == "Clock during hold") {
            0x00000000
        }
	else {
            0x00020000
		}
    ) 
inst EK2RATE_SETUP :: "1/4x EMIF input clock" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "1x EMIF input clock,1/2x EMIF input clock,1/4x EMIF input clock"
        prop Label :: "ECLKOUT2 Rate (EK2RATE)"
        prop JSName :: "emifaGblctlEk2rate"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT != 0) ? 1 : 0
        prop NoGen :: 1
        prop TabName :: "Global Control"
	prop Set :: (
		.EK2RATE_SETUP = $1,
		.GBLCTL_VALUE = .GBLCTL_VALUE_update(),
		"ok"
	        )
	}
    prop EK2RATE_GBLCTL :: (
         if (.EK2RATE_SETUP == "1x EMIF input clock") {
            0x00000000
        }
	  else {
         if (.EK2RATE_SETUP == "1/2x EMIF input clock") {
            0x00040000
		} else {
               if (.EK2RATE_SETUP == "1/4x EMIF input clock") {
                   0x00080000
                  }
             }
         }
               
    ) 
     
inst BRMODE_SETUP :: "access/refresh pending or in progress" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "access/refresh pending or in progress,access pending or in progress"
        prop Label :: "Bus Request Mode"
        prop JSName :: "emifaGblctlBrmode"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT != 0) ? 1 : 0
        prop NoGen :: 1
        prop TabName :: "Global Control"
	prop Set :: (
		.BRMODE_SETUP = $1,
		.GBLCTL_VALUE = .GBLCTL_VALUE_update(),
		"ok"
	        )
	}
    prop BRMODE_GBLCTL :: (
         if (.BRMODE_SETUP == "access pending or in progress") {
            0x00000000
        }
	  else {
         if (.BRMODE_SETUP == "access/refresh pending or in progress") {
            0x00002000
		} 
         }               
    ) 
 
   inst MTYPE0_SETUP :: "32-bit async. interf." {   
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "  8-bit async. interf.,16-bit async. interf.,32-bit async. interf.,64-bit async. interf.,  8-bit SDRAM,16-bit SDRAM,32-bit SDRAM,64-bit SDRAM,  8-bit prog. sync. mem,16-bit prog. sync. mem,32-bit prog. sync. mem,64-bit prog. sync. mem"
        prop Label :: "Memory Type (MTYPE)"    
        prop JSName :: "emifaCectl0Mtype"      
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFA_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	  prop Set :: (
               
		.MTYPE0_SETUP = $1,
		.CECTL0_VALUE = .CECTL0_VALUE_update(),
		"ok" 
	)
   }
    prop MTYPE0_CECTL0 :: (
     if (.MTYPE0_SETUP == "32-bit async. interf.") {
            0x00000020
        } else {
            if (.MTYPE0_SETUP == "32-bit SDRAM") {
            0x00000030
		} else {     
                 if ( .MTYPE0_SETUP == "32-bit prog. sync. mem") {
                 0x00000040 
                   } else {
                       if ( .MTYPE0_SETUP == "  8-bit async. interf.") {
                         0x00000000 
                        } else {
                            if ( .MTYPE0_SETUP == "  8-bit SDRAM") {
                             0x00000080 
                             } else {
                                if ( .MTYPE0_SETUP == "  8-bit prog. sync. mem") {
                                 0x000000a0 
                                   } else {
                                      if ( .MTYPE0_SETUP == "16-bit async. interf.") {
                                        0x00000010 
                                       } else {
                                           if ( .MTYPE0_SETUP == "16-bit SDRAM") {
                                            0x00000090 
                                            } else {
                                                if ( .MTYPE0_SETUP == "16-bit prog. sync. mem") {
                                                   0x000000b0 
                                                   } else {
                                                       if ( .MTYPE0_SETUP == "64-bit async. interf.") {
                                                          0x000000c0 
                                                          } else {
                                                              if ( .MTYPE0_SETUP == "64-bit SDRAM") {
                                                                 0x000000d0 
                                                                 } else {
                                                                     if ( .MTYPE0_SETUP == "64-bit prog. sync. mem") {
                                                                        0x000000e0 
                                                                        }
                                                            }
                                                      }
                                                }
                                          }
                                     }
                                }       
                           }
                       }
                 }
            }   
         }       
    ) 
 
 
 
 inst  RDSTRB0_SETUP :: 63{
    	prop Label :: "Read Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl0ReadStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 63 ) {
		.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")
	    }
	    else {
              .RDSTRB0_SETUP = $1,
              .CECTL0_VALUE = .CECTL0_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSTRB0_CECTL0 :: (
          ((.RDSTRB0_SETUP) << 8)
       )   
       
 inst  RDSETUP0_SETUP :: 15{
    	prop Label :: "Read Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl0ReadSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")
	    } else {
              .RDSETUP0_SETUP = $1,
              .CECTL0_VALUE = .CECTL0_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSETUP0_CECTL0 :: (
          ((.RDSETUP0_SETUP  )<< 16)
       )   
  inst  RDHLD0_SETUP :: 3 {
    	prop Label :: "Read Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl0ReadHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	prop Set :: (
        if ((!CSL.C11_SUPPORT)) { 
	    if ( $1 < 0 || $1 > 3 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 3 cycless")
                    } else {
                     .RDHLD0_SETUP = $1,
                     .CECTL0_VALUE = .CECTL0_VALUE_update(),
		      "ok"
	            }
	   }  else {
	          if ( $1 < 0 || $1 > 7 ) {
		     .error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")
                       } else {
                      .RDHLD0_SETUP = $1,
                       .CECTL0_VALUE = .CECTL0_VALUE_update(),
		        "ok"
	               }
           }    
	)
      }
      
   prop RDHLD0_CECTL0 :: (
          (.RDHLD0_SETUP)
       )   
       
      
  
   inst  WRSTRB0_SETUP :: 63{
    	prop Label :: "Write Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl0WriteStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 63 ) {
		.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")
	    } else {
              .WRSTRB0_SETUP = $1,
              .CECTL0_VALUE = .CECTL0_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop WRSTRB0_CECTL0 :: (
          ((.WRSTRB0_SETUP )<< 22)
       )   
       
 inst  WRSETUP0_SETUP :: 15{
    	prop Label :: "Write Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl0WriteSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")
	    } else {
              .WRSETUP0_SETUP = $1,
              .CECTL0_VALUE = .CECTL0_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop WRSETUP0_CECTL0 :: (
          ((.WRSETUP0_SETUP ) << 28) 
       )   
    inst  WRHLD0_SETUP :: 3 {
    	prop Label :: "Write Hold Width (WRHLD-WRHLDMSB) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl0WriteHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 7 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")
             } else {
                     .WRHLD0_SETUP = $1,
                     .CECTL0_VALUE = .CECTL0_VALUE_update(),
		          "ok"
	            }
	       
	         )
      }
      
    prop WRHLD0_CECTL0 :: (
       if ( .WRHLD0_SETUP > 3 ) {
         ( (.WRHLD0_SETUP - 4) << 20)     
      } else {   
           ((.WRHLD0_SETUP << 20) )
       }    
     )       
    prop WRHLDMSB0_CECTL0 :: (
     if (.WRHLD0_SETUP > 3) {
            0x00000008
        } else {
            0x00000000
    }                                                            
  )  
        
 
 inst TA0_SETUP :: 3 {
    	prop Label :: "Turn around time (TA) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl0Ta"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	prop Set :: (
	    if ( $1 < 1 || $1 > 3 ) {
		.error(" Minimum: 1 ECLKOU1 cycle - Maximum : 3 ECLKOU1 cycles")
	    } else {
              .TA0_SETUP = $1,
              .CECTL0_VALUE = .CECTL0_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop TA0_CECTL0 :: (
          (.TA0_SETUP << 14) 
       )   
 
  inst MTYPE1_SETUP :: "32-bit async. interf." {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "  8-bit async. interf.,16-bit async. interf.,32-bit async. interf.,64-bit async. interf.,  8-bit SDRAM,16-bit SDRAM,32-bit SDRAM,64-bit SDRAM,  8-bit prog. sync. mem,16-bit prog. sync. mem,32-bit prog. sync. mem,64-bit prog. sync. mem"
        prop Label :: "Memory Type (MTYPE)"
        prop JSName :: "emifaCectl1Mtype"      
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFA_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	  prop Set :: (
               
		.MTYPE1_SETUP = $1,
		.CECTL1_VALUE = .CECTL1_VALUE_update(),
		"ok" 
	)
   }
    prop MTYPE1_CECTL1 :: (
     if (.MTYPE1_SETUP == "32-bit async. interf.") {
            0x00000020
        } else {
            if (.MTYPE1_SETUP == "32-bit SDRAM") {
            0x00000030
		} else {     
                 if ( .MTYPE1_SETUP == "32-bit prog. sync. mem") {
                 0x00000040 
                   } else {
                       if ( .MTYPE1_SETUP == "  8-bit async. interf.") {
                         0x00000000 
                        } else {
                            if ( .MTYPE1_SETUP == "  8-bit SDRAM") {
                             0x00000080 
                             } else {
                                if ( .MTYPE1_SETUP == "  8-bit prog. sync. mem") {
                                 0x000000a0 
                                   } else {
                                      if ( .MTYPE1_SETUP == "16-bit async. interf.") {
                                        0x00000010 
                                       } else {
                                           if ( .MTYPE1_SETUP == "16-bit SDRAM") {
                                            0x00000090 
                                            } else {
                                                if ( .MTYPE1_SETUP == "16-bit prog. sync. mem") {
                                                   0x000000b0 
                                                   } else {
                                                       if ( .MTYPE1_SETUP == "64-bit async. interf.") {
                                                          0x000000c0 
                                                          } else {
                                                              if ( .MTYPE1_SETUP == "64-bit SDRAM") {
                                                                 0x000000d0 
                                                                 } else {
                                                                     if ( .MTYPE1_SETUP == "64-bit prog. sync. mem") {
                                                                        0x000000e0 
                                                                        }
                                                            }
                                                      }
                                                }
                                          }
                                     }
                                }       
                           }
                       }
                 }
            }   
         }       
    ) 
  
 
 inst  RDSTRB1_SETUP :: 63{
    	prop Label :: "Read Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl1ReadStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 63 ) {
		.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")
	    } else {
              .RDSTRB1_SETUP = $1,
              .CECTL1_VALUE = .CECTL1_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSTRB1_CECTL1 :: (
          ((.RDSTRB1_SETUP) << 8)
       )   
       
 inst  RDSETUP1_SETUP :: 15{
    	prop Label :: "Read Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl1ReadSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")
	    } else {
              .RDSETUP1_SETUP = $1,
              .CECTL1_VALUE = .CECTL1_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSETUP1_CECTL1 :: (
          ((.RDSETUP1_SETUP) << 16)
       )   
  inst  RDHLD1_SETUP :: 3 {
    	prop Label :: "Read Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl1ReadHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	prop Set :: (
        if ((!CSL.C11_SUPPORT)) { 
	    if ( $1 < 0 || $1 > 3 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 3 cycless")
                    } else {
                     .RDHLD1_SETUP = $1,
                     .CECTL1_VALUE = .CECTL1_VALUE_update(),
		      "ok"
	            }
	   }  else {
	          if ( $1 < 0 || $1 > 7 ) {
		     .error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")
                       } else {
                      .RDHLD1_SETUP = $1,
                       .CECTL1_VALUE = .CECTL1_VALUE_update(),
		        "ok"
	               }
           }    
	)
      }
      
   prop RDHLD1_CECTL1 :: (
          (.RDHLD1_SETUP)
       )   
       
      
  
   inst  WRSTRB1_SETUP :: 63{
    	prop Label :: "Write Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl1WriteStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 63 ) {
		.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")
	    } else {
              .WRSTRB1_SETUP = $1,
              .CECTL1_VALUE = .CECTL1_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop WRSTRB1_CECTL1 :: (
          ((.WRSTRB1_SETUP ) << 22)
       )   
       
 inst  WRSETUP1_SETUP :: 15{
    	prop Label :: "Write Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl1WriteSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")
	    } else {
              .WRSETUP1_SETUP = $1,
              .CECTL1_VALUE = .CECTL1_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop WRSETUP1_CECTL1 :: (
          ((.WRSETUP1_SETUP ) << 28)
       )   
    inst  WRHLD1_SETUP :: 3 {
    	prop Label :: "Write Hold Width (WRHLD - WHLDMSB) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl1WriteHold"
      prop Visible :: 1
      prop Writable :: (CSL.EMIFA_SUPPORT) 
      prop NoGen :: 1
      prop TabName :: "CE1 Space"
	prop Set :: (
        	if ( $1 < 0 || $1 > 7 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")
                 } else {
                     .WRHLD1_SETUP = $1,
                     .CECTL1_VALUE = .CECTL1_VALUE_update(),
	        	      "ok"
	            }
              )
	  }
      
   prop WRHLD1_CECTL1 :: (
       if ( .WRHLD1_SETUP > 3 ) {
         ( (.WRHLD1_SETUP - 4) << 20)
      } else {   
           ((.WRHLD1_SETUP << 20) )
       }    
     )   
  
  prop WRHLDMSB1_CECTL1 :: (
    if ( .WRHLD1_SETUP > 3 ) { 
        0x00000008 
      } else {
        0x00000000
     }
   )  
        
 
 inst TA1_SETUP ::  3 {
    	prop Label :: "Turn around time (TA) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl1Ta"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	prop Set :: (
	    if ( $1 < 1 || $1 > 3 ) {
		.error(" Minimum: 1 ECLKOU1 cycle - Maximum : 3 ECLKOU1 cycles")
	    } else {
              .TA1_SETUP = $1,
              .CECTL1_VALUE = .CECTL1_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop TA1_CECTL1 :: (
          (.TA1_SETUP << 14) 
    )
          
 
inst MTYPE2_SETUP :: "32-bit async. interf." {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "  8-bit async. interf.,16-bit async. interf.,32-bit async. interf.,64-bit async. interf.,  8-bit SDRAM,16-bit SDRAM,32-bit SDRAM,64-bit SDRAM,  8-bit prog. sync. mem,16-bit prog. sync. mem,32-bit prog. sync. mem,64-bit prog. sync. mem"
        prop Label :: "Memory Type (MTYPE)"
        prop JSName :: "emifaCectl2Mtype"      
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFA_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	  prop Set :: (
               
		.MTYPE2_SETUP = $1,
		.CECTL2_VALUE = .CECTL2_VALUE_update(),
		"ok" 
	)
   }
    prop MTYPE2_CECTL2 :: (
     if (.MTYPE2_SETUP == "32-bit async. interf.") {
            0x00000020
        } else {
            if (.MTYPE2_SETUP == "32-bit SDRAM") {
            0x00000030
		} else {     
                 if ( .MTYPE2_SETUP == "32-bit prog. sync. mem") {
                 0x00000040 
                   } else {
                       if ( .MTYPE2_SETUP == "  8-bit async. interf.") {
                         0x00000000 
                        } else {
                            if ( .MTYPE2_SETUP == "  8-bit SDRAM") {
                             0x00000080 
                             } else {
                                if ( .MTYPE2_SETUP == "  8-bit prog. sync. mem") {
                                 0x000000a0 
                                   } else {
                                      if ( .MTYPE2_SETUP == "16-bit async. interf.") {
                                        0x00000010 
                                       } else {
                                           if ( .MTYPE2_SETUP == "16-bit SDRAM") {
                                            0x00000090 
                                            } else {
                                                if ( .MTYPE2_SETUP == "16-bit prog. sync. mem") {
                                                   0x000000b0 
                                                   } else {
                                                       if ( .MTYPE2_SETUP == "64-bit async. interf.") {
                                                          0x000000c0 
                                                          } else {
                                                              if ( .MTYPE2_SETUP == "64-bit SDRAM") {
                                                                 0x000000d0 
                                                                 } else {
                                                                     if ( .MTYPE2_SETUP == "64-bit prog. sync. mem") {
                                                                        0x000000e0 
                                                                        }
                                                            }
                                                      }
                                                }
                                          }
                                     }
                                }       
                           }
                       }
                 }
            }   
         }       
    ) 
 
 
 
 inst  RDSTRB2_SETUP :: 63{
    	prop Label :: "Read Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl2ReadStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 63 ) {
		.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")
	    } else {
              .RDSTRB2_SETUP = $1,
              .CECTL2_VALUE = .CECTL2_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSTRB2_CECTL2 :: (
          ((.RDSTRB2_SETUP ) << 8)
       )   
       
 inst  RDSETUP2_SETUP :: 15{
    	prop Label :: "Read Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl2ReadSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")
	    } else {
              .RDSETUP2_SETUP = $1,
              .CECTL2_VALUE = .CECTL2_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSETUP2_CECTL2 :: (
          ((.RDSETUP2_SETUP )<< 16)
       )   
  inst  RDHLD2_SETUP :: 3 {
    	prop Label :: "Read Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl2ReadHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	prop Set :: (
        if ((!CSL.C11_SUPPORT)) { 
	    if ( $1 < 0 || $1 > 3 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 3 cycless")
                    } else {
                     .RDHLD2_SETUP = $1,
                     .CECTL2_VALUE = .CECTL2_VALUE_update(),
		      "ok"
	            }
	   }  else {
	          if ( $1 < 0 || $1 > 7 ) {
		     .error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")
                       } else {
                      .RDHLD2_SETUP = $1,
                       .CECTL2_VALUE = .CECTL2_VALUE_update(),
		        "ok"
	               }
           }    
	)
      }
      
   prop RDHLD2_CECTL2 :: (
          (.RDHLD2_SETUP)
       )   
       
      
  
   inst  WRSTRB2_SETUP :: 63{
    	prop Label :: "Write Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl2WriteStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 63 ) {
		.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")
	    } else {
              .WRSTRB2_SETUP = $1,
              .CECTL2_VALUE = .CECTL2_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop WRSTRB2_CECTL2 :: (
          ((.WRSTRB2_SETUP )<< 22)
       )   
       
 inst  WRSETUP2_SETUP :: 15{
    	prop Label :: "Write Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl2WriteSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")
	    } else {
              .WRSETUP2_SETUP = $1,
              .CECTL2_VALUE = .CECTL2_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop WRSETUP2_CECTL2 :: (
          ((.WRSETUP2_SETUP )<< 28)
       )   
    inst  WRHLD2_SETUP :: 3 {
    	prop Label :: "Write Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl2WriteHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	prop Set :: (
        	    if ( $1 < 0 || $1 > 7 ) {
		      .error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")
                    } else {
                     .WRHLD2_SETUP = $1,
                     .CECTL2_VALUE = .CECTL2_VALUE_update(),
		      "ok"
	            }
	              
	   )
      }
      
   prop WRHLD2_CECTL2 :: (
       if ( .WRHLD2_SETUP > 3 ) {
         ( (.WRHLD2_SETUP - 4) << 20)
      } else {   
           ((.WRHLD2_SETUP << 20) )
       }    
     )   
  
  prop WRHLDMSB2_CECTL2 :: (
    if ( .WRHLD2_SETUP > 3 ) { 
      0x00000008 
    } else {
     0x00000000
     }
   )
   
        
 
 inst TA2_SETUP :: 3 {
    	prop Label :: "Turn around time (TA) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl2Ta"
      prop Visible :: 1
      prop Writable :: (CSL.EMIFA_SUPPORT) 
      prop NoGen :: 1
      prop TabName :: "CE2 Space"
	prop Set :: (
	    if ( $1 < 1 || $1 > 3 ) {
		.error(" Minimum: 1 ECLKOU1 cycle - Maximum : 3 ECLKOU1 cycles")
	    } else {
              .TA2_SETUP = $1,
              .CECTL2_VALUE = .CECTL2_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop TA2_CECTL2 :: (
          (.TA2_SETUP << 14) 
       )   
 
    inst MTYPE3_SETUP :: "32-bit async. interf." {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "  8-bit async. interf.,16-bit async. interf.,32-bit async. interf.,64-bit async. interf.,  8-bit SDRAM,16-bit SDRAM,32-bit SDRAM,64-bit SDRAM,  8-bit prog. sync. mem,16-bit prog. sync. mem,32-bit prog. sync. mem,64-bit prog. sync. mem"
        prop Label :: "Memory Type (MTYPE)"
        prop JSName :: "emifaCectl3Mtype"      
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFA_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	  prop Set :: (
               
		.MTYPE3_SETUP = $1,
		.CECTL3_VALUE = .CECTL3_VALUE_update(),
		"ok" 
	)
   }
    prop MTYPE3_CECTL3 :: (
     if (.MTYPE3_SETUP == "32-bit async. interf.") {
            0x00000020
        } else {
            if (.MTYPE3_SETUP == "32-bit SDRAM") {
            0x00000030
		} else {     
                 if ( .MTYPE3_SETUP == "32-bit prog. sync. mem") {
                 0x00000040 
                   } else {
                       if ( .MTYPE3_SETUP == "  8-bit async. interf.") {
                         0x00000000 
                        } else {
                            if ( .MTYPE3_SETUP == "  8-bit SDRAM") {
                             0x00000080 
                             } else {
                                if ( .MTYPE3_SETUP == "  8-bit prog. sync. mem") {
                                 0x000000a0 
                                   } else {
                                      if ( .MTYPE3_SETUP == "16-bit async. interf.") {
                                        0x00000010 
                                       } else {
                                           if ( .MTYPE3_SETUP == "16-bit SDRAM") {
                                            0x00000090 
                                            } else {
                                                if ( .MTYPE3_SETUP == "16-bit prog. sync. mem") {
                                                   0x000000b0 
                                                   } else {
                                                       if ( .MTYPE3_SETUP == "64-bit async. interf.") {
                                                          0x000000c0 
                                                          } else {
                                                              if ( .MTYPE3_SETUP == "64-bit SDRAM") {
                                                                 0x000000d0 
                                                                 } else {
                                                                     if ( .MTYPE3_SETUP == "64-bit prog. sync. mem") {
                                                                        0x000000e0 
                                                                        }
                                                            }
                                                      }
                                                }
                                          }
                                     }
                                }       
                           }
                       }
                 }
            }   
         }       
    ) 
 
 
 
 inst  RDSTRB3_SETUP :: 63{
    	prop Label :: "Read Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl3ReadStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 63 ) {
		.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")
	    } else {
              .RDSTRB3_SETUP = $1,
              .CECTL3_VALUE = .CECTL3_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSTRB3_CECTL3 :: (
          ((.RDSTRB3_SETUP ) << 8)
       )   
       
 inst  RDSETUP3_SETUP :: 15{
    	prop Label :: "Read Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl3ReadSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")
	    } else {
              .RDSETUP3_SETUP = $1,
              .CECTL3_VALUE = .CECTL3_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSETUP3_CECTL3 :: (
          ((.RDSETUP3_SETUP )<< 16)
       )   
  inst  RDHLD3_SETUP :: 3 {
    	prop Label :: "Read Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl3ReadHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	prop Set :: (
        if ((!CSL.C11_SUPPORT)) { 
	    if ( $1 < 0 || $1 > 3 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 3 cycless")
                    } else {
                     .RDHLD3_SETUP = $1,
                     .CECTL3_VALUE = .CECTL3_VALUE_update(),
		      "ok"
	            }
	   }  else {
	          if ( $1 < 0 || $1 > 7 ) {
		     .error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")
                       } else {
                      .RDHLD3_SETUP = $1,
                       .CECTL3_VALUE = .CECTL3_VALUE_update(),
		        "ok"
	               }
           }    
	)
      }
      
   prop RDHLD3_CECTL3 :: (
          (.RDHLD3_SETUP)
       )   
       
      
  
   inst  WRSTRB3_SETUP :: 63{
    	prop Label :: "Write Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl3WriteStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 63 ) {
		.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")
	    } else {
              .WRSTRB3_SETUP = $1,
              .CECTL3_VALUE = .CECTL3_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop WRSTRB3_CECTL3 :: (
          ((.WRSTRB3_SETUP )<< 22)
       )   
       
 inst  WRSETUP3_SETUP :: 15{
    	prop Label :: "Write Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl3WriteSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")
	    } else {
              .WRSETUP3_SETUP = $1,
              .CECTL3_VALUE = .CECTL3_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop WRSETUP3_CECTL3 :: (
          ((.WRSETUP3_SETUP) << 28)
       )   
    inst  WRHLD3_SETUP :: 3 {
    	prop Label :: "Write Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl3WriteHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	prop Set :: (  
	       if ( $1 < 0 || $1 > 7 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")
                    } else {
                     .WRHLD3_SETUP = $1,
                     .CECTL3_VALUE = .CECTL3_VALUE_update(),
		      "ok"
	            }
	  	)
      }
      
   prop WRHLD3_CECTL3 :: (
       if ( .WRHLD3_SETUP > 3 ) {
         ( (.WRHLD3_SETUP - 4) << 20)
      } else {   
           ((.WRHLD3_SETUP << 20) )
       }    
     )   
  
  prop WRHLDMSB3_CECTL3 :: (
    if ( .WRHLD3_SETUP > 3 ) {
        0x00000008 
    } else {
     0x00000000
     }
   )  
        
 
 inst TA3_SETUP :: 3 {
    	prop Label :: "Turn around time (TA) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaCectl3Ta"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	prop Set :: (
	    if ( $1 < 1 || $1 > 3 ) {
		.error(" Minimum: 1 ECLKOU1 cycle - Maximum : 3 ECLKOU1 cycles")
	    } else {
              .TA3_SETUP = $1,
              .CECTL3_VALUE = .CECTL3_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop TA3_CECTL3 :: (
          (.TA3_SETUP << 14) 
       )   
 
                                                                          
 inst SYNCRL0_SETUP :: "2 cycles"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data read latency (SYNCRL)"
        prop JSName :: "emifaCesec0Syncrl"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFA_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	  prop Set :: (
               
		.SYNCRL0_SETUP = $1,
		.CESEC0_VALUE = .CESEC0_VALUE_update(),
		"ok" 
	)
   }
    prop SYNCRL0_CESEC0 :: (
     if (.SYNCRL0_SETUP == "0 cycle") {
            0x00000000
        } else {
            if (.SYNCRL0_SETUP == "1 cycle") {
            0x00000001
		} else {     
                 if ( .SYNCRL0_SETUP == "2 cycles") {
                 0x00000002 
                   } else {
                         0x00000003 
                     }
              }   
         }       
    )   
                                                                 
 inst SYNCWL0_SETUP :: "0 cycle"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data write latency (SYNCWL)"
        prop Visible :: 1
        prop JSName :: "emifaCesec0Syncwl"  
        prop Writable :: ((CSL.EMIFA_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	  prop Set :: (
               
		.SYNCWL0_SETUP = $1,
		.CESEC0_VALUE = .CESEC0_VALUE_update(),
		"ok" 
	)
   }
    prop SYNCWL0_CESEC0 :: (
     if (.SYNCWL0_SETUP == "0 cycle") {
            0x00000000
        } else {
            if (.SYNCWL0_SETUP == "1 cycle") {
            0x00000004
		} else {     
                 if ( .SYNCWL0_SETUP == "2 cycles") {
                 0x00000008 
                   } else {
                         0x0000000c 
                     }
              }   
         }       
    )   
 inst CEEXT0_SETUP :: "Inactive"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Inactive,Active"
        prop Label :: "CE Extension Register (CEEXT)"
        prop JSName :: "emifaCesec0Ceext"  
       prop Visible :: 1
        prop Writable :: ((CSL.EMIFA_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	  prop Set :: (
               
		.CEEXT0_SETUP = $1,
		.CESEC0_VALUE = .CESEC0_VALUE_update(),
		"ok" 
	)
   }
    prop CEEXT0_CESEC0 :: (
     if (.CEEXT0_SETUP == "Inactive") {
            0x00000000
        } else { 
            0x0000010
		}                        
    )   
inst RENEN0_SETUP :: "ADS Mode"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "ADS Mode,Read Enable Mode"
        prop Label :: "Read Enable Enable (RENEN)"
        prop JSName :: "emifaCesec0Renen"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFA_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	  prop Set :: (
               
		.RENEN0_SETUP = $1,
		.CESEC0_VALUE = .CESEC0_VALUE_update(),
		"ok" 
	)
   }
    prop RENEN0_CESEC0 :: (
     if (.RENEN0_SETUP == "ADS Mode") {
            0x00000000
        } else { 
            0x0000020
		}                        
    )   
inst SNCCLK0_SETUP :: "Sync. to ECLKOUT1"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Sync. to ECLKOUT1,Sync. to ECLKOUT2"
        prop Label :: "Synchronization Clock (SNCCLK)"
        prop JSName :: "emifaCesec0Sncclk"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFA_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	  prop Set :: (
               
		.SNCCLK0_SETUP = $1,
		.CESEC0_VALUE = .CESEC0_VALUE_update(),
		"ok" 
	)
   }
    prop SNCCLK0_CESEC0 :: (
     if (.SNCCLK0_SETUP == "Sync. to ECLKOUT1") {
            0x00000000
        } else { 
            0x0000040
		}                        
    )   
 
 inst SYNCRL1_SETUP :: "2 cycles"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data read latency (SYNCRL)"
        prop JSName :: "emifaCesec1Syncrl"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFA_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	  prop Set :: (
               
		.SYNCRL1_SETUP = $1,
		.CESEC1_VALUE = .CESEC1_VALUE_update(),
		"ok" 
	)
   }
    prop SYNCRL1_CESEC1 :: (
     if (.SYNCRL1_SETUP == "0 cycle") {
            0x00000000
        } else {
            if (.SYNCRL1_SETUP == "1 cycle") {
            0x00000001
		} else {     
                 if ( .SYNCRL1_SETUP == "2 cycles") {
                 0x00000002 
                   } else {
                         0x00000003 
                     }
              }   
         }       
    )   
                                                               
 inst SYNCWL1_SETUP :: "0 cycle"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data write latency (SYNCWL)"
        prop JSName :: "emifaCesec1Syncwl"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFA_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	  prop Set :: (
               
		.SYNCWL1_SETUP = $1,
		.CESEC1_VALUE = .CESEC1_VALUE_update(),
		"ok" 
	)
   }
    prop SYNCWL1_CESEC1 :: (
     if (.SYNCWL1_SETUP == "0 cycle") {
            0x00000000
        } else {
            if (.SYNCWL1_SETUP == "1 cycle") {
            0x00000004
		} else {     
                 if ( .SYNCWL1_SETUP == "2 cycles") {
                 0x00000008 
                   } else {
                         0x0000000c 
                     }
              }   
         }       
    )   
 inst CEEXT1_SETUP :: "Inactive"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Inactive,Active"
        prop Label :: "CE Extension Register (CEEXT)"
        prop JSName :: "emifaCesec1Ceext"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFA_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	  prop Set :: (
               
		.CEEXT1_SETUP = $1,
		.CESEC1_VALUE = .CESEC1_VALUE_update(),
		"ok" 
	)
   }
    prop CEEXT1_CESEC1 :: (
     if (.CEEXT1_SETUP == "Inactive") {
            0x00000000
        } else { 
            0x0000010
		}                        
    )   
inst RENEN1_SETUP :: "ADS Mode"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "ADS Mode,Read Enable Mode"
        prop Label :: "Read Enable Enable (RENEN)"
        prop JSName :: "emifaCesec1Renen"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFA_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	  prop Set :: (
               
		.RENEN1_SETUP = $1,
		.CESEC1_VALUE = .CESEC1_VALUE_update(),
		"ok" 
	)
   }
    prop RENEN1_CESEC1 :: (
     if (.RENEN1_SETUP == "ADS Mode") {
            0x00000000
        } else { 
            0x0000020
		}                        
    )   
inst SNCCLK1_SETUP :: "Sync. to ECLKOUT1"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Sync. to ECLKOUT1,Sync. to ECLKOUT2"
        prop Label :: "Synchronization Clock (SNCCLK)"
        prop JSName :: "emifaCesec1Sncclk"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFA_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	  prop Set :: (
               
		.SNCCLK1_SETUP = $1,
		.CESEC1_VALUE = .CESEC1_VALUE_update(),
		"ok" 
	)
   }
    prop SNCCLK1_CESEC1 :: (
     if (.SNCCLK1_SETUP == "Sync. to ECLKOUT1") {
            0x00000000
        } else { 
            0x0000040
		}                        
    )   
 
inst SYNCRL2_SETUP :: "2 cycles"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data read latency (SYNCRL)"
        prop JSName :: "emifaCesec2Syncrl"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFA_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	  prop Set :: (
               
		.SYNCRL2_SETUP = $1,
		.CESEC2_VALUE = .CESEC2_VALUE_update(),
		"ok" 
	)
   }
    prop SYNCRL2_CESEC2 :: (
     if (.SYNCRL2_SETUP == "0 cycle") {
            0x00000000
        } else {
            if (.SYNCRL2_SETUP == "1 cycle") {
            0x00000001
		} else {     
                 if ( .SYNCRL2_SETUP == "2 cycles") {
                 0x00000002 
                   } else {
                         0x00000003 
                     }
              }   
         }       
    )   
                                                               
 inst SYNCWL2_SETUP :: "0 cycle"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data write latency (SYNCWL)"
        prop JSName :: "emifaCesec2Syncwl"  
       prop Visible :: 1
        prop Writable :: ((CSL.EMIFA_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	  prop Set :: (
               
		.SYNCWL2_SETUP = $1,
		.CESEC2_VALUE = .CESEC2_VALUE_update(),
		"ok" 
	)
   }
    prop SYNCWL2_CESEC2 :: (
     if (.SYNCWL2_SETUP == "0 cycle") {
            0x00000000
        } else {
            if (.SYNCWL2_SETUP == "1 cycle") {
            0x00000004
		} else {     
                 if ( .SYNCWL2_SETUP == "2 cycles") {
                 0x00000008 
                   } else {
                         0x0000000c 
                     }
              }   
         }       
    )   
 inst CEEXT2_SETUP :: "Inactive"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Inactive,Active"
        prop Label :: "CE Extension Register (CEEXT)"
        prop JSName :: "emifaCesec2Ceext"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFA_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	  prop Set :: (
               
		.CEEXT2_SETUP = $1,
		.CESEC2_VALUE = .CESEC2_VALUE_update(),
		"ok" 
	)
   }
    prop CEEXT2_CESEC2 :: (
     if (.CEEXT2_SETUP == "Inactive") {
            0x00000000
        } else { 
            0x0000010
		}                        
    )   
inst RENEN2_SETUP :: "ADS Mode"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "ADS Mode,Read Enable Mode"
        prop Label :: "Read Enable Enable (RENEN)"
        prop JSName :: "emifaCesec2Renen"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFA_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	  prop Set :: (
               
		.RENEN2_SETUP = $1,
		.CESEC2_VALUE = .CESEC2_VALUE_update(),
		"ok" 
	)
   }
    prop RENEN2_CESEC2 :: (
     if (.RENEN2_SETUP == "ADS Mode") {
            0x00000000
        } else { 
            0x0000020
		}                        
    )   
inst SNCCLK2_SETUP :: "Sync. to ECLKOUT1"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Sync. to ECLKOUT1,Sync. to ECLKOUT2"
        prop Label :: "Synchronization Clock (SNCCLK)"
        prop JSName :: "emifaCesec2Sncclk"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFA_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	  prop Set :: (
               
		.SNCCLK2_SETUP = $1,
		.CESEC2_VALUE = .CESEC2_VALUE_update(),
		"ok" 
	)
   }
    prop SNCCLK2_CESEC2 :: (
     if (.SNCCLK2_SETUP == "Sync. to ECLKOUT1") {
            0x00000000
        } else { 
            0x0000040
		}                        
    )   
 
  inst SYNCRL3_SETUP :: "2 cycles"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data read latency (SYNCRL)"
         prop JSName :: "emifaCesec3Syncrl"  
       prop Visible :: 1
        prop Writable :: ((CSL.EMIFA_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	  prop Set :: (
               
		.SYNCRL3_SETUP = $1,
		.CESEC3_VALUE = .CESEC3_VALUE_update(),
		"ok" 
	)
   }
    prop SYNCRL3_CESEC3 :: (
     if (.SYNCRL3_SETUP == "0 cycle") {
            0x00000000
        } else {
            if (.SYNCRL3_SETUP == "1 cycle") {
            0x00000001
		} else {     
                 if ( .SYNCRL3_SETUP == "2 cycles") {
                 0x00000002 
                   } else {
                         0x00000003 
                     }
              }   
         }       
    )   
                                                               
 inst SYNCWL3_SETUP :: "0 cycle"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data write latency (SYNCWL)"
         prop JSName :: "emifaCesec3Syncwl"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFA_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	  prop Set :: (
               
		.SYNCWL3_SETUP = $1,
		.CESEC3_VALUE = .CESEC3_VALUE_update(),
		"ok" 
	)
   }
    prop SYNCWL3_CESEC3 :: (
     if (.SYNCWL3_SETUP == "0 cycle") {
            0x00000000
        } else {
            if (.SYNCWL3_SETUP == "1 cycle") {
            0x00000004
		} else {     
                 if ( .SYNCWL3_SETUP == "2 cycles") {
                 0x00000008 
                   } else {
                         0x0000000c 
                     }
              }   
         }       
    )   
 inst CEEXT3_SETUP :: "Inactive"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Inactive,Active"
        prop Label :: "CE Extension Register (CEEXT)"
        prop JSName :: "emifaCesec3Ceext"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFA_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	  prop Set :: (
               
		.CEEXT3_SETUP = $1,
		.CESEC3_VALUE = .CESEC3_VALUE_update(),
		"ok" 
	)
   }
    prop CEEXT3_CESEC3 :: (
     if (.CEEXT3_SETUP == "Inactive") {
            0x00000000
        } else { 
            0x0000010
		}                        
    )   
inst RENEN3_SETUP :: "ADS Mode"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "ADS Mode,Read Enable Mode"
        prop Label :: "Read Enable Enable (RENEN)"
        prop JSName :: "emifaCesec3Renen"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFA_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	  prop Set :: (
               
		.RENEN3_SETUP = $1,
		.CESEC3_VALUE = .CESEC3_VALUE_update(),
		"ok" 
	)
   }
    prop RENEN3_CESEC3 :: (
     if (.RENEN3_SETUP == "ADS Mode") {
            0x00000000
        } else { 
            0x0000020
		}                        
    )   
inst SNCCLK3_SETUP :: "Sync. to ECLKOUT1"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Sync. to ECLKOUT1,Sync. to ECLKOUT2"
        prop Label :: "Synchronization Clock (SNCCLK)"
        prop JSName :: "emifaCesec3Sncclk"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFA_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	  prop Set :: (
               
		.SNCCLK3_SETUP = $1,
		.CESEC3_VALUE = .CESEC3_VALUE_update(),
		"ok" 
	)
   }
    prop SNCCLK3_CESEC3 :: (
     if (.SNCCLK3_SETUP == "Sync. to ECLKOUT1") {
            0x00000000
        } else { 
            0x0000040
		}                        
    )                                               
 
 inst TRC_SETUP :: 15 {
    	prop Label :: "TRC = trc/(eclkout1 period-1) (TRC) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaSdctlTrc"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error("Minimum TRC = 0 - Maximum TRC = 15 ")
	    } else {
              .TRC_SETUP = $1,
              .SDCTL_VALUE = .SDCTL_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop TRC_SDCTL :: (
          (.TRC_SETUP << 12) 
       )   
 inst TRP_SETUP :: 8 {
    	prop Label :: "TRP = trp/(eclkout1 period-1) (TRP) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaSdctlTrp"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error("Minimum TRP = 0 - Maximum TRP= 15 ")
	    } else {
              .TRP_SETUP = $1,
              .SDCTL_VALUE = .SDCTL_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop TRP_SDCTL :: (
          (.TRP_SETUP << 16) 
       )   
  
 
 inst TRCD_SETUP :: 4 {
    	prop Label :: "TRCD = trcd/(eclkout1 period-1) (TRCD) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaSdctlTrcd"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error("Minimum TRCD = 0 - Maximum TRCD= 15 ")
	    } else {
              .TRCD_SETUP = $1,
              .SDCTL_VALUE = .SDCTL_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop TRCD_SDCTL :: (
          (.TRCD_SETUP << 20) 
       )   
  
 inst INIT_SETUP :: "Initialize" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Initialize,No effect"
    	prop Label :: "Initialization of all SDRAMs (INIT)"
	prop JSName :: "emifaSdctlInit"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
              .INIT_SETUP = $1,
              .SDCTL_VALUE = .SDCTL_VALUE_update(),
		"ok"
	)
      }
      
   prop INIT_SDCTL :: (
         if  (.INIT_SETUP == "Initialize") {
          0x01000000
          } else {
          0x00000000
          }
       )   
 inst RFEN_SETUP :: "Enable" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Enable,Disable"
    	prop Label :: "SDRAM Refresh Enable (RFEN)"
	prop JSName :: "emifaSdctlRfen"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
              .RFEN_SETUP = $1,
              .SDCTL_VALUE = .SDCTL_VALUE_update(),
		"ok"
	)
      }
      
   prop RFEN_SDCTL :: (
         if  (.RFEN_SETUP == "Enable") {
          0x02000000
          } else {
          0x00000000
          }
       )   
  
     
 inst SDCSZ_SETUP :: " 9 addresses" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: " 9 addresses, 8 addresses,10 addresses"
    	prop Label :: "Column Size (SDCSZ)"
	prop JSName :: "emifaSdctlSdcsz"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
              .SDCSZ_SETUP = $1,
              .SDCTL_VALUE = .SDCTL_VALUE_update(),
		"ok"
	)
      }
      
   prop SDCSZ_SDCTL :: (
         if  (.SDCSZ_SETUP == " 8 addresses") {
          0x04000000
          } else {
             if  (.SDCSZ_SETUP == "10 addresses") {
              0x08000000
             } else {
             0x00000000
             } 
         }  
       )   
inst SDRSZ_SETUP :: "11 addresses" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "11 addresses,12 addresses,13 addresses"
    	prop Label :: "Row Size (SDRSZ)"
	prop JSName :: "emifaSdctlSdrsz"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
              .SDRSZ_SETUP = $1,
              .SDCTL_VALUE = .SDCTL_VALUE_update(),
		"ok"
	)
      }
      
   prop SDRSZ_SDCTL :: (
         if  (.SDRSZ_SETUP == "12 addresses") {
          0x10000000
          } else {
             if  (.SDRSZ_SETUP == "13 addresses") {
              0x20000000
             } else {
             0x00000000
             } 
         }  
       )   
inst SDBSZ_SETUP :: "Two banks" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Two banks,Four banks"
    	prop Label :: "Bank Size (SDBSZ)"
	prop JSName :: "emifaSdctlSdbsz"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
              .SDBSZ_SETUP = $1,
              .SDCTL_VALUE = .SDCTL_VALUE_update(),
		"ok"
	)
      }
      
   prop SDBSZ_SDCTL :: (
         if  (.SDBSZ_SETUP == "Four banks") {
          0x40000000
          } else {
              0x00000000
             } 
       )   
 inst SLFRFR_SETUP :: "Disable" {                                  
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
      prop Enum :: "Disable,Enable"
    	prop Label :: "Self-refresh mode(SLFRFR)"
      prop JSName :: "emifaSdctlSlfrfr"
      prop Visible :: 1
      prop Writable :: ((CSL.EMIFA_SUPPORT))? 1:0
      prop NoGen :: 1
      prop TabName :: "SDRAM Control"
	prop Set :: (
              .SLFRFR_SETUP = $1,
              .SDCTL_VALUE = .SDCTL_VALUE_update(),
		"ok"
	)
      }
      
      prop SLFRFR_SDCTL :: (
         if  (.SLFRFR_SETUP == "Enable") {
          0x00000001 
          } else {
              0x00000000
             } 
       )                                                            
inst PERIOD_SETUP2 :: 1500 {
    	prop Label :: "Refresh Period (ECLKOU1 cycles)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaSdtimEclkPeriod"
        prop Visible ::  1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
	    if ( $1 < 1 || $1 > 4096 ) {
		.error("1 cyc. < PERIOD < 4096 cyc. ")
	    } else {
              .PERIOD_SETUP2 = $1,
              .SDTIM_VALUE = .SDTIM_VALUE_update(),
		"ok"
	    }
	)
      }
      
      
      
   prop PERIOD_SDTIM2 :: (
          (.PERIOD_SETUP2)
        )   
inst XRFR_SETUP :: 1 {
    	prop Label :: "Extra Refreshes Ctrl. (XRFR)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaSdctlXrfr"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
	    if ( $1 < 1 || $1 > 4 ) {
		.error("1 < Extra refreshes < 4 ")
	    } else {
              .XRFR_SETUP = $1,
              .SDTIM_VALUE = .SDTIM_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop XRFR_SDTIM :: (
          ((.XRFR_SETUP - 1) << 24)
        )   
 
 inst TCL_SETUP :: 3  {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    	prop Label :: "CAS Latency (TCL)"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaSdextTcl"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 2 || $1 > 3 ) {
		.error("TCL : 2 or 3 ECLKOU1 cycles ")
	    } else {
              .TCL_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
            }    
        )
      }
      
   prop TCL_SDEXT :: (
         (.TCL_SETUP - 2)   
       )   
       
 inst TRAS_SETUP :: 8 {
    	prop Label :: "tras = TRAS + 1 (ECLKOU1 cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaSdextTras"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 8 ) {
		.error("1 ECLKOU1 cycle < tras < 8 ECLKOU1 cycles ")
	    } else {
              .TRAS_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop TRAS_SDEXT :: (
          ((.TRAS_SETUP - 1) << 1)
        )   
       
 inst TRRD_SETUP :: 3 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
    	prop Label :: "trrd = TRRD (2 or 3 ECLKOU1 cyc.)"
	prop JSName :: "emifaSdextTrrd"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 2 || $1 > 3 ) {
		.error("TRRD : 2 or 3 ECLKOU1 cycles ")
	    } else {
              .TRRD_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
              }  
        )
      }
      
   prop TRRD_SDEXT :: (
         (.TRRD_SETUP - 2) << 4  
       )   
 inst TWR_SETUP :: 2 {
    	prop Label :: "twr  = TWR + 1 (ECLKOU1 cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaSdextTwr"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 4 ) {
		.error("1 ECLKOU1 cycle < twr < 4 ECLKOU1 cycles ")
	    } else {
              .TWR_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop TWR_SDEXT :: (
          ((.TWR_SETUP - 1) << 5)
        )   
 inst THZP_SETUP :: 3 {
    	prop Label :: "thzp = THZP + 1 (ECLKOU1 cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaSdextThzp"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 4 ) {
		.error("1 ECLKOU1 cycle < thzp < 4 ECLKOU1 cycles ")
	    } else {
              .THZP_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop THZP_SDEXT :: (
          ((.THZP_SETUP - 1) << 7)
        )   
       
  inst RD2RD_SETUP :: 2 {
    	prop Label :: "READ-To-READ (ECLKOU1 cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaSdextRd2rd"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 2 ) {
		.error("1 < # of ECLKOU1 cycles < 2  ")
	    } else {
              .RD2RD_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }           
      
   prop RD2RD_SDEXT :: (
          ((.RD2RD_SETUP - 1) << 9)
        )   
       
  
  inst RD2DEAC_SETUP :: 4 {
    	prop Label :: "READ-To-DEAC/DEAB (ECLKOU1 cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaSdextRd2deac"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 4 ) {
		.error("1 < # of ECLKOU1 cycles < 4  ")
	    } else {
              .RD2DEAC_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }           
      
   prop RD2DEAC_SDEXT :: (
          ((.RD2DEAC_SETUP - 1) << 10)
        )   
 inst RD2WR_SETUP :: 6 {
    	prop Label :: "READ-To-WRITE (ECLKOU1 cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaSdextRd2wr"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 8 ) {
		.error("1 < # of ECLKOU1 cycles < 8  ")
	    } else {
              .RD2WR_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }           
      
   prop RD2WR_SDEXT :: (
          ((.RD2WR_SETUP - 1) << 12)
        )   
 inst R2WDQM_SETUP :: 3 {
    	prop Label :: "READ-To-WRITE with Interrupt (BEx cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaSdextR2wdqm"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 4 ) {
		.error("1 < # of Bex cycles < 4  ")
	    } else {
              .R2WDQM_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }           
      
   prop R2WDQM_SDEXT :: (
          ((.R2WDQM_SETUP - 1) << 15)
        )   
  
   
  inst WR2WR_SETUP :: 2 {
    	prop Label :: "WRITE-To-WRITE (ECLKOU1 cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaSdextWr2wr"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 2 ) {
		.error("1 < # of ECLKOU1 cycles < 2  ")
	    } else {
              .WR2WR_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }           
      
   prop WR2WR_SDEXT :: (
          ((.WR2WR_SETUP - 1) << 17)
        )   
        
  inst WR2DEAC_SETUP :: 2 {
    	prop Label :: "WRITE-To-DEAC/DEAB (ECLKOU1 cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaSdextWr2deac"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 4 ) {
		.error("1 < # of ECLKOU1 cycles < 4  ")
	    } else {
              .WR2DEAC_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }           
      
   prop WR2DEAC_SDEXT :: (
          ((.WR2DEAC_SETUP - 1) << 18)
        )   
 inst WR2RD_SETUP :: 2 {
    	prop Label :: "WRITE-To-READ (# of ECLKOU1 cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifaSdextWr2rd"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFA_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 2 ) {
		.error("1 < # of ECLKOU1 cycles < 2  ")
	    } else {
              .WR2RD_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }           
   prop WR2RD_SDEXT :: (
          ((.WR2RD_SETUP - 1) << 20)
        )   
      
 
 
prop GBLCTL_VALUE_update :: (
     0x00000004
     |.NOHOLD_GBLCTL()
     |.CLK4EN_GBLCTL()
     |.CLK6EN_GBLCTL()
     |.EK1EN_GBLCTL()
     |.EK2EN_GBLCTL()
     |.EK1HZ_GBLCTL()
     |.EK2HZ_GBLCTL()
     |.EK2RATE_GBLCTL()
     |.BRMODE_GBLCTL()
 )  
 prop GBLCTL_SETUP_update :: (
    .NOHOLD_SETUP =  ($1 & 0x00000080) ? "Disable Hold" : "Enable Hold",
    .CLK4EN_SETUP =  ($1 & 0x00000010) ? "Enabled to clock" : "Held high",
    .CLK6EN_SETUP =  ($1 & 0x00000008) ? "Enabled to clock" : "Held high",
    .EK1EN_SETUP  =  ($1 & 0x00000020) ? "Enabled to clock" : "Held low",
    .EK2EN_SETUP  =  ($1 & 0x00010000) ? "Enabled to clock" : "Held low",
    .EK1HZ_SETUP  =  ($1 & 0x00000040) ? "High-Z during hold" : "Clock during hold",
    .EK2HZ_SETUP  =  ($1 & 0x00020000) ? "High-Z during hold" : "Clock during hold",
    .BRMODE_SETUP =  ($1 & 0x00002000) ? "access/refresh pending or in progress" : "access pending or in progress",
$a = $1 & 0x000C0000,
if ($a == 0x00080000){
    .EK2RATE_SETUP = "1/4x EMIF input clock"
   } else {
     .EK2RATE_SETUP  =  ($1 & 0x00040000) ? "1/2x EMIF input clock" : "1x EMIF input clock"    
    }
 
  )
  
   inst GBLCTL_VALUE :: .GBLCTL_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Global Control Reg. (GBLCTL) "
	prop Format :: "0x%08X"
	prop JSName :: "emifaGblctl"
	prop Visible :: 1
	prop Writable :: (CSL.EMIFA_SUPPORT) 
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (
               $a = $1 & 0xFFF00000,
                $b = $1 & 0x0000C000,
                $c = $1 & 0x00001000,
                $d = $1 & 0x00000003,
                $e = $1 & 0x000C0000,
        if ($a != 0) {
               .error("Bit field (31..20) is reserved")
        } else {
	     if ($b != 0) {
               .error("Bit field (15..14) is reserved")
	     } else {
              if ($c != 0) {
                  .error("Bit field 12 is reserved")
              } else {
                 if ($d != 0 ) {
                    .error("Bit field (1..0) is reserved")
                 } else {
                    if ($e == 0x000C0000) {
                        .error("Invalid input for EK2RATE bit[19:18]")
                    } else {
                        .GBLCTL_VALUE = $1 | 0x0000004,
                        .GBLCTL_SETUP_update($1 | 0x0000004  ),
 		            "ok"
                   }
                }
             }
          }
        }
      )
   }
   
prop CECTL0_VALUE_update :: (
     .MTYPE0_CECTL0()
  |  .RDHLD0_CECTL0()
  |  .RDSTRB0_CECTL0()
  |  .RDSETUP0_CECTL0()
  |  .WRHLD0_CECTL0()
  |  .WRHLDMSB0_CECTL0()  
  |  .WRSETUP0_CECTL0()
  |  .WRSTRB0_CECTL0()
  |  .TA0_CECTL0() 
  )
   prop CECTL0_SETUP_update :: (
       .MTYPE0_SETUP = ( $a = ( $1 & 0x000000f0),
                       ($a == 0x00000000) ? "  8-bit async. interf." :
                       ($a == 0x00000010) ? "16-bit async. interf." :
                       ($a == 0x00000020) ? "32-bit async. interf." :
                       ($a == 0x00000030) ? "32-bit SDRAM" :
                       ($a == 0x00000040) ? "32-bit prog. sync. mem" :
                       ($a == 0x00000080) ? "  8-bit SDRAM" :
                       ($a == 0x00000090) ? "16-bit SDRAM" :
                       ($a == 0x000000a0) ? "  8-bit prog. sync. mem" :
                       ($a == 0x000000b0) ? "16-bit prog. sync. mem" :
                       ($a == 0x000000c0) ? "64-bit async. interf." :
                       ($a == 0x000000d0) ? "64-bit SDRAM" : "64-bit prog. sync. mem"),
    .RDHLD0_SETUP = ( $1 & 0x00000007),  
   .RDSTRB0_SETUP =  ( ( $1 & 0x00003F00) >> 8 ) ,
   .RDSETUP0_SETUP =  ( ($1 & 0x000F0000) >> 16) ,
   .WRHLD0_SETUP =  ((( $1 & 0x00300000) >> 20) + (($1 & 0x00000008) >> 1 )), 
   .WRSTRB0_SETUP =   ( ($1 & 0x0FC00000) >> 22) ,
   .WRSETUP0_SETUP =  ( ($1 >> 28) & 0xF) ,
   .TA0_SETUP =  ($1 & 0x0000c000) >> 14  
    )   
    
      
   inst CECTL0_VALUE :: .CECTL0_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "CE0 Space Control Reg. (CECTL0) "
	prop Format :: "0x%08X"
	prop JSName :: "emifaCectl0"
	prop Visible :: 1
	prop Writable :: (CSL.EMIFA_SUPPORT) 
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (    
          $a = $1 & 0x000000F0,
          $b = $1 & 0x0000C000,
          if ( $a == 0x00000070 || $a == 0x000000F0 || $a == 0x00000050 || $a == 0x00000060)  {   
               .error("Undefined Memory type for CE Spaces - See CEx Space Pages") 
              } else {
                 if ( $b == 0x00000000 ) {
                     .error("Minimum: 1 ECLKOUT cycle - Maximum : 3 ECLKOUT cycles")
                   } else {
                           .CECTL0_VALUE = $1,
                           .CECTL0_SETUP_update($1),
                           "ok"
                     }
              }
          )
   }
 prop CECTL1_VALUE_update :: (
     .MTYPE1_CECTL1()
  |  .RDHLD1_CECTL1()
  |  .RDSTRB1_CECTL1()
  |  .RDSETUP1_CECTL1()
  |  .WRHLD1_CECTL1()
  |  .WRHLDMSB1_CECTL1()
  |  .WRSETUP1_CECTL1()
  |  .WRSTRB1_CECTL1()
  |  .TA1_CECTL1() 
  )
    prop CECTL1_SETUP_update :: (
           .MTYPE1_SETUP = ( $a = ( $1 & 0x000000f0),
                       ($a == 0x00000000) ? "  8-bit async. interf." :
                       ($a == 0x00000010) ? "16-bit async. interf." :
                       ($a == 0x00000020) ? "32-bit async. interf." :
                       ($a == 0x00000030) ? "32-bit SDRAM" :
                       ($a == 0x00000040) ? "32-bit prog. sync. mem" :
                       ($a == 0x00000080) ? "  8-bit SDRAM" :
                       ($a == 0x00000090) ? "16-bit SDRAM" :
                       ($a == 0x000000a0) ? "  8-bit prog. sync. mem" :
                       ($a == 0x000000b0) ? "16-bit prog. sync. mem" :
                       ($a == 0x000000c0) ? "64-bit async. interf." :
                       ($a == 0x000000d0) ? "64-bit SDRAM" : "64-bit prog. sync. mem"),
   .RDHLD1_SETUP = ( $1 & 0x00000007),  
   .RDSTRB1_SETUP =  ( ( $1 & 0x00003F00) >> 8 ) ,
   .RDSETUP1_SETUP =  ( ($1 & 0x000F0000) >> 16) ,
   .WRHLD1_SETUP =  ((( $1 & 0x00300000) >> 20) + (($1 & 0x00000008) >> 1 )), 
   .WRSTRB1_SETUP =   ( ($1 & 0x0FC00000) >> 22) ,
   .WRSETUP1_SETUP =  ( ($1 >> 28) & 0xF) ,
   .TA1_SETUP =  ($1 & 0x0000c000) >> 14  
    )
    
   inst CECTL1_VALUE :: .CECTL1_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "CE1 Space Control Reg. (CECTL1) "
	prop Format :: "0x%08X"
	prop JSName :: "emifaCectl1"
	prop Visible :: 1
	prop Writable :: (CSL.EMIFA_SUPPORT) 
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
      prop Set :: (    
          $a = $1 & 0x000000F0,
          $b = $1 & 0x0000C000,
          if ( $a == 0x00000070 || $a == 0x000000F0 || $a == 0x00000050 || $a == 0x00000060)  {   
               .error("Undefined Memory type for CE Spaces - See CEx Space Pages") 
              } else {
                 if ( $b == 0x00000000 ) {
                     .error("Minimum: 1 ECLKOUT cycle - Maximum : 3 ECLKOUT cycles")
                   } else {
                   .CECTL1_VALUE = $1,
                   .CECTL1_SETUP_update($1),
                    "ok"
                     }
               }        
          )
   } 
    
   
 prop CECTL2_VALUE_update :: (
     .MTYPE2_CECTL2()
  |  .RDHLD2_CECTL2()
  |  .RDSTRB2_CECTL2()
  |  .RDSETUP2_CECTL2()
  |  .WRHLD2_CECTL2()
  |  .WRHLDMSB2_CECTL2()
  |  .WRSETUP2_CECTL2()
  |  .WRSTRB2_CECTL2()
  |  .TA2_CECTL2() 
  )
 prop CECTL2_SETUP_update :: (
       .MTYPE2_SETUP = ( $a = ( $1 & 0x000000f0),
                       ($a == 0x00000000) ? "  8-bit async. interf." :
                       ($a == 0x00000010) ? "16-bit async. interf." :
                       ($a == 0x00000020) ? "32-bit async. interf." :
                       ($a == 0x00000030) ? "32-bit SDRAM" :
                       ($a == 0x00000040) ? "32-bit prog. sync. mem" :
                       ($a == 0x00000080) ? "  8-bit SDRAM" :
                       ($a == 0x00000090) ? "16-bit SDRAM" :
                       ($a == 0x000000a0) ? "  8-bit prog. sync. mem" :
                       ($a == 0x000000b0) ? "16-bit prog. sync. mem" :
                       ($a == 0x000000c0) ? "64-bit async. interf." :
                       ($a == 0x000000d0) ? "64-bit SDRAM" : "64-bit prog. sync. mem"),
   .RDHLD2_SETUP = ( $1 & 0x00000007),  
   .RDSTRB2_SETUP =  ( ( $1 & 0x00003F00) >> 8 ) ,
   .RDSETUP2_SETUP =  ( ($1 & 0x000F0000) >> 16) ,
   .WRHLD2_SETUP =  ((( $1 & 0x00300000) >> 20) + (($1 & 0x00000008) >> 1 )), 
   .WRSTRB2_SETUP =   ( ($1 & 0x0FC00000) >> 22) ,
   .WRSETUP2_SETUP =  ( ($1 >> 28) & 0xF) ,
   .TA2_SETUP =  ($1 & 0x0000c000) >> 14  
    )   
    
    
   inst CECTL2_VALUE :: .CECTL2_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "CE2 Space Control Reg. (CECTL2) "
	prop Format :: "0x%08X"
	prop JSName :: "emifaCectl2"
	prop Visible :: 1
	prop Writable :: (CSL.EMIFA_SUPPORT) 
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (    
         $a = $1 & 0x000000F0,
          $b = $1 & 0x0000C000,
          if ( $a == 0x00000070 || $a == 0x000000F0 || $a == 0x00000050 || $a == 0x00000060)  {   
               .error("Undefined Memory type for CE Spaces - See CEx Space Pages") 
              } else {
                 if ( $b == 0x00000000 ) {
                     .error("Minimum: 1 ECLKOUT cycle - Maximum : 3 ECLKOUT cycles")
                   } else {
                           .CECTL2_VALUE = $1,
                           .CECTL2_SETUP_update($1),
                           "ok"
                     }
              }
          )
   }
   
 prop CECTL3_VALUE_update :: (
     .MTYPE3_CECTL3()
  |  .RDHLD3_CECTL3()
  |  .RDSTRB3_CECTL3()
  |  .RDSETUP3_CECTL3()
  |  .WRHLD3_CECTL3()
  |  .WRHLDMSB3_CECTL3()
  |  .WRSETUP3_CECTL3()
  |  .WRSTRB3_CECTL3()
  |  .TA3_CECTL3() 
  )
 
  prop CECTL3_SETUP_update :: (
       .MTYPE3_SETUP = ( $a = ( $1 & 0x000000f0),
                       ($a == 0x00000000) ? "  8-bit async. interf." :
                       ($a == 0x00000010) ? "16-bit async. interf." :
                       ($a == 0x00000020) ? "32-bit async. interf." :
                       ($a == 0x00000030) ? "32-bit SDRAM" :
                       ($a == 0x00000040) ? "32-bit prog. sync. mem" :
                       ($a == 0x00000080) ? "  8-bit SDRAM" :
                       ($a == 0x00000090) ? "16-bit SDRAM" :
                       ($a == 0x000000a0) ? "  8-bit prog. sync. mem" :
                       ($a == 0x000000b0) ? "16-bit prog. sync. mem" :
                       ($a == 0x000000c0) ? "64-bit async. interf." :
                       ($a == 0x000000d0) ? "64-bit SDRAM" : "64-bit prog. sync. mem"),
   .RDHLD3_SETUP = ( $1 & 0x00000007),  
   .RDSTRB3_SETUP =  ( ( $1 & 0x00003F00) >> 8 ) ,
   .RDSETUP3_SETUP =  ( ($1 & 0x000F0000) >> 16) ,
   .WRHLD3_SETUP = ((( $1 & 0x00300000) >> 20) + (($1 & 0x00000008) >> 1 )), 
   .WRSTRB3_SETUP =   ( ($1 & 0x0FC00000) >> 22) ,
   .WRSETUP3_SETUP =  ( ($1 >> 28) & 0xF) ,
   .TA3_SETUP =  ($1 & 0x0000c000) >> 14  
    )   
    
   inst CECTL3_VALUE :: .CECTL3_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "CE3 Space Control Reg. (CECTL3) "
	prop Format :: "0x%08X"
	prop JSName :: "emifaCectl3"
	prop Visible :: 1
	prop Writable :: (CSL.EMIFA_SUPPORT) 
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (    
           $a = $1 & 0x000000F0,
          $b = $1 & 0x0000C000,
          if ( $a == 0x00000070 || $a == 0x000000F0 || $a == 0x00000050 || $a == 0x00000060)  {   
               .error("Undefined Memory type for CE Spaces - See CEx Space Pages") 
              } else {
                 if ( $b == 0x00000000 ) {
                     .error("Minimum: 1 ECLKOUT cycle - Maximum : 3 ECLKOUT cycles")
                   } else {
                           .CECTL3_VALUE = $1,
                           .CECTL3_SETUP_update($1),
                           "ok"
                     }
              }
          )
   }
   
 prop SDCTL_VALUE_update :: (
     .TRC_SDCTL()
  |  .TRP_SDCTL()
  |  .SLFRFR_SDCTL()                                          
  |  .TRCD_SDCTL()
  |  .INIT_SDCTL()
  |  .RFEN_SDCTL()
  | .SDCSZ_SDCTL() 
  | .SDRSZ_SDCTL() 
  | .SDBSZ_SDCTL() 
  )
  prop SDCTL_SETUP_update :: (
   .TRC_SETUP = ($1 & 0x0000F000) >> 12,
   .TRP_SETUP = ($1 & 0x000F0000) >> 16,
   .TRCD_SETUP = ($1 & 0x00F00000) >> 20,
   .INIT_SETUP = ( $a = ($1 & 0x01000000),
                         ($a == 0x01000000 ) ? "Initialize" : "No effect"),
   .RFEN_SETUP = ( $a = ($1 & 0x02000000),
                         ($a == 0x02000000 ) ? "Enable" : "Disable"),
   .SDCSZ_SETUP = ( $a = ($1 & 0x0c000000),
                         ($a == 0x04000000 ) ? " 8 addresses" : 
                         ($a == 0x08000000 ) ? "10 addresses" : " 9 addresses"),                         
   .SDRSZ_SETUP = ( $a = ($1 & 0x30000000),
                         ($a == 0x10000000 ) ? "12 addresses" : 
                         ($a == 0x20000000 ) ? "13 addresses" : "11 addresses"),
   .SDBSZ_SETUP = ( $a = ($1 & 0x40000000),
                         ($a == 0x40000000 ) ? "Four banks" : "Two banks"),
   .SLFRFR_SETUP = ( $a = ($1 & 0x00000001),                                  
                          ($a == 0x00000001) ? "Enable" : "Disable")                                   
  )  
   inst SDCTL_VALUE :: .SDCTL_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "SDRAM Control Reg.(SDCTL) "
	prop Format :: "0x%08X"
	prop JSName :: "emifaSdctl"
	prop Visible :: 1
	prop Writable :: (CSL.EMIFA_SUPPORT) 
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (    
             $a =  $1 & 0x0c000000,
             if ( $a == 0x0c000000 ) {
              .error("Undefined Value for Column Size field SDCSZ")
              } else {
               $b = $1 & 0x30000000,
               if ( $b == 0x30000000) {
                 .error("Undefined Value for Row Size field SDRSZ")
              } else {
                  $c = $1 & 0x80000000,
                  if( $c == 0x80000000) {                 
                   .error("Bit field 31 is reserved")
                   }  else {
                        $d = $1 & 0x00000FFE,
                        if( $d != 0) {     
                          .error("Bit field(bit[1..11]) is reserved")
                         } else {
                        .SDCTL_VALUE = $1,
                        .SDCTL_SETUP_update($1),
 		            "ok"
                         }  
                      }
                   }
              }        
        )              
              
       }           
   
 prop SDTIM_VALUE_update :: (
    .PERIOD_SDTIM2() 
  | .XRFR_SDTIM()
  | 0x005dc000       
  )
  prop SDTIM_SETUP_update :: (
      .PERIOD_SETUP2 = ($1 & 0x00000FFF),
      .XRFR_SETUP = (($1 & 0x03000000) >> 24) + 1                        
  )
   inst SDTIM_VALUE :: .SDTIM_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "SDRAM Timing Reg.(SDTIM) "
	prop Format :: "0x%08X"
	prop JSName :: "emifaSdtim"
	prop Visible :: 1
	prop Writable :: (CSL.EMIFA_SUPPORT) 
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (    
                            $a =  $1 & 0x0000FFF,                       
             if ( $a == 0x00000000 ) {
              .error("1 cyc. < PERIOD < 4096 cyc. ")
              } else {
                       $b = $1 & 0xFC000000,
                        if( $b != 0) {     
                          .error("Bit field(bit[26..31]) is reserved")
                         } else { 
                        .SDTIM_VALUE = $1 | 0x005dc000,           
                        .SDTIM_SETUP_update($1 | 0x005dc000),
 		        "ok"
                    }
                }
        )              
              
       }           
 prop SDEXT_VALUE_update :: (
     .TCL_SDEXT()
  |  .TRAS_SDEXT()
  |  .TRRD_SDEXT()
  |  .TWR_SDEXT()
  |  .THZP_SDEXT()
  |  .RD2RD_SDEXT()
  |  .RD2DEAC_SDEXT()
  |  .RD2WR_SDEXT()
  |  .R2WDQM_SDEXT()
  |  .WR2WR_SDEXT()
  |  .WR2DEAC_SDEXT()
  |  .WR2RD_SDEXT()
  )
  prop SDEXT_SETUP_update :: (
   .TCL_SETUP =   ($1 & 0x00000001) + 2,
   .TRAS_SETUP = (($1 & 0x0000000E) >> 1 ) + 1 ,
   .TRRD_SETUP = (($1 & 0x00000010) >> 4 ) + 2 ,
   .TWR_SETUP =  (($1 & 0x00000060) >> 5 ) + 1 ,
   .THZP_SETUP = (($1 & 0x00000180) >> 7 ) + 1 ,
   .RD2RD_SETUP =  (($1 & 0x00000200) >> 9 ) + 1 ,
   .RD2DEAC_SETUP =(($1 & 0x00000c00) >> 10 ) + 1 ,
   .RD2WR_SETUP =  (($1 & 0x00007000) >> 12 ) + 1 ,
   .R2WDQM_SETUP = (($1 & 0x00018000) >> 15 ) + 1 ,
   .WR2WR_SETUP =  (($1 & 0x00020000) >> 17 ) + 1 ,
   .WR2DEAC_SETUP =(($1 & 0x000c0000) >> 18 ) + 1 ,
   .WR2RD_SETUP =  (($1 & 0x00100000) >> 20 ) + 1 
   )
   inst SDEXT_VALUE :: .SDEXT_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "SDRAM Extended Reg.(SDEXT) "
	prop Format :: "0x%08X"
	prop JSName :: "emifaSdext"
	prop Visible :: 1
	prop Writable :: (CSL.EMIFA_SUPPORT) 
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (    
	              $a = $1 & 0xFFE00000,
                if ( $a != 0) {
                    .error("Bit field(bit[21..31]) is reserved")
                 } else {
	                .SDEXT_VALUE = $1,
                        .SDEXT_SETUP_update($1),
 		        "ok"
                    }
                   )              
       }        
prop CESEC0_VALUE_update :: (                                      
     .SYNCRL0_CESEC0()
    |.SYNCWL0_CESEC0()
    |.CEEXT0_CESEC0()
    |.RENEN0_CESEC0()
    |.SNCCLK0_CESEC0()
  )
  prop CESEC0_SETUP_update :: (
      
       .SYNCRL0_SETUP = ( $a = ( $1 & 0x00000003),
                       ($a == 0x00000000) ? "0 cycle" :
                       ($a == 0x00000001) ? "1 cycle" :
                       ($a == 0x00000002) ? "2 cycles" : "3 cycles"),
       .SYNCWL0_SETUP = ( $a = ( $1 & 0x0000000C),
                       ($a == 0x00000000) ? "0 cycle" :
                       ($a == 0x00000004) ? "1 cycle" :
                       ($a == 0x00000008) ? "2 cycles" : "3 cycles"),
                               
       .CEEXT0_SETUP = ( $a = ( $1 & 0x00000010),
                      ($a == 0x00000000) ? "Inactive" : "Active"),
       .RENEN0_SETUP = ( $a = ( $1 & 0x00000020),
                      ($a == 0x00000000) ? "ADS Mode" : "Read Enable Mode"),
       .SNCCLK0_SETUP = ( $a = ( $1 & 0x00000040),
                       ($a == 0x00000000) ? "Sync. to ECLKOUT1" : "Sync. to ECLKOUT2")
)
    
       
inst CESEC0_VALUE :: .CESEC0_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE0 Space Secondary Control Reg. (CESEC0)"
	prop Format :: "0x%08X"
        prop JSName :: "emifaCesec0"     	    	
	prop Visible :: 1
	prop Writable :: (CSL.EMIFA_SUPPORT != 0) ? 1 : 0
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (    
                      $a = $1 & 0xFFFFFF80,
                      if ($a != 0) {
                     .error("Bit field(bit[7..31]) is reserved")
                      } else { 
                           .CESEC0_VALUE = $1,
                           .CESEC0_SETUP_update($1),
                           "ok"  
                  }            
          )
   }     
  
prop CESEC1_VALUE_update :: (                                      
     .SYNCRL1_CESEC1()
    |.SYNCWL1_CESEC1()
    |.CEEXT1_CESEC1()
    |.RENEN1_CESEC1()
    |.SNCCLK1_CESEC1()
  )
  prop CESEC1_SETUP_update :: (
      
       .SYNCRL1_SETUP = ( $a = ( $1 & 0x00000003),
                       ($a == 0x00000000) ? "0 cycle" :
                       ($a == 0x00000001) ? "1 cycle" :
                       ($a == 0x00000002) ? "2 cycles" : "3 cycles"),
       .SYNCWL1_SETUP = ( $a = ( $1 & 0x0000000C),
                       ($a == 0x00000000) ? "0 cycle" :
                       ($a == 0x00000004) ? "1 cycle" :
                       ($a == 0x00000008) ? "2 cycles" : "3 cycles"),
                               
       .CEEXT1_SETUP = ( $a = ( $1 & 0x00000010),
                      ($a == 0x00000000) ? "Inactive" : "Active"),
       .RENEN1_SETUP = ( $a = ( $1 & 0x00000020),
                      ($a == 0x00000000) ? "ADS Mode" : "Read Enable Mode"),
       .SNCCLK1_SETUP = ( $a = ( $1 & 0x00000040),
                       ($a == 0x00000000) ? "Sync. to ECLKOUT1" : "Sync. to ECLKOUT2")
)
    
    
                                                              
   inst CESEC1_VALUE :: .CESEC1_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE1 Space Secondary Control Reg. (CESEC1)"
	prop Format :: "0x%08X"
        prop JSName :: "emifaCesec1"     	    	
	prop Visible :: 1
	prop Writable :: (CSL.EMIFA_SUPPORT != 0) ? 1 : 0
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (    
                     $a = $1 & 0xFFFFFF80,
                      if ($a != 0) {
                     .error("Bit field(bit[7..31]) is reserved")
                      } else { 
                           .CESEC1_VALUE = $1,
                           .CESEC1_SETUP_update($1),
                           "ok"  
                  }            
          )
   }    
prop CESEC2_VALUE_update :: (                                      
     .SYNCRL2_CESEC2()
    |.SYNCWL2_CESEC2()
    |.CEEXT2_CESEC2()
    |.RENEN2_CESEC2()
    |.SNCCLK2_CESEC2()
  )
  prop CESEC2_SETUP_update :: (
      
       .SYNCRL2_SETUP = ( $a = ( $1 & 0x00000003),
                       ($a == 0x00000000) ? "0 cycle" :
                       ($a == 0x00000001) ? "1 cycle" :
                       ($a == 0x00000002) ? "2 cycles" : "3 cycles"),
       .SYNCWL2_SETUP = ( $a = ( $1 & 0x0000000C),
                       ($a == 0x00000000) ? "0 cycle" :
                       ($a == 0x00000004) ? "1 cycle" :
                       ($a == 0x00000008) ? "2 cycles" : "3 cycles"),
                               
       .CEEXT2_SETUP = ( $a = ( $1 & 0x00000010),
                      ($a == 0x00000000) ? "Inactive" : "Active"),
       .RENEN2_SETUP = ( $a = ( $1 & 0x00000020),
                      ($a == 0x00000000) ? "ADS Mode" : "Read Enable Mode"),
       .SNCCLK2_SETUP = ( $a = ( $1 & 0x00000040),
                       ($a == 0x00000000) ? "Sync. to ECLKOUT1" : "Sync. to ECLKOUT2")
)
    
    
                                                              
   inst CESEC2_VALUE :: .CESEC2_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE2 Space Secondary Control Reg. (CESEC2)"
	prop Format :: "0x%08X"
        prop JSName :: "emifaCesec2"     	    	
	prop Visible :: 1
	prop Writable :: (CSL.EMIFA_SUPPORT != 0) ? 1 : 0
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (    
                      $a = $1 & 0xFFFFFF80,
                      if ($a != 0) {
                     .error("Bit field(bit[7..31]) is reserved")
                      } else { 
                           .CESEC2_VALUE = $1,
                           .CESEC2_SETUP_update($1),
                           "ok"    
                       }          
          )
   }                                           
prop CESEC3_VALUE_update :: (                                      
     .SYNCRL3_CESEC3()
    |.SYNCWL3_CESEC3()
    |.CEEXT3_CESEC3()
    |.RENEN3_CESEC3()
    |.SNCCLK3_CESEC3()
  )
  prop CESEC3_SETUP_update :: (
      
       .SYNCRL3_SETUP = ( $a = ( $1 & 0x00000003),
                       ($a == 0x00000000) ? "0 cycle" :
                       ($a == 0x00000001) ? "1 cycle" :
                       ($a == 0x00000002) ? "2 cycles" : "3 cycles"),
       .SYNCWL3_SETUP = ( $a = ( $1 & 0x0000000C),
                       ($a == 0x00000000) ? "0 cycle" :
                       ($a == 0x00000004) ? "1 cycle" :
                       ($a == 0x00000008) ? "2 cycles" : "3 cycles"),
                               
       .CEEXT3_SETUP = ( $a = ( $1 & 0x00000010),
                      ($a == 0x00000000) ? "Inactive" : "Active"),
       .RENEN3_SETUP = ( $a = ( $1 & 0x00000020),
                      ($a == 0x00000000) ? "ADS Mode" : "Read Enable Mode"),
       .SNCCLK3_SETUP = ( $a = ( $1 & 0x00000040),
                       ($a == 0x00000000) ? "Sync. to ECLKOUT1" : "Sync. to ECLKOUT2")
)
    
    
 
                                     
   inst CESEC3_VALUE :: .CESEC3_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE3 Space Secondary Control Reg. (CESEC3)"
	prop Format :: "0x%08X"
        prop JSName :: "emifaCesec3"     	    	
	prop Visible :: 1
	prop Writable :: (CSL.EMIFA_SUPPORT != 0) ? 1 : 0
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: ( 
                    $a = $1 & 0xFFFFFF80,
                      if ($a != 0) {
                     .error("Bit field(bit[7..31]) is reserved")
                      } else {    
                           .CESEC3_VALUE = $1,
                           .CESEC3_SETUP_update($1),
                           "ok"   
                  }           
          )
   }                                           
                                       
                                      
     
}
type hEmifa {
   prop IsContainedIn :: EMIFAFOLDER
   prop name :: "hEmifa"     	    	
   prop Label :: "EMIF Resource Manager"
   prop JSName :: "HEMIFA"     	    	
   prop NoGen :: 1
   prop GlobalPropertyPage :: "{980E6534-6246-11d4-B5CC-0050DA2E2CC0}"
   prop InstancePropertyPage :: "{980E6535-6246-11d4-B5CC-0050DA2E2CC0}"
   prop GlobalIcon :: 163
   prop InstanceIcon :: 164
    prop GlobalHelpTopic :: (
	   1045
   )
     
   prop cGen :: 1
 
   global EMIFA_INIT_ENABLE :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Enable Pre-Initialization"
	  prop JSName :: "emifaEnablePreInit"
	  prop Visible :: 1
	  prop Writable :: (CSL.EMIFA_SUPPORT) 
	  prop NoGen :: 0
          prop Set :: (
          $a = 0,
            scan ($b ; emifaCfg) { $a = $a + 1},
                  if ( $1 == 1 && $a ==1 &&  .EMIFA_INIT == EMIFA_NOTHING ) 
                 {         
                 " You must create a new configuration object"
                 } else { 
                      .EMIFA_INIT_ENABLE = $1,
		      if ( $1 == 0) {
		      .EMIFA_INIT = EMIFA_NOTHING
		      },
			"ok"
                  }      
	  )      
    	}
	global EMIFA_INIT :: EMIFA_NOTHING {
	    prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	    prop MemberType :: emifaCfg
	    prop Label :: " Pre-Initialize with"
	    prop JSName :: "emifaPreInit"
	    prop Visible :: 1
	    prop Writable :: (CSL.EMIFA_SUPPORT) &&  (.EMIFA_INIT_ENABLE == 1) ? 1 :0 
    }
 
}
object EMIFA_NOTHING :: emifaCfg {
       param iIsUsed :: 0
}
type EMIFBFOLDER {
    isa ModuleFolder
    prop IsContainedIn :: CSL 
       	    	
   prop name :: "EMIFB"
   prop Label :: "EMIFB - External Memory Interface B (64x devices only)"
   prop NoGen :: 1
   prop GlobalPropertyPage :: "{980E6530-6246-11d4-B5CC-0050DA2E2CC0}"
   prop InstancePropertyPage :: "{980E6531-6246-11d4-B5CC-0050DA2E2CC0}"
   prop GlobalIcon :: 163
   prop InstanceIcon :: 164
   prop GlobalHelpTopic :: (
	   1043
   )
}   
  
type emifbCfg {
    isa ObjectMgr
    prop Name :: "emifbCfg"
    prop Label :: "EMIFB Configuration Manager"
    prop JSName :: "EMIFB"
    prop IsContainedIn :: EMIFBFOLDER
    prop NoGen :: 1
    prop maxObjs :: (32767)
    prop GlobalPropertyPage :: "{980E6532-6246-11d4-B5CC-0050DA2E2CC0}"
    prop InstancePropertyPage :: "{980E6533-6246-11d4-B5CC-0050DA2E2CC0}"
    prop GlobalIcon :: 163
    prop InstanceIcon :: 164
    prop GlobalHelpTopic :: (
	   1044
   )
    
   prop InstanceHelpTopic :: (
   1044
   )
      prop cGen :: CSL.EMIFB_SUPPORT
    	prop cStruct :: 1
    	prop cStructType :: "EMIFB_Config"
	prop cHeaderName :: .gNumOf > 0 ? "csl_emifb.h" : ""
	prop cStructQual :: "far"
        prop cStructName :: self
           	
	prop cConfigName :: "EMIFB_config"
        prop localDelete :: (
         .myDelete
           )           
        prop myDelete :: (
         $a=0,
          scan($b; emifbCfg) { 
               $a = $a + 1
           }, 		
	  if ($a == 2) {
                hEmifb.EMIFB_INIT_ENABLE = 0
		},
		"ok"
           )           
    
    inst cConfigGen ::= ((hEmifb.EMIFB_INIT_ENABLE == 1) && (hEmifb.EMIFB_INIT == self) && (hEmifb.EMIFB_INIT != EMIFB_NOTHING)) {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
    }
 	
 
    inst cConfigArg0 ::= hEmifb.EMIFB_INIT {
         prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop MemberType :: emifbCfg
	  prop Label :: "Pre-initialize Config"
	  prop Visible :: 0
	  prop Writable :: (CSL.EMIFB_SUPPORT) 
          prop NoGen :: 0
	  prop cPreVal :: "&"
    }
    inst NOHOLD_SETUP :: "Enable Hold" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Enable Hold,Disable Hold"
        prop Label :: "External HOLD disable (NOHOLD)"
	prop JSName :: "emifbGblctlNoHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "Global Control"
	prop Set :: (
		.NOHOLD_SETUP = $1,
		.GBLCTL_VALUE = .GBLCTL_VALUE_update(),
		"ok"
	     )
	 }
    prop NOHOLD_GBLCTL :: (
         if (.NOHOLD_SETUP == "Disable Hold") {
            0x00000080
        }
	else {
            0x00000000
	}
    ) 
    
   inst CLK4EN_SETUP :: "Enabled to clock" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Held high,Enabled to clock"
        prop Label :: "CLKOUT4 Enable (CLK4EN)"
        prop JSName :: "emifbGblctlClk4en"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT != 0) ? 1 : 0
        prop NoGen :: 1
        prop TabName :: "Global Control"
	prop Set :: (
		.CLK4EN_SETUP = $1,
		.GBLCTL_VALUE = .GBLCTL_VALUE_update(),
		"ok"
	        )
	}
    prop CLK4EN_GBLCTL :: (
         if (.CLK4EN_SETUP == "Held high") {
            0x00000000
        }
	else {
            0x00000010
		}
    ) 
   
 inst CLK6EN_SETUP :: "Enabled to clock" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Held high,Enabled to clock"
        prop Label :: "CLKOUT6 Enable (CLK6EN)"
        prop JSName :: "emifbGblctlClk6en"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT != 0) ? 1 : 0
        prop NoGen :: 1
        prop TabName :: "Global Control"
	prop Set :: (
		.CLK6EN_SETUP = $1,
		.GBLCTL_VALUE = .GBLCTL_VALUE_update(),
		"ok"
	        )
	}
    prop CLK6EN_GBLCTL :: (
         if (.CLK6EN_SETUP == "Held high") {
            0x00000000
        }
	else {
            0x00000008
		}
    ) 
 
    inst EK1EN_SETUP :: "Enabled to clock" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Held low,Enabled to clock"
        prop Label :: "ECLKOUT1 Enable (EK1EN)"
        prop JSName :: "emifbGblctlEk1en"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT != 0) ? 1 : 0
        prop NoGen :: 1
        prop TabName :: "Global Control"
	prop Set :: (
		.EK1EN_SETUP = $1,
		.GBLCTL_VALUE = .GBLCTL_VALUE_update(),
		"ok"
	        )
	}
    prop EK1EN_GBLCTL :: (
         if (.EK1EN_SETUP == "Held low") {
            0x00000000
        }
	else {
            0x00000020
		}
    ) 
   
inst EK2EN_SETUP :: "Enabled to clock" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Held low,Enabled to clock"
        prop Label :: "ECLKOUT2 Enable (EK2EN)"
        prop JSName :: "emifbGblctlEk2en"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT != 0) ? 1 : 0
        prop NoGen :: 1
        prop TabName :: "Global Control"
	prop Set :: (
		.EK2EN_SETUP = $1,
		.GBLCTL_VALUE = .GBLCTL_VALUE_update(),
		"ok"
	        )
	}
    prop EK2EN_GBLCTL :: (
         if (.EK2EN_SETUP == "Held low") {
            0x00000000
        }
	else {
            0x00010000
		}
    ) 
inst EK1HZ_SETUP :: "High-Z during hold" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Clock during hold,High-Z during hold"
        prop Label :: "ECLKOUT1 High-Z Control (EK1HZ)"
        prop JSName :: "emifbGblctlEk1hz"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT != 0) ? 1 : 0
        prop NoGen :: 1
        prop TabName :: "Global Control"
	prop Set :: (
		.EK1HZ_SETUP = $1,
		.GBLCTL_VALUE = .GBLCTL_VALUE_update(),
		"ok"
	        )
	}
    prop EK1HZ_GBLCTL :: (
         if (.EK1HZ_SETUP == "Clock during hold") {
            0x00000000
        }
	else {
            0x00000040
		}
    ) 
inst EK2HZ_SETUP :: "Clock during hold" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Clock during hold,High-Z during hold"
        prop Label :: "ECLKOUT2 High-Z Control (EK2HZ)"
        prop JSName :: "emifbGblctlEk2hz"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT != 0) ? 1 : 0
        prop NoGen :: 1
        prop TabName :: "Global Control"
	prop Set :: (
		.EK2HZ_SETUP = $1,
		.GBLCTL_VALUE = .GBLCTL_VALUE_update(),
		"ok"
	        )
	}
    prop EK2HZ_GBLCTL :: (
         if (.EK2HZ_SETUP == "Clock during hold") {
            0x00000000
        }
	else {
            0x00020000
		}
    ) 
inst EK2RATE_SETUP :: "1/4x EMIF input clock" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "1x EMIF input clock,1/2x EMIF input clock,1/4x EMIF input clock"
        prop Label :: "ECLKOUT2 Rate (EK2RATE)"
        prop JSName :: "emifbGblctlEk2rate"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT != 0) ? 1 : 0
        prop NoGen :: 1
        prop TabName :: "Global Control"
	prop Set :: (
		.EK2RATE_SETUP = $1,
		.GBLCTL_VALUE = .GBLCTL_VALUE_update(),
		"ok"
	        )
	}
    prop EK2RATE_GBLCTL :: (
         if (.EK2RATE_SETUP == "1x EMIF input clock") {
            0x00000000
        }
	  else {
         if (.EK2RATE_SETUP == "1/2x EMIF input clock") {
            0x00040000
		} else {
               if (.EK2RATE_SETUP == "1/4x EMIF input clock") {
                   0x00080000
                  }
             }
         }
               
    ) 
     
inst BRMODE_SETUP :: "access/refresh pending or in progress" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "access/refresh pending or in progress,access pending or in progress"
        prop Label :: "Bus Request Mode"
        prop JSName :: "emifbGblctlBrmode"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT != 0) ? 1 : 0
        prop NoGen :: 1
        prop TabName :: "Global Control"
	prop Set :: (
		.BRMODE_SETUP = $1,
		.GBLCTL_VALUE = .GBLCTL_VALUE_update(),
		"ok"
	        )
	}
    prop BRMODE_GBLCTL :: (
         if (.BRMODE_SETUP == "access pending or in progress") {
            0x00000000
        }
	  else {
         if (.BRMODE_SETUP == "access/refresh pending or in progress") {
            0x00002000
		} 
         }               
    ) 
 
   inst MTYPE0_SETUP :: "  8-bit async. interf." {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
      prop Enum :: "  8-bit async. interf.,16-bit async. interf.,  8-bit SDRAM,16-bit SDRAM,  8-bit prog. sync. mem,16-bit prog. sync. mem"
        prop Label :: "Memory Type (MTYPE)"
	prop JSName :: "emifbCectl0Mtype"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	  prop Set :: (   
		.MTYPE0_SETUP = $1,
		.CECTL0_VALUE = .CECTL0_VALUE_update(),
		"ok"                 
           )
   }
    prop MTYPE0_CECTL0 :: (
                    if ( .MTYPE0_SETUP == "  8-bit async. interf.") {
                         0x00000000 
                        } else {
                            if ( .MTYPE0_SETUP == "  8-bit SDRAM") {
                             0x00000080 
                             } else {
                                if ( .MTYPE0_SETUP == "  8-bit prog. sync. mem") {
                                 0x000000a0 
                                   } else {
                                      if ( .MTYPE0_SETUP == "16-bit async. interf.") {
                                        0x00000010 
                                       } else {
                                           if ( .MTYPE0_SETUP == "16-bit SDRAM") {
                                            0x00000090 
                                            } else {
                                                if ( .MTYPE0_SETUP == "16-bit prog. sync. mem") {
                                                   0x000000b0 
                                                   }                                                            
                                                            
                           }
                       }
                 }
            }   
         }       
    ) 
 
 
 inst  RDSTRB0_SETUP :: 63{
    	prop Label :: "Read Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl0ReadStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 63 ) {
		.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")
	    }
	    else {
              .RDSTRB0_SETUP = $1,
              .CECTL0_VALUE = .CECTL0_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSTRB0_CECTL0 :: (
          ((.RDSTRB0_SETUP) << 8)
       )   
       
 inst  RDSETUP0_SETUP :: 15{
    	prop Label :: "Read Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl0ReadSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")
	    } else {
              .RDSETUP0_SETUP = $1,
              .CECTL0_VALUE = .CECTL0_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSETUP0_CECTL0 :: (
          ((.RDSETUP0_SETUP  )<< 16)
       )   
  inst  RDHLD0_SETUP :: 3 {
    	prop Label :: "Read Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl0ReadHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	prop Set :: (
        if ((!CSL.C11_SUPPORT)) { 
	    if ( $1 < 0 || $1 > 3 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 3 cycless")
                    } else {
                     .RDHLD0_SETUP = $1,
                     .CECTL0_VALUE = .CECTL0_VALUE_update(),
		      "ok"
	            }
	   }  else {
	          if ( $1 < 0 || $1 > 7 ) {
		     .error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")
                       } else {
                      .RDHLD0_SETUP = $1,
                       .CECTL0_VALUE = .CECTL0_VALUE_update(),
		        "ok"
	               }
           }    
	)
      }
      
   prop RDHLD0_CECTL0 :: (
          (.RDHLD0_SETUP)
       )   
       
      
  
   inst  WRSTRB0_SETUP :: 63{
    	prop Label :: "Write Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl0WriteStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 63 ) {
		.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")
	    } else {
              .WRSTRB0_SETUP = $1,
              .CECTL0_VALUE = .CECTL0_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop WRSTRB0_CECTL0 :: (
          ((.WRSTRB0_SETUP )<< 22)
       )   
       
 inst  WRSETUP0_SETUP :: 15{
    	prop Label :: "Write Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl0WriteSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")
	    } else {
              .WRSETUP0_SETUP = $1,
              .CECTL0_VALUE = .CECTL0_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop WRSETUP0_CECTL0 :: (
          ((.WRSETUP0_SETUP ) << 28) 
       )   
    inst  WRHLD0_SETUP :: 3 {
    	prop Label :: "Write Hold Width (WRHLD-WRHLDMSB) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl0WriteHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 7 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")
             } else {
                     .WRHLD0_SETUP = $1,
                     .CECTL0_VALUE = .CECTL0_VALUE_update(),
		          "ok"
	            }
	       
	         )
      }
      
    prop WRHLD0_CECTL0 :: (
       if ( .WRHLD0_SETUP > 3 ) {
         ( (.WRHLD0_SETUP - 4) << 20)     
      } else {   
           ((.WRHLD0_SETUP << 20) )
       }    
     )       
    prop WRHLDMSB0_CECTL0 :: (
     if (.WRHLD0_SETUP > 3) {
            0x00000008
        } else {
            0x00000000
    }                                                            
  )  
        
 
 inst TA0_SETUP :: 3 {
    	prop Label :: "Turn around time (TA) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl0Ta"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	prop Set :: (
	    if ( $1 < 1 || $1 > 3 ) {
		.error(" Minimum: 1 ECLKOU1 cycle - Maximum : 3 ECLKOU1 cycles")
	    } else {
              .TA0_SETUP = $1,
              .CECTL0_VALUE = .CECTL0_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop TA0_CECTL0 :: (
          (.TA0_SETUP << 14) 
       )   
 
   inst MTYPE1_SETUP :: "  8-bit async. interf." {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "  8-bit async. interf.,16-bit async. interf.,  8-bit SDRAM,16-bit SDRAM,  8-bit prog. sync. mem,16-bit prog. sync. mem"
        prop Label :: "Memory Type (MTYPE)"
	  prop JSName :: "emifbCectl1Mtype"
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFB_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	  prop Set :: (
               
		.MTYPE1_SETUP = $1,
		.CECTL1_VALUE = .CECTL1_VALUE_update(),
		"ok" 
	)
   }
    prop MTYPE1_CECTL1 :: (
                    if ( .MTYPE1_SETUP == "  8-bit async. interf.") {
                         0x00000000 
                        } else {
                            if ( .MTYPE1_SETUP == "  8-bit SDRAM") {
                             0x00000080 
                             } else {
                                if ( .MTYPE1_SETUP == "  8-bit prog. sync. mem") {
                                 0x000000a0 
                                   } else {
                                      if ( .MTYPE1_SETUP == "16-bit async. interf.") {
                                        0x00000010 
                                       } else {
                                           if ( .MTYPE1_SETUP == "16-bit SDRAM") {
                                            0x00000090 
                                            } else {
                                                if ( .MTYPE1_SETUP == "16-bit prog. sync. mem") {
                                                   0x000000b0 
                                                   }                                                            
                                                            
                           }
                       }
                 }
            }   
         }       
    ) 
 
 
 
 inst  RDSTRB1_SETUP :: 63{
    	prop Label :: "Read Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl1ReadStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 63 ) {
		.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")
	    } else {
              .RDSTRB1_SETUP = $1,
              .CECTL1_VALUE = .CECTL1_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSTRB1_CECTL1 :: (
          ((.RDSTRB1_SETUP) << 8)
       )   
       
 inst  RDSETUP1_SETUP :: 15{
    	prop Label :: "Read Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl1ReadSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")
	    } else {
              .RDSETUP1_SETUP = $1,
              .CECTL1_VALUE = .CECTL1_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSETUP1_CECTL1 :: (
          ((.RDSETUP1_SETUP) << 16)
       )   
  inst  RDHLD1_SETUP :: 3 {
    	prop Label :: "Read Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl1ReadHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	prop Set :: (
        if ((!CSL.C11_SUPPORT)) { 
	    if ( $1 < 0 || $1 > 3 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 3 cycless")
                    } else {
                     .RDHLD1_SETUP = $1,
                     .CECTL1_VALUE = .CECTL1_VALUE_update(),
		      "ok"
	            }
	   }  else {
	          if ( $1 < 0 || $1 > 7 ) {
		     .error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")
                       } else {
                      .RDHLD1_SETUP = $1,
                       .CECTL1_VALUE = .CECTL1_VALUE_update(),
		        "ok"
	               }
           }    
	)
      }
      
   prop RDHLD1_CECTL1 :: (
          (.RDHLD1_SETUP)
       )   
       
      
  
   inst  WRSTRB1_SETUP :: 63{
    	prop Label :: "Write Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl1WriteStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 63 ) {
		.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")
	    } else {
              .WRSTRB1_SETUP = $1,
              .CECTL1_VALUE = .CECTL1_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop WRSTRB1_CECTL1 :: (
          ((.WRSTRB1_SETUP ) << 22)
       )   
       
 inst  WRSETUP1_SETUP :: 15{
    	prop Label :: "Write Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl1WriteSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")
	    } else {
              .WRSETUP1_SETUP = $1,
              .CECTL1_VALUE = .CECTL1_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop WRSETUP1_CECTL1 :: (
          ((.WRSETUP1_SETUP ) << 28)
       )   
    inst  WRHLD1_SETUP :: 3 {
    	prop Label :: "Write Hold Width (WRHLD - WHLDMSB) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl1WriteHold"
      prop Visible :: 1
      prop Writable :: (CSL.EMIFB_SUPPORT) 
      prop NoGen :: 1
      prop TabName :: "CE1 Space"
	prop Set :: (
        	if ( $1 < 0 || $1 > 7 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")
                 } else {
                     .WRHLD1_SETUP = $1,
                     .CECTL1_VALUE = .CECTL1_VALUE_update(),
	        	      "ok"
	            }
              )
	  }
      
   prop WRHLD1_CECTL1 :: (
       if ( .WRHLD1_SETUP > 3 ) {
         ( (.WRHLD1_SETUP - 4) << 20)
      } else {   
           ((.WRHLD1_SETUP << 20) )
       }    
     )   
  
  prop WRHLDMSB1_CECTL1 :: (
    if ( .WRHLD1_SETUP > 3 ) { 
        0x00000008 
      } else {
        0x00000000
     }
   )  
        
 
 inst TA1_SETUP ::  3 {
    	prop Label :: "Turn around time (TA) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl1Ta"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	prop Set :: (
	    if ( $1 < 1 || $1 > 3 ) {
		.error(" Minimum: 1 ECLKOU1 cycle - Maximum : 3 ECLKOU1 cycles")
	    } else {
              .TA1_SETUP = $1,
              .CECTL1_VALUE = .CECTL1_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop TA1_CECTL1 :: (
          (.TA1_SETUP << 14) 
    )
          
 
inst MTYPE2_SETUP :: "  8-bit async. interf." {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "  8-bit async. interf.,16-bit async. interf.,  8-bit SDRAM,16-bit SDRAM,  8-bit prog. sync. mem,16-bit prog. sync. mem"
        prop Label :: "Memory Type (MTYPE)"
	  prop JSName :: "emifbCectl2Mtype"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	  prop Set :: (
               
		.MTYPE2_SETUP = $1,
		.CECTL2_VALUE = .CECTL2_VALUE_update(),
		"ok" 
	)
   }
    prop MTYPE2_CECTL2 :: (
                    if ( .MTYPE2_SETUP == "  8-bit async. interf.") {
                         0x00000000 
                        } else {
                            if ( .MTYPE2_SETUP == "  8-bit SDRAM") {
                             0x00000080 
                             } else {
                                if ( .MTYPE2_SETUP == "  8-bit prog. sync. mem") {
                                 0x000000a0 
                                   } else {
                                      if ( .MTYPE2_SETUP == "16-bit async. interf.") {
                                        0x00000010 
                                       } else {
                                           if ( .MTYPE2_SETUP == "16-bit SDRAM") {
                                            0x00000090 
                                            } else {
                                                if ( .MTYPE2_SETUP == "16-bit prog. sync. mem") {
                                                   0x000000b0 
                                                   }                                                            
                                                            
                           }
                       }
                 }
            }   
         }       
    ) 
 
 
 
 inst  RDSTRB2_SETUP :: 63{
    	prop Label :: "Read Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl2ReadStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 63 ) {
		.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")
	    } else {
              .RDSTRB2_SETUP = $1,
              .CECTL2_VALUE = .CECTL2_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSTRB2_CECTL2 :: (
          ((.RDSTRB2_SETUP ) << 8)
       )   
       
 inst  RDSETUP2_SETUP :: 15{
    	prop Label :: "Read Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl2ReadSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")
	    } else {
              .RDSETUP2_SETUP = $1,
              .CECTL2_VALUE = .CECTL2_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSETUP2_CECTL2 :: (
          ((.RDSETUP2_SETUP )<< 16)
       )   
  inst  RDHLD2_SETUP :: 3 {
    	prop Label :: "Read Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl2ReadHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	prop Set :: (
        if ((!CSL.C11_SUPPORT)) { 
	    if ( $1 < 0 || $1 > 3 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 3 cycless")
                    } else {
                     .RDHLD2_SETUP = $1,
                     .CECTL2_VALUE = .CECTL2_VALUE_update(),
		      "ok"
	            }
	   }  else {
	          if ( $1 < 0 || $1 > 7 ) {
		     .error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")
                       } else {
                      .RDHLD2_SETUP = $1,
                       .CECTL2_VALUE = .CECTL2_VALUE_update(),
		        "ok"
	               }
           }    
	)
      }
      
   prop RDHLD2_CECTL2 :: (
          (.RDHLD2_SETUP)
       )   
       
      
  
   inst  WRSTRB2_SETUP :: 63{
    	prop Label :: "Write Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl2WriteStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 63 ) {
		.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")
	    } else {
              .WRSTRB2_SETUP = $1,
              .CECTL2_VALUE = .CECTL2_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop WRSTRB2_CECTL2 :: (
          ((.WRSTRB2_SETUP )<< 22)
       )   
       
 inst  WRSETUP2_SETUP :: 15{
    	prop Label :: "Write Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl2WriteSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")
	    } else {
              .WRSETUP2_SETUP = $1,
              .CECTL2_VALUE = .CECTL2_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop WRSETUP2_CECTL2 :: (
          ((.WRSETUP2_SETUP )<< 28)
       )   
    inst  WRHLD2_SETUP :: 3 {
    	prop Label :: "Write Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl2WriteHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	prop Set :: (
        	    if ( $1 < 0 || $1 > 7 ) {
		      .error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")
                    } else {
                     .WRHLD2_SETUP = $1,
                     .CECTL2_VALUE = .CECTL2_VALUE_update(),
		      "ok"
	            }
	              
	   )
      }
      
   prop WRHLD2_CECTL2 :: (
       if ( .WRHLD2_SETUP > 3 ) {
         ( (.WRHLD2_SETUP - 4) << 20)
      } else {   
           ((.WRHLD2_SETUP << 20) )
       }    
     )   
  
  prop WRHLDMSB2_CECTL2 :: (
    if ( .WRHLD2_SETUP > 3 ) { 
      0x00000008 
    } else {
     0x00000000
     }
   )
   
        
 
 inst TA2_SETUP :: 3 {
    	prop Label :: "Turn around time (TA) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl2Ta"
      prop Visible :: 1
      prop Writable :: (CSL.EMIFB_SUPPORT) 
      prop NoGen :: 1
      prop TabName :: "CE2 Space"
	prop Set :: (
	    if ( $1 < 1 || $1 > 3 ) {
		.error(" Minimum: 1 ECLKOU1 cycle - Maximum : 3 ECLKOU1 cycles")
	    } else {
              .TA2_SETUP = $1,
              .CECTL2_VALUE = .CECTL2_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop TA2_CECTL2 :: (
          (.TA2_SETUP << 14) 
       )   
 
inst MTYPE3_SETUP :: "  8-bit async. interf." {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "  8-bit async. interf.,16-bit async. interf.,  8-bit SDRAM,16-bit SDRAM,  8-bit prog. sync. mem,16-bit prog. sync. mem"
        prop Label :: "Memory Type (MTYPE)"
	prop JSName :: "emifbCectl3Mtype"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	  prop Set :: (
             .MTYPE3_SETUP = $1,
		.CECTL3_VALUE = .CECTL3_VALUE_update(),
		"ok"
           	)
   }
   prop MTYPE3_CECTL3 :: (
                    if ( .MTYPE3_SETUP == "  8-bit async. interf.") {
                         0x00000000 
                        } else {
                            if ( .MTYPE3_SETUP == "  8-bit SDRAM") {
                             0x00000080 
                             } else {
                                if ( .MTYPE3_SETUP == "  8-bit prog. sync. mem") {
                                 0x000000a0 
                                   } else {
                                      if ( .MTYPE3_SETUP == "16-bit async. interf.") {
                                        0x00000010 
                                       } else {
                                           if ( .MTYPE3_SETUP == "16-bit SDRAM") {
                                            0x00000090 
                                            } else {
                                                if ( .MTYPE3_SETUP == "16-bit prog. sync. mem") {
                                                   0x000000b0 
                                                   }                                                            
                                                            
                           }
                       }
                 }
            }   
         }       
    ) 
 
 
 inst  RDSTRB3_SETUP :: 63{
    	prop Label :: "Read Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl3ReadStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 63 ) {
		.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")
	    } else {
              .RDSTRB3_SETUP = $1,
              .CECTL3_VALUE = .CECTL3_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSTRB3_CECTL3 :: (
          ((.RDSTRB3_SETUP ) << 8)
       )   
       
 inst  RDSETUP3_SETUP :: 15{
    	prop Label :: "Read Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl3ReadSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")
	    } else {
              .RDSETUP3_SETUP = $1,
              .CECTL3_VALUE = .CECTL3_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSETUP3_CECTL3 :: (
          ((.RDSETUP3_SETUP )<< 16)
       )   
  inst  RDHLD3_SETUP :: 3 {
    	prop Label :: "Read Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl3ReadHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	prop Set :: (
        if ((!CSL.C11_SUPPORT)) { 
	    if ( $1 < 0 || $1 > 3 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 3 cycless")
                    } else {
                     .RDHLD3_SETUP = $1,
                     .CECTL3_VALUE = .CECTL3_VALUE_update(),
		      "ok"
	            }
	   }  else {
	          if ( $1 < 0 || $1 > 7 ) {
		     .error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")
                       } else {
                      .RDHLD3_SETUP = $1,
                       .CECTL3_VALUE = .CECTL3_VALUE_update(),
		        "ok"
	               }
           }    
	)
      }
      
   prop RDHLD3_CECTL3 :: (
          (.RDHLD3_SETUP)
       )   
       
      
  
   inst  WRSTRB3_SETUP :: 63{
    	prop Label :: "Write Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl3WriteStrobe"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 63 ) {
		.error(" Minimum strobe :0 cycle - Maximum strobe: 63 cycless")
	    } else {
              .WRSTRB3_SETUP = $1,
              .CECTL3_VALUE = .CECTL3_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop WRSTRB3_CECTL3 :: (
          ((.WRSTRB3_SETUP )<< 22)
       )   
       
 inst  WRSETUP3_SETUP :: 15{
    	prop Label :: "Write Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl3WriteSetup"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error(" Minimum setup :0 cycle - Maximum setup: 15 cycles")
	    } else {
              .WRSETUP3_SETUP = $1,
              .CECTL3_VALUE = .CECTL3_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop WRSETUP3_CECTL3 :: (
          ((.WRSETUP3_SETUP) << 28)
       )   
    inst  WRHLD3_SETUP :: 3 {
    	prop Label :: "Write Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl3WriteHold"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	prop Set :: (  
	       if ( $1 < 0 || $1 > 7 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 7 cycles")
                    } else {
                     .WRHLD3_SETUP = $1,
                     .CECTL3_VALUE = .CECTL3_VALUE_update(),
		      "ok"
	            }
	  	)
      }
      
   prop WRHLD3_CECTL3 :: (
       if ( .WRHLD3_SETUP > 3 ) {
         ( (.WRHLD3_SETUP - 4) << 20)
      } else {   
           ((.WRHLD3_SETUP << 20) )
       }    
     )   
  
  prop WRHLDMSB3_CECTL3 :: (
    if ( .WRHLD3_SETUP > 3 ) {
        0x00000008 
    } else {
     0x00000000
     }
   )  
        
 
 inst TA3_SETUP :: 3 {
    	prop Label :: "Turn around time (TA) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbCectl3Ta"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	prop Set :: (
	    if ( $1 < 1 || $1 > 3 ) {
		.error(" Minimum: 1 ECLKOU1 cycle - Maximum : 3 ECLKOU1 cycles")
	    } else {
              .TA3_SETUP = $1,
              .CECTL3_VALUE = .CECTL3_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop TA3_CECTL3 :: (
          (.TA3_SETUP << 14) 
       )   
 
                                                                          
 inst SYNCRL0_SETUP :: "2 cycles"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data read latency (SYNCRL)"
        prop JSName :: "emifbCesec0Syncrl"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFB_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	  prop Set :: (
               
		.SYNCRL0_SETUP = $1,
		.CESEC0_VALUE = .CESEC0_VALUE_update(),
		"ok" 
	)
   }
    prop SYNCRL0_CESEC0 :: (
     if (.SYNCRL0_SETUP == "0 cycle") {
            0x00000000
        } else {
            if (.SYNCRL0_SETUP == "1 cycle") {
            0x00000001
		} else {     
                 if ( .SYNCRL0_SETUP == "2 cycles") {
                 0x00000002 
                   } else {
                         0x00000003 
                     }
              }   
         }       
    )   
                                                                 
 inst SYNCWL0_SETUP :: "0 cycle"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data write latency (SYNCWL)"
        prop Visible :: 1
        prop JSName :: "emifbCesec0Syncwl"  
        prop Writable :: ((CSL.EMIFB_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	  prop Set :: (
               
		.SYNCWL0_SETUP = $1,
		.CESEC0_VALUE = .CESEC0_VALUE_update(),
		"ok" 
	)
   }
    prop SYNCWL0_CESEC0 :: (
     if (.SYNCWL0_SETUP == "0 cycle") {
            0x00000000
        } else {
            if (.SYNCWL0_SETUP == "1 cycle") {
            0x00000004
		} else {     
                 if ( .SYNCWL0_SETUP == "2 cycles") {
                 0x00000008 
                   } else {
                         0x0000000c 
                     }
              }   
         }       
    )   
 inst CEEXT0_SETUP :: "Inactive"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Inactive,Active"
        prop Label :: "CE Extension Register (CEEXT)"
        prop JSName :: "emifbCesec0Ceext"  
       prop Visible :: 1
        prop Writable :: ((CSL.EMIFB_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	  prop Set :: (
               
		.CEEXT0_SETUP = $1,
		.CESEC0_VALUE = .CESEC0_VALUE_update(),
		"ok" 
	)
   }
    prop CEEXT0_CESEC0 :: (
     if (.CEEXT0_SETUP == "Inactive") {
            0x00000000
        } else { 
            0x0000010
		}                        
    )   
inst RENEN0_SETUP :: "ADS Mode"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "ADS Mode,Read Enable Mode"
        prop Label :: "Read Enable Enable (RENEN)"
        prop JSName :: "emifbCesec0Renen"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFB_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	  prop Set :: (
               
		.RENEN0_SETUP = $1,
		.CESEC0_VALUE = .CESEC0_VALUE_update(),
		"ok" 
	)
   }
    prop RENEN0_CESEC0 :: (
     if (.RENEN0_SETUP == "ADS Mode") {
            0x00000000
        } else { 
            0x0000020
		}                        
    )   
inst SNCCLK0_SETUP :: "Sync. to ECLKOUT1"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Sync. to ECLKOUT1,Sync. to ECLKOUT2"
        prop Label :: "Synchronization Clock (SNCCLK)"
        prop JSName :: "emifbCesec0Sncclk"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFB_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE0 Space"
	  prop Set :: (
               
		.SNCCLK0_SETUP = $1,
		.CESEC0_VALUE = .CESEC0_VALUE_update(),
		"ok" 
	)
   }
    prop SNCCLK0_CESEC0 :: (
     if (.SNCCLK0_SETUP == "Sync. to ECLKOUT1") {
            0x00000000
        } else { 
            0x0000040
		}                        
    )   
 
 inst SYNCRL1_SETUP :: "2 cycles"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data read latency (SYNCRL)"
        prop JSName :: "emifbCesec1Syncrl"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFB_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	  prop Set :: (
               
		.SYNCRL1_SETUP = $1,
		.CESEC1_VALUE = .CESEC1_VALUE_update(),
		"ok" 
	)
   }
    prop SYNCRL1_CESEC1 :: (
     if (.SYNCRL1_SETUP == "0 cycle") {
            0x00000000
        } else {
            if (.SYNCRL1_SETUP == "1 cycle") {
            0x00000001
		} else {     
                 if ( .SYNCRL1_SETUP == "2 cycles") {
                 0x00000002 
                   } else {
                         0x00000003 
                     }
              }   
         }       
    )   
                                                               
 inst SYNCWL1_SETUP :: "0 cycle"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data write latency (SYNCWL)"
        prop JSName :: "emifbCesec1Syncwl"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFB_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	  prop Set :: (
               
		.SYNCWL1_SETUP = $1,
		.CESEC1_VALUE = .CESEC1_VALUE_update(),
		"ok" 
	)
   }
    prop SYNCWL1_CESEC1 :: (
     if (.SYNCWL1_SETUP == "0 cycle") {
            0x00000000
        } else {
            if (.SYNCWL1_SETUP == "1 cycle") {
            0x00000004
		} else {     
                 if ( .SYNCWL1_SETUP == "2 cycles") {
                 0x00000008 
                   } else {
                         0x0000000c 
                     }
              }   
         }       
    )   
 inst CEEXT1_SETUP :: "Inactive"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Inactive,Active"
        prop Label :: "CE Extension Register (CEEXT)"
        prop JSName :: "emifbCesec1Ceext"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFB_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	  prop Set :: (
               
		.CEEXT1_SETUP = $1,
		.CESEC1_VALUE = .CESEC1_VALUE_update(),
		"ok" 
	)
   }
    prop CEEXT1_CESEC1 :: (
     if (.CEEXT1_SETUP == "Inactive") {
            0x00000000
        } else { 
            0x0000010
		}                        
    )   
inst RENEN1_SETUP :: "ADS Mode"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "ADS Mode,Read Enable Mode"
        prop Label :: "Read Enable Enable (RENEN)"
        prop JSName :: "emifbCesec1Renen"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFB_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	  prop Set :: (
               
		.RENEN1_SETUP = $1,
		.CESEC1_VALUE = .CESEC1_VALUE_update(),
		"ok" 
	)
   }
    prop RENEN1_CESEC1 :: (
     if (.RENEN1_SETUP == "ADS Mode") {
            0x00000000
        } else { 
            0x0000020
		}                        
    )   
inst SNCCLK1_SETUP :: "Sync. to ECLKOUT1"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Sync. to ECLKOUT1,Sync. to ECLKOUT2"
        prop Label :: "Synchronization Clock (SNCCLK)"
        prop JSName :: "emifbCesec1Sncclk"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFB_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE1 Space"
	  prop Set :: (
               
		.SNCCLK1_SETUP = $1,
		.CESEC1_VALUE = .CESEC1_VALUE_update(),
		"ok" 
	)
   }
    prop SNCCLK1_CESEC1 :: (
     if (.SNCCLK1_SETUP == "Sync. to ECLKOUT1") {
            0x00000000
        } else { 
            0x0000040
		}                        
    )   
 
inst SYNCRL2_SETUP :: "2 cycles"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data read latency (SYNCRL)"
        prop JSName :: "emifbCesec2Syncrl"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFB_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	  prop Set :: (
               
		.SYNCRL2_SETUP = $1,
		.CESEC2_VALUE = .CESEC2_VALUE_update(),
		"ok" 
	)
   }
    prop SYNCRL2_CESEC2 :: (
     if (.SYNCRL2_SETUP == "0 cycle") {
            0x00000000
        } else {
            if (.SYNCRL2_SETUP == "1 cycle") {
            0x00000001
		} else {     
                 if ( .SYNCRL2_SETUP == "2 cycles") {
                 0x00000002 
                   } else {
                         0x00000003 
                     }
              }   
         }       
    )   
                                                               
 inst SYNCWL2_SETUP :: "0 cycle"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data write latency (SYNCWL)"
        prop JSName :: "emifbCesec2Syncwl"  
       prop Visible :: 1
        prop Writable :: ((CSL.EMIFB_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	  prop Set :: (
               
		.SYNCWL2_SETUP = $1,
		.CESEC2_VALUE = .CESEC2_VALUE_update(),
		"ok" 
	)
   }
    prop SYNCWL2_CESEC2 :: (
     if (.SYNCWL2_SETUP == "0 cycle") {
            0x00000000
        } else {
            if (.SYNCWL2_SETUP == "1 cycle") {
            0x00000004
		} else {     
                 if ( .SYNCWL2_SETUP == "2 cycles") {
                 0x00000008 
                   } else {
                         0x0000000c 
                     }
              }   
         }       
    )   
 inst CEEXT2_SETUP :: "Inactive"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Inactive,Active"
        prop Label :: "CE Extension Register (CEEXT)"
        prop JSName :: "emifbCesec2Ceext"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFB_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	  prop Set :: (
               
		.CEEXT2_SETUP = $1,
		.CESEC2_VALUE = .CESEC2_VALUE_update(),
		"ok" 
	)
   }
    prop CEEXT2_CESEC2 :: (
     if (.CEEXT2_SETUP == "Inactive") {
            0x00000000
        } else { 
            0x0000010
		}                        
    )   
inst RENEN2_SETUP :: "ADS Mode"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "ADS Mode,Read Enable Mode"
        prop Label :: "Read Enable Enable (RENEN)"
        prop JSName :: "emifbCesec2Renen"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFB_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	  prop Set :: (
               
		.RENEN2_SETUP = $1,
		.CESEC2_VALUE = .CESEC2_VALUE_update(),
		"ok" 
	)
   }
    prop RENEN2_CESEC2 :: (
     if (.RENEN2_SETUP == "ADS Mode") {
            0x00000000
        } else { 
            0x0000020
		}                        
    )   
inst SNCCLK2_SETUP :: "Sync. to ECLKOUT1"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Sync. to ECLKOUT1,Sync. to ECLKOUT2"
        prop Label :: "Synchronization Clock (SNCCLK)"
        prop JSName :: "emifbCesec2Sncclk"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFB_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE2 Space"
	  prop Set :: (
               
		.SNCCLK2_SETUP = $1,
		.CESEC2_VALUE = .CESEC2_VALUE_update(),
		"ok" 
	)
   }
    prop SNCCLK2_CESEC2 :: (
     if (.SNCCLK2_SETUP == "Sync. to ECLKOUT1") {
            0x00000000
        } else { 
            0x0000040
		}                        
    )   
 
  inst SYNCRL3_SETUP :: "2 cycles"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data read latency (SYNCRL)"
         prop JSName :: "emifbCesec3Syncrl"  
       prop Visible :: 1
        prop Writable :: ((CSL.EMIFB_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	  prop Set :: (
               
		.SYNCRL3_SETUP = $1,
		.CESEC3_VALUE = .CESEC3_VALUE_update(),
		"ok" 
	)
   }
    prop SYNCRL3_CESEC3 :: (
     if (.SYNCRL3_SETUP == "0 cycle") {
            0x00000000
        } else {
            if (.SYNCRL3_SETUP == "1 cycle") {
            0x00000001
		} else {     
                 if ( .SYNCRL3_SETUP == "2 cycles") {
                 0x00000002 
                   } else {
                         0x00000003 
                     }
              }   
         }       
    )   
                                                               
 inst SYNCWL3_SETUP :: "0 cycle"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "0 cycle,1 cycle,2 cycles,3 cycles"
        prop Label :: "Sync. interf. data write latency (SYNCWL)"
         prop JSName :: "emifbCesec3Syncwl"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFB_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	  prop Set :: (
               
		.SYNCWL3_SETUP = $1,
		.CESEC3_VALUE = .CESEC3_VALUE_update(),
		"ok" 
	)
   }
    prop SYNCWL3_CESEC3 :: (
     if (.SYNCWL3_SETUP == "0 cycle") {
            0x00000000
        } else {
            if (.SYNCWL3_SETUP == "1 cycle") {
            0x00000004
		} else {     
                 if ( .SYNCWL3_SETUP == "2 cycles") {
                 0x00000008 
                   } else {
                         0x0000000c 
                     }
              }   
         }       
    )   
 inst CEEXT3_SETUP :: "Inactive"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Inactive,Active"
        prop Label :: "CE Extension Register (CEEXT)"
        prop JSName :: "emifbCesec3Ceext"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFB_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	  prop Set :: (
               
		.CEEXT3_SETUP = $1,
		.CESEC3_VALUE = .CESEC3_VALUE_update(),
		"ok" 
	)
   }
    prop CEEXT3_CESEC3 :: (
     if (.CEEXT3_SETUP == "Inactive") {
            0x00000000
        } else { 
            0x0000010
		}                        
    )   
inst RENEN3_SETUP :: "ADS Mode"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "ADS Mode,Read Enable Mode"
        prop Label :: "Read Enable Enable (RENEN)"
        prop JSName :: "emifbCesec3Renen"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFB_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	  prop Set :: (
               
		.RENEN3_SETUP = $1,
		.CESEC3_VALUE = .CESEC3_VALUE_update(),
		"ok" 
	)
   }
    prop RENEN3_CESEC3 :: (
     if (.RENEN3_SETUP == "ADS Mode") {
            0x00000000
        } else { 
            0x0000020
		}                        
    )   
inst SNCCLK3_SETUP :: "Sync. to ECLKOUT1"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Sync. to ECLKOUT1,Sync. to ECLKOUT2"
        prop Label :: "Synchronization Clock (SNCCLK)"
        prop JSName :: "emifbCesec3Sncclk"  
        prop Visible :: 1
        prop Writable :: ((CSL.EMIFB_SUPPORT)? 1: 0)
        prop NoGen :: 1
        prop TabName :: "CE3 Space"
	  prop Set :: (
               
		.SNCCLK3_SETUP = $1,
		.CESEC3_VALUE = .CESEC3_VALUE_update(),
		"ok" 
	)
   }
    prop SNCCLK3_CESEC3 :: (
     if (.SNCCLK3_SETUP == "Sync. to ECLKOUT1") {
            0x00000000
        } else { 
            0x0000040
		}                        
    )                                               
 
 inst TRC_SETUP :: 15 {
    	prop Label :: "TRC = trc/(eclkout1 period-1) (TRC) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbSdctlTrc"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error("Minimum TRC = 0 - Maximum TRC = 15 ")
	    } else {
              .TRC_SETUP = $1,
              .SDCTL_VALUE = .SDCTL_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop TRC_SDCTL :: (
          (.TRC_SETUP << 12) 
       )   
 inst TRP_SETUP :: 8 {
    	prop Label :: "TRP = trp/(eclkout1 period-1) (TRP) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbSdctlTrp"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error("Minimum TRP = 0 - Maximum TRP= 15 ")
	    } else {
              .TRP_SETUP = $1,
              .SDCTL_VALUE = .SDCTL_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop TRP_SDCTL :: (
          (.TRP_SETUP << 16) 
       )   
  
 
 inst TRCD_SETUP :: 4 {
    	prop Label :: "TRCD = trcd/(eclkout1 period-1) (TRCD) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbSdctlTrcd"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
	    if ( $1 < 0 || $1 > 15 ) {
		.error("Minimum TRCD = 0 - Maximum TRCD= 15 ")
	    } else {
              .TRCD_SETUP = $1,
              .SDCTL_VALUE = .SDCTL_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop TRCD_SDCTL :: (
          (.TRCD_SETUP << 20) 
       )   
  
 inst INIT_SETUP :: "Initialize" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Initialize,No effect"
    	prop Label :: "Initialization of all SDRAMs (INIT)"
	prop JSName :: "emifbSdctlInit"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
              .INIT_SETUP = $1,
              .SDCTL_VALUE = .SDCTL_VALUE_update(),
		"ok"
	)
      }
      
   prop INIT_SDCTL :: (
         if  (.INIT_SETUP == "Initialize") {
          0x01000000
          } else {
          0x00000000
          }
       )   
 inst RFEN_SETUP :: "Enable" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Enable,Disable"
    	prop Label :: "SDRAM Refresh Enable (RFEN)"
	prop JSName :: "emifbSdctlRfen"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
              .RFEN_SETUP = $1,
              .SDCTL_VALUE = .SDCTL_VALUE_update(),
		"ok"
	)
      }
      
   prop RFEN_SDCTL :: (
         if  (.RFEN_SETUP == "Enable") {
          0x02000000
          } else {
          0x00000000
          }
       )   
  
     
 inst SDCSZ_SETUP :: " 9 addresses" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: " 9 addresses, 8 addresses,10 addresses"
    	prop Label :: "Column Size (SDCSZ)"
	prop JSName :: "emifbSdctlSdcsz"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
              .SDCSZ_SETUP = $1,
              .SDCTL_VALUE = .SDCTL_VALUE_update(),
		"ok"
	)
      }
      
   prop SDCSZ_SDCTL :: (
         if  (.SDCSZ_SETUP == " 8 addresses") {
          0x04000000
          } else {
             if  (.SDCSZ_SETUP == "10 addresses") {
              0x08000000
             } else {
             0x00000000
             } 
         }  
       )   
inst SDRSZ_SETUP :: "11 addresses" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "11 addresses,12 addresses,13 addresses"
    	prop Label :: "Row Size (SDRSZ)"
	prop JSName :: "emifbSdctlSdrsz"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
              .SDRSZ_SETUP = $1,
              .SDCTL_VALUE = .SDCTL_VALUE_update(),
		"ok"
	)
      }
      
   prop SDRSZ_SDCTL :: (
         if  (.SDRSZ_SETUP == "12 addresses") {
          0x10000000
          } else {
             if  (.SDRSZ_SETUP == "13 addresses") {
              0x20000000
             } else {
             0x00000000
             } 
         }  
       )   
inst SDBSZ_SETUP :: "Two banks" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Two banks,Four banks"
    	prop Label :: "Bank Size (SDBSZ)"
	prop JSName :: "emifbSdctlSdbsz"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
              .SDBSZ_SETUP = $1,
              .SDCTL_VALUE = .SDCTL_VALUE_update(),
		"ok"
	)
      }
      
   prop SDBSZ_SDCTL :: (
         if  (.SDBSZ_SETUP == "Four banks") {
          0x40000000
          } else {
              0x00000000
             } 
       )   
 
inst PERIOD_SETUP2 :: 1500 {
    	prop Label :: "Refresh Period (ECLKOU1 cycles)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbSdtimEclkPeriod"
        prop Visible ::  1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
	    if ( $1 < 1 || $1 > 4096 ) {
		.error("1 cyc. < PERIOD < 4096 cyc. ")
	    } else {
              .PERIOD_SETUP2 = $1,
              .SDTIM_VALUE = .SDTIM_VALUE_update(),
		"ok"
	    }
	)
      }
      
      
      
   prop PERIOD_SDTIM2 :: (
          (.PERIOD_SETUP2)
        )   
inst XRFR_SETUP :: 1 {
    	prop Label :: "Extra Refreshes Ctrl. (XRFR)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbSdctlXrfr"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM Control"
	prop Set :: (
	    if ( $1 < 1 || $1 > 4 ) {
		.error("1 < Extra refreshes < 4 ")
	    } else {
              .XRFR_SETUP = $1,
              .SDTIM_VALUE = .SDTIM_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop XRFR_SDTIM :: (
          ((.XRFR_SETUP - 1) << 24)
        )   
 
 inst TCL_SETUP :: 3  {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    	prop Label :: "CAS Latency (TCL)"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbSdextTcl"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 2 || $1 > 3 ) {
		.error("TCL : 2 or 3 ECLKOU1 cycles ")
	    } else {
              .TCL_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
            }    
        )
      }
      
   prop TCL_SDEXT :: (
         (.TCL_SETUP - 2)   
       )   
       
 inst TRAS_SETUP :: 8 {
    	prop Label :: "tras = TRAS + 1 (ECLKOU1 cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbSdextTras"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 8 ) {
		.error("1 ECLKOU1 cycle < tras < 8 ECLKOU1 cycles ")
	    } else {
              .TRAS_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop TRAS_SDEXT :: (
          ((.TRAS_SETUP - 1) << 1)
        )   
       
 inst TRRD_SETUP :: 3 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
    	prop Label :: "trrd = TRRD (2 or 3 ECLKOU1 cyc.)"
	prop JSName :: "emifbSdextTrrd"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 2 || $1 > 3 ) {
		.error("TRRD : 2 or 3 ECLKOU1 cycles ")
	    } else {
              .TRRD_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
              }  
        )
      }
      
   prop TRRD_SDEXT :: (
         (.TRRD_SETUP - 2) << 4  
       )   
 inst TWR_SETUP :: 2 {
    	prop Label :: "twr  = TWR + 1 (ECLKOU1 cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbSdextTwr"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 4 ) {
		.error("1 ECLKOU1 cycle < twr < 4 ECLKOU1 cycles ")
	    } else {
              .TWR_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop TWR_SDEXT :: (
          ((.TWR_SETUP - 1) << 5)
        )   
 inst THZP_SETUP :: 3 {
    	prop Label :: "thzp = THZP + 1 (ECLKOU1 cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbSdextThzp"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 4 ) {
		.error("1 ECLKOU1 cycle < thzp < 4 ECLKOU1 cycles ")
	    } else {
              .THZP_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop THZP_SDEXT :: (
          ((.THZP_SETUP - 1) << 7)
        )   
       
  inst RD2RD_SETUP :: 2 {
    	prop Label :: "READ-To-READ (ECLKOU1 cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbSdextRd2rd"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 2 ) {
		.error("1 < # of ECLKOU1 cycles < 2  ")
	    } else {
              .RD2RD_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }           
      
   prop RD2RD_SDEXT :: (
          ((.RD2RD_SETUP - 1) << 9)
        )   
       
  
  inst RD2DEAC_SETUP :: 4 {
    	prop Label :: "READ-To-DEAC/DEAB (ECLKOU1 cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbSdextRd2deac"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 4 ) {
		.error("1 < # of ECLKOU1 cycles < 4  ")
	    } else {
              .RD2DEAC_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }           
      
   prop RD2DEAC_SDEXT :: (
          ((.RD2DEAC_SETUP - 1) << 10)
        )   
 inst RD2WR_SETUP :: 6 {
    	prop Label :: "READ-To-WRITE (ECLKOU1 cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbSdextRd2wr"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 8 ) {
		.error("1 < # of ECLKOU1 cycles < 8  ")
	    } else {
              .RD2WR_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }           
      
   prop RD2WR_SDEXT :: (
          ((.RD2WR_SETUP - 1) << 12)
        )   
 inst R2WDQM_SETUP :: 3 {
    	prop Label :: "READ-To-WRITE with Interrupt (BEx cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbSdextR2wdqm"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 4 ) {
		.error("1 < # of Bex cycles < 4  ")
	    } else {
              .R2WDQM_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }           
      
   prop R2WDQM_SDEXT :: (
          ((.R2WDQM_SETUP - 1) << 15)
        )   
  
   
  inst WR2WR_SETUP :: 2 {
    	prop Label :: "WRITE-To-WRITE (ECLKOU1 cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbSdextWr2wr"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 2 ) {
		.error("1 < # of ECLKOU1 cycles < 2  ")
	    } else {
              .WR2WR_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }           
      
   prop WR2WR_SDEXT :: (
          ((.WR2WR_SETUP - 1) << 17)
        )   
        
  inst WR2DEAC_SETUP :: 2 {
    	prop Label :: "WRITE-To-DEAC/DEAB (ECLKOU1 cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbSdextWr2deac"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 4 ) {
		.error("1 < # of ECLKOU1 cycles < 4  ")
	    } else {
              .WR2DEAC_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }           
      
   prop WR2DEAC_SDEXT :: (
          ((.WR2DEAC_SETUP - 1) << 18)
        )   
 inst WR2RD_SETUP :: 2 {
    	prop Label :: "WRITE-To-READ (# of ECLKOU1 cyc.)"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "emifbSdextWr2rd"
        prop Visible :: 1
        prop Writable :: (CSL.EMIFB_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "SDRAM More Opt."
	prop Set :: (
	    if ( $1 < 1 || $1 > 2 ) {
		.error("1 < # of ECLKOU1 cycles < 2  ")
	    } else {
              .WR2RD_SETUP = $1,
              .SDEXT_VALUE = .SDEXT_VALUE_update(),
		"ok"
	    }
	)
      }           
   prop WR2RD_SDEXT :: (
          ((.WR2RD_SETUP - 1) << 20)
        )   
      
 
 
prop GBLCTL_VALUE_update :: (
     0x00000004
     |.NOHOLD_GBLCTL()
     |.CLK4EN_GBLCTL()
     |.CLK6EN_GBLCTL()
     |.EK1EN_GBLCTL()
     |.EK2EN_GBLCTL()
     |.EK1HZ_GBLCTL()
     |.EK2HZ_GBLCTL()
     |.EK2RATE_GBLCTL()
     |.BRMODE_GBLCTL()
 )  
 prop GBLCTL_SETUP_update :: (
    .NOHOLD_SETUP =  ($1 & 0x00000080) ? "Disable Hold" : "Enable Hold",
    .CLK4EN_SETUP =  ($1 & 0x00000010) ? "Enabled to clock" : "Held high",
    .CLK6EN_SETUP =  ($1 & 0x00000008) ? "Enabled to clock" : "Held high",
    .EK1EN_SETUP  =  ($1 & 0x00000020) ? "Enabled to clock" : "Held low",
    .EK2EN_SETUP  =  ($1 & 0x00010000) ? "Enabled to clock" : "Held low",
    .EK1HZ_SETUP  =  ($1 & 0x00000040) ? "High-Z during hold" : "Clock during hold",
    .EK2HZ_SETUP  =  ($1 & 0x00020000) ? "High-Z during hold" : "Clock during hold",
    .BRMODE_SETUP =  ($1 & 0x00002000) ? "access/refresh pending or in progress" : "access pending or in progress",
$a = $1 & 0x000C0000,
if ($a == 0x00080000){
    .EK2RATE_SETUP = "1/4x EMIF input clock"
   } else {
     .EK2RATE_SETUP  =  ($1 & 0x00040000) ? "1/2x EMIF input clock" : "1x EMIF input clock"    
    }
 
  )
  
   inst GBLCTL_VALUE :: .GBLCTL_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Global Control Reg. (GBLCTL) "
	prop Format :: "0x%08X"
	prop JSName :: "emifbGblctl"
	prop Visible :: 1
	prop Writable :: (CSL.EMIFB_SUPPORT) 
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (
               $a = $1 & 0xFFF00000,
                $b = $1 & 0x0000C000,
                $c = $1 & 0x00001000,
                $d = $1 & 0x00000003,
                $e = $1 & 0x000C0000,
        if ($a != 0) {
               .error("Bit field (31..20) is reserved")
        } else {
	     if ($b != 0) {
               .error("Bit field (15..14) is reserved")
	     } else {
              if ($c != 0) {
                  .error("Bit field 12 is reserved")
              } else {
                 if ($d != 0 ) {
                    .error("Bit field (1..0) is reserved")
                 } else {
                    if ($e == 0x000C0000) {
                        .error("Invalid input for EK2RATE bit[19:18]")
                    } else {
                        .GBLCTL_VALUE = $1 | 0x0000004,
                        .GBLCTL_SETUP_update($1 | 0x0000004  ),
 		            "ok"
                   }
                }
             }
          }
        }
      )
   }
   
prop CECTL0_VALUE_update :: (
     .MTYPE0_CECTL0()
  |  .RDHLD0_CECTL0()
  |  .RDSTRB0_CECTL0()
  |  .RDSETUP0_CECTL0()
  |  .WRHLD0_CECTL0()
  |  .WRHLDMSB0_CECTL0()  
  |  .WRSETUP0_CECTL0()
  |  .WRSTRB0_CECTL0()
  |  .TA0_CECTL0() 
  )
   prop CECTL0_SETUP_update :: (
        .MTYPE0_SETUP = ( $a = ( $1 & 0x000000f0),
                       ($a == 0x00000000) ? "  8-bit async. interf." :
                       ($a == 0x00000010) ? "16-bit async. interf." :
                       ($a == 0x00000080) ? "  8-bit SDRAM" :
                       ($a == 0x00000090) ? "16-bit SDRAM" :
                       ($a == 0x000000a0) ? "  8-bit prog. sync. mem" : "16-bit prog. sync. mem"), 
   .RDHLD0_SETUP = ( $1 & 0x00000007),  
   .RDSTRB0_SETUP =  ( ( $1 & 0x00003F00) >> 8 ) ,
   .RDSETUP0_SETUP =  ( ($1 & 0x000F0000) >> 16) ,
   .WRHLD0_SETUP =  ((( $1 & 0x00300000) >> 20) + (($1 & 0x00000008) >> 1 )), 
   .WRSTRB0_SETUP =   ( ($1 & 0x0FC00000) >> 22) ,
   .WRSETUP0_SETUP =  ( ($1 >> 28) & 0xF) ,
   .TA0_SETUP =  ($1 & 0x0000c000) >> 14  
    )   
    
      
   inst CECTL0_VALUE :: .CECTL0_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "CE0 Space Control Reg. (CECTL0) "
	prop Format :: "0x%08X"
	prop JSName :: "emifbCectl0"
	prop Visible :: 1
	prop Writable :: (CSL.EMIFB_SUPPORT) 
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (    
          $a = $1 & 0x000000F0,
          $b = $1 & 0x0000C000,
          if ( $a == 0x00000070 || $a == 0x000000F0 || $a == 0x00000050 || $a == 0x00000060 || $a == 0x00000020 || $a == 0x00000030 || $a == 0x00000040 || $a == 0x000000c0 || $a == 0x000000d0 || $a == 0x000000e0)  {   
               .error("Undefined Memory type for CE Spaces - See CEx Space Pages") 
              } else {
                 if ( $b == 0x00000000 ) {
                     .error("Minimum: 1 ECLKOU1 cycle - Maximum : 3 ECLKOU1 cycles")
                   } else {
                           .CECTL0_VALUE = $1,
                           .CECTL0_SETUP_update($1),
                           "ok"
                     }
              }
          )
   }
 prop CECTL1_VALUE_update :: (
     .MTYPE1_CECTL1()
  |  .RDHLD1_CECTL1()
  |  .RDSTRB1_CECTL1()
  |  .RDSETUP1_CECTL1()
  |  .WRHLD1_CECTL1()
  |  .WRHLDMSB1_CECTL1()
  |  .WRSETUP1_CECTL1()
  |  .WRSTRB1_CECTL1()
  |  .TA1_CECTL1() 
  )
    prop CECTL1_SETUP_update :: (
       .MTYPE1_SETUP = ( $a = ( $1 & 0x000000f0),
                       ($a == 0x00000000) ? "  8-bit async. interf." :
                       ($a == 0x00000010) ? "16-bit async. interf." :
                       ($a == 0x00000080) ? "  8-bit SDRAM" :
                       ($a == 0x00000090) ? "16-bit SDRAM" :
                       ($a == 0x000000a0) ? "  8-bit prog. sync. mem" : "16-bit prog. sync. mem"), 
   .RDHLD1_SETUP = ( $1 & 0x00000007),  
   .RDSTRB1_SETUP =  ( ( $1 & 0x00003F00) >> 8 ) ,
   .RDSETUP1_SETUP =  ( ($1 & 0x000F0000) >> 16) ,
   .WRHLD1_SETUP =  ((( $1 & 0x00300000) >> 20) + (($1 & 0x00000008) >> 1 )), 
   .WRSTRB1_SETUP =   ( ($1 & 0x0FC00000) >> 22) ,
   .WRSETUP1_SETUP =  ( ($1 >> 28) & 0xF) ,
   .TA1_SETUP =  ($1 & 0x0000c000) >> 14  
    )
    
   inst CECTL1_VALUE :: .CECTL1_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "CE1 Space Control Reg. (CECTL1) "
	prop Format :: "0x%08X"
	prop JSName :: "emifbCectl1"
	prop Visible :: 1
	prop Writable :: (CSL.EMIFB_SUPPORT) 
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
		prop Set :: (    
          $a = $1 & 0x000000F0,
          $b = $1 & 0x0000C000,
          if ( $a == 0x00000070 || $a == 0x000000F0 || $a == 0x00000050 || $a == 0x00000060 || $a == 0x00000020 || $a == 0x00000030 || $a == 0x00000040 || $a == 0x000000c0 || $a == 0x000000d0 || $a == 0x000000e0)  {   
               .error("Undefined Memory type for CE Spaces - See CEx Space Pages") 
              } else {
                 if ( $b == 0x00000000 ) {
                     .error("Minimum: 1 ECLKOU1 cycle - Maximum : 3 ECLKOU1 cycles")
                   } else {
                   .CECTL1_VALUE = $1,
                   .CECTL1_SETUP_update($1),
                    "ok"
                     }
               }        
          )
   } 
    
   
 prop CECTL2_VALUE_update :: (
     .MTYPE2_CECTL2()
  |  .RDHLD2_CECTL2()
  |  .RDSTRB2_CECTL2()
  |  .RDSETUP2_CECTL2()
  |  .WRHLD2_CECTL2()
  |  .WRHLDMSB2_CECTL2()
  |  .WRSETUP2_CECTL2()
  |  .WRSTRB2_CECTL2()
  |  .TA2_CECTL2() 
  )
 prop CECTL2_SETUP_update :: (
   .MTYPE2_SETUP = ( $a = ( $1 & 0x000000f0),
                       ($a == 0x00000000) ? "  8-bit async. interf." :
                       ($a == 0x00000010) ? "16-bit async. interf." :
                       ($a == 0x00000080) ? "  8-bit SDRAM" :
                       ($a == 0x00000090) ? "16-bit SDRAM" :
                       ($a == 0x000000a0) ? "  8-bit prog. sync. mem" : "16-bit prog. sync. mem"), 
   .RDHLD2_SETUP = ( $1 & 0x00000007),  
   .RDSTRB2_SETUP =  ( ( $1 & 0x00003F00) >> 8 ) ,
   .RDSETUP2_SETUP =  ( ($1 & 0x000F0000) >> 16) ,
   .WRHLD2_SETUP =  ((( $1 & 0x00300000) >> 20) + (($1 & 0x00000008) >> 1 )), 
   .WRSTRB2_SETUP =   ( ($1 & 0x0FC00000) >> 22) ,
   .WRSETUP2_SETUP =  ( ($1 >> 28) & 0xF) ,
   .TA2_SETUP =  ($1 & 0x0000c000) >> 14  
    )   
    
    
   inst CECTL2_VALUE :: .CECTL2_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "CE2 Space Control Reg. (CECTL2) "
	prop Format :: "0x%08X"
	prop JSName :: "emifbCectl2"
	prop Visible :: 1
	prop Writable :: (CSL.EMIFB_SUPPORT) 
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (    
          $a = $1 & 0x000000F0,
          $b = $1 & 0x0000C000,
          if ( $a == 0x00000070 || $a == 0x000000F0 || $a == 0x00000050 || $a == 0x00000060 || $a == 0x00000020 || $a == 0x00000030 || $a == 0x00000040 || $a == 0x000000c0 || $a == 0x000000d0 || $a == 0x000000e0)  {   
               .error("Undefined Memory type for CE Spaces - See CEx Space Pages") 
              } else {
                 if ( $b == 0x00000000 ) {
                     .error("Minimum: 1 ECLKOU1 cycle - Maximum : 3 ECLKOU1 cycles")
                   } else {
                           .CECTL2_VALUE = $1,
                           .CECTL2_SETUP_update($1),
                           "ok"
                     }
              }
          )
   }
   
 prop CECTL3_VALUE_update :: (
     .MTYPE3_CECTL3()
  |  .RDHLD3_CECTL3()
  |  .RDSTRB3_CECTL3()
  |  .RDSETUP3_CECTL3()
  |  .WRHLD3_CECTL3()
  |  .WRHLDMSB3_CECTL3()
  |  .WRSETUP3_CECTL3()
  |  .WRSTRB3_CECTL3()
  |  .TA3_CECTL3() 
  )
 
  prop CECTL3_SETUP_update :: (
    .MTYPE3_SETUP = ( $a = ( $1 & 0x000000f0),
                       ($a == 0x00000000) ? "  8-bit async. interf." :
                       ($a == 0x00000010) ? "16-bit async. interf." :
                       ($a == 0x00000080) ? "  8-bit SDRAM" :
                       ($a == 0x00000090) ? "16-bit SDRAM" :
                       ($a == 0x000000a0) ? "  8-bit prog. sync. mem" : "16-bit prog. sync. mem"),     
   .RDHLD3_SETUP = ( $1 & 0x00000007),  
   .RDSTRB3_SETUP =  ( ( $1 & 0x00003F00) >> 8 ) ,
   .RDSETUP3_SETUP =  ( ($1 & 0x000F0000) >> 16) ,
   .WRHLD3_SETUP = ((( $1 & 0x00300000) >> 20) + (($1 & 0x00000008) >> 1 )), 
   .WRSTRB3_SETUP =   ( ($1 & 0x0FC00000) >> 22) ,
   .WRSETUP3_SETUP =  ( ($1 >> 28) & 0xF) ,
   .TA3_SETUP =  ($1 & 0x0000c000) >> 14  
    )   
    
   inst CECTL3_VALUE :: .CECTL3_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE3 Space Control Reg. (CECTL3) "
	prop Format :: "0x%08X"
	prop JSName :: "emifbCectl3"
	prop Visible :: 1
	prop Writable :: (CSL.EMIFB_SUPPORT) 
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (    
          $a = $1 & 0x000000F0,
          $b = $1 & 0x0000C000,
          if ( $a == 0x00000070 || $a == 0x000000F0 || $a == 0x00000050 || $a == 0x00000060 || $a == 0x00000020 || $a == 0x00000030 || $a == 0x00000040 || $a == 0x000000c0 || $a == 0x000000d0 || $a == 0x000000e0)  {   
               .error("Undefined Memory type for CE Spaces - See CEx Space Pages") 
              } else {
                 if ( $b == 0x00000000 ) {
                     .error("Minimum: 1 ECLKOU1 cycle - Maximum : 3 ECLKOU1 cycles")
                   } else {
                           .CECTL3_VALUE = $1,
                           .CECTL3_SETUP_update($1),
                           "ok"
                     }
              }
          )
   }
   
 prop SDCTL_VALUE_update :: (
     .TRC_SDCTL()
  |  .TRP_SDCTL()
  |  .TRCD_SDCTL()
  |  .INIT_SDCTL()
  |  .RFEN_SDCTL()
  | .SDCSZ_SDCTL() 
  | .SDRSZ_SDCTL() 
  | .SDBSZ_SDCTL() 
  )
  prop SDCTL_SETUP_update :: (
   .TRC_SETUP = ($1 & 0x0000F000) >> 12,
   .TRP_SETUP = ($1 & 0x000F0000) >> 16,
   .TRCD_SETUP = ($1 & 0x00F00000) >> 20,
   .INIT_SETUP = ( $a = ($1 & 0x01000000),
                         ($a == 0x01000000 ) ? "Initialize" : "No effect"),
   .RFEN_SETUP = ( $a = ($1 & 0x02000000),
                         ($a == 0x02000000 ) ? "Enable" : "Disable"),
   .SDCSZ_SETUP = ( $a = ($1 & 0x0c000000),
                         ($a == 0x04000000 ) ? " 8 addresses" : 
                         ($a == 0x08000000 ) ? "10 addresses" : " 9 addresses"),                         
   .SDRSZ_SETUP = ( $a = ($1 & 0x30000000),
                         ($a == 0x10000000 ) ? "12 addresses" : 
                         ($a == 0x20000000 ) ? "13 addresses" : "11 addresses"),
   .SDBSZ_SETUP = ( $a = ($1 & 0x40000000),
                         ($a == 0x40000000 ) ? "Four banks" : "Two banks")                 
  )  
   inst SDCTL_VALUE :: .SDCTL_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "SDRAM Control Reg.(SDCTL) "
	prop Format :: "0x%08X"
	prop JSName :: "emifbSdctl"
	prop Visible :: 1
	prop Writable :: (CSL.EMIFB_SUPPORT) 
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (    
             $a =  $1 & 0x0c000000,
             if ( $a == 0x0c000000 ) {
              .error("Undefined Value for Column Size field SDCSZ")
              } else {
               $b = $1 & 0x30000000,
               if ( $b == 0x30000000) {
                 .error("Undefined Value for Row Size field SDRSZ")
              } else {
                  $c = $1 & 0x80000000,
                  if( $c == 0x80000000) {                 
                   .error("Bit field 31 is reserved")
                   }  else {
                        $d = $1 & 0x00000FFE,
                        if( $d != 0) {     
                          .error("Bit field(bit[1..11]) is reserved")
                         } else {
                        .SDCTL_VALUE = $1,
                        .SDCTL_SETUP_update($1),
 		            "ok"
                         }  
                      }
                   }
              }        
        )              
              
       }           
   
 prop SDTIM_VALUE_update :: (
    .PERIOD_SDTIM2() 
  | .XRFR_SDTIM()
  | 0x005dc000       
  )
  prop SDTIM_SETUP_update :: (
      .PERIOD_SETUP2 = ($1 & 0x00000FFF),
      .XRFR_SETUP = (($1 & 0x03000000) >> 24) + 1                        
  )
   inst SDTIM_VALUE :: .SDTIM_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "SDRAM Timing Reg.(SDTIM) "
	prop Format :: "0x%08X"
	prop JSName :: "emifbSdtim"
	prop Visible :: 1
	prop Writable :: (CSL.EMIFB_SUPPORT) 
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (    
                            $a =  $1 & 0x0000FFF,                       
             if ( $a == 0x00000000 ) {
              .error("1 cyc. < PERIOD < 4096 cyc. ")
              } else {
                       $b = $1 & 0xFC000000,
                        if( $b != 0) {     
                          .error("Bit field(bit[26..31]) is reserved")
                         } else { 
                        .SDTIM_VALUE = $1 | 0x005dc000,           
                        .SDTIM_SETUP_update($1 | 0x005dc000),
 		        "ok"
                    }
                }
        )              
              
       }           
 prop SDEXT_VALUE_update :: (
     .TCL_SDEXT()
  |  .TRAS_SDEXT()
  |  .TRRD_SDEXT()
  |  .TWR_SDEXT()
  |  .THZP_SDEXT()
  |  .RD2RD_SDEXT()
  |  .RD2DEAC_SDEXT()
  |  .RD2WR_SDEXT()
  |  .R2WDQM_SDEXT()
  |  .WR2WR_SDEXT()
  |  .WR2DEAC_SDEXT()
  |  .WR2RD_SDEXT()
  )
  prop SDEXT_SETUP_update :: (
   .TCL_SETUP =   ($1 & 0x00000001) + 2,
   .TRAS_SETUP = (($1 & 0x0000000E) >> 1 ) + 1 ,
   .TRRD_SETUP = (($1 & 0x00000010) >> 4 ) + 2 ,
   .TWR_SETUP =  (($1 & 0x00000060) >> 5 ) + 1 ,
   .THZP_SETUP = (($1 & 0x00000180) >> 7 ) + 1 ,
   .RD2RD_SETUP =  (($1 & 0x00000200) >> 9 ) + 1 ,
   .RD2DEAC_SETUP =(($1 & 0x00000c00) >> 10 ) + 1 ,
   .RD2WR_SETUP =  (($1 & 0x00007000) >> 12 ) + 1 ,
   .R2WDQM_SETUP = (($1 & 0x00018000) >> 15 ) + 1 ,
   .WR2WR_SETUP =  (($1 & 0x00020000) >> 17 ) + 1 ,
   .WR2DEAC_SETUP =(($1 & 0x000c0000) >> 18 ) + 1 ,
   .WR2RD_SETUP =  (($1 & 0x00100000) >> 20 ) + 1 
   )
   inst SDEXT_VALUE :: .SDEXT_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "SDRAM Extended Reg.(SDEXT) "
	prop Format :: "0x%08X"
	prop JSName :: "emifbSdext"
	prop Visible :: 1
	prop Writable :: (CSL.EMIFB_SUPPORT) 
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (    
	              $a = $1 & 0xFFE00000,
                if ( $a != 0) {
                    .error("Bit field(bit[21..31]) is reserved")
                 } else {
	                .SDEXT_VALUE = $1,
                        .SDEXT_SETUP_update($1),
 		        "ok"
                    }
                   )              
       }        
prop CESEC0_VALUE_update :: (                                      
     .SYNCRL0_CESEC0()
    |.SYNCWL0_CESEC0()
    |.CEEXT0_CESEC0()
    |.RENEN0_CESEC0()
    |.SNCCLK0_CESEC0()
  )
  prop CESEC0_SETUP_update :: (
      
       .SYNCRL0_SETUP = ( $a = ( $1 & 0x00000003),
                       ($a == 0x00000000) ? "0 cycle" :
                       ($a == 0x00000001) ? "1 cycle" :
                       ($a == 0x00000002) ? "2 cycles" : "3 cycles"),
       .SYNCWL0_SETUP = ( $a = ( $1 & 0x0000000C),
                       ($a == 0x00000000) ? "0 cycle" :
                       ($a == 0x00000004) ? "1 cycle" :
                       ($a == 0x00000008) ? "2 cycles" : "3 cycles"),
                               
       .CEEXT0_SETUP = ( $a = ( $1 & 0x00000010),
                      ($a == 0x00000000) ? "Inactive" : "Active"),
       .RENEN0_SETUP = ( $a = ( $1 & 0x00000020),
                      ($a == 0x00000000) ? "ADS Mode" : "Read Enable Mode"),
       .SNCCLK0_SETUP = ( $a = ( $1 & 0x00000040),
                       ($a == 0x00000000) ? "Sync. to ECLKOUT1" : "Sync. to ECLKOUT2")
)
    
       
inst CESEC0_VALUE :: .CESEC0_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE0 Space Secondary Control Reg. (CESEC0)"
	prop Format :: "0x%08X"
        prop JSName :: "emifbCesec0"     	    	
	prop Visible :: 1
	prop Writable :: (CSL.EMIFB_SUPPORT != 0) ? 1 : 0
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (    
                      $a = $1 & 0xFFFFFF80,
                      if ($a != 0) {
                     .error("Bit field(bit[7..31]) is reserved")
                      } else { 
                           .CESEC0_VALUE = $1,
                           .CESEC0_SETUP_update($1),
                           "ok"  
                  }            
          )
   }     
  
prop CESEC1_VALUE_update :: (                                      
     .SYNCRL1_CESEC1()
    |.SYNCWL1_CESEC1()
    |.CEEXT1_CESEC1()
    |.RENEN1_CESEC1()
    |.SNCCLK1_CESEC1()
  )
  prop CESEC1_SETUP_update :: (
      
       .SYNCRL1_SETUP = ( $a = ( $1 & 0x00000003),
                       ($a == 0x00000000) ? "0 cycle" :
                       ($a == 0x00000001) ? "1 cycle" :
                       ($a == 0x00000002) ? "2 cycles" : "3 cycles"),
       .SYNCWL1_SETUP = ( $a = ( $1 & 0x0000000C),
                       ($a == 0x00000000) ? "0 cycle" :
                       ($a == 0x00000004) ? "1 cycle" :
                       ($a == 0x00000008) ? "2 cycles" : "3 cycles"),
                               
       .CEEXT1_SETUP = ( $a = ( $1 & 0x00000010),
                      ($a == 0x00000000) ? "Inactive" : "Active"),
       .RENEN1_SETUP = ( $a = ( $1 & 0x00000020),
                      ($a == 0x00000000) ? "ADS Mode" : "Read Enable Mode"),
       .SNCCLK1_SETUP = ( $a = ( $1 & 0x00000040),
                       ($a == 0x00000000) ? "Sync. to ECLKOUT1" : "Sync. to ECLKOUT2")
)
    
    
                                                              
   inst CESEC1_VALUE :: .CESEC1_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE1 Space Secondary Control Reg. (CESEC1)"
	prop Format :: "0x%08X"
        prop JSName :: "emifbCesec1"     	    	
	prop Visible :: 1
	prop Writable :: (CSL.EMIFB_SUPPORT != 0) ? 1 : 0
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (    
                     $a = $1 & 0xFFFFFF80,
                      if ($a != 0) {
                     .error("Bit field(bit[7..31]) is reserved")
                      } else { 
                           .CESEC1_VALUE = $1,
                           .CESEC1_SETUP_update($1),
                           "ok"  
                  }            
          )
   }    
prop CESEC2_VALUE_update :: (                                      
     .SYNCRL2_CESEC2()
    |.SYNCWL2_CESEC2()
    |.CEEXT2_CESEC2()
    |.RENEN2_CESEC2()
    |.SNCCLK2_CESEC2()
  )
  prop CESEC2_SETUP_update :: (
      
       .SYNCRL2_SETUP = ( $a = ( $1 & 0x00000003),
                       ($a == 0x00000000) ? "0 cycle" :
                       ($a == 0x00000001) ? "1 cycle" :
                       ($a == 0x00000002) ? "2 cycles" : "3 cycles"),
       .SYNCWL2_SETUP = ( $a = ( $1 & 0x0000000C),
                       ($a == 0x00000000) ? "0 cycle" :
                       ($a == 0x00000004) ? "1 cycle" :
                       ($a == 0x00000008) ? "2 cycles" : "3 cycles"),
                               
       .CEEXT2_SETUP = ( $a = ( $1 & 0x00000010),
                      ($a == 0x00000000) ? "Inactive" : "Active"),
       .RENEN2_SETUP = ( $a = ( $1 & 0x00000020),
                      ($a == 0x00000000) ? "ADS Mode" : "Read Enable Mode"),
       .SNCCLK2_SETUP = ( $a = ( $1 & 0x00000040),
                       ($a == 0x00000000) ? "Sync. to ECLKOUT1" : "Sync. to ECLKOUT2")
)
    
    
                                                              
   inst CESEC2_VALUE :: .CESEC2_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE2 Space Secondary Control Reg. (CESEC2)"
	prop Format :: "0x%08X"
        prop JSName :: "emifbCesec2"     	    	
	prop Visible :: 1
	prop Writable :: (CSL.EMIFB_SUPPORT != 0) ? 1 : 0
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (    
                      $a = $1 & 0xFFFFFF80,
                      if ($a != 0) {
                     .error("Bit field(bit[7..31]) is reserved")
                      } else { 
                           .CESEC2_VALUE = $1,
                           .CESEC2_SETUP_update($1),
                           "ok"    
                       }          
          )
   }                                           
prop CESEC3_VALUE_update :: (                                      
     .SYNCRL3_CESEC3()
    |.SYNCWL3_CESEC3()
    |.CEEXT3_CESEC3()
    |.RENEN3_CESEC3()
    |.SNCCLK3_CESEC3()
  )
  prop CESEC3_SETUP_update :: (
      
       .SYNCRL3_SETUP = ( $a = ( $1 & 0x00000003),
                       ($a == 0x00000000) ? "0 cycle" :
                       ($a == 0x00000001) ? "1 cycle" :
                       ($a == 0x00000002) ? "2 cycles" : "3 cycles"),
       .SYNCWL3_SETUP = ( $a = ( $1 & 0x0000000C),
                       ($a == 0x00000000) ? "0 cycle" :
                       ($a == 0x00000004) ? "1 cycle" :
                       ($a == 0x00000008) ? "2 cycles" : "3 cycles"),
                               
       .CEEXT3_SETUP = ( $a = ( $1 & 0x00000010),
                      ($a == 0x00000000) ? "Inactive" : "Active"),
       .RENEN3_SETUP = ( $a = ( $1 & 0x00000020),
                      ($a == 0x00000000) ? "ADS Mode" : "Read Enable Mode"),
       .SNCCLK3_SETUP = ( $a = ( $1 & 0x00000040),
                       ($a == 0x00000000) ? "Sync. to ECLKOUT1" : "Sync. to ECLKOUT2")
)
    
    
 
                                     
   inst CESEC3_VALUE :: .CESEC3_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "CE3 Space Secondary Control Reg. (CESEC3)"
	prop Format :: "0x%08X"
        prop JSName :: "emifbCesec3"     	    	
	prop Visible :: 1
	prop Writable :: (CSL.EMIFB_SUPPORT != 0) ? 1 : 0
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: ( 
                    $a = $1 & 0xFFFFFF80,
                      if ($a != 0) {
                     .error("Bit field(bit[7..31]) is reserved")
                      } else {    
                           .CESEC3_VALUE = $1,
                           .CESEC3_SETUP_update($1),
                           "ok"   
                  }           
          )
   }                                           
                                       
                                      
     
}
type hEmifb {
   prop IsContainedIn :: EMIFBFOLDER
   prop name :: "hEmifb"     	    	
   prop Label :: "EMIF Resource Manager"
   prop JSName :: "HEMIFB"     	    	
   prop NoGen :: 1
   prop GlobalPropertyPage :: "{980E6534-6246-11d4-B5CC-0050DA2E2CC0}"
   prop InstancePropertyPage :: "{980E6535-6246-11d4-B5CC-0050DA2E2CC0}"
   prop GlobalIcon :: 163
   prop InstanceIcon :: 164
    prop GlobalHelpTopic :: (
	   1045
   )
     
   prop cGen :: 1
 
   global EMIFB_INIT_ENABLE :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Enable Pre-Initialization"
	  prop JSName :: "emifbEnablePreInit"
	  prop Visible :: 1
	  prop Writable :: (CSL.EMIFB_SUPPORT) 
	  prop NoGen :: 0
          prop Set :: (
          $a = 0,
            scan ($b ; emifbCfg) { $a = $a + 1},
                  if ( $1 == 1 && $a ==1 &&  .EMIFB_INIT == EMIFB_NOTHING ) 
                 {         
                 " You must create a new configuration object"
                 } else { 
                      .EMIFB_INIT_ENABLE = $1,
		      if ( $1 == 0) {
		      .EMIFB_INIT = EMIFB_NOTHING
		      },
			"ok"
                  }      
	  )      
    	}
	global EMIFB_INIT :: EMIFB_NOTHING {
	    prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	    prop MemberType :: emifbCfg
	    prop Label :: " Pre-Initialize with"
	    prop JSName :: "emifbPreInit"
	    prop Visible :: 1
	    prop Writable :: (CSL.EMIFB_SUPPORT) &&  (.EMIFB_INIT_ENABLE == 1) ? 1 :0 
    }
 
}
object EMIFB_NOTHING :: emifbCfg {
       param iIsUsed :: 0
}
type MCBSPFOLDER {
    isa ModuleFolder
   prop IsContainedIn :: CSL 
    prop name :: "MCBSP"
    prop Label :: "MCBSP - Multichannel Buffered Serial Port"
    prop NoGen :: 1
       	    	
    prop GlobalPropertyPage :: "{1E62DD14-59A8-11d4-947D-0050048381B7}"
    prop InstancePropertyPage :: "{1E62DD15-59A8-11d4-947D-0050048381B7}"
    prop GlobalIcon :: 159
    prop InstanceIcon :: 160
    prop GlobalHelpTopic :: (
      1050
    ) 
} 
type mcbspCfg {
	isa ObjectMgr
	prop Name :: "mcbspCfg"
	prop Label :: "MCBSP Configuration Manager"
	prop JSName :: "MCBSP"
	prop IsContainedIn :: MCBSPFOLDER
	prop NoGen :: 1
        prop GlobalPropertyPage :: "{1E62DD12-59A8-11d4-947D-0050048381B7}"
        prop InstancePropertyPage :: "{1E62DD13-59A8-11d4-947D-0050048381B7}"
        prop GlobalIcon :: 159
        prop InstanceIcon :: 160
       
        prop GlobalHelpTopic :: (
	   1051
        )
	
	
        prop InstanceHelpTopic :: (
	   1051
        )
	
        prop cGen :: 1
    	prop cStruct :: 1
    	prop cStructType :: "MCBSP_Config"
	prop cHeaderName :: .gNumOf > 0 ? "csl_mcbsp.h" : ""
	prop cStructQual :: "far"
   
        prop cStructName :: self
        
        prop localDelete :: (
         .myDelete
           )           
        prop myDelete :: (
         $a=0,
          scan($b; mcbspCfg) { 
               $a = $a + 1
           }, 		
	  if ($a == 2) {
	   scan($c;hMcbsp) {
                $c.MCBSP_INIT_ENABLE = 0
		  }
	        },
		"ok"
           )           
 
    
    inst DLB_SETUP :: "Disable" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Disable,Enable"
        prop Label :: "Digital Loopback Mode (DLB)"
	  prop JSName :: "mcbspSpcrDlb"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "Operating Mode"
	  prop Set :: (
		.DLB_SETUP = $1,
		.SPCR_VALUE = .SPCR_VALUE_update(),
		"ok"
	)
	 }
    prop DLB_SPCR :: (
        if (.DLB_SETUP == "Enable") {
            0x00008000
        }
	else {
            0x00000000
		}
    ) 
    
    inst CLKSTP_SETUP :: "Disable" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,NoDelay(SPI),Delay(SPI)"
        prop Label :: "Clock Stop Mode (CLKSTP)  "
	prop JSName :: "mcbspSpcrClkstp"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Operating Mode"
        prop Set :: (
		.CLKSTP_SETUP = $1,
		.SPCR_VALUE = .SPCR_VALUE_update(),
		"ok"
	)
    	}
    prop CLKSTP_SPCR :: (
        if (.CLKSTP_SETUP == "Disable") {
            0x00000000
        } else {
		if (.CLKSTP_SETUP == "NoDelay(SPI)") {
			0x00001000
		} else {
			if (.CLKSTP_SETUP == "Delay(SPI)") {
				0x00001800
			} 							
	   }
	}
    )
    
  inst FREE_SETUP :: "SOFT bit Control" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "SOFT bit Control,Free Running"
        prop Label :: "Serial Clock Free Running (FREE)"
	prop JSName :: "mcbspSpcrFree"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  (((CSL.C11_SUPPORT || CSL.C64_SUPPORT))? 1 : 0)
        prop NoGen :: 1
        prop TabName :: "Operating Mode"
	 prop Set :: (
		.FREE_SETUP = $1,
		.SPCR_VALUE = .SPCR_VALUE_update(),
		"ok"
	)
	 }
    prop FREE_SPCR :: (
        if (.FREE_SETUP == "Free Running") {
            0x02000000
        }
	else {
            0x00000000
		}
    ) 
    
  inst SOFT_SETUP :: "Transmission Aborted" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Transmission Aborted,Transmission Complete"
        prop Label :: "Serial Clock Emulation (SOFT)"
	prop JSName :: "mcbspSpcrSoft"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && ( ((CSL.C11_SUPPORT || CSL.C64_SUPPORT ))&& .FREE_SETUP == "SOFT bit Control") ? 1 : 0
        prop NoGen :: 1
        prop TabName :: "Operating Mode"
        prop Set :: (
		.SOFT_SETUP = $1,
		.SPCR_VALUE = .SPCR_VALUE_update(),
		"ok"
	)
	 }
    prop SOFT_SPCR :: (
        if (.SOFT_SETUP == "Transmission Complete") {
            0x01000000
        }
	else {
            0x00000000
		}
     )
    
    inst XINTM_SETUP :: "XRDY" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "XRDY,End of Subframe,New Frame,XSYNCERR"
        prop Label :: "Interrupt Mode (XINTM)"
	prop JSName :: "mcbspSpcrXintm"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Transmit Mode"
	  prop Set :: (
		.XINTM_SETUP = $1,
		.SPCR_VALUE = .SPCR_VALUE_update(),
		"ok"
	)
    	}
    prop XINTM_SPCR :: (
        if (.XINTM_SETUP == "XRDY") {
            0x00000000
        } else {
		if (.XINTM_SETUP == "End of Subframe") {
			0x00100000
		} else {
			if (.XINTM_SETUP == "New Frame") {
				0x00200000
			} else {
				if (.XINTM_SETUP == "XSYNCERR") {
					0x00300000
				}
			}
		}
	}
    ) 
    inst RINTM_SETUP :: "RRDY" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "RRDY,End of Subframe,New Frame,RSYNCERR"
        prop Label :: "Interrupt Mode (RINTM)"
	prop JSName :: "mcbspSpcrRintm"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Receiver Mode"
        	  prop Set :: (
		.RINTM_SETUP = $1,
		.SPCR_VALUE = .SPCR_VALUE_update(),
		"ok"
	)
    }
    prop RINTM_SPCR :: (
        if (.RINTM_SETUP == "RRDY") {
            0x00000000
        } else {
		if (.RINTM_SETUP == "End of Subframe") {
			0x00000010
		} else {
			if (.RINTM_SETUP == "New Frame") {
				0x00000020
			} else {
				if (.RINTM_SETUP == "RSYNCERR") {
					0x00000030
				}
			}
        	}	
	}
    )
     inst XCOMPAND_SETUP :: "No Companding/MSB" { 
       prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"  
       prop Enum :: "No Companding/MSB,No Companding/LSB,Companding/u-law,Companding/A-law" 
          prop Label :: "Companding Mode (XCOMPAND)"   
	  prop JSName :: "mcbspXcrXcompand"
           prop Visible :: 1  
           prop Writable :: (CSL.MCBSP_SUPPORT) &&  1  
           prop NoGen :: 1  
           prop TabName :: "Transmit Mode" 
           prop Set :: (
                      .XCOMPAND_SETUP = $1,
                      .XCR_VALUE = .XCR_VALUE_update(),
		      "ok"
           )        
	}         
     
    prop XCOMPAND_XCR :: (                                   
        if (.XCOMPAND_SETUP == "No Companding/MSB") {
            0x00000000
        } else {
              if (.XCOMPAND_SETUP == "No Compamding/LSB") {
              0x00080000
		} else {
			if (.XCOMPAND_SETUP == "Companding/u-law") {
				0x00100000
			} else {
				if (.XCOMPAND_SETUP == "Companding/A-law") {
					0x00180000
				}
			}
		}
	}
    ) 
     inst RCOMPAND_SETUP :: "No Companding/MSB" { 
       prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"  
       prop Enum :: "No Companding/MSB,No Companding/LSB,Companding/u-law,Companding/A-law" 
          prop Label :: "Companding Mode (RCOMPAND)"   
	  prop JSName :: "mcbspRcrRcompand"
           prop Visible :: 1  
           prop Writable :: (CSL.MCBSP_SUPPORT) &&  1  
           prop NoGen :: 1  
           prop TabName :: "Receiver Mode" 
           prop Set :: (                       
                      .RCOMPAND_SETUP = $1,
                      .RCR_VALUE = .RCR_VALUE_update(),
		      "ok"          
           )        
	    }         
     
    prop RCOMPAND_RCR :: (                                   
        if (.RCOMPAND_SETUP == "No Companding/MSB") {
            0x00000000
        } else {
              if (.RCOMPAND_SETUP == "No Compamding/LSB") {
              0x00080000
		} else {
			if (.RCOMPAND_SETUP == "Companding/u-law") {
				0x00100000
			} else {
				if (.RCOMPAND_SETUP == "Companding/A-law") {
					0x00180000
				}
			}
		}
	}
    )    
   
   
    inst XRST_SETUP :: "Disable/Reset" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
          prop Enum :: "Disable/Reset,Enable"
        prop Label :: "Enable/Disable: (XRST)"
        prop Visible :: 0
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  0
        prop NoGen :: 1
        prop TabName :: "Transmit Mode"
	  prop Set :: (
		.XRST_SETUP = $1,
		.SPCR_VALUE = .SPCR_VALUE_update(),
		"ok"
	)
    }
    prop XRST_SPCR :: (
        if (.XRST_SETUP == "Enable") {
            0x00010000
        }
		else {
		0x00000000
		}
    ) 
   
   inst XSYNCERR_SETUP :: "Clear" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
          prop Enum :: "Clear,Set"
        prop Label :: "Bit Sync. Error (XSYNCERR)"
	prop JSName :: "mcbspSpcrXsyncerr"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Transmit Mode"
	  prop Set :: (
		.XSYNCERR_SETUP = $1,
		.SPCR_VALUE = .SPCR_VALUE_update(),
		"ok"
	)
    }
    prop XSYNCERR_SPCR :: (
        if (.XSYNCERR_SETUP == "Set") {
            0x00080000
        }
		else {
		0x00000000
		}
    ) 
   
    inst CLKXM_SETUP :: "Input/Mcbsp-slave(SPI)" {                  
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Input/Mcbsp-slave(SPI),Output/Mcbsp-master(SPI)"
        prop Label :: "Clock Mode (CLKXM)  "
	prop JSName :: "mcbspPcrClkxm"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Transmit Mode"
        prop Set :: (
            .CLKXM_SETUP =  $1,
            .PCR_VALUE = .PCR_VALUE_update(),
            "ok"
           ) 
    	}
        
   
    prop CLKXM_PCR :: (
        if (.CLKXM_SETUP == "Input/Mcbsp-slave(SPI)") {
            0x00000000
        } else {
        if (.CLKXM_SETUP == "Output/Mcbsp-master(SPI)") {
	   0x00000200
		}
	}
    ) 
  inst CLKXP_SETUP :: "Rising Edge" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Rising Edge,Falling Edge"
        prop Label :: "Clock Polarity (CLKXP)"
	prop JSName :: "mcbspPcrClkxp"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Transmit Mode"
        prop Set :: (
            .CLKXP_SETUP =  $1,
            .PCR_VALUE = .PCR_VALUE_update(),
            "ok"
           ) 
    	}
    prop CLKXP_PCR :: (
        if (.CLKXP_SETUP == "Rising Edge") {
            0x00000000
        } else {
	   0x00000002
		}
    ) 
    inst FSXM_SETUP :: "External Source" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "External Source,Sample-rate Generator"
        prop Label :: "Frame Sync. Mode (FSXM) "
	prop JSName :: "mcbspPcrFsxm"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Transmit Mode"
        prop Set :: (
            .FSXM_SETUP =  $1,
            .PCR_VALUE = .PCR_VALUE_update(),
            "ok"
           ) 
    	}
    prop FSXM_PCR :: (
        if (.FSXM_SETUP == "External Source") {
            0x00000000
        } else {
		if (.FSXM_SETUP == "Sample-rate Generator") {
			0x00000800
		}
	}
    ) 
   inst FSXP_SETUP :: "Active High" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Active High,Active Low"
        prop Label :: "Frame Sync. Polarity (FSXP) "
	prop JSName :: "mcbspPcrFsxp"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Transmit Mode"
        prop Set :: (
            .FSXP_SETUP =  $1,
            .PCR_VALUE = .PCR_VALUE_update(),
            "ok"
           ) 
    	}
    prop FSXP_PCR :: (
        if (.FSXP_SETUP == "Active High") {
            0x00000000
        } else {
            0x00000008
	}
    ) 
    
    
    inst DXENA_SETUP ::= "Disable" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "DX Enabler (621x/671x/64x only)"
	prop JSName :: "mcbspSpcrDxena"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  (((CSL.C11_SUPPORT || CSL.C64_SUPPORT))? 1 : 0)
        prop NoGen :: 1
        prop TabName :: "Transmit Mode"
	  prop Set :: (
              .DXENA_SETUP = $1,
              .SPCR_VALUE = .SPCR_VALUE_update(),
              "ok"
       )
    	}
    prop DXENA_SPCR :: (
        if (.DXENA_SETUP == "Enable") {
            0x00000080
        } else {
		0x00000000
	}
    )
    
    inst XFIG_SETUP :: "Transfer restarted" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Transfer restarted,Pulse ignored"
        prop Label :: "Unexpected Frame Pulse(XFIG)  "
	prop JSName :: "mcbspXcrXfig"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Transmit Mode"
        prop Set :: (
            .XFIG_SETUP = $1,
            .XCR_VALUE = .XCR_VALUE_update(),
            "ok"
           ) 
    	}
        
    prop XFIG_XCR :: (
        if (.XFIG_SETUP == "Transfer restarted") {
            0x00000000
        } else {
            0x00040000
	}
    ) 
    inst XDATDLY_SETUP :: "0-bit" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0-bit,1-bit,2-bits"
        prop Label :: "Data Delay (XDATDLY)  "
	prop JSName :: "mcbspXcrXdatdly"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Transmit Mode"
        prop Set :: (
            .XDATDLY_SETUP = $1,
            .XCR_VALUE = .XCR_VALUE_update(),
            "ok"
           ) 
    	}
        
    prop XDATDLY_XCR :: (
        if (.XDATDLY_SETUP == "0-bit") {
            0x0000000
        } else {
            if (.XDATDLY_SETUP == "1-bit") {
            0x00010000
	    } else {
                if (.XDATDLY_SETUP == "2-bits") {
                0x00020000
                }
              }
         }       
    ) 
   
   inst XWDREVRS_SETUP ::= "Disable" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "32-bit reversal feature (XWDREVRS) (621x/671x/64x only)"
	prop JSName :: "mcbspXcrXwdrevrs"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  (((CSL.C11_SUPPORT || CSL.C64_SUPPORT))? 1 : 0)
        prop NoGen :: 1
        prop TabName :: "Transmit Mode"
        prop Set :: (
            .XWDREVRS_SETUP = $1,
            .XCR_VALUE = .XCR_VALUE_update(),
            "ok"
           ) 
    	}
    prop XWDREVRS_XCR :: (
        if (.XWDREVRS_SETUP == "Enable") {
            0x00000010
        } else {
		0x00000000
	}
    )
    inst XPHASE_SETUP :: "Single Phase" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Single Phase,Dual Phase"
        prop Label :: "Phase(s) (XPHASE)  "
	prop JSName :: "mcbspXcrXphase"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Transmit Frame\Elt"
	prop Set :: (
              .XPHASE_SETUP = $1,
              .XCR_VALUE = .XCR_VALUE_update(),
              "ok"
           )
    	}
        
    prop XPHASE_XCR :: (
        if (.XPHASE_SETUP == "Single Phase") {
            0x00000000
        } else {
            0x80000000
	}
    ) 
   
    inst XFRLEN1_SETUP :: 0x01 {
	prop Label :: "     Word(s) per phase(1) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "mcbspXcrXfrlen1"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Transmit Frame\Elt"
	prop Set :: (
	    if ($1 < 1  || $1 > 128 ) {
		.error(" Minimum word per frame :1 - Maximum words per Frame :128")
	    }
	    else {
              .XFRLEN1_SETUP = $1,
              .XCR_VALUE = .XCR_VALUE_update(),
		"ok"
	    }
	)
      }
     	
      prop XFRLEN1_XCR :: (
         (.XFRLEN1_SETUP-1) << 8 
      ) 
     
    inst XWDLEN1_SETUP :: "8-bits" {
	prop Label :: "     Element length XWDLEN(1) "
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "8-bits,12-bits,16-bits,20-bits,24-bits,32-bits"
	prop JSName :: "mcbspXcrXwdlen1"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Transmit Frame\Elt"
        prop Set :: (
             if ( ( $1 != "8-bits")  
                 && ( .XCOMPAND_SETUP != "No Companding/MSB")) {
                      .XWDLEN1_SETUP = $1,
                      .XCR_VALUE = .XCR_VALUE_update(),
                      "Note: 'No Companding/MSB' (XCOMPAND) is the only mode applicable (default)- See Operating Mode Tab " 
                     
              }
             else {
                      .XWDLEN1_SETUP = $1,
                     .XCR_VALUE = .XCR_VALUE_update(),
		      "ok"
             }
           )        
	 }
     	
      prop XWDLEN1_XCR :: (
         if ( .XWDLEN1_SETUP == "8-bits" ) { 0x00000000 }
         else { 
            if ( .XWDLEN1_SETUP == "12-bits" ) { 0x00000020 }
            else { 
               if ( .XWDLEN1_SETUP == "16-bits" ) { 0x00000040 }
               else { 
                 if ( .XWDLEN1_SETUP == "20-bits" ) { 0x00000060 }
                 else { 
                   if ( .XWDLEN1_SETUP == "24-bits" ) { 0x00000080 }
                   else { 
                     if ( .XWDLEN1_SETUP == "32-bits" ) { 0x000000A0 }
                    } 
                 } 
               }  
             }
           }     
    )
    inst XFRLEN2_SETUP :: 0x01 {
	prop Label :: "     Word(s) per phase(2) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "mcbspXcrXfrlen2"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  (((.XPHASE_SETUP == "Dual Phase" )) ? 1:0)
        prop NoGen :: 1
        prop TabName :: "Transmit Frame\Elt"
	prop Set :: (
	    if ($1 < 1  || $1 > 128 ) {
		.error(" Minimum word per frame :1 - Maximum words per Frame :128")
	    }
	    else {
              .XFRLEN2_SETUP = $1,
               .XCR_VALUE = .XCR_VALUE_update(),
		"ok"
	    }
	)
      }
     	
      prop XFRLEN2_XCR :: (
         (.XFRLEN2_SETUP-1) << 24
    ) 
    inst XWDLEN2_SETUP :: "8-bits" {
	prop Label :: "     Element length XWDLEN(2) "
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "8-bits,12-bits,16-bits,20-bits,24-bits,32-bits"
	prop JSName :: "mcbspXcrXwdLen2"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  (((.XPHASE_SETUP == "Dual Phase")) ? 1 :0)
        prop NoGen :: 1
        prop TabName :: "Transmit Frame\Elt"
        prop Set :: (
      if ( ( $1 != "8-bits")  && ( .XCOMPAND_SETUP != "No Companding/MSB")) {
                      .XWDLEN2_SETUP = $1,
                      .XCR_VALUE = .XCR_VALUE_update(),
         "Note: 'No Companding/MSB' (XCOMPAND) is the only mode applicable (default) " 
         } else {
                      .XWDLEN2_SETUP = $1,
                      .XCR_VALUE = .XCR_VALUE_update(),
                      "ok"
                 }     
                  ) 
	 }
	 
      prop XWDLEN2_XCR :: (
         if ( .XWDLEN2_SETUP == "8-bits" ) { 0x00000000 }
         else { 
            if ( .XWDLEN2_SETUP == "12-bits" ) { 0x00200000 }
            else { 
               if ( .XWDLEN2_SETUP == "16-bits" ) { 0x00400000 }
               else { 
                 if ( .XWDLEN2_SETUP == "20-bits" ) { 0x00600000 }
                 else { 
                   if ( .XWDLEN2_SETUP == "24-bits" ) { 0x00800000 }
                   else { 
                     if ( .XWDLEN2_SETUP == "32-bits" ) { 0x00A00000 }
                    } 
                 } 
               }  
             }
           }     
    ) 
    
	
	
    inst RRST_SETUP :: "Disable/Reset" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable/Reset,Enable"
        prop Label :: "Enable/Disable: (RRST)"
        prop Visible :: 0
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  0
        prop NoGen :: 1
        prop TabName :: "Receiver Mode"
	  prop Set :: (
		.RRST_SETUP = $1,
		.SPCR_VALUE = .SPCR_VALUE_update(),
		"ok"
	)
    }
    prop RRST_SPCR :: (
        if (.RRST_SETUP == "Enable") {
            0x00000001
        }
	else {
		0x00000000
	}
    ) 
    
   inst RSYNCERR_SETUP :: "Clear" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
          prop Enum :: "Clear,Set"
        prop Label :: "Bit Sync. Error (RSYNCERR)"
	prop JSName :: "mcbspSpcrRsyncerr"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Receiver Mode"
	  prop Set :: (
		.RSYNCERR_SETUP = $1,
		.SPCR_VALUE = .SPCR_VALUE_update(),
		"ok"
	)
    }
    prop RSYNCERR_SPCR :: (
        if (.RSYNCERR_SETUP == "Set") {
            0x00000008
        }
		else {
		0x00000000
		}
    ) 
  
  
  
    inst CLKRM_SETUP :: "Input/Hi.Z(DLB)" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Input/Hi.Z(DLB),Output/Output(DLB)"
        prop Label :: "Clock Mode (CLKRM)"
	prop JSName :: "mcbspPcrClkrm"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Receiver Mode"
        prop Set :: (
            .CLKRM_SETUP =  $1,
            .PCR_VALUE = .PCR_VALUE_update(),
            "ok"
           ) 
    	}
    prop CLKRM_PCR :: (
        if (.CLKRM_SETUP == "Input/Hi.Z(DLB)") {
            0x00000000
        } else {
        if (.CLKRM_SETUP == "Output/Output(DLB)") {
	   0x00000100
		}
	}
    )
    inst CLKRP_SETUP :: "Falling Edge" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Rising Edge,Falling Edge"
        prop Label :: "Clock Polarity (CLKRP)"
	prop JSName :: "mcbspPcrClkrp"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Receiver Mode"
        prop Set :: (
            .CLKRP_SETUP =  $1,
            .PCR_VALUE = .PCR_VALUE_update(),
            "ok"
           ) 
    	}
    prop CLKRP_PCR :: (
        if (.CLKRP_SETUP == "Falling Edge") {
            0x00000000
        } else {
	   0x00000001
		}
    )         
    
    inst FSRM_SETUP :: "External Source" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "External Source,Sample-rate Generator"
        prop Label :: "Frame Sync. Mode (FSRM)  "
	prop JSName :: "mcbspPcrFsrm"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Receiver Mode"
	prop Set :: (
		.FSRM_SETUP = $1,
		.PCR_VALUE = .PCR_VALUE_update(),
		"ok"
	)
    	}
   prop FSRM_PCR :: (
        if (.FSRM_SETUP == "External Source") {
            0x00000000
        } else {
		if (.FSRM_SETUP == "Sample-rate Generator") {
			0x00000400
		}
	}
    ) 
   inst FSRP_SETUP :: "Active High" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Active High,Active Low"
        prop Label :: "Frame Sync. Polarity (FSRP) "
	prop JSName :: "mcbspPcrFsrp"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Receiver Mode"
	prop Set :: (
		.FSRP_SETUP = $1,
		.PCR_VALUE = .PCR_VALUE_update(),
		"ok"
            )
    	}
        
    prop FSRP_PCR :: (
        if (.FSRP_SETUP == "Active High") {
            0x00000000
        } else {
            0x00000004
	}
    ) 
    
    inst RJUST_SETUP ::= "Right/zero-fill" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Right/zero-fill,Right/sign-ext.,Left/zero-fill"
        prop Label :: "Data Justification/sign-ext. (RJUST)"
	prop JSName :: "mcbspSpcrRjust"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Receiver Mode"
        prop Set :: (
		.RJUST_SETUP = $1,
		.SPCR_VALUE = .SPCR_VALUE_update(),
		"ok"
	)
    	}
    prop RJUST_SPCR :: (
        if (.RJUST_SETUP == "Right/sign-ext.") {
            0x00002000
        } else {
            if (.RJUST_SETUP == "Left/zero-fill") {
		0x00004000
            } else {
                0x00000000
            }    
	}
    )
    
    
    inst RFIG_SETUP :: "Transfer restarted" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Transfer restarted,Pulse ignored"
        prop Label :: "Unexpected Frame Pulse (RFIG)  "
	prop JSName :: "mcbspRcrRfig"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Receiver Mode"
        prop Set :: (
		.RFIG_SETUP = $1,
		.RCR_VALUE = .RCR_VALUE_update(),
		"ok"
 	)
    	}
        
    prop RFIG_RCR :: (
        if (.RFIG_SETUP == "Transfer restarted") {
            0x00000000
        } else {
            0x00040000
	}
    )
    inst RDATDLY_SETUP :: "0-bit" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0-bit,1-bit,2-bits"
        prop Label :: "Data Delay (RDATDLY)  "
	prop JSName :: "mcbspRcrRdatdly"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Receiver Mode"
        prop Set :: (
		.RDATDLY_SETUP = $1,
		.RCR_VALUE = .RCR_VALUE_update(),
		"ok"
 	)
    	}
        
    prop RDATDLY_RCR :: (
        if (.RDATDLY_SETUP == "0-bit") {
            0x0000000
        } else {
            if (.RDATDLY_SETUP == "1-bit") {
            0x00010000
	    } else {
                if (.RDATDLY_SETUP == "2-bits") {
                0x00020000
                }
              }
         }       
    ) 
   
   inst RWDREVRS_SETUP ::= "Disable" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "32-bit reversal feature (RWDREVRS)(621x/671x/64x only)"
	prop JSName :: "mcbspRcrRwdrevrs"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  (((CSL.C11_SUPPORT || CSL.C64_SUPPORT ))? 1 : 0)
        prop NoGen :: 1
        prop TabName :: "Receiver Mode"
        prop Set :: (
		.RWDREVRS_SETUP = $1,
		.RCR_VALUE = .RCR_VALUE_update(),
		"ok"
 	)
    	}
    prop RWDREVRS_RCR :: (
        if (.RWDREVRS_SETUP == "Enable") {
            0x00000010
        } else {
		0x00000000
	}
    ) 
    
   
    inst RPHASE_SETUP :: "Single Phase" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Single Phase,Dual Phase"
        prop Label :: "Phase(s) (RPHASE)  "
	prop JSName :: "mcbspRcrRphase"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Receiver Frame\Elt"
        prop Set :: (
		.RPHASE_SETUP = $1,
		.RCR_VALUE = .RCR_VALUE_update(),
		"ok"
 	)
    	}
        
    prop RPHASE_RCR :: (
        if (.RPHASE_SETUP == "Single Phase") {
            0x00000000
        } else {
            0x80000000
	}
    ) 
    inst RFRLEN1_SETUP :: 0x01 {
	prop Label :: "     Word(s) per phase(1) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "mcbspRcrRfrlen1"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Receiver Frame\Elt"
	prop Set :: (
	    if ($1 < 1  || $1 > 128 ) {
		.error(" Minimum word per frame :1 - Maximum words per Frame :128")
	    }
	    else {
              .RFRLEN1_SETUP = $1,
	       .RCR_VALUE = .RCR_VALUE_update(),
		"ok"
	    }
	)
      }
     	
      prop RFRLEN1_RCR :: (
         (.RFRLEN1_SETUP-1) << 8 
      ) 
    
     
    inst RWDLEN1_SETUP :: "8-bits" {
	prop Label :: "     Element length RWDLEN(1) "
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "8-bits,12-bits,16-bits,20-bits,24-bits,32-bits"
	prop JSName :: "mcbspRcrRwdlen1"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Receiver Frame\Elt"
        prop Set :: (
             if ( ( $1 != "8-bits")  
                 && ( .RCOMPAND_SETUP != "No Companding/MSB")) {
                    "Note: 'No Companding/MSB' (RCOMPAND) is only mode applicable (default) " 
                      .RWDLEN1_SETUP = $1,
          	      .RCR_VALUE = .RCR_VALUE_update(),
                      "ok"
              }
             else {
                      .RWDLEN1_SETUP = $1,
          	      .RCR_VALUE = .RCR_VALUE_update(),
		      "ok"
             }
           )        
	}
     	
      prop RWDLEN1_RCR :: (
         if ( .RWDLEN1_SETUP == "8-bits" ) { 0x00000000 }
         else { 
            if ( .RWDLEN1_SETUP == "12-bits" ) { 0x00000020 }
            else { 
               if ( .RWDLEN1_SETUP == "16-bits" ) { 0x00000040 }
               else { 
                 if ( .RWDLEN1_SETUP == "20-bits" ) { 0x00000060 }
                 else { 
                   if ( .RWDLEN1_SETUP == "24-bits" ) { 0x00000080 }
                   else { 
                     if ( .RWDLEN1_SETUP == "32-bits" ) { 0x000000A0 }
                    } 
                 } 
               }  
             }
           }     
    )
    inst RFRLEN2_SETUP :: 0x01 {
	prop Label :: "     Word(s) per phase(2) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "mcbspRcrRfrlen2"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  (((.RPHASE_SETUP == "Dual Phase" )) ? 1:0)
        prop NoGen :: 1
        prop TabName :: "Receiver Frame\Elt"
	prop Set :: (
	    if ($1 < 1  || $1 > 128 ) {
		.error(" Minimum word per frame :1 - Maximum words per Frame :128")
	    }
	    else {
              .RFRLEN2_SETUP = $1,
              .RCR_VALUE = .RCR_VALUE_update(),
		"ok"
	    }
	)
      }
     	
      prop RFRLEN2_RCR :: (
         (.RFRLEN2_SETUP-1) << 24
     )
     
    inst RWDLEN2_SETUP :: "8-bits" {
	prop Label :: "     Element length RWDLEN(2) "
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "8-bits,12-bits,16-bits,20-bits,24-bits,32-bits"
	prop JSName :: "mcbspRcrRwdlen2"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  ((.RPHASE_SETUP == "Dual Phase") ? 1 :0)
        prop NoGen :: 1
        prop TabName :: "Receiver Frame\Elt"
        prop Set :: (                        
      if ( ( $1 != "8-bits")  && ( .RCOMPAND_SETUP != "No Companding/MSB")) {
                      .RWDLEN2_SETUP = $1,
                      .RCR_VALUE = .RCR_VALUE_update(),
        "Note: 'No Companding/MSB' (RCOMPAND) is the only mode applicable (default)- Operating Mode Tab " 
         } else {    .RWDLEN2_SETUP = $1,
                      .RCR_VALUE = .RCR_VALUE_update(),
		      "ok"    
                 }          
           )        
      }
     	
      prop RWDLEN2_RCR :: (
         if ( .RWDLEN2_SETUP == "8-bits" ) { 0x00000000 }
         else { 
            if ( .RWDLEN2_SETUP == "12-bits" ) { 0x00200000 }
            else { 
               if ( .RWDLEN2_SETUP == "16-bits" ) { 0x00400000 }
               else { 
                 if ( .RWDLEN2_SETUP == "20-bits" ) { 0x00600000 }
                 else { 
                   if ( .RWDLEN2_SETUP == "24-bits" ) { 0x00800000 }
                   else { 
                     if ( .RWDLEN2_SETUP == "32-bits" ) { 0x00A00000 }
                    } 
                 } 
               }  
             }
           }     
    ) 
	
	
    inst GRST_SETUP :: "Reset" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
          prop Enum :: "Reset,Clock Generation"
        prop Label :: "Reset/Clock Generation (GRST)"
        prop Visible :: 0
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  0
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Generator"
	  prop Set :: (
		.GRST_SETUP = $1,
		.SPCR_VALUE = .SPCR_VALUE_update(),
		"ok"
	)
    }
    prop GRST_SPCR ::(
        if (.GRST_SETUP == "Clock Generation") {
            0x00400000
        }else {
		0x00000000
		}
    ) 
			
    inst FRST_SETUP :: "Reset" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
          prop Enum :: "Reset,Frame Sync."
        prop Label :: "Reset/Frame Sync. (FRST)"
        prop Visible :: 0
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  0
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Generator"
	prop Set :: (
		.FRST_SETUP = $1,
		.SPCR_VALUE = .SPCR_VALUE_update(),
		"ok"
	)
    }
   
    prop FRST_SPCR ::(
        if (.FRST_SETUP == "Frame Sync.") {
            0x00800000
        }  else {
		0x00000000
		}
    ) 
    
     inst CLKSM_SETUP :: "Internal Clock" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
          prop Enum :: "External Clock (CLKS),Internal Clock"
        prop Label :: "Sample-Rate Gen.Clock Mode (CLKSM) "
	prop JSName :: "mcbspSrgrClksm"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Generator"
	prop Set :: (
		.CLKSM_SETUP = $1,
		.SRGR_VALUE = .SRGR_VALUE_update(),
		"ok"
	)
    }
    prop CLKSM_SRGR :: (
        if (.CLKSM_SETUP == "Internal Clock") {
            0x20000000
        }
        else {
	    0x00000000
       }
    ) 
    
    inst GSYNC_SETUP :: "Free" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
          prop Enum :: "Free,External Frame Sync."
        prop Label :: "Sample-Rate Clock Sync. (GSYNC) "
	prop JSName :: "mcbspSrgrGsync"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  ((.CLKSM_SETUP == "External Clock (CLKS)") ? 1 : 0)
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Generator"
	prop Set :: (
		.GSYNC_SETUP = $1,
		.SRGR_VALUE = .SRGR_VALUE_update(),
		"ok"
	)
    }
    prop GSYNC_SRGR :: (
        if (.GSYNC_SETUP == "External Frame Sync.") {
            0x80000000
        }
        else {
	    0x00000000
       }
    )
    
     inst CLKSP_SETUP :: "Rising Edge" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
          prop Enum :: "Rising Edge,Falling Edge"
        prop Label :: "External Clock Polarity (CLKSP) "
	prop JSName :: "mcbspSrgrClksp"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  (((.CLKSM_SETUP == "External Clock (CLKS)")) ? 1 : 0)
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Generator"
	prop Set :: (
		.CLKSP_SETUP = $1,
		.SRGR_VALUE = .SRGR_VALUE_update(),
		"ok"
	)
    }
   prop CLKSP_SRGR :: (
        if (.CLKSP_SETUP == "Falling Edge") {
            0x40000000
        }
        else {
	    0x00000000
       }
    ) 
  inst FSGM_SETUP :: "DXR-to-XSR copy" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
          prop Enum :: "DXR-to-XSR copy,Frame Sync. Signal"
        prop Label :: "Transmit Frame Sync. Mode (FSGM) "
	prop JSName :: "mcbspSrgrFsgm"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  (((.FSXM_SETUP == "Sample-rate Generator" ))? 1 : 0)
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Generator"
	prop Set :: (
		.FSGM_SETUP = $1,
		.SRGR_VALUE = .SRGR_VALUE_update(),
		"ok"
	)
    }
    prop FSGM_SRGR :: (
        if (.FSGM_SETUP == "DXR-to-XSR copy") {
            0x00000000
        }
        else {
	    0x10000000
       }
    ) 
    
    inst FPER_SETUP :: 0x01 {
	prop Label :: "Frame Period (1-4096) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "mcbspSrgrFper"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  ((( .GSYNC_SETUP == "Free")) ? 1 : 0)
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Generator"
	prop Set :: (
	    if ($1 < 1  || $1 > 4096 ) {
		.error("Minimum Frame Period :1 - Maximum Frame Period :4096")
	    }
	    else {
              .FPER_SETUP = $1,
              .SRGR_VALUE = .SRGR_VALUE_update(),
		"ok"
	    }
	)
      }
     	
      prop FPER_SRGR :: (
         (.FPER_SETUP-1) << 16
    )
    
    inst FWID_SETUP :: 0x01 {
	prop Label :: "Frame Width (1-256) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "mcbspSrgrFwid"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Generator"
	prop Set :: (
	    if ($1 < 1  || $1 > 256 ) {
		.error("Minimum Frame Period :1 - Maximum Frame Period :256")
	    }
	    else {
              .FWID_SETUP = $1,
              .SRGR_VALUE = .SRGR_VALUE_update(),
		"ok"
	    }
	)
      }
     	
      prop FWID_SRGR :: (
         (.FWID_SETUP-1) << 8
    ) 
    
    inst CLKGDV_SETUP :: 0x02 {
	prop Label :: "Clock freq.Divider (1-256) "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "mcbspSrgrClkgdv"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Generator"
	prop Set :: (
	    if ($1 < 1  || $1 > 256 ) {
		.error("Minimum divide-down number :1 - Maximum divide-down number :256")
	    }
	    else {
              .CLKGDV_SETUP = $1,
              .SRGR_VALUE = .SRGR_VALUE_update(),
		"ok"
	    }
	)
      }
     	
      prop CLKGDV_SRGR :: (
         (.CLKGDV_SETUP - 1)
    ) 
	
	
 
    inst XMCM_SETUP :: "Enable/No-Masking" {
	prop Label :: "Transmit Multichannel (XMCM)"
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "Enable/No-Masking,Enable/Masking,Disable/XP(A/B)BLK-XCEREx,Disable/RP(A/B)BLK-RCEREx"
	prop JSName :: "mcbspMcrXmcm"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1 
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
        prop Set :: (
             .XMCM_SETUP = $1,
             .MCR_VALUE = .MCR_VALUE_update(),
             "ok"
        )
      }
	 
     	
      prop XMCM_MCR :: (
         if ( .XMCM_SETUP == "Enable/No-Masking" ) { 0x00000000 }
         else { 
            if ( .XMCM_SETUP == "Disable/XP(A/B)BLK-XCEREx" ) { 0x00010000 }
            else { 
               if ( .XMCM_SETUP == "Enable/Masking" ) { 0x00020000 }
               else { 
                       0x00030000 
                   }
               }  
           }     
    ) 
  inst RX_MCME_SETUP :: "Normal Operation" {                                         
	prop Label :: "Enhanced Multichannel Enable (XMCME-RMCME)"
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "Normal Operation,Enhanced Operation"
      prop Visible :: 1
      prop Writable :: (((CSL.C64_SUPPORT))? 1 : 0) 
      prop JSName :: "mcbspMcrXmcmeRmcme"
      prop NoGen :: 1
      prop TabName :: "Multichannel Operation"
      prop Set :: (
             .RX_MCME_SETUP = $1,
             .MCR_VALUE = .MCR_VALUE_update(),
             "ok"
        )
      }
	 
      prop RX_MCME_MCR :: (
         if ( .RX_MCME_SETUP == "Normal Operation" ) { 0x00000000 }
         else { 
            if ( .RX_MCME_SETUP == "Enhanced Operation" ) { 0x02000200 }
                       }    
    )                                                                            
    inst XPABLK_SETUP :: "  0-to-15" {
	prop Label :: "   Subframe Element part.A (XPABLK) "
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "  0-to-15, 32-to-47, 64-to-79, 96-to-111"
	prop JSName :: "mcbspMcrXpablk"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
       prop Set :: (
             .XPABLK_SETUP = $1,
             .MCR_VALUE = .MCR_VALUE_update(),
             "ok"
        )
       }       
     	
      prop XPABLK_MCR :: (
         if ( .XPABLK_SETUP == "  0-to-15" ) { 0x00000000 }
         else { 
             if ( .XPABLK_SETUP == " 32-to-47" ) { 0x00200000 }
                else { 
                   if ( .XPABLK_SETUP == " 64-to-79" ) { 0x00400000 }
                    else { 
                        0x00600000 
                        }
                                            
                 }  
          }
      ) 
    inst XPBBLK_SETUP :: " 16-to-31" {
	prop Label :: "   Subframe Element part.B (XPBBLK)  "
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: " 16-to-31, 48-to-63, 80-to-95, 112-to-127"
	prop JSName :: "mcbspMcrXpbblk"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
        prop Set :: (
             .XPBBLK_SETUP = $1,
             .MCR_VALUE = .MCR_VALUE_update(),
             "ok"
        )
       }       
     	
      prop XPBBLK_MCR :: (
           if ( .XPBBLK_SETUP == " 16-to-31" ) { 0x00000000 }
            else { 
               if ( .XPBBLK_SETUP == " 48-to-63" ) { 0x00800000 }
               else { 
                 if ( .XPBBLK_SETUP == " 80-to-95" ) { 0x01000000 }
                 else { 
                        0x01800000      
                       } 
                }
            }  
        ) 
        
    inst XCEA_SETUP :: 0x0000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04X"
        prop Style :: 0x02 
        prop Label :: "   Enable Channel Part.A (XCEAn)"
	prop JSName :: "mcbspXcerXcea"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  !CSL.C64_SUPPORT 
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
	prop Set :: (
	    if ($1 < 0x0000  || $1 > 0xffff ) {
		.error("Min=All Disable :0x0000 - Max=All Enable  : 0xFFFF")
	    }
	    else {
              .XCEA_SETUP = $1,
             .XCER_VALUE = .XCER_VALUE_update(),
      		"ok"
	    }
	)
        
    }
  prop XCEA_XCER :: (
         ( .XCEA_SETUP)
  )
    inst XCEB_SETUP :: 0x0000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04X"
        prop Style :: 0x02 
        prop Label :: "   Enable Channel Part.B (XCEBn)"
	prop JSName :: "mcbspXcerXceb"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && !CSL.C64_SUPPORT  
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
	prop Set :: (
	    if ($1 < 0x0000  || $1 > 0xffff ) {
		.error("Min=All Disable :0x0000 - Max=All Enable  : 0xFFFF")
	    }
	    else {
              .XCEB_SETUP = $1,
               .XCER_VALUE = .XCER_VALUE_update(),
		"ok"
	    }
	)
        
    }
 
prop XCEB_XCER :: (
         ( .XCEB_SETUP << 16 )
  )
 
    inst XCE0_SETUP :: 0x00000000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Style :: 0x02 
        prop Label :: "   Enhanced Transmit Chan. Enable (XCERE0)"
	prop JSName :: "mcbspXcere0Xce"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && CSL.C64_SUPPORT  
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
	prop Set :: (
              .XCE0_SETUP = $1,
               .XCERE0_VALUE = .XCERE0_VALUE_update(),
		"ok"
	)
        
    }
 
prop XCE0_XCERE0 :: (
         ( .XCE0_SETUP  )
  )
    inst XCE1_SETUP :: 0x00000000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Style :: 0x02 
        prop Label :: "   Enhanced Transmit Chan. Enable (XCERE1)"
	prop JSName :: "mcbspXcere1Xce"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && CSL.C64_SUPPORT  
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
	prop Set :: (
              .XCE1_SETUP = $1,
               .XCERE1_VALUE = .XCERE1_VALUE_update(),
		"ok"
	)
        
    }
 
prop XCE1_XCERE1 :: (
         ( .XCE1_SETUP  )
  )
    inst XCE2_SETUP :: 0x00000000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Style :: 0x02 
        prop Label :: "   Enhanced Transmit Chan. Enable (XCERE2)"
	prop JSName :: "mcbspXcere2Xce"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && CSL.C64_SUPPORT  
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
	prop Set :: (
              .XCE2_SETUP = $1,
               .XCERE2_VALUE = .XCERE2_VALUE_update(),
		"ok"
	)
        
    }
 
prop XCE2_XCERE2 :: (
         ( .XCE2_SETUP  )
  )
    inst XCE3_SETUP :: 0x00000000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X"
        prop Style :: 0x02 
        prop Label :: "   Enhanced Transmit Chan. Enable (XCERE3)"
	prop JSName :: "mcbspXcere3Xce"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) && CSL.C64_SUPPORT  
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
	prop Set :: (
              .XCE3_SETUP = $1,
               .XCERE3_VALUE = .XCERE3_VALUE_update(),
		"ok"
	)
        
    }
 
prop XCE3_XCERE3 :: (
         ( .XCE3_SETUP  )
  )
    inst RMCM_SETUP :: "All Enable" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
          prop Enum :: "All Enable,Disable/RP(A/B)BLK-RCEREx"
        prop Label :: "Receive Multichannel (RMCM)"
	prop JSName :: "mcbspMcrRmcm"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
	  prop Set :: (
             .RMCM_SETUP = $1,
             .MCR_VALUE = .MCR_VALUE_update(),
             "ok"
         )
    }
    prop RMCM_MCR :: (
        if (.RMCM_SETUP == "All Enable") {
            0x00000000
        }
		else {
			0x00000001
		}
    ) 
 
    inst RPABLK_SETUP :: "  0-to-15" {
	prop Label :: "   Subframe Element part.A (RPABLK) "
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "  0-to-15, 32-to-47, 64-to-79, 96-to-111"
	prop JSName :: "mcbspMcrRpablk"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
        prop Set :: (
             .RPABLK_SETUP = $1,
             .MCR_VALUE = .MCR_VALUE_update(),
             "ok"
         )
       }       
     	
      prop RPABLK_MCR :: (
         if ( .RPABLK_SETUP == "  0-to-15" ) { 0x00000000 }
         else { 
             if ( .RPABLK_SETUP == " 32-to-47" ) { 0x00000020 }
                else { 
                   if ( .RPABLK_SETUP == " 64-to-79" ) { 0x00000040 }
                    else { 
                        0x00000060 
                        }
                                            
                 }  
          }
      )
    inst RPBBLK_SETUP :: " 16-to-31" {
	prop Label :: "   Subframe Element part.B (RPBBLK) "
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: " 16-to-31, 48-to-63, 80-to-95, 112-to-127"
	prop JSName :: "mcbspMcrRpbblk"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
       prop Set :: (
             .RPBBLK_SETUP = $1,
             .MCR_VALUE = .MCR_VALUE_update(),
             "ok"
         )
      }
        
    prop RPBBLK_MCR :: (
           if ( .RPBBLK_SETUP == " 16-to-31" ) {  0x00000000  }
            else { 
               if ( .RPBBLK_SETUP  == " 48-to-63" ) {  0x00000080   }
               else { 
                 if ( .RPBBLK_SETUP  == " 80-to-95" ) {  0x00000100  }
                 else { 
                        0x00000180       
                       } 
                }
            }  
    ) 
   
   
    inst RCEA_SETUP :: 0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04X"
        prop Label :: "   Enable Channel Part.A (RCEAn)"
	prop JSName :: "mcbspRcerRcea"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT && !CSL.C64_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
	prop Set :: (
	    if ($1 < 0x0000  || $1 > 0xffff ) {
		.error("Min=All Disable :0x0000 - Max=All Enable  : 0xFFFF")
	    }
	    else {
              .RCEA_SETUP = $1,
              .RCER_VALUE = .RCER_VALUE_update(),
		"ok"
	    }
	)
        
    }
 prop RCEA_RCER :: (
         ( .RCEA_SETUP)
  )
    inst RCEB_SETUP :: 0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "   Enable Channel Part.B (RCEBn)"
        prop Format :: "0x%04X"
	prop JSName :: "mcbspRcerRceb"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT && !CSL.C64_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
	prop Set :: (
	    if ($1 < 0x0000  || $1 > 0xffff ) {
		.error("Min=All Disable :0x0000 - Max=All Enable  : 0xFFFF")
	    }
	    else {
              .RCEB_SETUP = $1,
              .RCER_VALUE = .RCER_VALUE_update(),
   		"ok"
	    }
	)
        
    }  
 prop RCEB_RCER :: (
         ( .RCEB_SETUP  << 16 )
  )
   inst RCE0_SETUP :: 0x00000000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "   Enhanced Receive Chan. Enable (RCERE0)"
        prop Format :: "0x%08X"
	prop JSName :: "mcbspRcere0Rce"
        prop Visible :: 1
        prop Writable :: CSL.MCBSP_SUPPORT && (CSL.C64_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
	prop Set :: (
              .RCE0_SETUP = $1,
              .RCERE0_VALUE = .RCERE0_VALUE_update(),
   		"ok"
	)
        
    }  
 prop RCE0_RCERE0 :: (
         ( .RCE0_SETUP )
  )
    inst RCE1_SETUP :: 0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "   Enhanced Receive Chan. Enable (RCERE1)"
        prop Format :: "0x%08X"
	prop JSName :: "mcbspRcere1Rce"
        prop Visible :: 1
        prop Writable :: CSL.MCBSP_SUPPORT && (CSL.C64_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
	prop Set :: (
              .RCE1_SETUP = $1,
              .RCERE1_VALUE = .RCERE1_VALUE_update(),
   		"ok"
	)
        
    }  
 prop RCE1_RCERE1 :: (
         ( .RCE1_SETUP )
  )
    inst RCE2_SETUP :: 0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "   Enhanced Receive Chan. Enable (RCERE2)"
        prop Format :: "0x%08X"
	prop JSName :: "mcbspRcere2Rce"
        prop Visible :: 1
        prop Writable :: CSL.MCBSP_SUPPORT && (CSL.C64_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
	prop Set :: (
              .RCE2_SETUP = $1,
              .RCERE2_VALUE = .RCERE2_VALUE_update(),
   		"ok"
	)
        
    }  
 prop RCE2_RCERE2 :: (
         ( .RCE2_SETUP )
  )
    inst RCE3_SETUP :: 0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "   Enhanced Receive Chan. Enable (RCERE3)"
        prop Format :: "0x%08X"
	prop JSName :: "mcbspRcere3Rce"
        prop Visible :: 1
        prop Writable :: CSL.MCBSP_SUPPORT && (CSL.C64_SUPPORT) 
        prop NoGen :: 1
        prop TabName :: "Multichannel Operation"
	prop Set :: (
              .RCE3_SETUP = $1,
              .RCERE3_VALUE = .RCERE3_VALUE_update(),
   		"ok"
	)
        
    }  
 prop RCE3_RCERE3 :: (
         ( .RCE3_SETUP )
  )
    
    
 
 inst XIOEN_SETUP :: "Disable" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Disable,Enable"
        prop Label :: "GP I/O Enable (XIOEN)"
	prop JSName :: "mcbspPcrXioen"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  ((.XRST_SETUP == "Disable/Reset") ? 1 : 0)
        prop NoGen :: 1
        prop TabName :: "General-Purpose IO"
        prop Set :: (
            .XIOEN_SETUP = $1,
            .PCR_VALUE = .PCR_VALUE_update(),
            "ok"
           ) 
    	}
        
    prop XIOEN_PCR :: (
        if (.XIOEN_SETUP == "Enable") {
            0x00002000
        }
        else {
	    0x00000000
            }
    )
     
    inst CLKXP_output :: 0x00 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "   CLKX Output value"
	prop JSName :: "mcbspClkxOutput"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  ((( .XIOEN_SETUP == "Enable") && (.CLKXM_SETUP == "Output/Mcbsp-master(SPI)")) ? 1 : 0 )
        prop NoGen :: 1
        prop TabName :: "General-Purpose IO"
	prop Set :: (
	    if ($1 < 0  || $1 > 1 ) {
		.error("Binary value only: 0 or 1")
	    }
	    else {
              .CLKXP_output = $1,
              .PCR_VALUE = .PCR_VALUE_update(),
         	"ok"
    	      }
 	)
       }
    prop CLKXP_IO :: (
           (.CLKXP_output << 1)  
        ) 
inst FSXP_output :: 0x00 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "   FSX Output value"
	prop JSName :: "mcbspFsxOutput"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  ((( .XIOEN_SETUP == "Enable") && (.FSXM_SETUP == "Sample-rate Generator")) ? 1 : 0 )
        prop NoGen :: 1
        prop TabName :: "General-Purpose IO"
	prop Set :: (
	    if ($1 < 0  || $1 > 1 ) {
		.error("Binary value only: 0 or 1")
	    }
	    else {
              .FSXP_output = $1,
               .PCR_VALUE = .PCR_VALUE_update(),
		"ok"
	    }
	)
         }
     prop FSXP_IO :: (
           (.FSXP_output << 3)  
        ) 
 
 inst DX_output :: 0x00 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "   DX Output (DX_STAT)"
	prop JSName :: "mcbspPcrDxstat"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  (( .XIOEN_SETUP == "Enable")  ? 1 : 0 )
        prop NoGen :: 1
        prop TabName :: "General-Purpose IO"
	prop Set :: (
	    if ($1 < 0  || $1 > 1 ) {
		.error("Binary value only: 0 or 1")
	    }
	    else {
              .DX_output = $1,
              .PCR_VALUE =.PCR_VALUE_update(),
		"ok"
	    }
         )
       }
 prop DX_IO :: (
           (.DX_output << 5)  
        )
        
 inst RIOEN_SETUP :: "Disable" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "GP I/O Enable (RIOEN)"
	prop JSName :: "mcbspPcrRioen"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  ((.RRST_SETUP == "Disable/Reset") ? 1 : 0)
        prop NoGen :: 1
        prop TabName :: "General-Purpose IO"
        prop Set :: (
            .RIOEN_SETUP = $1,
            .PCR_VALUE = .PCR_VALUE_update(),
            "ok"
           ) 
    }
    prop RIOEN_PCR :: (
        if (.RIOEN_SETUP == "Enable") {
            0x00001000
        }
	else {
		0x00000000
	}
    ) 
 inst CLKRP_output :: 0x00 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "   CLKR Output value"
	prop JSName :: "mcbspClkrOutput"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  ((( .RIOEN_SETUP == "Enable") && (.CLKRM_SETUP == "Output/Output(DLB)")) ? 1 : 0 )
        prop NoGen :: 1
        prop TabName :: "General-Purpose IO"
	prop Set :: (
	    if ($1 < 0  || $1 > 1 ) {
		.error("Binary value only: 0 or 1")
	    }
	    else {
              .CLKRP_output = $1,
               .PCR_VALUE = .PCR_VALUE_update(),
		"ok"
    	      }
 	)
       }
   prop CLKRP_IO :: (
           (.CLKRP_output)  
        ) 
 inst FSRP_output :: 0x00 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "   FSR Output value"
	prop JSName :: "mcbspFsrOutput"
        prop Visible :: 1
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  (((.RIOEN_SETUP == "Enable") && (.FSRM_SETUP == "Sample-rate Generator")) ? 1 : 0) 
        prop NoGen :: 1
        prop TabName :: "General-Purpose IO"
	prop Set :: (
	    if ($1 < 0  || $1 > 1 ) {
		.error("Binary value only: 0 or 1")
	    }
	    else {
              .FSRP_output = $1,
              .PCR_VALUE = .PCR_VALUE_update(),
  		"ok"
	    }
	)
         }
    prop FSRP_IO :: (
           (.FSRP_output << 2)  
        ) 
 
 
    
    
         
 
 prop SPCR_VALUE_update :: (
    
   
     0x033EFFFE & (
     ((CSL.C11_SUPPORT || CSL.C64_SUPPORT)? .FREE_SPCR(): 0)
   | ((CSL.C11_SUPPORT|| CSL.C64_SUPPORT)? .SOFT_SPCR(): 0)
   | .XINTM_SPCR()
   | .XSYNCERR_SPCR()
   
   | .DLB_SPCR()
   | .RJUST_SPCR()
   | .CLKSTP_SPCR()
   | ((CSL.C11_SUPPORT || CSL.C64_SUPPORT)? .DXENA_SPCR(): 0)
   | .RINTM_SPCR()
   | .RSYNCERR_SPCR() 
   )
   
)
 prop SPCR_SETUP_update :: (
if ((CSL.C11_SUPPORT || CSL.C64_SUPPORT)){
   .FREE_SETUP = (  $1 & 0x02000000) ? "Free Running" : "SOFT bit Control" ,
   .SOFT_SETUP = (  $1 & 0x01000000) ? "Transmission Complete" : "Transmission Aborted"   },
  .XINTM_SETUP = ( $a = ( $1 & 0x00300000) ,
              	  ( $a == 0x00100000) ? "End of Subframe" :
		  ( $a == 0x00200000) ? "New Frame":
		  ( $a == 0x00300000) ? "XSYNCERR" : "XRDY" ),
 .XSYNCERR_SETUP  = ( $1 & 0x00080000) ? "Set" : "Clear",
 .DLB_SETUP   = ( $1 & 0x00008000) ? "Enable" : "Disable",
 .RJUST_SETUP = ( $a =( $1 & 0x00003000),
                 ( $a == 0x00002000) ? "Right/sign-ext.": 
                 ( $a == 0x00004000) ? "Left/zero-fill": "Right/zero-fill"),
 .CLKSTP_SETUP = ( $a = ($1 & 0x00001800),   
                  ( $a == 0x00001000) ? "NoDelay(SPI)":
                  ( $a == 0x00001800) ?  "Delay(SPI)": "Disable"),
if ((CSL.C11_SUPPORT) ||CSL.C64_SUPPORT)
    {
 .DXENA_SETUP = ( $1 & 0x00000080) ? "Enable" : "Disable"
    },
 .RINTM_SETUP = ( $a = ( $1 & 0x00000030) ,
              	 ( $a == 0x00000010) ? "End of Subframe" :
		 ( $a == 0x00000020) ? "New Frame":
		 ( $a == 0x00000030) ? "RSYNCERR" : "RRDY" ),
 .RSYNCERR_SETUP  = ( $1 & 0x00000008) ? "Set" : "Clear"
 )
inst SPCR_VALUE :: .SPCR_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Serial Port Control Reg. (SPCR) "
	prop Format :: "0x%08X"
	prop JSName :: "mcbspSpcr"
	prop Visible :: 1
	prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (
           if ((CSL.C11_SUPPORT || CSL.C64_SUPPORT))  
               {
               $e = $1 & 0x00006000,
               if ($e == 0x00006000) {
                   .error("Invalid input for RJUST bit[13..14]")
               } else {
               $a = $1 & 0x00000700,
               if ($a != 0) {
                   .error("Bit field(bit[8..10]) is reserved")
               } else {
                 $b = $1 & 0x00000040,   
                 if($b != 0) {
                   .error("Bit field 6 is reserved")  
                 } else {   
                            .SPCR_VALUE = $1 & 0x033EFFFE,
                            .SPCR_SETUP_update($1 & 0x033EFFFE),
                             "ok"
                          
                         }
                       }
                     }
              } else { 
               $f = $1 & 0x00006000,
               if ($f == 0x00006000) {
                   .error("Invalid input for RJUST bit[13..14]")
               } else {
                $c = $1 & 0x00000700,
                 if ($c != 0) {
                   .error("Bit field(bit[8..10]) is reserved")
                  } else {
                    $d = $1 & 0x00000040,   
                    if ($d != 0) {
                    .error("Bit field 6 is reserved")  
                    } else {   
                      .SPCR_VALUE = $1 & 0x003EFFFE,
                      .SPCR_SETUP_update($1 & 0x003EFFFE),
                      "ok"
                      }
                    }
                  }   
             }            
      
      )
   }
  
        
   
   prop RCR_VALUE_update :: (
          .RPHASE_RCR()  
        | .RFRLEN2_RCR()  
        | .RWDLEN2_RCR() 
        | .RCOMPAND_RCR() 
        | .RFIG_RCR() 
        | .RDATDLY_RCR() 
       
        | .RFRLEN1_RCR()  
        | .RWDLEN1_RCR()  
        | (((CSL.C11_SUPPORT || CSL.C64_SUPPORT))? .RWDREVRS_RCR() : 0)
      )  
                           
             
   prop RCR_SETUP_update ::  (
         .RPHASE_SETUP = ( $1  & 0x80000000) ? "Dual Phase" : "Single Phase",  
         .RFRLEN2_SETUP =(( ( $1 & 0x7f000000 ) >> 24) + 1),
         .RWDLEN2_SETUP = ( $a = ($1 & 0x00e00000 ) , 
                              ( $a == 0x00200000 ) ? "12-bits":
                              ( $a == 0x00400000 ) ? "16-bits":
                              ( $a == 0x00600000 ) ? "20-bits":
                              ( $a == 0x00800000 ) ? "24-bits":
                              ( $a == 0x00A00000 ) ? "32-bits": "8-bits"),    
         .RCOMPAND_SETUP = ( $a = ($1 & 0x00180000),
                              ( $a == 0x00080000 ) ? "No Companding/LSB":
                              ( $a == 0x00100000 ) ? "Companding/u-law":
                              ( $a == 0x00180000 ) ? "Companding/A-law": "No Companding/MSB"),
        .RFIG_SETUP    =  ( $1 & 0x00040000) ? "Pulse ignored" : "Transfer restarted",
        .RDATDLY_SETUP = ( $a = ($1 & 0x00030000),
                              ( $a == 0x00010000 ) ? "1-bit":
                              ( $a == 0x00020000 ) ? "2-bits": "0-bit"),                          
         .RFRLEN1_SETUP = ((( $1 & 0x00007f00 ) >> 8) + 1),
         .RWDLEN1_SETUP = ( $a = ($1 & 0x000000e0 ),
                              ( $a == 0x00000020 ) ? "12-bits":
                              ( $a == 0x00000040 ) ? "16-bits":
                              ( $a == 0x00000060 ) ? "20-bits":
                              ( $a == 0x00000080 ) ? "24-bits":
                              ( $a == 0x000000A0 ) ? "32-bits": "8-bits"),          
         if ((CSL.C11_SUPPORT || CSL.C64_SUPPORT )){    
            .RWDREVRS_SETUP = ( $1 & 0x00000010) ? "Enable" : "Disable"
        }
       ) 
   
    inst RCR_VALUE :: .RCR_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Receiver Control Reg. (RCR) "
	prop Format :: "0x%08X"
	prop JSName :: "mcbspRcr"
	prop Visible :: 1
	prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (
         if(CSL.C11_SUPPORT || CSL.C64_SUPPORT){
        $a = $1 & 0x00008000,
        $b = $1 & 0x0000000F,
	  $e = $1 & 0x00030000,
        $g = $1 & 0x00C00000,
        $h = $1 & 0x000000C0,
  if ($g == 0x00C00000) {
     .error("Invalid input for RWDLEN2 bit[21..23]")
   } else {
     if ($h == 0x000000C0) {
        .error("Invalid input for RWDLEN1 bit[5..7]")
     } else {   
      if ($e == 0x00030000) {
           .error("Invalid input for RDATDLY bit[16..17]")
        } else { 
        if ($a != 0) {
               .error("Bit field 15 is reserved")
        } else {
	     if ($b != 0) {
               .error("Bit field(bit[0..3]) is reserved")
	     } else {
                .RCR_VALUE = $1,
               .RCR_SETUP_update($1),
 		   "ok"
                   }
                 }
                }
		  }
	     }
         } else {
            $c = $1 & 0x00008000,
            $d = $1 & 0x0000001F,
            $f = $1 & 0x00030000,
            $i = $1 & 0x00C00000,
            $j = $1 & 0x000000C0,
   if ($i == 0x00C00000) {
    .error("Invalid input for RWDLEN2 bit[21..23]")
    } else {
     if ($j == 0x000000C0) {
      .error("Invalid input for RWDLEN1 bit[5..7]")
      } else {   
        if ($f == 0x00030000) {
           .error("Invalid input for RDATDLY bit[16..17]")
        } else { 
            if ($c != 0) {
                   .error("Bit field 15 is reserved")
            } else {
	         if ($d != 0) {
                   .error("Bit field(bit[0..4]) is reserved")
	         } else {
                  .RCR_VALUE = $1,
                  .RCR_SETUP_update($1),
 		      "ok"
                       }
                     }
                   }
	           }
	        }
          }                                              
      )
   }
        
   
   prop XCR_VALUE_update :: (
          .XPHASE_XCR()  
        | .XFRLEN2_XCR()  
        | .XWDLEN2_XCR() 
        | .XCOMPAND_XCR() 
        | .XFIG_XCR() 
        | .XDATDLY_XCR() 
        | .XFRLEN1_XCR()  
        | .XWDLEN1_XCR()  
        | (((CSL.C11_SUPPORT ||CSL.C64_SUPPORT))? .XWDREVRS_XCR() : 0)
      )  
                           
             
   prop XCR_SETUP_update ::  (
         .XPHASE_SETUP = ( $1  & 0x80000000) ? "Dual Phase" : "Single Phase",  
          .XFRLEN2_SETUP =(( ( $1 & 0x7f000000 ) >> 24) + 1),
          .XWDLEN2_SETUP = ( $a = ($1 & 0x00e00000 ) , 
                              ( $a == 0x00200000 ) ? "12-bits":
                              ( $a == 0x00400000 ) ? "16-bits":
                              ( $a == 0x00600000 ) ? "20-bits":
                              ( $a == 0x00800000 ) ? "24-bits":
                              ( $a == 0x00a00000 ) ? "32-bits": "8-bits"),    
         .XCOMPAND_SETUP = ( $a = ($1 & 0x00180000),
                              ( $a == 0x00080000 ) ? "No Companding/LSB":
                              ( $a == 0x00100000 ) ? "Companding/u-law":
                              ( $a == 0x00180000 ) ? "Companding/A-law": "No Companding/MSB"),
        
        .XFIG_SETUP    =  ( $1 & 0x00040000) ? "Pulse ignored" : "Transfer restarted",
        .XDATDLY_SETUP = ( $a = ($1 & 0x00030000),
                              ( $a == 0x00010000 ) ? "1-bit":
                              ( $a == 0x00020000 ) ? "2-bits": "0-bit"),                          
         
  
         .XFRLEN1_SETUP = ((( $1 & 0x00007f00 ) >> 8) + 1),
         .XWDLEN1_SETUP = ( $a = ($1 & 0x000000e0 ),
                              ( $a == 0x00000020 ) ? "12-bits":
                              ( $a == 0x00000040 ) ? "16-bits":
                              ( $a == 0x00000060 ) ? "20-bits":
                              ( $a == 0x00000080 ) ? "24-bits":
                              ( $a == 0x000000A0 ) ? "32-bits": "8-bits"),          
         if ((CSL.C11_SUPPORT || CSL.C64_SUPPORT )){    
            .XWDREVRS_SETUP = ( $1 & 0x00000010) ? "Enable" : "Disable"
        }
       ) 
   
    inst XCR_VALUE :: .XCR_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Transmitter Control Reg. (XCR) "
	prop Format :: "0x%08X"
	prop JSName :: "mcbspXcr"
	prop Visible :: 1
	prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
	prop NoGen :: 0
   	prop TabName :: "Advanced"
	prop cGen :: 1
	prop cType :: "Uint32"
	prop Set :: (
       if(CSL.C11_SUPPORT || CSL.C64_SUPPORT){   
        $a = $1 & 0x00008000,
        $b = $1 & 0x0000000F,
        $e = $1 & 0x00030000,
        $g = $1 & 0x00C00000,
        $h = $1 & 0x000000C0,
         if ($g == 0x00C00000) {
         .error("Invalid input for XWDLEN2 bit[21..23]")
          } else {
         if ($h == 0x000000C0) {
          .error("Invalid input for XWDLEN1 bit[5..7]")
            } else {   
            if ($e == 0x00030000) {
              .error("Invalid input for XDATDLY bit[16..17]")
               } else { 
               if ($a != 0) {
                   .error("Bit field 15 is reserved")
                  } else {
	             if ($b != 0) {
                     .error("Bit field(bit[0..3]) is reserved")
	               } else {
                         .XCR_VALUE = $1,
                         .XCR_SETUP_update($1),
 		             "ok"
                     }
                   }
                }
             }
          }
         } else {
            $c = $1 & 0x00008000,
            $d = $1 & 0x0000001F,
            $f = $1 & 0x00030000,
            $i = $1 & 0x00C00000,
            $j = $1 & 0x000000C0,
           if ($i == 0x00C00000) {
             .error("Invalid input for XWDLEN2 bit[21..23]")
             } else {
              if ($j == 0x000000C0) {
                 .error("Invalid input for XWDLEN1 bit[5..7]")
                 } else {   
                  if ($f == 0x00030000) {
                     .error("Invalid input for XDATDLY bit[16..17]")
                     } else { 
                      if ($c != 0) {
                         .error("Bit field 15 is reserved")
                         } else {
	                   if ($d != 0) {
                           .error("Bit field(bit[0..4]) is reserved")
	                     } else {
                            .XCR_VALUE = $1,
                            .XCR_SETUP_update($1),
 		                 "ok"
                           }
                         }
                      }
                   }
	         }
           }
      )
   }
 
  
   
      prop SRGR_VALUE_update :: (
          .GSYNC_SRGR()
        | .CLKSP_SRGR()
        | .CLKSM_SRGR()
        | .FSGM_SRGR()
        | .FPER_SRGR() 
        | .FWID_SRGR()  
        | .CLKGDV_SRGR() 
        ) 
      prop SRGR_SETUP_update :: (
       if (.CLKSM_SRGR() == 0x00000000) { 
          .GSYNC_SETUP =  ( $1 & 0x80000000) ? "External Frame Sync." : "Free",
          .CLKSP_SETUP =  ( $1 & 0x40000000) ? "Falling Edge" : "Rising Edge"
           },  
        .CLKSM_SETUP = ( $1 & 0x20000000) ? "Internal Clock" : "External Clock (CLKS)",
        if (  .FSXM_SETUP == "Sample-rate Generator" ) { 
           .FSGM_SETUP = ( $1 & 0x10000000) ? "Frame Sync. Signal" : "DXR-to-XSR copy"
           }, 
        .FPER_SETUP = ( $1 & 0x0fff0000) >> 16,  
        .FWID_SETUP = ( $1 & 0x0000ff00) >> 8 ,  
        .CLKGDV_SETUP = ( $1 & 0X000000ff) 
      ) 
  
    inst SRGR_VALUE :: .SRGR_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Sample-Rate Generator Reg. (SRGR) "
	prop Format :: "0x%08X"
	prop JSName :: "mcbspSrgr"
	prop Visible :: 1
	prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (
               .SRGR_VALUE = $1,
               .SRGR_SETUP_update($1),
 		   "ok"
      )
    }
              
     
  
  prop MCR_VALUE_update :: (
        .XPBBLK_MCR() 
     |  .XPABLK_MCR()
     |  .XMCM_MCR() 
     |  .RPBBLK_MCR() 
     |  .RPABLK_MCR() 
     |  .RMCM_MCR() 
     |  .RX_MCME_MCR()
    ) 
        
    prop MCR_SETUP_update :: ( 
         .XPBBLK_SETUP  = ( $a = ( $1 & 0x01800000), 
                          ( $a == 0x00800000 ) ? " 48-to-63" :         
                          ( $a == 0x01000000 ) ? " 80-to-95" : 
                          ( $a == 0x01800000 ) ? " 112-to-127" :  " 16-to-31"),                   
         .XPABLK_SETUP  = ( $a = ( $1 & 0x00600000), 
                          ( $a == 0x00200000 ) ? " 32-to-47" :         
                          ( $a == 0x00400000 ) ? " 64-to-79" : 
                          ( $a == 0x00600000 ) ? " 96-to-111" :  "  0-to-15"), 
          .XMCM_SETUP  = ( $a = ( $1 & 0x00030000), 
                          ( $a == 0x00010000 ) ? "Disable/XP(A/B)BLK-XCEREx":         
                          ( $a == 0x00020000 ) ? "Enable/Masking" : 
                          ( $a == 0x000300000 ) ? "Disable/RP(A/B)BLK-RCEREx":  "Enable/No-Masking"),
          .RPBBLK_SETUP  = ( $a = ( $1 & 0x00000180), 
                          ( $a == 0x00000080 ) ? " 48-to-63" :         
                          ( $a == 0x01000100 ) ? " 80-to-95" : 
                          ( $a == 0x00000180 ) ? " 112-to-127" :  " 16-to-31"),                   
          .RPABLK_SETUP  = ( $a = ( $1 & 0x00000060), 
                          ( $a == 0x00000020 ) ? " 32-to-47" :         
                          ( $a == 0x00000040 ) ? " 64-to-79" : 
                          ( $a == 0x00000060 ) ? " 96-to-111" :  "  0-to-15"), 
          .RMCM_SETUP  = ( $1 & 0x00000001) ? "Disable/RP(A/B)-RCEREx" : "All Enable" ,
          .RX_MCME_SETUP = ( $1 & 0x02000200) ? "Enhanced Operation" : "Normal Operation"  
       ) 
 
  inst MCR_VALUE :: .MCR_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Multichannel Control Reg. (MCR) "
	prop Format :: "0x%08X"
	prop JSName :: "mcbspMcr"
	prop Visible :: 1
	prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (
                    $a = $1 & 0x02000200,
                      if ( CSL.C64_SUPPORT  && ($a == 0x00000200 || $a == 0x02000000)) {
                      .error("XMCME and RMCME have to be identical")
                       } else {
               .MCR_VALUE = $1,
               .MCR_SETUP_update($1),
 		   "ok"
         }
      )
   }
	
         
   prop RCER_VALUE_update :: ( 
         .RCEB_RCER()
         |.RCEA_RCER()
       )
     
     prop RCER_SETUP_update :: (
          .RCEB_SETUP = ( $1 & 0xffff0000 ) >> 16,  
          .RCEA_SETUP = ( $1 & 0x0000ffff)
     )
   inst RCER_VALUE :: .RCER_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Receiver Channel Enable(RCER) "
	prop Format :: "0x%08X"
	prop JSName :: "mcbspRcer"
	prop Visible :: 1
	prop Writable :: (CSL.MCBSP_SUPPORT) && !CSL.C64_SUPPORT 
	prop NoGen :: 0
	prop cGen :: !CSL.C64_SUPPORT
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (
               .RCER_VALUE = $1,
               .RCER_SETUP_update($1),
 		   "ok"
      )
   }
	
   prop RCERE0_VALUE_update :: ( 
         .RCE0_RCERE0()
       )
     
     prop RCERE0_SETUP_update :: (
          .RCE0_SETUP =  $1     
     )
   inst RCERE0_VALUE :: .RCERE0_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Enhanced Receiver Channel Enable(RCERE0) "
	prop Format :: "0x%08X"
	prop JSName :: "mcbspRcere0"
	prop Visible :: 1
	prop Writable :: (CSL.MCBSP_SUPPORT) && CSL.C64_SUPPORT 
	prop NoGen :: 0
	prop cGen :: CSL.C64_SUPPORT
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (
               .RCERE0_VALUE = $1,
               .RCERE0_SETUP_update($1),
 		   "ok"
      )
   }
	
   prop RCERE1_VALUE_update :: ( 
         .RCE1_RCERE1()
       )
     
     prop RCERE1_SETUP_update :: (
          .RCE1_SETUP =  $1     
     )
   inst RCERE1_VALUE :: .RCERE1_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Enhanced Receiver Channel Enable(RCERE1) "
	prop Format :: "0x%08X"
	prop JSName :: "mcbspRcere1"
	prop Visible :: 1
	prop Writable :: (CSL.MCBSP_SUPPORT) && CSL.C64_SUPPORT 
	prop NoGen :: 0
	prop cGen :: CSL.C64_SUPPORT
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (
               .RCERE1_VALUE = $1,
               .RCERE1_SETUP_update($1),
 		   "ok"
      )
   }
  
   prop RCERE2_VALUE_update :: ( 
         .RCE2_RCERE2()
       )
     
     prop RCERE2_SETUP_update :: (
          .RCE2_SETUP =  $1     
     )
   inst RCERE2_VALUE :: .RCERE2_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Enhanced Receiver Channel Enable(RCERE2) "
	prop Format :: "0x%08X"
	prop JSName :: "mcbspRcere2"
	prop Visible :: 1
	prop Writable :: (CSL.MCBSP_SUPPORT) && CSL.C64_SUPPORT 
	prop NoGen :: 0
	prop cGen :: CSL.C64_SUPPORT
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (
               .RCERE2_VALUE = $1,
               .RCERE2_SETUP_update($1),
 		   "ok"
      )
   }
   prop RCERE3_VALUE_update :: ( 
         .RCE3_RCERE3()
       )
     
     prop RCERE3_SETUP_update :: (
          .RCE3_SETUP =  $1     
     )
   inst RCERE3_VALUE :: .RCERE3_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Enhanced Receiver Channel Enable(RCERE3) "
	prop Format :: "0x%08X"
	prop JSName :: "mcbspRcere3"
	prop Visible :: 1
	prop Writable :: (CSL.MCBSP_SUPPORT) && CSL.C64_SUPPORT 
	prop NoGen :: 0
	prop cGen :: CSL.C64_SUPPORT
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (
               .RCERE3_VALUE = $1,
               .RCERE3_SETUP_update($1),
 		   "ok"
      )
   }
   prop XCER_VALUE_update :: ( 
         .XCEB_XCER()
         |.XCEA_XCER()
       )
     
     prop XCER_SETUP_update :: (
          .XCEB_SETUP = ( $1 & 0xffff0000 ) >> 16,  
          .XCEA_SETUP = ( $1 & 0x0000ffff)
     )
   inst XCER_VALUE :: .XCER_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Transmitter Channel Enable(XCER) "
	prop Format :: "0x%08X"
	prop JSName :: "mcbspXcer"
	prop Visible :: 1
	prop Writable :: (CSL.MCBSP_SUPPORT) && !CSL.C64_SUPPORT 
	prop NoGen :: 0
	prop cGen :: !CSL.C64_SUPPORT 
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (
               .XCER_VALUE = $1,
               .XCER_SETUP_update($1),
 		   "ok"
      )
   }
   prop XCERE0_VALUE_update :: ( 
         .XCE0_XCERE0()
       )
     
     prop XCERE0_SETUP_update :: (
          .XCE0_SETUP = ( $1 )
     )
   inst XCERE0_VALUE :: .XCERE0_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Enhanced Transmitter Channel Enable(XCERE0) "
	prop Format :: "0x%08X"
	prop JSName :: "mcbspXcere0"
	prop Visible :: 1
	prop Writable :: (CSL.MCBSP_SUPPORT) &&  CSL.C64_SUPPORT 
	prop NoGen :: 0
	prop cGen :: CSL.C64_SUPPORT 
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (
               .XCERE0_VALUE = $1,
               .XCERE0_SETUP_update($1),
 		   "ok"
      )
   }
 
   prop XCERE1_VALUE_update :: ( 
         .XCE1_XCERE1()
       )
     
     prop XCERE1_SETUP_update :: (
          .XCE1_SETUP = ( $1 )
     )
   inst XCERE1_VALUE :: .XCERE1_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Enhanced Transmitter Channel Enable(XCERE1) "
	prop Format :: "0x%08X"
	prop JSName :: "mcbspXcere1"
	prop Visible :: 1
	prop Writable :: (CSL.MCBSP_SUPPORT) &&  CSL.C64_SUPPORT 
	prop NoGen :: 0
	prop cGen :: CSL.C64_SUPPORT 
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (
               .XCERE1_VALUE = $1,
               .XCERE1_SETUP_update($1),
 		   "ok"
      )
   }
   prop XCERE2_VALUE_update :: ( 
         .XCE2_XCERE2()
       )
     
     prop XCERE2_SETUP_update :: (
          .XCE2_SETUP = ( $1 )
     )
   inst XCERE2_VALUE :: .XCERE2_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Enhanced Transmitter Channel Enable(XCERE2) "
	prop Format :: "0x%08X"
	prop JSName :: "mcbspXcere2"
	prop Visible :: 1
	prop Writable :: (CSL.MCBSP_SUPPORT) &&  CSL.C64_SUPPORT 
	prop NoGen :: 0
	prop cGen :: CSL.C64_SUPPORT 
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (
               .XCERE2_VALUE = $1,
               .XCERE2_SETUP_update($1),
 		   "ok"
      )
   }
   prop XCERE3_VALUE_update :: ( 
         .XCE3_XCERE3()
       )
     
     prop XCERE3_SETUP_update :: (
          .XCE3_SETUP = ( $1 )
     )
   inst XCERE3_VALUE :: .XCERE3_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Enhanced Transmitter Channel Enable(XCERE3) "
	prop Format :: "0x%08X"
	prop JSName :: "mcbspXcere3"
	prop Visible :: 1
	prop Writable :: (CSL.MCBSP_SUPPORT) &&  CSL.C64_SUPPORT 
	prop NoGen :: 0
	prop cGen :: CSL.C64_SUPPORT 
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (
               .XCERE3_VALUE = $1,
               .XCERE3_SETUP_update($1),
 		   "ok"
      )
   }
 
 prop PCR_VALUE_update :: (
         .XIOEN_PCR() 
        | .RIOEN_PCR() 
        | .FSXM_PCR() 
        | .FSRM_PCR() 
        | .CLKXM_PCR() 
        | .CLKRM_PCR()        
| (((.XIOEN_SETUP == "Enable") && (.FSXM_SETUP == "Sample-rate Generator")) ? .FSXP_IO() : .FSXP_PCR()) 
| (((.RIOEN_SETUP == "Enable") && (.FSRM_SETUP == "Sample-rate Generator")) ? .FSRP_IO() : .FSRP_PCR()) 
 | ((.XIOEN_SETUP == "Enable") ? .DX_IO() : 0 )
 | (((.XIOEN_SETUP == "Enable")&&(.CLKXM_SETUP == "Output/Mcbsp-master(SPI)")) ? .CLKXP_IO(): .CLKXP_PCR())
| (((.RIOEN_SETUP == "Enable") && (.CLKRM_SETUP == "Output/Output(DLB)")) ? .CLKRP_IO() : .CLKRP_PCR()) 
  )
  
 
   prop PCR_SETUP_update :: (
    .XIOEN_SETUP = ( $1 & 0x00002000) ? "Enable" : "Disable",
    .RIOEN_SETUP = ( $1 & 0x00001000) ? "Enable" : "Disable",
   .FSXM_SETUP  = ( $1 & 0x000000800) ? "Sample-rate Generator" : "External Source",
    .FSRM_SETUP  = ( $1 & 0x000000400) ? "Sample-rate Generator" : "External Source",
   .CLKXM_SETUP = ( $1 & 0x000000200) ? "Output/Mcbsp-master(SPI)" : "Input/Mcbsp-slave(SPI)",
    .CLKRM_SETUP = ( $1 & 0x000000100) ? "Output/Output(DLB)" : "Input/Hi.Z(DLB)",
if  (.XIOEN_SETUP == "Enable")  {
    .DX_output = ( $1 & 0x00000020 ) ? 1 : 0 
    } else  { 0x00000000 
    },  
if ((.XIOEN_SETUP == "Enable") && (.FSXM_SETUP == "Sample-rate Generator")) {
     .FSXP_output = ( $1 & 0x00000008) ? 1 : 0
    } else {
     .FSXP_SETUP =  ( $1 & 0x00000008) ?  "Active Low" : "Active High"
     },
if ((.RIOEN_SETUP == "Enable") && (.FSRM_SETUP == "Sample-rate Generator")) {
   .FSRP_output = ( $1 & 0x00000004) ? 1 : 0
    } else {
    .FSRP_SETUP = ( $1 & 0x00000004) ?  "Active Low" : "Active High"
     },
 if ((.XIOEN_SETUP == "Enable")&&(.CLKXM_SETUP == "Output/Mcbsp-master(SPI)")) {
     .CLKXP_output = ( $1 & 0x00000002) ? 1 : 0 
     } else {
     .CLKXP_SETUP = ( $1 & 0x00000002) ? "Falling Edge" : "Rising Edge"
     },    
if ((.RIOEN_SETUP == "Enable") && (.CLKRM_SETUP == "Output/Output(DLB)")) {
     .CLKRP_output = ( $1 & 0x00000001) ? 1 : 0
     } else {
     .CLKRP_SETUP = ( $1 & 0x00000001) ? "Rising Edge" : "Falling Edge"
     }  
    ) 
     inst PCR_VALUE :: .PCR_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Pin Control Reg. (PCR) "
	prop Format :: "0x%08X"
	prop JSName :: "mcbspPcr"
	prop Visible :: 1
	prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (
               .PCR_VALUE = $1,
               .PCR_SETUP_update($1),
 		   "ok"
      )
   }
                        
}  
type hMcbsp {
     isa ObjectMgr
     prop name :: "hMcbsp"
     prop Label :: "MCBSP Resource Manager"
     prop JSName :: "HMCBSP"
        
     prop IsContainedIn :: MCBSPFOLDER
     prop NoGen :: 1
       	    	
     prop GlobalPropertyPage :: "{1E62DD10-59A8-11d4-947D-0050048381B7}"
     prop InstancePropertyPage :: "{1E62DD11-59A8-11d4-947D-0050048381B7}"
        
     prop GlobalIcon :: 159
     prop InstanceIcon :: 160
     prop GlobalHelpTopic :: (
	   1052
      )
	
    
     prop InstanceHelpTopic :: (
	   1053
      )
         prop localCanCreate :: (
	.error("New Mcbsp handle objects cannot be created")
       )
        prop localCanDelete :: (
	.error("Mcbsp handle objects cannot be deleted")
       )
       
      prop chipcall :: (     
	scan ($i; hMcbsp) {
	    if ( !CSL.MCBSP2_SUPPORT && $i.PORT == "MCBSP2" ) {
	        $i.MCBSP_HANDLE_ENABLE = 0,
	        $i.MCBSP_INIT_ENABLE = 0,
                $i.cOpenArg0 = "MCBSP_None"
                }
           },    
           if (.CHIPCHAIN != nil) {
                 $e = .CHIPCHAIN.chipcall()
            },
            "ok"
        )
       
     
        prop localInit :: (
            .CHIPCHAIN = GBL.CHIPCHAIN,
            GBL.CHIPCHAIN = hMcbsp
        )
	global CHIPCHAIN :: nil {
	    prop Visible :: 0
	    prop Writable :: (CSL.MCBSP_SUPPORT) &&  0
	    prop NoGen :: 1
	}
        prop cGen :: 1 
	 
        prop cHandle ::( .cOpenGen) 	 
	prop cHeaderName :: (
	    $a = "",
	    scan ($b; hMcbsp) {
	        if ($b.MCBSP_HANDLE_ENABLE == 1) {
	            $a = "csl_mcbsp.h"
	        }
	    },
	    $a
	)
         prop cHandleType :: "MCBSP_Handle"
         prop cStructQual :: "far"
         
         
         prop cOpenName :: "MCBSP_open"
         prop cConfigName :: "MCBSP_config"
   inst MCBSP_HANDLE_ENABLE :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Open MCBSP Port"
	  prop JSName :: "mcbspHandleEnable"
	  prop Visible :: 1
	  prop Writable :: (CSL.MCBSP_SUPPORT) &&  ( CSL.MCBSP2_SUPPORT || ( !CSL.MCBSP2_SUPPORT && ( .PORT == "MCBSP0" || .PORT == "MCBSP1") )) ? 1: 0  
	  prop NoGen :: 1
          prop Set :: (
              $a = 0,
             if ( $1 == 0) {
              	.MCBSP_HANDLE_ENABLE = $1,
		.MCBSP_INIT = MCBSP_NOTHING,
                .cOpenArg0 = "MCBSP_None",
                "ok"
            } else {               
                      .MCBSP_HANDLE_ENABLE = $1,                         
                       if ( .PORT == "MCBSP0") {
                          .cOpenArg0 = "MCBSP_DEV0", 
                           "ok"
                        } else { 
                        if ( .PORT == "MCBSP1") { 
                          .cOpenArg0 = "MCBSP_DEV1", 
                          "ok" 
                          } else {
                          .cOpenArg0 = "MCBSP_DEV2", 
                          "ok" 
			   }
                       }    
                     }                                                            
	  )
    	}      
   
 
  
    inst HandleName :: self {
             prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	     prop Label :: " Handle  "
	     prop JSName :: "mcbspHandleName"
	     prop Visible :: 1
	     prop Writable :: (CSL.MCBSP_SUPPORT) &&  (.MCBSP_HANDLE_ENABLE == 1 ) ? 1 :0
          }
	   
    prop cHandleName :: .HandleName 
 
 
 
 
 inst PORT :: "MCBSP0"  {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "MCBSP0,MCBSP1,MCBSP2"
        prop Label :: "        Port"
        prop Visible :: 0
        prop Writable :: (CSL.MCBSP_SUPPORT) &&  0
        prop NoGen :: 1
	}
        
 
     
  
  inst cOpenGen ::= (CSL.MCBSP_SUPPORT && (.MCBSP_HANDLE_ENABLE == 1) && (.HandleName != "") ) {
            prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
            prop Visible :: 0
            prop Writable :: (CSL.MCBSP_SUPPORT) &&  0
            prop NoGen :: 1           
           }
  
  
  
	inst cOpenArg0 :: (  
	if ( .MCBSP_HANDLE_ENABLE == 0) {
                      "MCBSP_None"         
                }      
        ) {
	     prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	     prop Label :: "   Arg0 "
	     prop Visible :: 0
	     prop Writable :: (CSL.MCBSP_SUPPORT) &&  0
	     prop NoGen :: 1 
           }
   
         
	inst cOpenArg1 :: "MCBSP_OPEN_RESET" {
	     prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	     prop Label :: "Pre-initialize (Default) "
	     prop Visible :: 0
	     prop Writable :: (CSL.MCBSP_SUPPORT) &&  0
	     prop NoGen :: 1 
	}
	 
        
   inst MCBSP_INIT_ENABLE :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Enable Pre-Initialization"
	  prop JSName :: "mcbspEnablePreInit"
	  prop Visible :: 1
	  prop Writable :: (CSL.MCBSP_SUPPORT) &&  (.MCBSP_HANDLE_ENABLE == 1) ? 1 : 0
	  prop NoGen :: 1
          prop Set :: (
              $a = 0,
                scan($b; mcbspCfg) { 
                      $a = $a + 1
                  }, 		
		if ($a == 1) {
                 	.MCBSP_INIT_ENABLE = 0,
            .error("You must create a new configuration object")
                } else {               
                 	.MCBSP_INIT_ENABLE = $1,
			if ($1 == 0) {
			.MCBSP_INIT = MCBSP_NOTHING
			},
			"ok"
		}           
	  )
    	}
	inst MCBSP_INIT :: MCBSP_NOTHING {
	    prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	    prop MemberType :: mcbspCfg
	    prop Label :: " Pre-Initialize with"
	    prop JSName :: "mcbspPreInit"
	    prop Visible :: 1
	    prop Writable :: (CSL.MCBSP_SUPPORT) &&  ((.MCBSP_INIT_ENABLE == 1) && (.MCBSP_HANDLE_ENABLE == 1)  ) ? 1: 0
            prop NoGen :: 0
       	}
    inst cConfigGen ::= (( .MCBSP_HANDLE_ENABLE == 1) && 
(.MCBSP_INIT_ENABLE == 1) && (.MCBSP_INIT != MCBSP_NOTHING)&& (.HandleName != "") ) {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
      }
 	inst cConfigArg0 ::= .cHandleName {
	    prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Label :: "Config argument 0"
	    prop Visible :: 0
	}
 
   inst cConfigArg1 ::= .MCBSP_INIT {
         prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop MemberType :: mcbspCfg
	  prop Label :: "Pre-initialize Config"
	  prop Visible :: 0
	  prop Writable :: (CSL.MCBSP_SUPPORT) &&  1
          prop NoGen :: 0
	  prop cPreVal :: "&"
    }
}
object Mcbsp_Port0 :: hMcbsp {
	 param iComment :: "Mcbsp 0"  
         param iIsUsed :: 1
         param iDelUser :: "hMcbsp"
         param iDelMsg :: (
  	"This MCBSP Handle object cannot be deleted"
	)
	 param HandleName :: "hMcbsp0"
         param PORT :: "MCBSP0"
         param MCBSP_INIT :: MCBSP_NOTHING
       }
       
object Mcbsp_Port1 :: hMcbsp {
	 param iComment :: "Mcbsp 1"  
         param iIsUsed :: 1
         param iDelUser :: "hMcbsp"
         param iDelMsg :: (
	"This MCBSP Handle object cannot be deleted"
	)
	 param HandleName :: "hMcbsp1"
         param PORT :: "MCBSP1"
         param MCBSP_INIT :: MCBSP_NOTHING
       }
       
object Mcbsp_Port2 :: hMcbsp {
	 param iComment :: "Mcbsp 2"  
         param iIsUsed :: 1
         param iDelUser :: "hMcbsp"
         param iDelMsg :: (
	"This MCBSP Handle object cannot be deleted"
	)
	 param HandleName :: "hMcbsp2"
         param PORT :: "MCBSP2"
         param MCBSP_INIT :: MCBSP_NOTHING
       }
object MCBSP_NOTHING :: mcbspCfg {
       param iIsUsed :: 0
}
type TCPFOLDER {
    prop Label :: "Turbo Decoder Coprocessor -TCP "
    prop GlobalIcon :: 197
    prop InstanceIcon :: 198
    prop GlobalHelpTopic :: 1080
    prop GlobalPropertyPage :: "{B936FB81-49A5-11d4-967C-0050048381C7}"
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}
type tcpBaseParam {
      isa ObjectMgr
      prop name :: "tcpBaseParam"
      prop Label :: "TCP Parameters Manager"
      prop JSName :: "TCPBP"
      prop IsContainedIn :: TCPFOLDER
      prop GlobalIcon :: 197
      prop InstanceIcon :: 198
      prop GlobalHelpTopic :: 1081
      prop InstanceHelpTopic :: 1081
      prop GlobalPropertyPage :: "{B936FB81-49A5-11d4-967C-0050048381C8}"
      prop InstancePropertyPage :: "{B936FB81-49A5-11d4-967C-0050048381C9}"
      prop Vendor :: "vendor1"
      prop Version :: "1.00.00"
	
	prop NoGen :: 1
        prop cGen :: CSL.TCP_SUPPORT 
    	prop cStruct :: CSL.TCP_SUPPORT
        prop cHeaderName :: .gNumOf > 0 ? "csl_tcp.h" : ""
    	prop cStructType :: "TCP_BaseParams"
        prop cStructQual :: "far"
        prop cStructName :: self
           	
	prop cConfigName :: "TCP_genParams"
       prop ParamConfigType :: (hTcp.TCP_INITPARAM_ENABLE == 1 && hTcp.TCP_PARAMCONFIGNAME != "NULL") ? "TCP_Params " : ""
       prop ParamConfigName :: (hTcp.TCP_INITPARAM_ENABLE == 1 && hTcp.TCP_PARAMCONFIGNAME != "NULL") ? hTcp.TCP_PARAMCONFIGNAME : ""
       prop ParamEnd :: (hTcp.TCP_INITPARAM_ENABLE == 1 && hTcp.TCP_PARAMCONFIGNAME != "NULL") ? ";\n" : ""
       prop cGenCEpilogue :: ("%1S%2S%3S\n\0,ParamConfigType,ParamConfigName,ParamEnd")  
        
    
     
     inst cConfigGen ::= 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
    }
 
    inst cConfigArg0 ::= hTcp.TCP_INITPARAM {
         prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop MemberType :: tcpBaseParam
	  prop Label :: "Pre-initialize Params"
	  prop Visible :: 0
	  prop Writable :: (CSL.TCP_SUPPORT) 
          prop NoGen :: 0
	  prop cPreVal :: "&"
       }  
    inst cConfigArg1 ::= hTcp.TCP_PARAMCONFIGNAME {
         prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Pre-initialize Params"
	  prop Visible :: 0
	  prop Writable :: (CSL.TCP_SUPPORT) 
          prop NoGen :: 0
	  prop cPreVal :: "&"
      }
 
     prop localDelete :: (
        .myDelete
      )      
     
     prop myDelete :: (
        $a=0,
        scan($b; tcpBaseParam) { 
             $a += 1
        }, 		
        if($a == 2 ) {
              hTcp.TCP_INITPARAM_ENABLE = 0             
          },
        "ok"
      )          
     
      prop GenParamStr :: (hTcp.TCP_INITPARAM_ENABLE == 1  ) ? "TCP_genParams(&%3s, &" : ""
      prop ParamConfigObj :: ( hTcp.TCP_INITPARAM_ENABLE == 1 && hTcp.TCP_PARAMCONFIGNAME != "NULL" ) ? hTcp.TCP_PARAMCONFIGNAME : ""
      prop ConfigEnd :: (hTcp.TCP_INITPARAM_ENABLE == 1 && hTcp.TCP_PARAMCONFIGNAME != "NULL") ? ");" : ""
       
      prop cGenFxnPreInst :: ( "   %1S%2S%4S\n\0,GenParamStr,ParamConfigObj,cStructName,ConfigEnd")
 inst STANDARD_SETUP :: "3GPP" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "3GPP,IS2000"
        prop Label :: "Turbo Decoder Standard"
        prop Visible :: 1
	prop JSName :: "tcpBaseParamStandard"
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "TCP Base Params"
        prop Set :: (
            if ( $1 == "IS2000") { 
                 .cStandardGen = "TCP_STANDARD_IS2000" 
               } else { 
                       .cStandardGen = "TCP_STANDARD_3GPP" 
              },
             .STANDARD_SETUP = $1,
             "ok"
        )
   }  
inst  cStandardGen ::= "TCP_STANDARD_3GPP" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Decoder Standard"
        prop Visible :: 0
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        }  
inst RATE_SETUP :: "None"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,1/2,1/3,1/4"
        prop Label :: " Code Rate (RATE)"
        prop Visible :: 1
	prop JSName :: "tcpBaseParamRate"
        prop Writable :: (CSL.TCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "TCP Base Params"
        prop Set :: (
             if (.STANDARD_SETUP == "3GPP" && $1 != "1/3") {
                   .error("Rate 1/3 is required for 3GPP Standard")
              } else {
                if ($1 == "1/2") {   
                    .cRateGen = "TCP_RATE_1_2"                          
                 } else {
                     if ($1 == "1/3") {
                          .cRateGen = "TCP_RATE_1_3"  
                       } else {
                        if ($1 == "1/4") {
                          .cRateGen = "TCP_RATE_1_4"
                           } else {
                                  .cRateGen = " 0" 
                             }
                        } 
                 },
             .RATE_SETUP = $1,
             "ok"
            }
        )
     }
  
inst  cRateGen ::= " 0"  {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Rate"
        prop Visible :: 0
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        }  
 
inst FRAMELEN_SETUP ::= 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Frame Length (FL: 40 to 20730) "
        prop Visible :: 1
	prop JSName :: "tcpBaseParamFrameLen"
        prop Writable :: (CSL.TCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "TCP Base Params"
        prop Set :: (
             if ( $1 < 40 || $1 > 20730) {
                   .error("Frame Length range [40-20730]")
              } else {
             .FRAMELEN_SETUP = $1,
             "ok"
              }
        )
     }
inst PROLSIZE_SETUP :: 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Prolog Size (P: 24 to 48)"
        prop Visible :: 1
	prop JSName :: "tcpBaseParamProlSize"
        prop Writable :: (CSL.TCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "TCP Base Params"
        prop Set :: ( 
              if ( $1 < 24 || $1 > 48) {
                .error("Prolog Size range [24-48]")
              } else {        
                   .PROLSIZE_SETUP = $1,
     
                  "ok"
              }
        )
     }
inst MAXIT_SETUP :: 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Maximum of Iterations (MAXIT - SA mode only)"
        prop Visible :: 1
	prop JSName :: "tcpBaseParamMaxIt"
        prop Writable :: (CSL.TCP_SUPPORT) 
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "TCP Base Params"
        prop Set :: ( 
              if ( $1 < 0 || $1 > 32) {
                .error("Maximum number of Iterations range [0-32]")
              } else {        
                   .MAXIT_SETUP = $1,
                   
                  "ok"
              }
        )
     }
inst SNR_SETUP :: 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " SNR Threshold (SNR - SA mode only)"
        prop Visible :: 1
	prop JSName :: "tcpBaseParamSnrTh"
        prop Writable :: (CSL.TCP_SUPPORT) 
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "TCP Base Params"
        prop Set :: ( 
              if ( $1 < 0 || $1 > 100) {
                .error("Maximum number of Iterations range [0-100]")
              } else {        
                   .SNR_SETUP = $1,
                     
                  "ok"
              }
        )
     }
inst INTER_SETUP :: "Disable"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: " Interleaver Write Flag (INTER)"
        prop Visible :: 1
	prop JSName :: "tcpBaseParamInterFlag"
        prop Writable :: (CSL.TCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "TCP Base Params"
        prop Set :: (
                    if ( $1 == "Enable") {
                      .cInterGen = " 1"
                      } else {
                      .cInterGen = " 0"
                     },
              .INTER_SETUP = $1,
              
             "ok"
        )
     }
inst  cInterGen ::= " 0"  {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Interleaver Write Flag "
        prop Visible :: 0
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        }  
inst OUTF_SETUP :: "Disable"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: " Output Parameters Read Flag (OUTF) "
        prop Visible :: 1
	prop JSName :: "tcpBaseParamOutFlag"
        prop Writable :: (CSL.TCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "TCP Base Params"
        prop Set :: (
                    if ( $1 == "Enable") {
                      .cOutfGen = " 1"
                      } else {
                      .cOutfGen = " 0"
                     },
             .OUTF_SETUP = $1,
           
             "ok"
        )
     }
inst  cOutfGen ::= " 0"  {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Output Parameters Read Flag "
        prop Visible :: 0
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        }  
  }
 
 type tcpCfg {
      isa ObjectMgr
      prop name :: "tcpCfg"
      prop Label :: "TCP Configuration Manager"
      prop JSName :: "TCP"
      prop IsContainedIn :: TCPFOLDER
      prop GlobalIcon :: 197
      prop InstanceIcon :: 198
      prop GlobalHelpTopic :: 1082
      prop InstanceHelpTopic :: 1082
      prop GlobalPropertyPage :: "{B936FB81-49A5-11d4-967C-0050048381C8}"
      prop InstancePropertyPage :: "{B936FB81-49A5-11d4-967C-0050048381C9}"
      prop Vendor :: "vendor1"
      prop Version :: "1.00.00"
	
	prop NoGen :: 1
        prop cGen :: CSL.TCP_SUPPORT 
    	prop cStruct :: CSL.TCP_SUPPORT
        prop cHeaderName :: .gNumOf > 0 ? "csl_tcp.h" : ""
    	prop cStructType :: "TCP_ConfigIc"
        prop cStructQual :: "far"
        prop cStructName :: self
        prop cConfigName :: "TCP_icConfig"                 	
    
    inst cConfigGen ::= ( (hTcp.TCP_INIT_ENABLE == 1)  && (hTcp.TCP_INIT == self) && (hTcp.TCP_INIT != TCP_NOTHING)) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
    }
 	
 
    inst cConfigArg0 ::=  hTcp.TCP_INIT {
         prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop MemberType :: tcpCfg
	  prop Label :: "Pre-initialize Config"
	  prop Visible :: 0
	  prop Writable :: (CSL.TCP_SUPPORT) 
          prop NoGen :: 0
	  prop cPreVal :: "&"
    }
      prop SetParamStr :: (hTcp.TCP_SETPARAM_ENABLE == 1  && hTcp.TCP_INIT != TCP_NOTHING) ? "TCP_setParams(&" : ""
      prop ParamConfigObj :: ( hTcp.TCP_SETPARAM_ENABLE == 1 && hTcp.TCP_INIT != TCP_NOTHING && hTcp.TCP_PARAMCONFIGNAME != "NULL" ) ? hTcp.TCP_PARAMCONFIGNAME : ""
      prop IcConfigObj :: ( hTcp.TCP_SETPARAM_ENABLE == 1 && hTcp.TCP_INIT != TCP_NOTHING && hTcp.TCP_PARAMCONFIGNAME != "NULL" ) ? ",&%4s" : ""
      prop ConfigEnd :: (hTcp.TCP_SETPARAM_ENABLE == 1 && hTcp.TCP_INIT != TCP_NOTHING && hTcp.TCP_PARAMCONFIGNAME != "NULL") ? ");" : ""
       
      prop cGenFxnPreInst :: ( "   %1S%2S%3S%5S\n\0,SetParamStr,ParamConfigObj,IcConfigObj,cStructName,ConfigEnd")
     prop localDelete :: (
        .myDelete
      )      
     
     prop myDelete :: (
        $a=0,
        scan($b; tcpCfg) { 
             $a += 1
        }, 		
        if($a == 2 ) {
              hTcp.TCP_INIT_ENABLE = 0             
          },
        "ok"
      )          
 inst STANDARD_SETUP :: "3GPP" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "3GPP,IS2000"
        prop Label :: "Turbo Decoder Standard"
        prop Visible :: 1
	prop JSName :: "tcpDecoderStandard"
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable TCP Params"
        prop Set :: (
            if ( $1 == "IS2000") { 
                 .cStandardGen = "TCP_STANDARD_IS2000" 
               } else { 
                       .cStandardGen = "TCP_STANDARD_3GPP" 
              },
             .STANDARD_SETUP = $1,
             "ok"
        )
   }  
inst  cStandardGen ::= "TCP_STANDARD_3GPP" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Decoder Standard"
        prop Visible :: 0
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        }  
 
inst MODE_SETUP :: "Standalone(SA)" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Standalone(SA),Shared(SP)"
        prop Label :: "Turbo Decoder Operation Mode"
        prop Visible :: 1
	prop JSName :: "tcpMode"
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable TCP Params"
        prop Set :: (
               if ( $1 == "Standalone(SA)") { 
                 .cModeGen = "TCP_MODE_SA" 
               } else { 
                       .cModeGen = "TCP_MODE_SP" 
              },
             .MODE_SETUP = $1,
             .IC0_VALUE = .IC0_VALUE_update(),
             "ok"
        )
     }
inst  cModeGen ::= "TCP_MODE_SA"  {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Decoder Mode"
        prop Visible :: 0
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        }  
inst MAP_SETUP :: "MAP1(1st Iter.)"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "MAP1(1st Iter.),MAP1(Any Other Iter.),MAP2"
        prop Label :: " Map (SP Mode only)"
        prop Visible :: 1
	prop JSName :: "tcpMap"
        prop Writable :: (CSL.TCP_SUPPORT !=0 && .MODE_SETUP == "Shared(SP)") ? 1:0
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable TCP Params"
        prop Set :: (
            if ( $1 == "MAP1(1st Iter.)") { 
                 .cMapGen = "TCP_MAP_MAP1A" 
               } else { 
                if ( $1 == "MAP1(Any Other Iter.)") { 
                 .cMapGen = "TCP_MAP_MAP1B"
                   }else {
                       .cMapGen = "TCP_MAP_MAP2"
                  } 
                },
             .MAP_SETUP = $1,
             .IC0_VALUE = .IC0_VALUE_update(),
             "ok"
        )
     }
inst  cMapGen ::= "TCP_MAP_MAP1A"  {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Operation Map (SP Mode only)"
        prop Visible :: 0
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        }  
prop OPMOD_IC0 :: (
        if ( .MODE_SETUP == "Standalone(SA)" ) { 
              0
        } else {
              if ( .MAP_SETUP == "MAP1(1st Iter.)") {
                  0x00000008   
               } else {
                    if ( .MAP_SETUP == "MAP1(Any Other Iter.)") {
                  0x0000000A   
                  } else {        
                   0x0000000E   
                    }
                }
           }
     )
inst RATE_SETUP :: "None"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,1/2,1/3,1/4"
        prop Label :: " Code Rate (RATE)"
        prop Visible :: 1
	prop JSName :: "tcpIc0Rate"
        prop Writable :: (CSL.TCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable TCP Params"
        prop Set :: (
             if (.STANDARD_SETUP == "3GPP" && $1 != "1/3") {
                   .error("Rate 1/3 is required for 3GPP Standard")
              } else {
                if ($1 == "1/2") {   
                    .cRateGen = "TCP_RATE_1_2"                          
                 } else {
                     if ($1 == "1/3") {
                          .cRateGen = "TCP_RATE_1_3"  
                       } else {
                        if ($1 == "1/4") {
                          .cRateGen = "TCP_RATE_1_4"
                           } else {
                                  .cRateGen = " 0" 
                             }
                        } 
                 },
             .RATE_SETUP = $1,
             .IC0_VALUE = .IC0_VALUE_update(),
             "ok"
            }
        )
     }
  
inst  cRateGen ::= "0"  {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Rate"
        prop Visible :: 0
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        }  
prop RATE_IC0 :: (
        if (.RATE_SETUP == "None") { 
                 0
          } else {
             if (.RATE_SETUP == "1/2") {
                          0x00000100
                 } else {
                     if (.RATE_SETUP == "1/3") {
                          0x00000200
                       } else {
                          0x00000300
                       } 
                 }
          }  
             
        )                     
inst OUTF_SETUP :: "Disable"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: " Output Parameters Read Flag (OUTF) "
        prop Visible :: 1
	prop JSName :: "tcpIc0OutFlag"
        prop Writable :: (CSL.TCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "EDMA Operation"
        prop Set :: (
             .OUTF_SETUP = $1,
             .IC0_VALUE = .IC0_VALUE_update(),
             "ok"
        )
     }
inst  cOutfGen ::= "0"  {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Output Parameters Read Flag "
        prop Visible :: 0
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        }  
prop OUTF_IC0 :: (
        if (.OUTF_SETUP == "Disable") { 
                 0
          } else {
               0x00002000
          }
    )                     
inst INTER_SETUP :: "Disable"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: " Interleaver Write Flag (INTER)"
        prop Visible :: 1
	prop JSName :: "tcpIc0InterFlag"
        prop Writable :: (CSL.TCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "EDMA Operation"
        prop Set :: (
              .INTER_SETUP = $1,
              .IC0_VALUE = .IC0_VALUE_update(),
             "ok"
        )
     }
inst  cInterGen ::= "0"  {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Interleaver Write Flag "
        prop Visible :: 0
        prop Writable :: CSL.TCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        }  
prop INTER_IC0 :: (
        if (.INTER_SETUP == "Disable") { 
                 0x00000000
          } else {
                 0x00001000
          }
    )                     
inst FRAMELEN_SETUP ::= 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Frame Length (FL: 40 to 20730) "
        prop Visible :: 1
	prop JSName :: "tcpIc0FrameLen"
        prop Writable :: (CSL.TCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable TCP Params"
        prop Set :: (
             if ( $1 < 40 || $1 > 20730) {
                   .error("Frame Length range [40-20730]")
              } else {
             .FRAMELEN_SETUP = $1,
             .IC0_VALUE = .IC0_VALUE_update(),
             "ok"
              }
        )
     }
prop FRAMELEN_IC0 :: (
             .FRAMELEN_SETUP << 16
          )
inst RELLEN_SETUP ::= 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Reliability Length (R: 39 to 127)"
        prop Visible :: 1
	prop JSName :: "tcpIc0ReliaLen"
        prop Writable :: (CSL.TCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable TCP Params"
        prop Set :: (
             if ( $1 < 39 || $1 > 127) {
                   .error("Reliability Length range [39-127]")
              } else {
             .RELLEN_SETUP = $1,
             .IC1_VALUE = .IC1_VALUE_update(),
             "ok"
              }
        )
     }
prop RELLEN_IC1 :: (
             .RELLEN_SETUP << 16
          )
inst SUBFRAMELEN_SETUP ::= 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Sub-Frame Length (SFL: 98 to 5114)"
        prop Visible :: 1
	prop JSName :: "tcpIc1SubFrameLen"
        prop Writable :: (CSL.TCP_SUPPORT && .MODE_SETUP == "Shared(SP)" ) ? 1 :0
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable TCP Params"
        prop Set :: (
             if ( $1 < 98 || $1 > 5114) {
                   .error("Sub-Frame Length range [98-5114]")
              } else {
             .SUBFRAMELEN_SETUP = $1,
             .IC1_VALUE = .IC1_VALUE_update(),
             "ok"
              }
        )
     }
prop SUBFRAMELEN_IC1 :: (
             .SUBFRAMELEN_SETUP
          )
inst LASTRELLEN_SETUP ::= 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Last Sub-Frame Reliability Length -1 (LASTR)"
        prop Visible :: 1
	prop JSName :: "tcpIc1LastReliaLen"
        prop Writable :: (CSL.TCP_SUPPORT && .MODE_SETUP == "Shared(SP)" ) ? 1 :0
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable TCP Params"
        prop Set :: ( 
              if ( $1 < 0 || $1 > 127) {
                .error("Last sub-frame length from 0 to 127")
              } else {                 
             .LASTRELLEN_SETUP = $1,
              .IC1_VALUE = .IC1_VALUE_update(),
             "ok"
             }
              
        )
     }
prop LASTRELLEN_IC1 :: (
             .LASTRELLEN_SETUP << 24
          )
inst PROLSIZE_SETUP :: 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Prolog Size (P: 24 to 48)"
        prop Visible :: 1
	prop JSName :: "tcpIc2ProlSize"
        prop Writable :: (CSL.TCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable TCP Params"
        prop Set :: ( 
              if ( $1 < 24 || $1 > 48) {
                .error("Prolog Size range [24-48]")
              } else {        
                   .PROLSIZE_SETUP = $1,
                   .IC2_VALUE = .IC2_VALUE_update(),
                  "ok"
              }
        )
     }
prop PROLSIZE_IC2 :: (
             .PROLSIZE_SETUP
          )
inst NUMSUBBLK_SETUP :: 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Number of Sub-blocks (NSB)"
        prop Visible :: 1
	prop JSName :: "tcpIc2NumSubBlk"
        prop Writable :: (CSL.TCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable TCP Params"
        prop Set :: ( 
              if ( $1 < 0 || $1 > 16) {
                .error("Number of sub-blocks range [0-16]")
              } else {      
                    
               .NUMSUBBLK_SETUP = $1,
              .IC2_VALUE = .IC2_VALUE_update(),  
                  "ok"
              }
        )
     }
prop NUMSUBBLK_IC2 :: (
             .NUMSUBBLK_SETUP << 8
          )
inst LASTNUMSUBBLK_SETUP :: 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Last Number of Sub-blocks (LASTNSB :SP mode only)"
        prop Visible :: 1
	prop JSName :: "tcpIc2LastNumSubBlk"
        prop Writable :: (CSL.TCP_SUPPORT && .MODE_SETUP == "Shared(SP)" ) ? 1 : 0
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable TCP Params"
        prop Set :: ( 
              if ( $1 < 0 || $1 > 16) {
                .error("Number of sub-blocks range [0-16]")
              } else {        
                   .LASTNUMSUBBLK_SETUP = $1,
                   .IC2_VALUE = .IC2_VALUE_update(),
                  "ok"
              }
        )
     }
prop LASTNUMSUBBLK_IC2 :: (
             .LASTNUMSUBBLK_SETUP << 12
          )
inst MAXIT_SETUP :: 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Maximum of Iterations (MAXIT - SA mode only)"
        prop Visible :: 1
	prop JSName :: "tcpIc2Maxit"
        prop Writable :: (CSL.TCP_SUPPORT && .MODE_SETUP == "Standalone(SA)" ) ? 1 : 0
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable TCP Params"
        prop Set :: ( 
              if ( $1 < 0 || $1 > 32) {
                .error("Maximum number of Iterations range [0-32]")
              } else {        
                   .MAXIT_SETUP = $1,
                    .IC2_VALUE = .IC2_VALUE_update(),  
                  "ok"
              }
        )
     }
prop MAXIT_IC2 :: (
             .MAXIT_SETUP << 16
          )
inst SNR_SETUP :: 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " SNR Threshold (SNR - SA mode only)"
        prop Visible :: 1
	prop JSName :: "tcpIc2SnrTh"
        prop Writable :: (CSL.TCP_SUPPORT && .MODE_SETUP == "Standalone(SA)" ) ? 1 : 0
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable TCP Params"
        prop Set :: ( 
              if ( $1 < 0 || $1 > 100) {
                .error("Maximum number of Iterations range [0-100]")
              } else {        
                   .SNR_SETUP = $1,
                   .IC2_VALUE = .IC2_VALUE_update(),  
                  "ok"
              }
        )
     }
prop SNR_IC2 :: (
             .SNR_SETUP << 24
          )
inst NWORDINTER_SETUP :: 0{
        prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Interleaver words/XEVT (NWORDINTER) "
        prop Visible :: 1
	prop JSName :: "tcpIc3NwordInter"
        prop Writable :: (CSL.TCP_SUPPORT && .MODE_SETUP == "Standalone(SA)" ) ? 1 : 0
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "EDMA Operation"
        prop Set :: (    
           if ( $1 > 65535 || $1 < 0 ) {
               .error("Number of Interleaver Words range [0-65535]")
            } else {        
             .NWORDINTER_SETUP = $1,
             .IC3_VALUE = .IC3_VALUE_update(),  
             "ok"
           }
        )
     }
prop NWORDINTER_IC3 :: (
       .NWORDINTER_SETUP            
    )       
inst NWORDSP_SETUP :: 0{
        prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}" 
	prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Systematic and Parity words/XEVT (NWORDSP)"
        prop Visible :: 1
	prop JSName :: "tcpIc3NwordSp"
        prop Writable :: (CSL.TCP_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "EDMA Operation"
        prop Set :: (         
        if ( $1 > 65535 || $1 < 0 ) {
               .error("Number of Systematic and parity Words range [0-65535]")
            } else {   
             .NWORDSP_SETUP = $1,
              .IC3_VALUE = .IC3_VALUE_update(),  
             "ok"
          }
        )
     }
prop NWORDSP_IC3 :: (
       .NWORDSP_SETUP  << 16            
    )       
  
inst NWORDAP_SETUP :: 0 {
       prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: "  Apriori Write words/XEVT (NWORDAP) "
        prop Visible :: 1
	prop JSName :: "tcpIc4NwordAp"
        prop Writable :: (CSL.TCP_SUPPORT && .MODE_SETUP == "Shared(SP)" ) ? 1 : 0
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "EDMA Operation"
        prop Set :: ( 
          if ( $1 > 65535 || $1 < 0 ) {
               .error("Number of Apriori Words/XEVT range [0-65535]")
            } else {           
             .NWORDAP_SETUP = $1,
              .IC4_VALUE = .IC4_VALUE_update(),  
             "ok"
           }
        )
     }
prop NWORDAP_IC4 :: (
       .NWORDAP_SETUP            
    )                   
inst NWORDEXT_SETUP :: 0 {
       prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: "  Extrinsic Read words/REVT (NWORDEXT) "
        prop Visible :: 1
	prop JSName :: "tcpIc4NwordExt"
        prop Writable :: (CSL.TCP_SUPPORT && .MODE_SETUP == "Shared(SP)" ) ? 1 : 0
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "EDMA Operation"
        prop Set :: (            
             if ( $1 > 65535 || $1 < 0 ) {
               .error("Number of Extrinsic Words range [0-65535]")
            } else {
             .NWORDEXT_SETUP = $1,
             .IC4_VALUE = .IC4_VALUE_update(),  
             "ok"
            }
        )
     }
prop NWORDEXT_IC4 :: (
       .NWORDEXT_SETUP << 16            
    )                   
inst NWORDHD_SETUP :: 0 {
       prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: "  Hard Decision words/REVT (NWORDHD) "
        prop Visible :: 1
	prop JSName :: "tcpIc5NwordHd"
        prop Writable :: (CSL.TCP_SUPPORT && .MODE_SETUP == "Standalone(SA)" ) ? 1 : 0
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "EDMA Operation"
        prop Set :: (            
           if ( $1 > 255 || $1 < 0 ) {
               .error("Number of Hard Decision Words range [0-255]")
            } else {
             .NWORDHD_SETUP = $1,
             .IC5_VALUE = .IC5_VALUE_update(),  
             "ok"
           }
        )
     }
prop NWORDHD_IC5 :: (
       .NWORDHD_SETUP            
    )                   
  prop IC0_VALUE_update :: (       .OPMOD_IC0()                     
                                 |.RATE_IC0() 
                                 | .FRAMELEN_IC0() 
                                 | .OUTF_IC0() 
                                 | .INTER_IC0()
                                    
                              )
  prop IC0_SETUP_update :: (
        .FRAMELEN_SETUP = ($1 & 0xFFFF0000) >> 16, 
        .OUTF_SETUP = ($1 & 0x00002000) ? "Enable" : "Disable",
        .INTER_SETUP = ($1 & 0x00001000) ? "Enable" : "Disable",
	.RATE_SETUP = ( $a = ($1 & 0x00000300) ,
                        ($a == 0x00000100) ? "1/2" :
	                ($a == 0x00000200) ? "1/3" :
                        ($a == 0x00000300) ? "1/4" : "None"),
        .MAP_SETUP = ( $a =($1 & 0x0000000E),
                        ($a == 0x00000008) ? "MAP1(1st Iter.)" :
	                ($a == 0x0000000A) ? "MAP1(Any Other Iter.)" :
                        ($a == 0x0000000E) ? "MAP2" : "MAP1(1st Iter.)" ),
       .MODE_SETUP =  ( $a =($1 & 0x0000000E),
                        ($a == 0x00000000) ? "Standalone(SA)" : "Shared(SP)" )
        
       )
inst IC0_VALUE :: .IC0_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Input Configuration Reg 0 (IC0)"
     prop Format :: "0x%08X"
     prop Style :: 0x02
	prop JSName :: "tcpIc0"
      prop Visible :: 1
      prop Writable :: CSL.TCP_SUPPORT
      prop NoGen :: 1
      prop cGen :: 1
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
             .IC0_VALUE = ($1 & 0xFFFFF70E),
             .IC0_SETUP_update($1),
             "ok"
             
        )
      } 
prop IC1_VALUE_update :: (       .LASTRELLEN_IC1()                     
                                 |.RELLEN_IC1() 
                                 | .SUBFRAMELEN_IC1() 
                            ) 
 prop IC1_SETUP_update :: (
        .LASTRELLEN_SETUP = ($1 & 0x7F000000) >> 24, 
        .RELLEN_SETUP = ($1 & 0x007F0000) >> 16,
        .SUBFRAMELEN_SETUP = ($1 & 0x0000FFFF)
     )
inst IC1_VALUE :: .IC1_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Input Configuration Reg 1 (IC1)"
     prop Format :: "0x%08X"
     prop Style :: 0x02
	prop JSName :: "tcpIc1"
      prop Visible :: 1
      prop Writable :: CSL.TCP_SUPPORT
      prop NoGen :: 1
      prop cGen :: 1
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
             .IC1_VALUE = ($1 & 0x7F7FFFFF),
             .IC1_SETUP_update($1),
             "ok"
             
        )
      } 
prop IC2_VALUE_update :: (       .SNR_IC2()                     
                                 |.MAXIT_IC2() 
                                 | .LASTNUMSUBBLK_IC2() 
                                 | .NUMSUBBLK_IC2() 
                                 | .PROLSIZE_IC2() 
                            ) 
prop IC2_SETUP_update :: (
        .SNR_SETUP = ($1 & 0xFF000000) >> 24, 
        .MAXIT_SETUP = ($1 & 0x001F0000) >> 16,
        .LASTNUMSUBBLK_SETUP = ($1 & 0x0000F000) >> 12,
        .NUMSUBBLK_SETUP = ($1 & 0x00000F00) >> 8,
        .PROLSIZE_SETUP = ($1 & 0x0000003F)
   )
     
inst IC2_VALUE :: .IC2_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Input Configuration Reg 2 (IC2)"
     prop Format :: "0x%08X"
     prop Style :: 0x02
	prop JSName :: "tcpIc2"
      prop Visible :: 1
      prop Writable :: CSL.TCP_SUPPORT
      prop NoGen :: 1
      prop cGen :: 1
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
             .IC2_VALUE = ($1 & 0xFF1FF3F),
             .IC2_SETUP_update($1),
             "ok"
             
        )
      } 
     prop IC3_VALUE_update :: (  .NWORDINTER_IC3()                     
                                 |.NWORDSP_IC3() 
                         )
     prop IC3_SETUP_update :: (
        .NWORDINTER_SETUP = ($1 & 0x0000FFFF) ,
        .NWORDSP_SETUP = ($1 & 0xFFFF0000) >> 16
       )
inst IC3_VALUE :: .IC3_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Input Configuration Reg 3 (IC3)"
      prop Format :: "0x%08X"
      prop Style :: 0x02
      prop JSName :: "tcpIc3"
      prop Visible :: 1
      prop Writable :: CSL.TCP_SUPPORT
      prop NoGen :: 1
      prop cGen :: 1
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
             .IC3_VALUE = $1 ,
             .IC3_SETUP_update($1),
             "ok"
             
        )
      } 
prop IC4_VALUE_update :: (        .NWORDAP_IC4()                     
                                 |.NWORDEXT_IC4() 
                         )
     prop IC4_SETUP_update :: (
        .NWORDAP_SETUP = ($1 & 0x0000FFFF),
        .NWORDEXT_SETUP = ($1 & 0xFFFF0000) >> 16
       )
inst IC4_VALUE :: .IC4_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Input Configuration Reg 4 (IC4)"
      prop Format :: "0x%08X"
      prop Style :: 0x02
      prop JSName :: "tcpIc4"
      prop Visible :: 1
      prop Writable :: (CSL.TCP_SUPPORT && .MODE_SETUP == "Shared(SP)") ? 1 : 0
      prop NoGen :: 1
      prop cGen :: 1
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
             .IC4_VALUE = $1 ,
             .IC4_SETUP_update($1),
             "ok"
             
        )
      } 
    prop IC5_VALUE_update :: (        .NWORDHD_IC5() & 0x000000FF                                                     
                         )
     prop IC5_SETUP_update :: (
        .NWORDHD_SETUP = ($1 & 0x000000FF) 
       )
inst IC5_VALUE :: .IC5_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Input Configuration Reg 5 (IC5)"
      prop Format :: "0x%08X"
      prop Style :: 0x02
      prop JSName :: "tcpIc5"
      prop Visible :: 1
      prop Writable :: CSL.TCP_SUPPORT
      prop NoGen :: 1
      prop cGen :: 1
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
             .IC5_VALUE = $1 ,
             .IC5_SETUP_update($1),
             "ok"
             
        )
      } 
inst IC6_VALUE :: 0x00000000 {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Input Configuration Reg 6 (IC6)"
      prop Format :: "0x%08X"
      prop Style :: 0x02
      prop Writable :: CSL.TCP_SUPPORT
      prop NoGen :: 1
      prop cGen :: 1
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
}
inst IC7_VALUE :: 0x00000000 {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Input Configuration Reg 7 (IC7)"
      prop Format :: "0x%08X"
      prop Style :: 0x02
      prop Writable :: CSL.TCP_SUPPORT
      prop NoGen :: 1
      prop cGen :: 1
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
}
inst IC8_VALUE :: 0x00000000 {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Input Configuration Reg 8 (IC8)"
      prop Format :: "0x%08X"
      prop Style :: 0x02
      prop Writable :: CSL.TCP_SUPPORT
      prop NoGen :: 1
      prop cGen :: 1
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
}
inst IC9_VALUE :: 0x00000000 {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Input Configuration Reg 9 (IC9)"
      prop Format :: "0x%08X"
      prop Style :: 0x02
      prop Writable :: CSL.TCP_SUPPORT
      prop NoGen :: 1
      prop cGen :: 1
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
}
inst IC10_VALUE :: 0x00000000 {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Input Configuration Reg 10 (IC10)"
      prop Format :: "0x%08X"
      prop Style :: 0x02
      prop Writable :: CSL.TCP_SUPPORT
      prop NoGen :: 1
      prop cGen :: 1
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
}
inst IC11_VALUE :: 0x00000000 {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Input Configuration Reg 11 (IC11)"
      prop Format :: "0x%08X"
      prop Style :: 0x02
      prop Writable :: CSL.TCP_SUPPORT
      prop NoGen :: 1
      prop cGen :: 1
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
}
  }  
type hTcp {     
 
   
   prop IsContainedIn :: TCPFOLDER
   prop name :: "hTcp"     	    	
   prop Label :: "TCP Resource Manager"
   prop JSName :: "HTCP"     	    	
   prop NoGen :: 1
    prop GlobalPropertyPage :: "{B936FB81-49A5-11d4-967C-0050048381C6}"
   prop InstancePropertyPage :: "{B936FB81-49A5-11d4-967C-0050048381C5}"
   prop GlobalIcon :: 197
   prop InstanceIcon :: 198
    prop GlobalHelpTopic :: (
	   1083
   )
     
   prop cGen :: 1
 
   global TCP_INITPARAM_ENABLE :: 0 {        
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Enable Parameters Setting"
	  prop JSName :: "tcpEnableParams"
	  prop Visible :: 1
	  prop Writable :: (CSL.TCP_SUPPORT)
	  prop NoGen :: 0
          prop Set :: (
          $a = 0,
            scan ($b ; tcpBaseParam) { $a = $a + 1},
                  if ( $1 == 1 && $a ==1 &&  .TCP_INITPARAM == TCP_PARAMNULL ) 
                 {         
                 " You must create a new BaseParams object"
                 } else { 
                      .TCP_INITPARAM_ENABLE = $1,
		      if ( $1 == 0) {
		      .TCP_INITPARAM = TCP_PARAMNULL,
                      .TCP_PARAMCONFIGNAME = "NULL",
		      .TCP_SETPARAM_ENABLE = 0
		      },
			"ok"
                  }      
	  )      
    	}
	global TCP_INITPARAM :: TCP_PARAMNULL {
	    prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	    prop MemberType :: tcpBaseParam
	    prop Label :: " Pre-Initialize with"
	    prop JSName :: "tcpBaseParamInit"
	    prop Visible :: 1
	    prop Writable :: (CSL.TCP_SUPPORT) &&  (.TCP_INITPARAM_ENABLE == 1) ? 1 :0 
    }
 
       
     global TCP_PARAMCONFIGNAME :: "NULL" {
       prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
       prop Label :: "Output TCP Params ConfigName (ex: tcpParam) "
       prop JSName :: "tcpParamConfigName"
       prop Visible :: 1
       prop Writable :: (CSL.TCP_SUPPORT) &&  (.TCP_INITPARAM_ENABLE == 1) ? 1 :0 
       prop Set :: ( 
                      if ( $1 == "") {
                     .TCP_PARAMCONFIGNAME = "NULL",
                     "ok" 
                    } else {
                      .TCP_PARAMCONFIGNAME = $1,
                      "ok" 
                      } 
                  )
            }
                         
    
   global TCP_SETPARAM_ENABLE :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Set TCP Params Values to the IC Config. Obj"
	  prop JSName :: "tcpSetParamEnable"
	  prop Visible :: 1
	  prop Writable :: (CSL.TCP_SUPPORT && .TCP_INITPARAM_ENABLE)
	  prop NoGen :: 0
          prop Set :: (
          $a = 0,
            scan ($b ; tcpCfg) { $a = $a + 1},
                  if ( $1 == 1 && $a ==1 &&  .TCP_INIT == TCP_NOTHING ) 
                 {         
                 " You must create a configuration object"
                 } else { 
                      .TCP_SETPARAM_ENABLE = $1,
		      if ( $1 == 0 && .TCP_INIT_ENABLE == 0) {
		      .TCP_INIT = TCP_NOTHING
		      },
			"ok"
                  }      
	  )      
    	}
    
   global TCP_INIT_ENABLE :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Enable TCP Pre-Initialization "
	  prop JSName :: "tcpEnablePreInit"
	  prop Visible :: 1
	  prop Writable :: (CSL.TCP_SUPPORT )
	  prop NoGen :: 0
          prop Set :: (
          $a = 0,
            scan ($b ; tcpCfg) { $a = $a + 1},
                  if ( $1 == 1 && $a ==1 &&  .TCP_INIT == TCP_NOTHING ) 
                 {         
                 " You must create a new configuration object"
                 } else { 
                      .TCP_INIT_ENABLE = $1,
		      if ( $1 == 0 && .TCP_SETPARAM_ENABLE == 0) {
		      .TCP_INIT = TCP_NOTHING
		      },
			"ok"
                  }      
	  )      
    	}
	global TCP_INIT :: TCP_NOTHING {
	    prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	    prop MemberType :: tcpCfg
	    prop Label :: " Pre-Initialize with"
	    prop JSName :: "tcpPreInit"
	    prop Visible :: 1
	    prop Writable :: (CSL.TCP_SUPPORT) &&  ((.TCP_INIT_ENABLE == 1) || (.TCP_SETPARAM_ENABLE ==1 )) ? 1 :0 
    }
 
}
object TCP_NOTHING :: tcpCfg {
       param iIsUsed :: 0
}
object TCP_PARAMNULL :: tcpBaseParam {
       param iIsUsed :: 0
}
 
type TIMERFOLDER {
   isa ModuleFolder
   prop IsContainedIn :: CSL  
    prop name :: "TIMER"
    prop Label :: "TIMER - Timer Device"
    prop NoGen :: 1
    
    prop GlobalHelpTopic :: (
        1060
    )
   
   prop GlobalPropertyPage :: "{33A68984-598D-11d4-B5CC-0050DA2E2CC0}"
   prop InstancePropertyPage :: "{33A68985-598D-11d4-B5CC-0050DA2E2CC0}"
                        
     
   prop GlobalIcon :: 161
   prop InstanceIcon :: 162
} 
        
      
type timerCfg {
        isa ObjectMgr
        prop Name :: "timerCfg"
        prop Label :: "TIMER Configuration Manager"
        prop JSName :: "TIMER"
        prop IsContainedIn :: TIMERFOLDER
        prop NoGen :: 1
        
        prop GlobalHelpTopic :: (
           1061
        )
        
        
        prop InstanceHelpTopic :: (
           1061
        )
        prop GlobalPropertyPage :: "{33A68982-598D-11d4-B5CC-0050DA2E2CC0}"
        prop InstancePropertyPage :: "{33A68983-598D-11d4-B5CC-0050DA2E2CC0}"
            prop GlobalIcon :: 161
        prop InstanceIcon :: 162
        prop cGen :: 1
            prop cStruct :: 1
            prop cStructType :: "TIMER_Config"
        prop cHeaderName :: .gNumOf > 0 ? "csl_timer.h" : ""
        prop cStructQual :: "far"   
   
        prop localDelete :: (
         .myDelete
           )           
        prop myDelete :: (
         $a=0,
          scan($b; timerCfg) { 
               $a = $a + 1
           },                 
          if ($a == 2) {
           scan($c;hTimer) {
                $c.TIMER_INIT_ENABLE = 0
                  }
                },
                "ok"
           )           
    
    inst CLKSRC_SETUP :: "External Source" {
          prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
          prop Enum :: "External Source,(CPU clock)/4,(CPU clock)/8"
        prop Label :: "Input Clock Source (CLKSRC) "
        prop JSName :: "timerCtlClksrc"
        prop Visible :: 1
        prop Writable :: CSL.TIMER_SUPPORT
        prop NoGen :: 1
        prop TabName :: "Clock Control "
        prop Set :: (
                 if (CSL.C64_SUPPORT) {                                             
               if ($1 == "(CPU clock)/4") {
                 .error("Invalid Selection for C64x")
               } else {         
                      .CLKSRC_SETUP = $1,
                      .CTL_VALUE = .CTL_VALUE_update(),
                      "ok"
                 }
               } else {
                  if ($1 == "(CPU clock)/8") {
                 .error("Invalid Selection, For C64x Only")
               }  else {
                   .CLKSRC_SETUP = $1,
                      .CTL_VALUE = .CTL_VALUE_update(),
                      "ok"
                  }
                 }
             )
         }
    prop CLKSRC_CTL :: (
         if (.CLKSRC_SETUP == "(CPU clock)/4") {
            0x00000200
        } else {  
           if (.CLKSRC_SETUP == "(CPU clock)/8") {
            0x00000200
            } else {
               0x00000000
                  }
          }                                                
    ) 
    inst CP_SETUP :: "Pulse mode" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Pulse mode,Clock mode"
        prop Label :: "Clock/Pulse Mode (CP) "
        prop JSName :: "timerCtlCp"
        prop Visible :: 1
        prop Writable :: CSL.TIMER_SUPPORT
        prop NoGen :: 1
        prop TabName :: "Clock Control "
        prop Set :: (
                .CP_SETUP = $1,
                .CTL_VALUE = .CTL_VALUE_update(),
                "ok"
                )
         }
    prop CP_CTL :: (
        if (.CP_SETUP == "Clock mode") {
            0x00000100
        }
        else {
            0x00000000
                }
    ) 
   inst PWID_SETUP :: "One clock cycle" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "One Clock cycle,Two Clock cycles"
        prop Label :: "Pulse Width (PWID)"
        prop JSName :: "timerCtlPwid"
        prop Visible :: 1
        prop Writable :: CSL.TIMER_SUPPORT && ((.CP_SETUP == "Pulse mode") ? 1 :0)
        prop NoGen :: 1
        prop TabName :: "Clock Control "
        prop Set :: (
                .PWID_SETUP = $1,
                .CTL_VALUE = .CTL_VALUE_update(),
                "ok"
              )
         }
    prop PWID_CTL :: (
        if (.PWID_SETUP == "Two Clock cycles") {
            0x00000010
        } else {
            0x00000000
          }
    ) 
    
 inst FUNC_SETUP :: "General-Purpose Output" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "General-Purpose Output,Timer Output"
        prop Label :: "Function of TOUT (FUNC)"
        prop JSName :: "timerCtlFunc"
        prop Visible :: 1
        prop Writable :: CSL.TIMER_SUPPORT
        prop NoGen :: 1
        prop TabName :: "Pin Control "          
        prop Set :: (
                .FUNC_SETUP = $1,
                .CTL_VALUE = .CTL_VALUE_update(),
                "ok"
          )      
    }
    prop FUNC_CTL :: (
        if  (.FUNC_SETUP == "Timer Output") {
         0x00000001
         } else {
         0x00000000
         }  
    ) 
 inst DATOUT_SETUP :: 0 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    DATA output (TOUT pin)"
        prop Visible :: 1
        prop JSName :: "timerCtlDatout"
        prop Writable :: CSL.TIMER_SUPPORT && ((.FUNC_SETUP== "General-Purpose Output" ) ? 1 :0)
        prop NoGen :: 1
        prop TabName :: "Pin Control "
          prop Set :: (
              if ( $1 < 0 || $1 > 1) {
                 .error ("Binary value required : 0 or 1")
              } else {
                .DATOUT_SETUP = $1,
                .CTL_VALUE = .CTL_VALUE_update(),
                "ok"
                }
            )
    }
    prop DATOUT_CTL :: (
        (.DATOUT_SETUP  << 2)
    )
 inst INVOUT_SETUP :: "Uninverted" {
          prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
          prop Enum :: "Uninverted,Inverted"
        prop Label :: "    TOUT Inverter Control (INVOUT)"
        prop JSName :: "timerCtlInvout"
        prop Visible :: 1
        prop Writable :: ((.FUNC_SETUP == "Timer Output") ? 1 : 0)
        prop NoGen :: 1
        prop TabName :: "Pin Control "
        prop Set :: (
                .INVOUT_SETUP = $1,
                .CTL_VALUE = .CTL_VALUE_update(),
                "ok"
            )
       }
    prop INVOUT_CTL :: (
        if (.INVOUT_SETUP == "Inverted") {
            0x00000002
        }
        else {
            0x00000000
                }
    ) 
   
    inst INVINP_SETUP :: "Uninverted" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Uninverted,Inverted"
        prop Label :: "    TINP Inverter Control (INVINP)"
        prop JSName :: "timerCtlInvinp"
        prop Visible :: 1
        prop Writable :: CSL.TIMER_SUPPORT && ((.CLKSRC_SETUP == "External Source") ? 1 : 0)
        prop NoGen :: 1
        prop TabName :: "Pin Control "
          prop Set :: (
                .INVINP_SETUP = $1,
                .CTL_VALUE = .CTL_VALUE_update(),
                "ok"
        )
         }
    prop INVINP_CTL :: (
        if (.INVINP_SETUP == "Inverted") {
            0x00000400
        }
        else {
            0x00000000
                }
    )
    
  inst GO_HLD_SETUP :: "Hold" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "Hold,Restart (no-reset),Start with reset"
        prop Label :: "Timer Operation"
        prop JSName :: "timerCtlGoHold"
        prop Visible :: 1
        prop Writable :: CSL.TIMER_SUPPORT
        prop NoGen :: 1
        prop TabName :: "Counter Control "
          prop Set :: (
                .GO_HLD_SETUP = $1,
                .CTL_VALUE = .CTL_VALUE_update(),
                "ok"
        )
    }
    prop GO_HLD_CTL :: (
        if (.GO_HLD_SETUP == "Hold") {
            0x00000000
        } else {
             if (.GO_HLD_SETUP == "Restart (no-reset)") {
                0x00000080
               } else {
                   0x000000c0
                  }
          }      
      )
inst PERIOD_SETUP :: 0 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X" 
        prop Label :: "Period Value "
        prop JSName :: "timerPrd"
        prop Visible :: 1
        prop Writable :: CSL.TIMER_SUPPORT
        prop NoGen :: 1
        prop TabName :: "Counter Control "
          prop Set :: (
                .PERIOD_SETUP = $1,
                .PRD_VALUE = .PRD_VALUE_update(),
                "ok"
        )
    }
    prop PERIOD_PRD :: (
        (.PERIOD_SETUP)            
      )
      
inst COUNTER_SETUP :: 0 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08X" 
        prop Label :: "Counter value (optional)"
        prop JSName :: "timerCnt"
        prop Visible :: 1
        prop Writable :: CSL.TIMER_SUPPORT
        prop NoGen :: 1
        prop TabName :: "Counter Control "
          prop Set :: (
                .COUNTER_SETUP = $1,
                .CNT_VALUE = .CNT_VALUE_update(),
                "ok"
        )
    }
    prop COUNTER_CNT :: (
       (.COUNTER_SETUP)            
      )
      
 
prop CTL_VALUE_update :: (
    .INVINP_CTL()
   |.CLKSRC_CTL()
   |.CP_CTL()
   |.GO_HLD_CTL()
   |.PWID_CTL()
  
   |.DATOUT_CTL()
   |.INVOUT_CTL()
   |.FUNC_CTL()
  )
prop CTL_SETUP_update :: (
     .INVINP_SETUP = ( $1 & 0x00000400) ? "Inverted": "Uninverted",
     if (CSL.C64_SUPPORT) {                                                           
     .CLKSRC_SETUP = ( $1 & 0x00000200) ? "(CPU clock)/8": "External Source"
     } else {
     .CLKSRC_SETUP = ( $1 & 0x00000200) ? "(CPU clock)/4": "External Source"
     },                                                                             
     .CP_SETUP     = ( $1 & 0x00000100) ? "Clock mode": "Pulse mode",
     .GO_HLD_SETUP  = ( $a = ( $1 & 0x000000c0),
                         ( $a == 0x000000c0) ? "Start with reset":
                         ( $a == 0x00000080) ? "Restart (no-reset)": "Hold"),
     .PWID_SETUP   = ( $1 & 0x00000010) ? "Two clock cycles": "One clock cycle",
      
     .DATOUT_SETUP = (( $1 & 0x00000004) >> 2) , 
     .INVOUT_SETUP = ( $1 & 0x00000002) ? "Inverted": "Uninverted",
     .FUNC_SETUP   = ( $1 & 0x00000001) ? "Timer Output" : "General-Purpose Output"
  )   
   
  inst CTL_VALUE :: .CTL_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Control Register (CTL) "
        prop Format :: "0x%08X"
        prop JSName :: "timerCtlAdv"
        prop Visible :: 1
        prop Writable :: CSL.TIMER_SUPPORT
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
           prop TabName :: "Advanced"
        prop Set :: (
           
             $a = $1 & 0x000000c0,
             if ( $a == 0x00000040)  {
             .error ("Fields GO='1'& HOLD='0' : Undefined Timer Operation - See Counter Control Page")            
            } else {
                $b = $1 & 0xFFFFF000,         
                if ( $b != 0) {
                .error("Bit field (bit[12..31]) is reserved")
                } else {
                  $c = $1 & 0x00000020,
                  if( $c != 0) {
                     .error("Bit field 5 is reserved")
                     } else {
                         .CTL_VALUE = $1,
                         .CTL_SETUP_update($1),
                              "ok"
                       }
                   }   
               }
       )
   }
 prop PRD_VALUE_update :: (
   .PERIOD_PRD()
 )
 prop PRD_SETUP_update :: (
    .PERIOD_SETUP = $1
 )
  inst PRD_VALUE :: .PRD_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Period Register (PRD) "
        prop Format :: "0x%08X"
        prop JSName :: "timerPrdAdv"
        prop Visible :: 1
        prop Writable :: CSL.TIMER_SUPPORT
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
           prop TabName :: "Advanced"
        prop Set :: (
               .PRD_VALUE = $1,
               .PRD_SETUP_update($1),
                 "ok"
         )          
    }
 prop CNT_VALUE_update :: (
   .COUNTER_CNT()
 )
 prop CNT_SETUP_update :: (
    .COUNTER_SETUP = $1
 )
  inst CNT_VALUE :: .CNT_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Counter Register (CNT) "
        prop Format :: "0x%08X"
        prop JSName :: "timerCntAdv"
        prop Visible :: 1
        prop Writable :: CSL.TIMER_SUPPORT
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
           prop TabName :: "Advanced"
        prop Set :: (
               .CNT_VALUE = $1,
               .CNT_SETUP_update($1),
                 "ok"
         )          
    }
    
} 
type hTimer {
        isa ObjectMgr
        prop name :: "hTimer"
        prop Label :: "TIMER Resource Manager"
        prop JSName :: "HTIMER"
        
        prop IsContainedIn :: TIMERFOLDER
        prop NoGen :: 1
        prop GlobalPropertyPage :: "{33A68980-598D-11d4-B5CC-0050DA2E2CC0}"
        prop InstancePropertyPage :: "{33A68981-598D-11d4-B5CC-0050DA2E2CC0}"
        prop GlobalIcon :: 161
        prop InstanceIcon :: 162
        prop GlobalHelpTopic :: (
           1062
        )
        
        prop InstanceHelpTopic :: (
           1063
        )
  
      prop maxObjs :: 3
    
      
  
        prop localCanCreate :: (
        .error("New Timer handle objects cannot be created")
       )
        prop localCanDelete :: (
        .error("Timer handle objects cannot be deleted")
       )    
      prop chipcall :: (     
        scan ($i; hTimer) {
            if ( CSL.CHIP_6400 && $i.DEVICE == "TIMER2" ) {
                $i.TIMER_HANDLE_ENABLE = 0,
                $i.TIMER_INIT_ENABLE = 0,
                $i.cOpenArg0 = "TIMER_None"
                }
           },    
           if (.CHIPCHAIN != nil) {
                 $e = .CHIPCHAIN.chipcall()
            },
            "ok"
        )
       
     
         prop localInit :: (
            .CHIPCHAIN = GBL.CHIPCHAIN,
            GBL.CHIPCHAIN = hTimer
        )
        global CHIPCHAIN :: nil {
            prop Visible :: 0
            prop Writable :: 0
            prop NoGen :: 1
        }
        prop cGen ::  1
        
        prop cHeaderName :: (
            $a = "",
            scan ($b; hTimer) {
                if ($b.TIMER_HANDLE_ENABLE == 1) {
                    $a = "csl_timer.h"
                }
            },
            $a
        )
       
        prop cStructQual :: "far"   
         
         prop cOpenName :: "TIMER_open"
         prop cConfigName :: "TIMER_config"
          
 
  inst TIMER_HANDLE_ENABLE :: 0 {
          prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
          prop Label :: "Open Timer Device"
          prop JSName :: "timerHandleEnable"
          prop Visible :: 1
          prop Writable :: (CSL.TIMER_SUPPORT && (( .DEVICE == "TIMER0" || .DEVICE == "TIMER1")) ) || ( CSL.TIMER2_SUPPORT ) ? 1: 0  
          prop NoGen :: 1
          prop Set :: (
              $a = 0,
             if ( $1 == 0) {
                      .TIMER_HANDLE_ENABLE = $1,
                .TIMER_INIT_ENABLE = $1,
                .TIMER_INIT=TIMER_NOTHING,
                if(.DEVICE == "TIMER0")
                {        
                   HWI_INT14.client = "USER"
                }
                else{
                   if(.DEVICE == "TIMER1")
                   {
                      HWI_INT15.client = "USER"
                   }
                },
                .cOpenArg0 = "TIMER_None",
                "ok"
            } else {               
                 
                     if ( .DEVICE== "TIMER0" && (CLK.WHICHTIMER == "Timer 0" && CLK.USETIMER == 1)) {
                      .TIMER_HANDLE_ENABLE = 0,
                      .error("TIMER0 already used by the CLK module")
                      } else {
                     if ( .DEVICE == "TIMER1" && (CLK.WHICHTIMER == "Timer 1" && CLK.USETIMER == 1)) {
                      .TIMER_HANDLE_ENABLE = 0,
                        .error("TIMER1 already used by the CLK module")
                        } else {
                          if ( .DEVICE == "TIMER2" && (CLK.WHICHTIMER == "Timer 2" && CLK.USETIMER == 1)) {
                         .TIMER_HANDLE_ENABLE = 0,
                        .error("TIMER2 already used by the CLK module")
                          } else {       
                         .TIMER_HANDLE_ENABLE = $1,  
                       if ( .DEVICE == "TIMER0") {
                          .cOpenArg0 = "TIMER_DEV0", 
                           HWI_INT14.client = "CSL",
                           "ok"
                        } else { 
                        if ( .DEVICE == "TIMER1") { 
                          .cOpenArg0 = "TIMER_DEV1", 
                          HWI_INT15.client = "CSL",
                          "ok" 
                          } else {
                          .cOpenArg0 = "TIMER_DEV2", 
                          "ok" 
                           }
                       }   
                     } 
                                   
                   } 
                } 
              }  
            
            
          )
            }  
  prop cHandle :: (.cOpenGen)
  prop cHandleType :: "TIMER_Handle"
  
  
    inst HandleName :: self {
             prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
             prop Label :: " Handle  "
             prop JSName :: "timerHandleName"
             prop Visible :: 1
             prop Writable :: (.TIMER_HANDLE_ENABLE == 1) ? 1 :0
           }
           
    prop cHandleName ::   .HandleName 
     
 
 
 
   inst DEVICE:: "TIMER0" 
        {
         prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
         prop Enum :: "TIMER0,TIMER1,TIMER2"
         prop Label :: "         Device"
         prop Visible :: 0
         prop Writable :: 0
         prop NoGen :: 1                             
         }
  inst cOpenGen ::= ( CSL.TIMER_SUPPORT && .TIMER_HANDLE_ENABLE == 1 && .HandleName != "") {
            prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
           
            prop Visible :: 0
            prop NoGen :: 1
          }
  
     
        inst cOpenArg0 :: (
       if ( .TIMER_HANDLE_ENABLE == 0) {
                   "TIMER_None"  
        }
       )    {    
             prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
             prop Label :: "    Arg0  "
             prop Visible :: 0
             prop Writable :: 0
             prop NoGen :: 1 
           }
         
        inst cOpenArg1 :: "TIMER_OPEN_RESET" {
             prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
             prop Label :: "Pre-initialize (Default) "
             prop Visible :: 0
             prop Writable :: 0
             prop NoGen :: 1 
        }
        
   inst TIMER_INIT_ENABLE :: 0 {
          prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
          prop Label :: "Enable Pre-Initialization"
          prop JSName :: "timerEnablePreInit"
          prop Visible :: 1
          prop Writable :: CSL.TIMER_SUPPORT && (.TIMER_HANDLE_ENABLE == 1)  ? 1 : 0
          prop NoGen :: 1
          prop Set :: (
              $a = 0,
                scan($b; timerCfg) { 
                      $a = $a + 1
                  },                 
                if ($a == 1) {
                         .TIMER_INIT_ENABLE = 0,
               .error("You must create a new configuration object")
                } else {               
                         .TIMER_INIT_ENABLE = $1,
                        if ( $1 == 0) {
                        .TIMER_INIT=TIMER_NOTHING
                        },
                        "ok"
                }           
          )
            }
        inst TIMER_INIT :: TIMER_NOTHING {
            prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
            prop MemberType :: timerCfg
            prop Label :: " Pre-Initialize with"
            prop JSName :: "timerPreInit"
            prop Visible :: 1
            prop Writable :: (.TIMER_INIT_ENABLE == 1 && .TIMER_HANDLE_ENABLE == 1) ? 1: 0
            prop NoGen :: 0
               }
    inst cConfigGen ::= ( (.TIMER_INIT_ENABLE == 1) && (.TIMER_INIT != TIMER_NOTHING) && (.TIMER_HANDLE_ENABLE == 1) && (.HandleName != "") ) {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
      }
         inst cConfigArg0 ::= .cHandleName {
            prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
            prop Label :: "Config argument 0"
            prop Visible :: 0
        }
 
   inst cConfigArg1 ::= .TIMER_INIT {
         prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
          prop MemberType :: timerCfg
          prop Label :: "Pre-initialize Config"
          prop Visible :: 0
          prop Writable :: 0
          prop NoGen :: 0
          prop cPreVal :: "&"
    }
  
}
object Timer_Device0 :: hTimer {
         param iComment :: "Timer 0"  
         param iIsUsed :: 1
         param iDelUser :: "hTimer"
          param iDelMsg :: (
        "This TIMER Handle object cannot be deleted"
        )  
         param HandleName :: "hTimer0"  
         param DEVICE :: "TIMER0"
         param TIMER_INIT :: TIMER_NOTHING
       }
       
object Timer_Device1 :: hTimer {
         param iComment :: "Timer 1"  
         param iIsUsed :: 1
         param iDelUser :: "hTimer"         
         param iDelMsg :: (
        "This TIMER Handle object cannot be deleted"
        )   
         param HandleName :: "hTimer1"  
         param DEVICE :: "TIMER1"
         param TIMER_INIT :: TIMER_NOTHING
       }  
         
 object Timer_Device2 :: hTimer {
         param iComment :: "Timer 2"  
         param iIsUsed :: 1
         param iDelUser :: "hTimer"
          param iDelMsg :: (
        "This TIMER Handle object cannot be deleted"
        )  
         param HandleName :: "hTimer2"  
         param DEVICE :: "TIMER2"
         param TIMER_INIT :: TIMER_NOTHING
       }  
object TIMER_NOTHING :: timerCfg {
       param iIsUsed :: 0
}
type VCPFOLDER {
    prop Label :: "Viterbi Decoder Coprocessor - VCP "
    prop GlobalIcon :: 195
    prop InstanceIcon :: 196
    prop GlobalHelpTopic :: 1090
     prop GlobalPropertyPage :: "{B936FB82-49A5-11d4-967C-0050048381C7}"
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}
type vcpBaseParam {
      isa ObjectMgr
      prop name :: "vcpBaseParam"
      prop Label :: "VCP Parameters Manager"
      prop JSName :: "VCPBP"
      prop IsContainedIn :: VCPFOLDER
      prop GlobalIcon :: 195
      prop InstanceIcon :: 196
      prop GlobalHelpTopic :: 1091
      prop InstanceHelpTopic :: 1091
      prop GlobalPropertyPage :: "{B936FB82-49A5-11d4-967C-0050048381C8}"
      prop InstancePropertyPage :: "{B936FB82-49A5-11d4-967C-0050048381C9}"
      prop Vendor :: "vendor1"
      prop Version :: "1.00.00"
	
	prop NoGen :: 1
        prop cGen :: CSL.VCP_SUPPORT 
    	prop cStruct :: CSL.VCP_SUPPORT
    	prop cStructType :: "VCP_BaseParams"
	prop cHeaderName :: .gNumOf > 0 ? "csl_vcp.h" : ""
 
	prop cStructQual :: "far"
        prop cStructName :: self
           	
	prop cConfigName :: "VCP_BaseParams"
     prop localDelete :: (
        .myDelete
      )      
 prop myDelete :: (
        $a=0,
        scan($b; vcpBaseParam) { 
             $a += 1
        }, 		
        if($a == 2 ) {
              hVcp.VCP_INITPARAM_ENABLE = 0             
          },
        "ok"
      )          
       prop ParamConfigType :: (hVcp.VCP_INITPARAM_ENABLE == 1 && hVcp.VCP_PARAMCONFIGNAME != "NULL") ? "VCP_Params " : ""
       prop ParamConfigName :: (hVcp.VCP_INITPARAM_ENABLE == 1 && hVcp.VCP_PARAMCONFIGNAME != "NULL") ? hVcp.VCP_PARAMCONFIGNAME : ""
       prop ParamEnd :: (hVcp.VCP_INITPARAM_ENABLE == 1 && hVcp.VCP_PARAMCONFIGNAME != "NULL") ? ";\n" : ""
       prop cGenCEpilogue :: ("%1S%2S%3S\n\0,ParamConfigType,ParamConfigName,ParamEnd")    
 
      prop GenParamStr :: (hVcp.VCP_INITPARAM_ENABLE == 1  ) ? "VCP_genParams(&%3s, &" : ""
      prop ParamConfigObj :: ( hVcp.VCP_INITPARAM_ENABLE == 1 && hVcp.VCP_PARAMCONFIGNAME != "NULL" ) ? hVcp.VCP_PARAMCONFIGNAME : ""
      prop ConfigEnd :: (hVcp.VCP_INITPARAM_ENABLE == 1 && hVcp.VCP_PARAMCONFIGNAME != "NULL") ? ");" : ""
       
      prop cGenFxnPreInst :: ( "   %1S%2S%4S\n\0,GenParamStr,ParamConfigObj,cStructName,ConfigEnd")
inst RATE_SETUP :: "None"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,1/2,1/3,1/4"
        prop Label :: " Code Rate "
        prop Visible :: 1
	prop JSName :: "vcpBaseParamRate"
        prop Writable :: (CSL.VCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "VCP Base Params"
        prop Set :: (    
                if ($1 == "1/2") {   
                    .cRateGen = "VCP_RATE_1_2"                          
                 } else {
                     if ($1 == "1/3") {
                          .cRateGen = "VCP_RATE_1_3"  
                       } else {
                        if ($1 == "1/4") {
                          .cRateGen = "VCP_RATE_1_4"
                           } else {
                                  .cRateGen = " 0" 
                             }
                        } 
                 },
             .RATE_SETUP = $1,
            " For Information only, Not programmable directly - calculated via POLYx"                                                               
        )
     }
  
inst  cRateGen ::= " 0"  {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Rate"
        prop Visible :: 0
        prop Writable :: CSL.VCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        }  
                  
inst CONSTRLEN_SETUP :: 5 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Constraint Length (K= 5,6,7,8 or 9)"
        prop Visible :: 1
	prop JSName :: "vcpBaseParamConstrLen"
        prop Writable :: (CSL.VCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "VCP Base Params"
        prop Set :: (
                 if ($1 < 5 || $1 > 9) {
                          .error(" Constraint Length K=5,6,7,8 or 9")
                           } else {             
                                    
                        .CONSTRLEN_SETUP = $1,  
                        " For Information only, Not programmable directly - calculated via POLYx"
                       }
        )
     }
 
inst FRAMELEN_SETUP ::= 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Frame Length (FL) "
        prop Visible :: 1
	prop JSName :: "vcpBaseParamFrameLen"
        prop Writable :: (CSL.VCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "VCP Base Params"
        prop Set :: (
             if ( $1 < 0 || $1 > 65535) {
                   .error("Frame Length range [0-65535]")
              } else {
             .FRAMELEN_SETUP = $1,        
             "ok"
              }
        )
     }
 inst YAMTH_SETUP ::= 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Yamamoto Threshold (YAMT)"
        prop Visible :: 1
	prop JSName :: "vcpBaseParamYamth"
        prop Writable :: (CSL.VCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "VCP Base Params"
        prop Set :: (
             if ( $1 < 0 || $1 > 4095) {
                   .error("Yamamoto Threshold max value is 4095")
              } else {
             .YAMTH_SETUP = $1,
             "ok"
              }
        )
     }
inst IMAXI_SETUP ::= 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " State Index set to IMAXS (IMAXI)"
        prop Visible :: 1
	prop JSName :: "vcpBaseParamIndexMaxIter"
        prop Writable :: (CSL.VCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "VCP Base Params"
        prop Set :: (
             if ( (.CONSTRLEN_SETUP == 5 && $1 > 15) ) {
                   .error("For K=5 ,allowed values are 0 to 15")
              } else {
                 if ( (.CONSTRLEN_SETUP == 6 && $1 > 31) ) {
                     .error("For K=6 ,allowed values are 0 to 31")
                    } else {
                     if ( (.CONSTRLEN_SETUP == 7 && $1 > 63) ) {
                           .error("For K=7 ,allowed values are 0 to 63")
                               } else {
                               if ( (.CONSTRLEN_SETUP == 8 && $1 > 127) ) {
                                  .error("For K=8 ,allowed values are 0 to 127")
                                  } else {
                                 if ( (.CONSTRLEN_SETUP == 9 && $1 > 255) ) {
                                  .error("For K=9 ,allowed values are 0 to 255")
                                  } else {
                               .IMAXI_SETUP = $1,
                              
                               "ok"
                                }
                          }
                       }
                  }
              }
        )
     }
inst SDHD_SETUP :: "Hard"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Hard,Soft"
        prop Label :: " Ouput Hard Decision Type (SDHD) "
        prop Visible :: 1
	prop JSName :: "vcpBaseParamDecisionType"
        prop Writable :: (CSL.VCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "VCP Base Params"
        prop Set :: (
               if ( $1 == "Soft") {
                      .cSdhdGen = " 1"
                      } else {
                      .cSdhdGen = " 0"
                     },
              .SDHD_SETUP = $1,
              "ok"
        )
     }
inst  cSdhdGen ::= " 0"  {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Ouput Hard Decision Type "
        prop Visible :: 0
        prop Writable :: CSL.VCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        }  
inst OUTF_SETUP :: "Disable"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: " Ouput Parameters Read Flag (OUTF)"
        prop Visible :: 1
	prop JSName :: "vcpBaseParamOutFlag"
        prop Writable :: (CSL.VCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "VCP Base Params"
        prop Set :: (
             if ( $1 == "Enable") {
                      .cOutfGen = " 1"
                      } else {
                      .cOutfGen = " 0"
                     },
             .OUTF_SETUP = $1,
         
             "ok"
        )
    }
inst  cOutfGen ::= " 0"  {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Ouput Parameters Read Flag "
        prop Visible :: 0
        prop Writable :: CSL.VCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 1
        }  
}     
 type vcpCfg {
      isa ObjectMgr
      prop name :: "vcpCfg"
      prop Label :: "VCP Configuration Manager"
      prop JSName :: "VCP"
      prop IsContainedIn :: VCPFOLDER
      prop GlobalIcon :: 195
      prop InstanceIcon :: 196
      prop GlobalHelpTopic :: 1092
      prop InstanceHelpTopic :: 1092
      prop GlobalPropertyPage :: "{B936FB82-49A5-11d4-967C-0050048381C8}"
      prop InstancePropertyPage :: "{B936FB82-49A5-11d4-967C-0050048381C9}"
      prop Vendor :: "vendor1"
      prop Version :: "1.00.00"
	
	prop NoGen :: 1
        prop cGen :: CSL.VCP_SUPPORT 
    	prop cStruct :: CSL.VCP_SUPPORT
    	prop cStructType :: "VCP_ConfigIc"
	prop cHeaderName :: .gNumOf > 0 ? "csl_vcp.h" : ""
 
	prop cStructQual :: "far"
        prop cStructName :: self
           	
	prop cConfigName :: "VCP_icConfig"
     prop localDelete :: (
        .myDelete
      )      
     
     prop myDelete :: (
        $a=0,
        scan($b; vcpCfg) { 
             $a += 1
        }, 		
        if($a == 2 ) {
              hVcp.VCP_INIT_ENABLE = 0             
          },
        "ok"
      )
      prop SetParamStr :: (hVcp.VCP_SETPARAM_ENABLE == 1  && hVcp.VCP_INIT != VCP_NOTHING) ? "VCP_genIc(&" : ""
      prop ParamConfigObj :: ( hVcp.VCP_SETPARAM_ENABLE == 1 && hVcp.VCP_INIT != VCP_NOTHING && hVcp.VCP_PARAMCONFIGNAME != "NULL" ) ? hVcp.VCP_PARAMCONFIGNAME : ""
      prop IcConfigObj :: ( hVcp.VCP_SETPARAM_ENABLE == 1 && hVcp.VCP_INIT != VCP_NOTHING && hVcp.VCP_PARAMCONFIGNAME != "NULL" ) ? ",&%4s" : ""
      prop ConfigEnd :: (hVcp.VCP_SETPARAM_ENABLE == 1 && hVcp.VCP_INIT != VCP_NOTHING && hVcp.VCP_PARAMCONFIGNAME != "NULL") ? ");" : ""
       
      prop cGenFxnPreInst :: ( "   %1S%2S%3S%5S\n\0,SetParamStr,ParamConfigObj,IcConfigObj,cStructName,ConfigEnd")
          
 inst cConfigGen ::= ((hVcp.VCP_INIT_ENABLE == 1) && (hVcp.VCP_INIT == self) && (hVcp.VCP_INIT != VCP_NOTHING)) {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
    }
 	
 
    inst cConfigArg0 ::= hVcp.VCP_INIT {
         prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop MemberType :: vcpCfg
	  prop Label :: "Pre-initialize Config"
	  prop Visible :: 0
	  prop Writable :: (CSL.VCP_SUPPORT) 
          prop NoGen :: 0
	  prop cPreVal :: "&"
    }
	
 inst STANDARD_SETUP :: "3GPP" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "3GPP,IS2000"
        prop Label :: "Viterbi Decoder Standard"
        prop Visible :: 1
	prop JSName :: "vcpDecoderStandard"
        prop Writable :: CSL.VCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "VCP Setting"
        prop Set :: (
            if ( $1 == "IS2000") { 
                 .cStandardGen = "VCP_STANDARD_IS2000" 
               } else { 
                       .cStandardGen = "VCP_STANDARD_3GPP" 
              },
             .STANDARD_SETUP = $1,
             " For Information only, Not programmable"
        )
   }  
inst  cStandardGen ::= "VCP_STANDARD_3GPP" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: " Decoder Standard"
        prop Visible :: 0
        prop Writable :: CSL.VCP_SUPPORT
        prop NoGen :: 1
        prop cGen :: 0
        }  
 
inst RATE_SETUP :: "None"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "None,1/2,1/3,1/4"
        prop Label :: " Code Rate "
        prop Visible :: 1
	prop JSName :: "vcpRate"
        prop Writable :: (CSL.VCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "VCP Setting"
        prop Set :: (                       
             .RATE_SETUP = $1,
             " For Information only, Not programmable directly - calculated via POLYx"
            
        )
     }
  
                  
inst CONSTRLEN_SETUP :: 5 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Constraint Length (K= 5,6,7,8 or 9)"
        prop Visible :: 1
	prop JSName :: "vcpConstrLen"
        prop Writable :: (CSL.VCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "VCP Setting"
        prop Set :: (
                 if ($1 < 5 || $1 > 9) {
                          .error(" Constraint Length K=5,6,7,8 or 9")
                           } else {             
                                    
                        .CONSTRLEN_SETUP = $1,  
                        " For Information only, Not programmable directly - calculated via POLYx"
                       }
        )
     }
  
inst POLYG0_SETUP ::= 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Polynomial Generator G0 (POLY0) "
        prop Visible :: 1
	prop JSName :: "vcpIc0Poly0"
        prop Writable :: (CSL.VCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (
             if ( $1 < 0 || $1 > 255) {
                   .error(" G0 values allowed are [0-255]")
              } else {
             .POLYG0_SETUP = $1,
             .IC0_VALUE = .IC0_VALUE_update(),
             "ok"
              }
        )
     }
prop POLYG0_IC0 :: (
             .POLYG0_SETUP
          )
inst POLYG1_SETUP ::= 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Polynomial Generator G1 (POLY1) "
        prop Visible :: 1
	prop JSName :: "vcpIc0Poly1"
        prop Writable :: (CSL.VCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (
             if ( $1 < 0 || $1 > 255) {
                   .error(" G1 values allowed are [0-255]")
              } else {
             .POLYG1_SETUP = $1,
             .IC0_VALUE = .IC0_VALUE_update(),
             "ok"
              }
        )
     }
prop POLYG1_IC0 :: (
             .POLYG1_SETUP << 8
          )
inst POLYG2_SETUP ::= 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Polynomial Generator G2 (POLY2) "
        prop Visible :: 1
	prop JSName :: "vcpIc0Poly2"
        prop Writable :: (CSL.VCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (
             if ( $1 < 0 || $1 > 255) {
                   .error(" G2 values allowed are [0-255]")
              } else {
             .POLYG2_SETUP = $1,
             .IC0_VALUE = .IC0_VALUE_update(),
             "ok"
              }
        )
     }
prop POLYG2_IC0 :: (
             .POLYG2_SETUP << 16
          )
inst POLYG3_SETUP ::= 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Polynomial Generator G3 (POLY3) "
        prop Visible :: 1
	prop JSName :: "vcpIc0Poly3"
        prop Writable :: (CSL.VCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (
             if ( $1 < 0 || $1 > 255) {
                   .error(" G3 values allowed are [0-255]")
              } else {
             .POLYG3_SETUP = $1,
             .IC0_VALUE = .IC0_VALUE_update(),
             "ok"
              }
        )
     }
prop POLYG3_IC0 :: (
             .POLYG3_SETUP << 24
          )
 
inst FRAMELEN_SETUP ::= 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Frame Length (F) "
        prop Visible :: 1
	prop JSName :: "vcpIc2FrameLen"
        prop Writable :: (CSL.VCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (
             if ( $1 < 0 || $1 > 65535) {
                   .error("Frame Length range [0-65535]")
              } else {
             .FRAMELEN_SETUP = $1,
             .IC2_VALUE = .IC2_VALUE_update(),
             "ok"
              }
        )
     }
prop FRAMELEN_IC2 :: (
             .FRAMELEN_SETUP
          )
inst RELLEN_SETUP ::= 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Reliability Length (R)"
        prop Visible :: 1
	prop JSName :: "vcpIc2ReliaLen"
        prop Writable :: (CSL.VCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (
             if ( $1 < 0 || $1 > 127) {
                   .error("Reliability Length range [0-127]")
              } else {
             .RELLEN_SETUP = $1,
             .IC2_VALUE = .IC2_VALUE_update(),
             "ok"
              }
        )
     }
prop RELLEN_IC2 :: (
             .RELLEN_SETUP << 16
          )
      
inst CVGLEN_SETUP ::= 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Convergence Length (C) "
        prop Visible :: 1
	prop JSName :: "vcpIc3ConvLen"
        prop Writable :: (CSL.VCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (
             if ( $1 < 0 || $1 > 65535) {
                   .error("Convergence Length range [0-65535]")
              } else {
             .CVGLEN_SETUP = $1,
             .IC3_VALUE = .IC3_VALUE_update(),
             "ok"
              }
        )
     }
prop CVGLEN_IC3 :: (
             .CVGLEN_SETUP
          )
inst TRACEBACK_SETUP ::= "not Allowed" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "not allowed,tailed,convergent,mixed"
        prop Label :: " TraceBack Mode (TB)"
        prop Visible :: 1
	prop JSName :: "vcpIc5TraceBack"
        prop Writable :: (CSL.VCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (           
             .TRACEBACK_SETUP = $1,
             .IC5_VALUE = .IC5_VALUE_update(),
             "ok"
              
        )
     }
prop TRACEBACK_IC5 :: (
            if (.TRACEBACK_SETUP == "not allowed") {
                0
              } else {
                 if ( .TRACEBACK_SETUP == "tailed") {
                     0x01000000          
                   }else  {             
                        if ( .TRACEBACK_SETUP == "convergent") {
                     0x02000000                  
                          }else  {       
                           0x03000000
                          }    
                    }
                 }                    
          )
inst YAMEN_SETUP :: "Disable"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: " Yamamoto Algo. Enable (YAMEN) "
        prop Visible :: 1
	prop JSName :: "vcpIc1Yamen"
        prop Writable :: (CSL.VCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (
              .YAMEN_SETUP = $1,
              .IC1_VALUE = .IC1_VALUE_update(),
             "ok"
        )
     }
prop YAMEN_IC1 :: (
        if (.YAMEN_SETUP == "Disable") { 
                 0x00000000
          } else {
                 0x10000000
          }
    )                     
inst YAMTH_SETUP ::= 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Yamamoto Threshold (YAMT)"
        prop Visible :: 1
	prop JSName :: "vcpIc1Yamth"
        prop Writable :: (CSL.VCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (
             if ( $1 < 0 || $1 > 4095) {
                   .error("Yamamoto Threshold max value is 4095")
              } else {
             .YAMTH_SETUP = $1,
             .IC1_VALUE = .IC1_VALUE_update(),
             "ok"
              }
        )
     }
prop YAMTH_IC1 :: (
             .YAMTH_SETUP << 16
          )
inst IMAXS_SETUP ::= 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Max Initial State Metric (IMAXS)"
        prop Visible :: 1
	prop JSName :: "vcpIc2Imaxs"
        prop Writable :: (CSL.VCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (
             if ( $1 < 0 || $1 > 4095 ) {
                   .error("Max Initial State Metric value is 4095")
              } else {
             .IMAXS_SETUP = $1,
             .IC4_VALUE = .IC4_VALUE_update(),
             "ok"
              }
        )
     }
prop IMAXS_IC4 :: (
             .IMAXS_SETUP
          )
inst IMINS_SETUP ::= 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Min Initial State Metric (IMINS)"
        prop Visible :: 1
	prop JSName :: "vcpIc2Imins"
        prop Writable :: (CSL.VCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (
             if ( $1 < 0 || $1 > 4095 ) {
                   .error("Min Initial State Metric value is 4095")
              } else {
             .IMINS_SETUP = $1,
             .IC4_VALUE = .IC4_VALUE_update(),
             "ok"
              }
        )
     }
prop IMINS_IC4 :: (
             .IMINS_SETUP  << 16
          )
inst IMAXI_SETUP ::= 0 {
	prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " State Index set to IMAXS (IMAXI)"
        prop Visible :: 1
	prop JSName :: "vcpIc5IndexMaxIter"
        prop Writable :: (CSL.VCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (
             if ( (.CONSTRLEN_SETUP == 5 && $1 > 15) ) {
                   .error("For K=5 ,allowed values are 0 to 15")
              } else {
                 if ( (.CONSTRLEN_SETUP == 6 && $1 > 31) ) {
                     .error("For K=6 ,allowed values are 0 to 31")
                    } else {
                     if ( (.CONSTRLEN_SETUP == 7 && $1 > 63) ) {
                           .error("For K=7 ,allowed values are 0 to 63")
                               } else {
                               if ( (.CONSTRLEN_SETUP == 8 && $1 > 127) ) {
                                  .error("For K=8 ,allowed values are 0 to 127")
                                  } else {
                                 if ( (.CONSTRLEN_SETUP == 9 && $1 > 255) ) {
                                  .error("For K=9 ,allowed values are 0 to 255")
                                  } else {
                               .IMAXI_SETUP = $1,
                               .IC5_VALUE = .IC5_VALUE_update(),
                               "ok"
                                }
                          }
                       }
                  }
              }
        )
     }
prop IMAXI_IC5 :: (
             .IMAXI_SETUP
          )
inst SDHD_SETUP :: "Hard"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Hard,Soft"
        prop Label :: " Ouput Hard Decision Type (SDHD) "
        prop Visible :: 1
	prop JSName :: "vcpIc5DecisionType"
        prop Writable :: (CSL.VCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Programmable VCP Params"
        prop Set :: (
              .SDHD_SETUP = $1,
              .IC5_VALUE = .IC5_VALUE_update(),
             "ok"
        )
     }
prop SDHD_IC5 :: (
        if (.SDHD_SETUP == "Hard") { 
                 0x00000000
          } else {
                 0x80000000
          }
    )                     
inst SYMX_SETUP :: 1{
        prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Branch Metrics Buffer Length (SYMX + 1) "
        prop Visible :: 1
	prop JSName :: "vcpIc5BmBuffLen"
        prop Writable :: (CSL.VCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "EDMA Operation"
        prop Set :: (    
           if ( $1 > 16 || $1 < 1 ) {
               .error("Buffer length range [1-16]")
            } else {        
             .SYMX_SETUP = $1,
             .IC5_VALUE = .IC5_VALUE_update(),  
             "ok"
           }
        )
     }
prop SYMX_IC5 :: (
      ( (.SYMX_SETUP -1)<< 16   )         
    )       
inst SYMR_SETUP :: 1{
        prop Type:: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Format :: "%2d"
        prop Style :: 0x02
        prop Label :: " Decision Buffer Length (SYMR + 1) "
        prop Visible :: 1
	prop JSName :: "vcpIc5DecBuffLen"
        prop Writable :: (CSL.VCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "EDMA Operation"
        prop Set :: (    
           if ( $1 > 16 || $1 < 1 ) {
               .error("Buffer length range [1-16]")
            } else {        
             .SYMR_SETUP = $1,
             .IC5_VALUE = .IC5_VALUE_update(),  
             "ok"
           }
        )
     }
prop SYMR_IC5 :: (
       ((.SYMR_SETUP - 1) << 20)         
    )       
inst OUTF_SETUP :: "Disable"{
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: " Ouput Parameters Read Flag (OUTF)"
        prop Visible :: 1
	prop JSName :: "vcpIc5OutFlag"
        prop Writable :: (CSL.VCP_SUPPORT )
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "EDMA Operation"
        prop Set :: (
             .OUTF_SETUP = $1,
             .IC5_VALUE = .IC5_VALUE_update(),
             "ok"
        )
     }
prop OUTF_IC5 :: (
        if (.OUTF_SETUP == "Disable") { 
                 0
          } else {
               0x40000000
          }
    )                     
  prop IC0_VALUE_update :: (       .POLYG0_IC0()                     
                                 |.POLYG1_IC0() 
                                 | .POLYG2_IC0() 
                                 | .POLYG3_IC0() 
                                                                  
                              )
  prop IC0_SETUP_update :: (
        .POLYG0_SETUP = ($1 & 0x000000FF) , 
        .POLYG1_SETUP = ($1 & 0x0000FF00) >> 8, 
        .POLYG2_SETUP = ($1 & 0x00FF0000) >> 16, 
        .POLYG3_SETUP = ($1 & 0xFF000000) >> 24 
   )
inst IC0_VALUE :: .IC0_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Input Configuration Reg 0 (IC0)"
     prop Format :: "0x%08X"
     prop Style :: 0x02
	prop JSName :: "vcpIc0"
      prop Visible :: 1
      prop Writable :: CSL.VCP_SUPPORT
      prop NoGen :: 1
      prop cGen :: 1
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
             .IC0_VALUE = $1 ,
             .IC0_SETUP_update($1),
             "ok"
             
        )
      } 
 prop IC1_VALUE_update :: (       .YAMTH_IC1()                     
                                 |.YAMEN_IC1()                               
                            ) 
 prop IC1_SETUP_update :: (
        .YAMTH_SETUP =   ($1 & 0x0FFF0000), 
        .YAMEN_SETUP = ($a = ($1 & 0x10000000) ,
                           ($a == 0x10000000) ? "Enable" : "Disable")
     )
inst IC1_VALUE :: .IC1_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Input Configuration Reg 1 (IC1)"
     prop Format :: "0x%08X"
     prop Style :: 0x02
	prop JSName :: "vcpIc1"
      prop Visible :: 1
      prop Writable :: CSL.VCP_SUPPORT
      prop NoGen :: 1
      prop cGen :: 1
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
             .IC1_VALUE = ($1 & 0x1FFF0000) ,
             .IC1_SETUP_update($1),
             "ok"
             
        )
      } 
prop IC2_VALUE_update :: (       .FRAMELEN_IC2()                     
                                 |.RELLEN_IC2()                               
                            ) 
 prop IC2_SETUP_update :: (
        .FRAMELEN_SETUP = ($1 & 0x0000FFFF), 
        .RELLEN_SETUP = ($1 & 0xFFFF0000) >> 16
     )
inst IC2_VALUE :: .IC2_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Input Configuration Reg 2 (IC2)"
     prop Format :: "0x%08X"
     prop Style :: 0x02
	prop JSName :: "vcpIc2"
      prop Visible :: 1
      prop Writable :: CSL.VCP_SUPPORT
      prop NoGen :: 1
      prop cGen :: 1
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
             .IC2_VALUE = $1 ,
             .IC2_SETUP_update($1),
             "ok"
             
        )
      } 
     prop IC3_VALUE_update :: (  .CVGLEN_IC3()                     
                                 
                         )
     prop IC3_SETUP_update :: (
        .CVGLEN_SETUP = ($1 & 0x0000FFFF) 
       )
inst IC3_VALUE :: .IC3_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Input Configuration Reg 3 (IC3)"
      prop Format :: "0x%08X"
      prop Style :: 0x02
      prop JSName :: "vcpIc3"
      prop Visible :: 1
      prop Writable :: CSL.VCP_SUPPORT
      prop NoGen :: 1
      prop cGen :: 1
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
             .IC3_VALUE = ($1 & 0x0000FFFF) ,
             .IC3_SETUP_update($1),
             "ok"
             
        )
      } 
prop IC4_VALUE_update :: (        .IMAXS_IC4()                     
                                 |.IMINS_IC4() 
                         )
     prop IC4_SETUP_update :: (
        .IMAXS_SETUP = ($1 & 0x00000FFF),
        .IMINS_SETUP = ($1 & 0x0FFF0000) >> 16
       )
inst IC4_VALUE :: .IC4_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Input Configuration Reg 4 (IC4)"
      prop Format :: "0x%08X"
      prop Style :: 0x02
      prop JSName :: "vcpIc4"
      prop Visible :: 1
      prop Writable :: CSL.VCP_SUPPORT
      prop NoGen :: 1
      prop cGen :: 1
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
             .IC4_VALUE = ($1 & 0x0FFF0FFF) ,
             .IC4_SETUP_update($1),
             "ok"
             
        )
      } 
    prop IC5_VALUE_update :: (        .IMAXI_IC5() 
                                     |.SYMX_IC5()
                                     |.SYMR_IC5()
                                     |.TRACEBACK_IC5()
                                     |.OUTF_IC5()
                                     |.SDHD_IC5()                                                   
                         )
     prop IC5_SETUP_update :: (
        .IMAXI_SETUP = ($1 & 0x000000FF), 
        .SYMX_SETUP = (($1 & 0x000F0000) >> 16) + 1, 
        .SYMR_SETUP = (($1 & 0x00F00000) >> 20) + 1, 
        .TRACEBACK_SETUP = ( $a= ($1 & 0x03000000) ,
                               ($a == 0x00000000) ? "not allowed" :
                               ($a == 0x010000000) ? "tailed" :
                               ($a == 0x020000000) ? "convergent" : "mixed"),
        .OUTF_SETUP = ( $a = ($1 & 0x40000000),
                               ($a == 0x400000000) ? "Enable" : "Disable"),
        .SDHD_SETUP = ( $a = ($1 & 0x80000000),
                               ($a == 0x800000000) ? "Soft" : "Hard")
       )
inst IC5_VALUE :: .IC5_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Input Configuration Reg 5 (IC5)"
      prop Format :: "0x%08X"
      prop Style :: 0x02
      prop JSName :: "vcpIc5"
      prop Visible :: 1
      prop Writable :: CSL.VCP_SUPPORT
      prop NoGen :: 1
      prop cGen :: 1
      prop cType :: "Uint32"
      prop TabName :: "Advanced"
      prop Set :: (
             .IC5_VALUE = ($1 & 0xC3FF00FF) ,
             .IC5_SETUP_update($1),
             "ok"
             
        )
      } 
  }  
type hVcp {
   prop IsContainedIn :: VCPFOLDER
   prop name :: "hVcp"     	    	
   prop Label :: "VCP Resource Manager"
   prop JSName :: "HVCP"     	    	
   prop NoGen :: 1
  prop GlobalPropertyPage :: "{B936FB82-49A5-11d4-967C-0050048381C6}"
   prop InstancePropertyPage :: "{B936FB82-49A5-11d4-967C-0050048381C5}"
   prop GlobalIcon :: 195
   prop InstanceIcon :: 196
    prop GlobalHelpTopic :: (
	   1093
   )
     
   prop cGen :: 1
 
global VCP_INITPARAM_ENABLE :: 0 {        
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Enable Parameters Setting"
	  prop JSName :: "vcpEnableParams"
	  prop Visible :: 1
	  prop Writable :: (CSL.VCP_SUPPORT)
	  prop NoGen :: 0
          prop Set :: (
          $a = 0,
            scan ($b ; vcpBaseParam) { $a = $a + 1},
                  if ( $1 == 1 && $a ==1 &&  .VCP_INITPARAM == VCP_PARAMNULL ) 
                 {         
                 " You must create a new BaseParams object"
                 } else { 
                      .VCP_INITPARAM_ENABLE = $1,
		      if ( $1 == 0) {
		      .VCP_INITPARAM = VCP_PARAMNULL,
                      .VCP_PARAMCONFIGNAME = "NULL",
		      .VCP_SETPARAM_ENABLE = 0
		      },
			"ok"
                  }      
	  )      
    	}
	global VCP_INITPARAM :: VCP_PARAMNULL {
	    prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	    prop MemberType :: vcpBaseParam
	    prop Label :: " Pre-Initialize with"
	    prop JSName :: "vcpBaseParamInit"
	    prop Visible :: 1
	    prop Writable :: (CSL.VCP_SUPPORT) &&  (.VCP_INITPARAM_ENABLE == 1) ? 1 :0 
    }
 
       
     global VCP_PARAMCONFIGNAME :: "NULL" {
       prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
       prop Label :: "Output VCP Params ConfigName (ex: vcpParam)"
       prop JSName :: "vcpParamConfigName"
       prop Visible :: 1
       prop Writable :: (CSL.VCP_SUPPORT) &&  (.VCP_INITPARAM_ENABLE == 1) ? 1 :0 
       prop Set :: ( 
                      if ( $1 == "") {
                     .VCP_PARAMCONFIGNAME = "NULL",
                     "ok" 
                    } else {
                      .VCP_PARAMCONFIGNAME = $1,
                      "ok" 
                      } 
                  )
            }
                         
    
   global VCP_SETPARAM_ENABLE :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Set VCP Params Values to the IC Config. Obj"
	  prop JSName :: "vcpSetParamEnable"
	  prop Visible :: 1
	  prop Writable :: (CSL.VCP_SUPPORT && .VCP_INITPARAM_ENABLE)
	  prop NoGen :: 0
          prop Set :: (
          $a = 0,
            scan ($b ; vcpCfg) { $a = $a + 1},
                  if ( $1 == 1 && $a ==1 &&  .VCP_INIT == VCP_NOTHING ) 
                 {         
                 " You must create a configuration object"
                 } else { 
                      .VCP_SETPARAM_ENABLE = $1,
		      if ( $1 == 0 && .VCP_INIT_ENABLE == 0) {
		      .VCP_INIT = VCP_NOTHING
		      },
			"ok"
                  }      
	  )      
    	}
    
 
   global VCP_INIT_ENABLE :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Enable Pre-Initialization"
	  prop JSName :: "vcpEnablePreInit"
	  prop Visible :: 1
	  prop Writable :: (CSL.VCP_SUPPORT) 
	  prop NoGen :: 0
          prop Set :: (
          $a = 0,
            scan ($b ; vcpCfg) { $a = $a + 1},
                  if ( $1 == 1 && $a ==1 &&  .VCP_INIT == VCP_NOTHING ) 
                 {         
                 " You must create a new configuration object"
                 } else { 
                      .VCP_INIT_ENABLE = $1,
		      if ( $1 == 0 && .VCP_SETPARAM_ENABLE == 0)  {
		      .VCP_INIT = VCP_NOTHING
		      },
			"ok"
                  }      
	  )      
    	}
	global VCP_INIT :: VCP_NOTHING {
	    prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	    prop MemberType :: vcpCfg
	    prop Label :: " Pre-Initialize with"
	    prop JSName :: "vcpPreInit"
	    prop Visible :: 1
	    prop Writable :: (CSL.VCP_SUPPORT) &&  ((.VCP_INIT_ENABLE == 1) || (.VCP_SETPARAM_ENABLE == 1))  ? 1 :0 
    }
 
 
}
object VCP_NOTHING :: vcpCfg {
       param iIsUsed :: 0
}
object VCP_PARAMNULL :: vcpBaseParam {
       param iIsUsed :: 0
}
type XBUSFOLDER {
   isa ModuleFolder
   prop IsContainedIn :: CSL 
   prop name :: "XBUS"
   prop Label :: "XBUS - Expansion Bus"
   prop NoGen :: 1
   prop GlobalPropertyPage :: "{980E6524-6246-11d4-B5CC-0050DA2E2CC0}"
   prop InstancePropertyPage :: "{980E6525-6246-11d4-B5CC-0050DA2E2CC0}"
   prop GlobalIcon :: 163
   prop InstanceIcon :: 164
   prop GlobalHelpTopic :: 1070
}   
type xbusCfg {
    isa ObjectMgr
    prop Name :: "xbusCfg"
    prop Label :: "XBUS Configuration Manager"
    prop JSName :: "XBUS"
    prop IsContainedIn :: XBUSFOLDER
    prop NoGen :: 1
    prop maxObjs :: (32767)
    prop GlobalPropertyPage :: "{980E6522-6246-11d4-B5CC-0050DA2E2CC0}"
    prop InstancePropertyPage :: "{980E6523-6246-11d4-B5CC-0050DA2E2CC0}"
    prop GlobalIcon :: 163
    prop InstanceIcon :: 164
    prop GlobalHelpTopic :: 1071
    prop InstanceHelpTopic :: 1071
    prop cGen :: CSL.XBUS_SUPPORT
    prop cStruct :: CSL.XBUS_SUPPORT
    prop cStructType :: "XBUS_Config"
    prop cHeaderName :: .gNumOf > 0 ? "csl_xbus.h" : ""
    prop cStructQual :: "far"
    prop cStructName :: self
    prop cConfigName :: "XBUS_config"
    prop localDelete :: (
        .myDelete
        )           
    prop myDelete :: (
          $a=0,
          scan($b; xbusCfg) { 
            $a = $a + 1
          }, 		
          if ($a == 2) {
            hXbus.XBUS_INIT_ENABLE = 0
          },
          "ok"
        )           
    inst cConfigGen ::= ((CSL.XBUS_SUPPORT == 1) && (hXbus.XBUS_INIT_ENABLE == 1) && (hXbus.XBUS_INIT == self) && (hXbus.XBUS_INIT != XBUS_NOTHING)) {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
    }
    inst cConfigArg0 ::= hXbus.XBUS_INIT {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop MemberType :: xbusCfg
	  prop Label :: "Pre-initialize Config"
	  prop Visible :: 0
	  prop Writable :: (CSL.XBUS_SUPPORT == 1) ? 1 : 0
        prop NoGen :: 0
	  prop cPreVal :: "&"
    }
    inst XFCEN_SETUP :: "XFCLK High" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
      prop Enum :: "XFCLK High,XFCLK Enable"
      prop Label :: "FIFO Clock Enable(XFCEN)"
      prop JSName :: "xbusXbgcXfcen"
      prop Visible :: 1
      prop Writable :: (CSL.XBUS_SUPPORT == 1) ? 1 : 0
      prop NoGen :: 1
      prop TabName :: "Global Control"
	prop Set :: (
		.XFCEN_SETUP = $1,
		.GBLCTL_VALUE = .GBLCTL_VALUE_update(),
		"ok"
	     )
	 }
     prop XFCEN_GBLCTL :: (
         if (.XFCEN_SETUP == "XFCLK Enable") {
             0x00004000
         }
	   else {
               0x00000000
	   }
    ) 
    
    inst XFRAT_SETUP :: "1/8 CPU Clock Rate" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
      prop Enum :: "1/8 CPU Clock Rate,1/6 CPU Clock Rate,1/4 CPU Clock Rate,1/2 CPU Clock Rate"
      prop Label :: "FIFO Clock Rate(XFRAT)"
      prop JSName :: "xbusXbgcXfrat"
      prop Visible :: 1
      prop Writable :: (CSL.XBUS_SUPPORT == 1) ? 1 : 0
      prop NoGen :: 1
      prop TabName :: "Global Control"
      prop Set :: (
                    .XFRAT_SETUP = $1,
                    .GBLCTL_VALUE = .GBLCTL_VALUE_update(),
                    "ok"
                  )
    }
    prop XFRAT_GBLCTL :: (
         if (.XFRAT_SETUP == "1/8 CPU Clock Rate") {
             0x00000000
         } else {
             if (.XFRAT_SETUP == "1/6 CPU Clock Rate") {
                 0x00001000
             } else {
                 if (.XFRAT_SETUP == "1/4 CPU Clock Rate") {
                     0x00002000
                 } else {
                     if (.XFRAT_SETUP == "1/2 CPU Clock Rate") {
                         0x00003000
                     }
                 }
             }
	   }
    ) 
 inst  WRSETUP0_SETUP :: 15 {
    	prop Label :: "Write Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "xbusXce0ctlWrsetup"
      prop Visible :: 1
      prop Writable :: CSL.XBUS_SUPPORT
      prop NoGen :: 1
      prop TabName :: "XCE0 Space Control"
	prop Set :: (
	        if ( $1 < 1 || $1 > 15 ) {
		    .error(" Minimum setup :1 cycle - Maximum setup: 15 cycles")
	        } else {
                  .WRSETUP0_SETUP = $1,
                  .XCE0CTL_VALUE = .XCE0CTL_VALUE_update(),
                  "ok"
	        }
           )
      }
      
   prop WRSETUP0_XCE0CTL :: (
          (.WRSETUP0_SETUP << 28)
       )   
   inst  WRSTRB0_SETUP :: 63 {
    	prop Label :: "Write Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "xbusXce0ctlWrstrb0"
      prop Visible :: 1
      prop Writable :: CSL.XBUS_SUPPORT
      prop NoGen :: 1
      prop TabName :: "XCE0 Space Control"
	prop Set :: (
	    if ( $1 < 1 || $1 > 63 ) {
		.error(" Minimum strobe :1 cycle - Maximum strobe: 63 cycles")
	    } else {
              .WRSTRB0_SETUP = $1,
              .XCE0CTL_VALUE = .XCE0CTL_VALUE_update(),
		"ok"
	    }
	  )
      }
      
   prop WRSTRB0_XCE0CTL :: (
          (.WRSTRB0_SETUP << 22)
   )   
       
   inst  WRHLD0_SETUP :: 3 {
    	prop Label :: "Write Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "xbusXce0ctlWrhld"
      prop Visible :: 1
      prop Writable :: CSL.XBUS_SUPPORT
      prop NoGen :: 1
      prop TabName :: "XCE0 Space Control"
	prop Set :: (
          if ( $1 < 0 || $1 > 3 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")
          } else {
              .WRHLD0_SETUP = $1,
              .XCE0CTL_VALUE = .XCE0CTL_VALUE_update(),
              "ok"
	    }
       )
   }
   prop WRHLD0_XCE0CTL :: (
       (.WRHLD0_SETUP << 20)
   )   
 inst  RDSETUP0_SETUP :: 15 {
    	prop Label :: "Read Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "xbusXce0ctlRdsetup"
      prop Visible :: 1
      prop Writable :: CSL.XBUS_SUPPORT
      prop NoGen :: 1
      prop TabName :: "XCE0 Space Control"
	prop Set :: (
	    if ( $1 < 1 || $1 > 15 ) {
		.error(" Minimum setup :1 cycle - Maximum setup: 15 cycles")
	    } else {
              .RDSETUP0_SETUP = $1,
              .XCE0CTL_VALUE = .XCE0CTL_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSETUP0_XCE0CTL :: (
          (.RDSETUP0_SETUP << 16)
       )   
   inst  RDSTRB0_SETUP :: 63 {
    	prop Label :: "Read Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "xbusXce0ctlRdstrb"
      prop Visible :: 1
      prop Writable :: CSL.XBUS_SUPPORT
      prop NoGen :: 1
      prop TabName :: "XCE0 Space Control"
	prop Set :: (
	    if ( $1 < 1 || $1 > 63 ) {
		.error(" Minimum strobe :1 cycle - Maximum strobe: 63 cycles")
	    } else {
              .RDSTRB0_SETUP = $1,
              .XCE0CTL_VALUE = .XCE0CTL_VALUE_update(),
		"ok"
	    }
	  )
      }
      
   prop RDSTRB0_XCE0CTL :: (
          (.RDSTRB0_SETUP << 8)
   )   
       
   inst  RDHLD0_SETUP :: 3 {
    	prop Label :: "Read Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "xbusXce0ctlRdhld"
      prop Visible :: 1
      prop Writable :: CSL.XBUS_SUPPORT
      prop NoGen :: 1
      prop TabName :: "XCE0 Space Control"
	prop Set :: (
          if ( $1 < 0 || $1 > 3 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")
          } else {
              .RDHLD0_SETUP = $1,
              .XCE0CTL_VALUE = .XCE0CTL_VALUE_update(),
              "ok"
	    }
       )
   }
   prop RDHLD0_XCE0CTL :: (
       .RDHLD0_SETUP 
   )   
   inst MTYPE0_SETUP :: "32-bit async." {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "32-bit async.,32-bit FIFO"
        prop Label :: "Memory Type(MTYPE)"
	prop JSName :: "xbusXce0ctlMtype"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE0 Space Control"
	  prop Set :: (
		.MTYPE0_SETUP = $1,
		.XCE0CTL_VALUE = .XCE0CTL_VALUE_update(),
		"ok"
        )
   }
    prop MTYPE0_XCE0CTL :: (
       if (.MTYPE0_SETUP == "32-bit async.") {
           0x00000020
        } else {
            if (.MTYPE0_SETUP == "32-bit FIFO") {
                0x00000050
		} 
        }
    ) 
 inst  WRSETUP1_SETUP :: 15 {
    	prop Label :: "Write Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "xbusXce1ctlWrsetup"
      prop Visible :: 1
      prop Writable :: CSL.XBUS_SUPPORT
      prop NoGen :: 1
      prop TabName :: "XCE1 Space Control"
	prop Set :: (
	        if ( $1 < 1 || $1 > 15 ) {
		    .error(" Minimum setup :1 cycle - Maximum setup: 15 cycles")
	        } else {
                  .WRSETUP1_SETUP = $1,
                  .XCE1CTL_VALUE = .XCE1CTL_VALUE_update(),
                  "ok"
	        }
           )
      }
      
   prop WRSETUP1_XCE1CTL :: (
          (.WRSETUP1_SETUP << 28)
       )   
   inst  WRSTRB1_SETUP :: 63 {
    	prop Label :: "Write Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "xbusXce1ctlWrstrb"
      prop Visible :: 1
      prop Writable :: CSL.XBUS_SUPPORT
      prop NoGen :: 1
      prop TabName :: "XCE1 Space Control"
	prop Set :: (
	    if ( $1 < 1 || $1 > 63 ) {
		.error(" Minimum strobe :1 cycle - Maximum strobe: 63 cycles")
	    } else {
              .WRSTRB1_SETUP = $1,
              .XCE1CTL_VALUE = .XCE1CTL_VALUE_update(),
		"ok"
	    }
	  )
      }
      
   prop WRSTRB1_XCE1CTL :: (
          (.WRSTRB1_SETUP << 22)
   )   
       
   inst  WRHLD1_SETUP :: 3 {
    	prop Label :: "Write Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "xbusXce1ctlWrhld"
      prop Visible :: 1
      prop Writable :: CSL.XBUS_SUPPORT
      prop NoGen :: 1
      prop TabName :: "XCE1 Space Control"
	prop Set :: (
          if ( $1 < 0 || $1 > 3 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")
          } else {
              .WRHLD1_SETUP = $1,
              .XCE1CTL_VALUE = .XCE1CTL_VALUE_update(),
              "ok"
	    }
       )
   }
   prop WRHLD1_XCE1CTL :: (
       (.WRHLD1_SETUP << 20)
   )   
 inst  RDSETUP1_SETUP :: 15 {
    	prop Label :: "Read Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "xbusXce1ctlRdsetup"
      prop Visible :: 1
      prop Writable :: CSL.XBUS_SUPPORT
      prop NoGen :: 1
      prop TabName :: "XCE1 Space Control"
	prop Set :: (
	    if ( $1 < 1 || $1 > 15 ) {
		.error(" Minimum setup :1 cycle - Maximum setup: 15 cycles")
	    } else {
              .RDSETUP1_SETUP = $1,
              .XCE1CTL_VALUE = .XCE1CTL_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSETUP1_XCE1CTL :: (
          (.RDSETUP1_SETUP << 16)
       )   
   inst  RDSTRB1_SETUP :: 63 {
    	prop Label :: "Read Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "xbusXce1ctlRdstrb"
      prop Visible :: 1
      prop Writable :: CSL.XBUS_SUPPORT
      prop NoGen :: 1
      prop TabName :: "XCE1 Space Control"
	prop Set :: (
	    if ( $1 < 1 || $1 > 63 ) {
		.error(" Minimum strobe :1 cycle - Maximum strobe: 63 cycles")
	    } else {
              .RDSTRB1_SETUP = $1,
              .XCE1CTL_VALUE = .XCE1CTL_VALUE_update(),
		"ok"
	    }
	  )
      }
      
   prop RDSTRB1_XCE1CTL :: (
          (.RDSTRB1_SETUP << 8)
   )   
       
   inst  RDHLD1_SETUP :: 3 {
    	prop Label :: "Read Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "xbusXce1ctlRdhld"
      prop Visible :: 1
      prop Writable :: CSL.XBUS_SUPPORT
      prop NoGen :: 1
      prop TabName :: "XCE1 Space Control"
	prop Set :: (
          if ( $1 < 0 || $1 > 3 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")
          } else {
              .RDHLD1_SETUP = $1,
              .XCE1CTL_VALUE = .XCE1CTL_VALUE_update(),
              "ok"
	    }
       )
   }
   prop RDHLD1_XCE1CTL :: (
       .RDHLD1_SETUP 
   )   
   inst MTYPE1_SETUP :: "32-bit async." {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "32-bit async.,32-bit FIFO"
        prop Label :: "Memory Type(MTYPE)"
	prop JSName :: "xbusXce1ctlMtype"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE1 Space Control"
	  prop Set :: (
		.MTYPE1_SETUP = $1,
		.XCE1CTL_VALUE = .XCE1CTL_VALUE_update(),
		"ok"
        )
   }
    prop MTYPE1_XCE1CTL :: (
       if (.MTYPE1_SETUP == "32-bit async.") {
           0x00000020
        } else {
            if (.MTYPE1_SETUP == "32-bit FIFO") {
                0x00000050
		} 
        }
    ) 
 inst  WRSETUP2_SETUP :: 15 {
    	prop Label :: "Write Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "xbusXce2ctlWrsetup"
      prop Visible :: 1
      prop Writable :: CSL.XBUS_SUPPORT
      prop NoGen :: 1
      prop TabName :: "XCE2 Space Control"
	prop Set :: (
	        if ( $1 < 1 || $1 > 15 ) {
		    .error(" Minimum setup :1 cycle - Maximum setup: 15 cycles")
	        } else {
                  .WRSETUP2_SETUP = $1,
                  .XCE2CTL_VALUE = .XCE2CTL_VALUE_update(),
                  "ok"
	        }
           )
      }
      
   prop WRSETUP2_XCE2CTL :: (
          (.WRSETUP2_SETUP << 28)
       )   
   inst  WRSTRB2_SETUP :: 63 {
    	prop Label :: "Write Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "xbusXce2ctlWrstrb"
      prop Visible :: 1
      prop Writable :: CSL.XBUS_SUPPORT
      prop NoGen :: 1
      prop TabName :: "XCE2 Space Control"
	prop Set :: (
	    if ( $1 < 1 || $1 > 63 ) {
		.error(" Minimum strobe :1 cycle - Maximum strobe: 63 cycles")
	    } else {
              .WRSTRB2_SETUP = $1,
              .XCE2CTL_VALUE = .XCE2CTL_VALUE_update(),
		"ok"
	    }
	  )
      }
      
   prop WRSTRB2_XCE2CTL :: (
          (.WRSTRB2_SETUP << 22)
   )   
       
   inst  WRHLD2_SETUP :: 3 {
    	prop Label :: "Write Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "xbusXce2ctlWrhld"
      prop Visible :: 1
      prop Writable :: CSL.XBUS_SUPPORT
      prop NoGen :: 1
      prop TabName :: "XCE2 Space Control"
	prop Set :: (
          if ( $1 < 0 || $1 > 3 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")
          } else {
              .WRHLD2_SETUP = $1,
              .XCE2CTL_VALUE = .XCE2CTL_VALUE_update(),
              "ok"
	    }
       )
   }
   prop WRHLD2_XCE2CTL :: (
       (.WRHLD2_SETUP << 20)
   )   
 inst  RDSETUP2_SETUP :: 15 {
    	prop Label :: "Read Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "xbusXce2ctlRdsetup"
      prop Visible :: 1
      prop Writable :: CSL.XBUS_SUPPORT
      prop NoGen :: 1
      prop TabName :: "XCE2 Space Control"
	prop Set :: (
	    if ( $1 < 1 || $1 > 15 ) {
		.error(" Minimum setup :1 cycle - Maximum setup: 15 cycles")
	    } else {
              .RDSETUP2_SETUP = $1,
              .XCE2CTL_VALUE = .XCE2CTL_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSETUP2_XCE2CTL :: (
          (.RDSETUP2_SETUP << 16)
       )   
   inst  RDSTRB2_SETUP :: 63 {
    	prop Label :: "Read Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "xbusXce2ctlRdstrb"
      prop Visible :: 1
      prop Writable :: CSL.XBUS_SUPPORT
      prop NoGen :: 1
      prop TabName :: "XCE2 Space Control"
	prop Set :: (
	    if ( $1 < 1 || $1 > 63 ) {
		.error(" Minimum strobe :1 cycle - Maximum strobe: 63 cycles")
	    } else {
              .RDSTRB2_SETUP = $1,
              .XCE2CTL_VALUE = .XCE2CTL_VALUE_update(),
		"ok"
	    }
	  )
      }
      
   prop RDSTRB2_XCE2CTL :: (
          (.RDSTRB2_SETUP << 8)
   )   
       
   inst  RDHLD2_SETUP :: 3 {
    	prop Label :: "Read Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "xbusXce2ctlRdhld"
      prop Visible :: 1
      prop Writable :: CSL.XBUS_SUPPORT
      prop NoGen :: 1
      prop TabName :: "XCE2 Space Control"
	prop Set :: (
          if ( $1 < 0 || $1 > 3 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")
          } else {
              .RDHLD2_SETUP = $1,
              .XCE2CTL_VALUE = .XCE2CTL_VALUE_update(),
              "ok"
	    }
       )
   }
   prop RDHLD2_XCE2CTL :: (
       .RDHLD2_SETUP 
   )   
   inst MTYPE2_SETUP :: "32-bit async." {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "32-bit async.,32-bit FIFO"
        prop Label :: "Memory Type(MTYPE)"
	prop JSName :: "xbusXce2ctlMtype"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE2 Space Control"
	  prop Set :: (
		.MTYPE2_SETUP = $1,
		.XCE2CTL_VALUE = .XCE2CTL_VALUE_update(),
		"ok"
        )
   }
    prop MTYPE2_XCE2CTL :: (
       if (.MTYPE2_SETUP == "32-bit async.") {
           0x00000020
        } else {
            if (.MTYPE2_SETUP == "32-bit FIFO") {
                0x00000050
		} 
        }
    ) 
 inst  WRSETUP3_SETUP :: 15 {
    	prop Label :: "Write Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "xbusXce3ctlWrsetup"
      prop Visible :: 1
      prop Writable :: CSL.XBUS_SUPPORT
      prop NoGen :: 1
      prop TabName :: "XCE3 Space Control"
	prop Set :: (
	        if ( $1 < 1 || $1 > 15 ) {
		    .error(" Minimum setup :1 cycle - Maximum setup: 15 cycles")
	        } else {
                  .WRSETUP3_SETUP = $1,
                  .XCE3CTL_VALUE = .XCE3CTL_VALUE_update(),
                  "ok"
	        }
           )
      }
      
   prop WRSETUP3_XCE3CTL :: (
          (.WRSETUP3_SETUP << 28)
       )   
   inst  WRSTRB3_SETUP :: 63 {
    	prop Label :: "Write Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "xbusXce3ctlWrstrb"
      prop Visible :: 1
      prop Writable :: CSL.XBUS_SUPPORT
      prop NoGen :: 1
      prop TabName :: "XCE3 Space Control"
	prop Set :: (
	    if ( $1 < 1 || $1 > 63 ) {
		.error(" Minimum strobe :1 cycle - Maximum strobe: 63 cycles")
	    } else {
              .WRSTRB3_SETUP = $1,
              .XCE3CTL_VALUE = .XCE3CTL_VALUE_update(),
		"ok"
	    }
	  )
      }
      
   prop WRSTRB3_XCE3CTL :: (
          (.WRSTRB3_SETUP << 22)
   )   
       
   inst  WRHLD3_SETUP :: 3 {
    	prop Label :: "Write Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "xbusXce3ctlWrhld"
      prop Visible :: 1
      prop Writable :: CSL.XBUS_SUPPORT
      prop NoGen :: 1
      prop TabName :: "XCE3 Space Control"
	prop Set :: (
          if ( $1 < 0 || $1 > 3 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")
          } else {
              .WRHLD3_SETUP = $1,
              .XCE3CTL_VALUE = .XCE3CTL_VALUE_update(),
              "ok"
	    }
       )
   }
   prop WRHLD3_XCE3CTL :: (
       (.WRHLD3_SETUP << 20)
   )   
 inst  RDSETUP3_SETUP :: 15 {
    	prop Label :: "Read Setup Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "xbusXce3ctlRdsetup"
      prop Visible :: 1
      prop Writable :: CSL.XBUS_SUPPORT
      prop NoGen :: 1
      prop TabName :: "XCE3 Space Control"
	prop Set :: (
	    if ( $1 < 1 || $1 > 15 ) {
		.error(" Minimum setup :1 cycle - Maximum setup: 15 cycles")
	    } else {
              .RDSETUP3_SETUP = $1,
              .XCE3CTL_VALUE = .XCE3CTL_VALUE_update(),
		"ok"
	    }
	)
      }
      
   prop RDSETUP3_XCE3CTL :: (
          (.RDSETUP3_SETUP << 16)
       )   
   inst  RDSTRB3_SETUP :: 63 {
    	prop Label :: "Read Strobe Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "xbusXce3ctlRdstrb"
      prop Visible :: 1
      prop Writable :: CSL.XBUS_SUPPORT
      prop NoGen :: 1
      prop TabName :: "XCE3 Space Control"
	prop Set :: (
	    if ( $1 < 1 || $1 > 63 ) {
		.error(" Minimum strobe :1 cycle - Maximum strobe: 63 cycles")
	    } else {
              .RDSTRB3_SETUP = $1,
              .XCE3CTL_VALUE = .XCE3CTL_VALUE_update(),
		"ok"
	    }
	  )
      }
      
   prop RDSTRB3_XCE3CTL :: (
          (.RDSTRB3_SETUP << 8)
   )   
       
   inst  RDHLD3_SETUP :: 3 {
    	prop Label :: "Read Hold Width "
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "xbusXce3ctlRdhld"
      prop Visible :: 1
      prop Writable :: CSL.XBUS_SUPPORT
      prop NoGen :: 1
      prop TabName :: "XCE3 Space Control"
	prop Set :: (
          if ( $1 < 0 || $1 > 3 ) {
		.error(" Minimum hold :0 cycle - Maximum hold: 3 cycles")
          } else {
              .RDHLD3_SETUP = $1,
              .XCE3CTL_VALUE = .XCE3CTL_VALUE_update(),
              "ok"
	    }
       )
   }
   prop RDHLD3_XCE3CTL :: (
       .RDHLD3_SETUP 
   )   
   inst MTYPE3_SETUP :: "32-bit async." {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
        prop Enum :: "32-bit async.,32-bit FIFO"
        prop Label :: "Memory Type(MTYPE)"
	prop JSName :: "xbusXce3ctlMtype"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 1
        prop TabName :: "XCE3 Space Control"
	  prop Set :: (
		.MTYPE3_SETUP = $1,
		.XCE3CTL_VALUE = .XCE3CTL_VALUE_update(),
		"ok"
        )
   }
    prop MTYPE3_XCE3CTL :: (
       if (.MTYPE3_SETUP == "32-bit async.") {
           0x00000020
        } else {
            if (.MTYPE3_SETUP == "32-bit FIFO") {
                0x00000050
		} 
        }
    ) 
    inst  XFRCT_SETUP :: 0 {
    	prop Label :: "Transfer Counter(XFRCT)"
      prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
      prop Style :: 0x01 | 0x02
      prop JSName :: "xbusXbhcXfrct"
      prop Visible :: 1
      prop Writable :: CSL.XBUS_SUPPORT
      prop NoGen :: 1
      prop TabName :: "XBUS HPI Control"
      prop Set :: (
              if ( $1 > 65535 ) {
                  .error("Maximum transfer count: 65535 elements")
              } else {
                  .XFRCT_SETUP = $1,
                  .XBHC_VALUE = .XBHC_VALUE_update(),
                  "ok"
	        }
          )
      }
      
    prop XFRCT_XBHC :: (
           (.XFRCT_SETUP << 16)
         )   
    inst INTSRC_SETUP :: "DSPINT" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
      prop Enum :: "DSPINT,XFRCT Counter"
      prop Label :: "Interrupt Source(INTSRC)"
      prop JSName :: "xbusXbhcIntsrc"
      prop Visible :: 1
      prop Writable :: (CSL.XBUS_SUPPORT == 1) ? 1 : 0
      prop NoGen :: 1
      prop TabName :: "XBUS HPI Control"
      prop Set :: (
                    .INTSRC_SETUP = $1,
                    .XBHC_VALUE = .XBHC_VALUE_update(),
                    "ok"
                  )
    }
    prop INTSRC_XBHC :: (
         if (.INTSRC_SETUP == "DSPINT") {
             0x00000000
         } else {
             if (.INTSRC_SETUP == "XFRCT Counter") {
                 0x00000020
             } 
	   }
    ) 
    inst START_SETUP :: "Abort Transfer" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
      prop Enum :: "Abort Transfer,Write: XBIMA-->XBEA,Read: XBEA-->XBIMA"
      prop Label :: "Start Master Transaction(START)"
      prop JSName :: "xbusXbhcStart"
      prop Visible :: 1
      prop Writable :: (CSL.XBUS_SUPPORT == 1) ? 1 : 0
      prop NoGen :: 1
      prop TabName :: "XBUS HPI Control"
      prop Set :: (
                    .START_SETUP = $1,
                    .XBHC_VALUE = .XBHC_VALUE_update(),
                    "ok"
                  )
    }
    prop START_XBHC :: (
         if (.START_SETUP == "Abort Transfer") {
             0x00000000
         } else {
             if (.START_SETUP == "Write: XBIMA-->XBEA") {
                 0x00000008
             } else {
                 if(.START_SETUP == "Read: XBEA-->XBIMA") {
                    0x00000010
                 }
             }
	   }
    ) 
    inst DSPINT_SETUP :: "None" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}" 
      prop Enum :: "None,Clear"
      prop Label :: "External Master to DSP Interrupt(DSPINT)"
      prop JSName :: "xbusXbhcDspint"
      prop Visible :: 1
      prop Writable :: (CSL.XBUS_SUPPORT == 1) ? 1 : 0
      prop NoGen :: 1
      prop TabName :: "XBUS HPI Control"
      prop Set :: (
                    .DSPINT_SETUP = $1,
                    .XBHC_VALUE = .XBHC_VALUE_update(),
                    "ok"
                  )
    }
    prop DSPINT_XBHC :: (
         if (.DSPINT_SETUP == "None") {
             0x00000000
         } else {
             if (.DSPINT_SETUP == "Clear") {
                 0x00000002
             } 
	   }
    ) 
    inst  XBIMA_SETUP :: 0x00000000 {
    	prop Label :: "XBUS Internal Master Address(XBIMA)"
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Style :: 0x02
      prop Format :: "0x%08X"
      prop JSName :: "xbusXbima"
      prop Visible :: 1
      prop Writable :: CSL.XBUS_SUPPORT
      prop NoGen :: 1
      prop TabName :: "Int. Master/Ext. Addr."
      prop Set :: (
               .XBIMA_SETUP = $1,
               .XBIMA_VALUE = .XBIMA_VALUE_update(),
               "ok"
          )
      }
      
    prop XBIMA_XBIMA :: (
           .XBIMA_SETUP
         )   
    inst  XBEA_SETUP :: 0x00000000 {
    	prop Label :: "XBUS External Address(XBEA)"
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Style :: 0x02
      prop Format :: "0x%08X"
      prop JSName :: "xbusXbea"
      prop Visible :: 1
      prop Writable :: CSL.XBUS_SUPPORT
      prop NoGen :: 1
      prop TabName :: "Int. Master/Ext. Addr."
      prop Set :: (
               .XBEA_SETUP = $1,
               .XBEA_VALUE = .XBEA_VALUE_update(),
               "ok"
          )
      }
      
    prop XBEA_XBEA :: (
           .XBEA_SETUP
         )   
    prop GBLCTL_VALUE_update :: (
        .XFCEN_GBLCTL()
       |.XFRAT_GBLCTL()
    )  
    
    prop GBLCTL_SETUP_update :: (
        .XFCEN_SETUP = ($1 & 0x00004000) ? "XFCLK Enable" : "XFCLK High",
        .XFRAT_SETUP = ($a =($1 & 0x00003000),
                       ($a == 0x00003000) ? "1/2 CPU Clock Rate" :
                       ($a == 0x00002000) ? "1/4 CPU Clock Rate" :
                       ($a == 0x00001000) ? "1/6 CPU Clock Rate" : "1/8 CPU Clock Rate")
    )
  
    inst GBLCTL_VALUE :: .GBLCTL_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "Global Control Register(XBGC)"
	prop Format :: "0x%08X"
	prop JSName :: "xbusXbgc"
	prop Visible :: 1
	prop Writable :: CSL.XBUS_SUPPORT
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (
                 $a = $1 & 0xFFFF0000,
                 $b = $1 & 0x000007FF,
                 $c = $1 & 0x00008000,
                 $d = $1 & 0x00000800,
                 if ($a != 0x00000000) {
                     .error("reserved space, bit[16..31]")
                 } else {
                     if ($b != 0x00000000) {
                         .error("reserved space, bit[0..10]")
                     } else {
                         if ($c != 0x00000000) {
                             .error("Read only for FMOD, bit[15]")
                         } else {
                             if ($d != 0x00000000) {
                                 .error("Read only for XARB, bit[11]")
                             } else {
                                .GBLCTL_VALUE = $1,
                                .GBLCTL_SETUP_update($1),
                                "ok"
                             }
                         }
                     }
                 }
      )
   }
    prop XCE0CTL_VALUE_update :: (
         .MTYPE0_XCE0CTL()
        |.RDHLD0_XCE0CTL()
        |.RDSTRB0_XCE0CTL()
        |.RDSETUP0_XCE0CTL()
        |.WRHLD0_XCE0CTL()
        |.WRSTRB0_XCE0CTL()
        |.WRSETUP0_XCE0CTL()
    )
    prop XCE0CTL_SETUP_update :: (
       .MTYPE0_SETUP = (  $a = ( $1 & 0x00000070),
                         ($a == 0x00000050) ? "32-bit FIFO" : "32-bit async."), 
       .RDHLD0_SETUP =   ($1 & 0x00000003),
       .RDSTRB0_SETUP =  ($1 & 0x00003F00) >> 8,
       .RDSETUP0_SETUP = ($1 & 0x000F0000) >> 16,
       .WRHLD0_SETUP =   ($1 & 0x00300000) >> 20,
       .WRSTRB0_SETUP =  ($1 & 0x0FC00000) >> 22,
       .WRSETUP0_SETUP = (($1 & 0xF0000000) >> 28) & 0xF
    )   
    
    inst XCE0CTL_VALUE :: .XCE0CTL_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "XCE0 Space Control Register(XCE0CTL) "
        prop Format :: "0x%08X"
	prop JSName :: "xbusXcectl0"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (   
                 $a = $1 & 0x00000070,
                 $b = $1 & 0x0000000C,
                 $c = $1 & 0x00000080,
                 $d = $1 & 0x0000C000,
                 if (($a != 0x00000020) && ($a != 0x00000050))  {
                     .error("Undefined memory type for XCE spaces, bit[4..6]") 
                 } else {   
                    if ($b != 0x00000000) {
                        .error("reserved space, bit[2..3]")
                    } else {
                        if ($c != 0x00000000) {
                            .error("reserved space, bit[7]")
                        } else {
                            if ($d != 0x00000000) {
                                .error("reserved space, bit[14..15]")
                            } else {
                                if(((($1 & 0xF0000000)>>28) & 0xF) == 0x00000000){
                                   .error("Write setup width, bit[28..31], requires minimum of 1 cycle")
                                } else {
                                    if((($1 & 0x0FC00000) >> 22) == 0x00000000){
                                       .error("Write strobe width, bit[22..27], requires minimum of 1 cycle")
                                    } else {
                                        if((($1 & 0x000F0000) >> 16) == 0x00000000){
                                           .error("Read setup width, bit[16..19], requires minimum of 1 cycle")
                                        } else {
                                            if((($1 & 0x00003F00) >> 8) == 0x00000000){
                                               .error("Read strobe width, bit[8..13], requires minimum of 1 cycle")
                                            } else {
                                                .XCE0CTL_VALUE = $1,
                                                .XCE0CTL_SETUP_update($1),
                                                "ok"
                                            }
                                        }
                                    }
                                }
                            }
                         }
                     }
                 }
             )
    }
    prop XCE1CTL_VALUE_update :: (
         .MTYPE1_XCE1CTL()
        |.RDHLD1_XCE1CTL()
        |.RDSTRB1_XCE1CTL()
        |.RDSETUP1_XCE1CTL()
        |.WRHLD1_XCE1CTL()
        |.WRSTRB1_XCE1CTL()
        |.WRSETUP1_XCE1CTL()
    )
    prop XCE1CTL_SETUP_update :: (
       .MTYPE1_SETUP = (  $a = ( $1 & 0x00000070),
                         ($a == 0x00000050) ? "32-bit FIFO" : "32-bit async."), 
       .RDHLD1_SETUP =   ($1 & 0x00000003),
       .RDSTRB1_SETUP =  ($1 & 0x00003F00) >> 8,
       .RDSETUP1_SETUP = ($1 & 0x000F0000) >> 16,
       .WRHLD1_SETUP =   ($1 & 0x00300000) >> 20,
       .WRSTRB1_SETUP =  ($1 & 0x0FC00000) >> 22,
       .WRSETUP1_SETUP = (($1 & 0xF0000000) >> 28) & 0xF
    )   
    
    inst XCE1CTL_VALUE :: .XCE1CTL_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "XCE1 Space Control Register(XCE1CTL) "
        prop Format :: "0x%08X"
	prop JSName :: "xbusXcectl1"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (   
                 $a = $1 & 0x00000070,
                 $b = $1 & 0x0000000C,
                 $c = $1 & 0x00000080,
                 $d = $1 & 0x0000C000,
                 if (($a != 0x00000020) && ($a != 0x00000050))  {
                     .error("Undefined memory type for XCE spaces, bit[4..6]") 
                 } else {   
                    if ($b != 0x00000000) {
                        .error("reserved space, bit[2..3]")
                    } else {
                        if ($c != 0x00000000) {
                            .error("reserved space, bit[7]")
                        } else {
                            if ($d != 0x00000000) {
                                .error("reserved space, bit[14..15]")
                            } else {
                                if(((($1 & 0xF0000000)>>28) & 0xF) == 0x00000000){
                                   .error("Write setup width, bit[28..31], requires minimum of 1 cycle")
                                } else {
                                    if((($1 & 0x0FC00000) >> 22) == 0x00000000){
                                       .error("Write strobe width, bit[22..27], requires minimum of 1 cycle")
                                    } else {
                                        if((($1 & 0x000F0000) >> 16) == 0x00000000){
                                           .error("Read setup width, bit[16..19], requires minimum of 1 cycle")
                                        } else {
                                            if((($1 & 0x00003F00) >> 8) == 0x00000000){
                                               .error("Read strobe width, bit[8..13], requires minimum of 1 cycle")
                                            } else {
                                                .XCE1CTL_VALUE = $1,
                                                .XCE1CTL_SETUP_update($1),
                                                "ok"
                                            }
                                        }
                                    }
                                }
                            }
                         }
                     }
                 }
             )
    }
    prop XCE2CTL_VALUE_update :: (
         .MTYPE2_XCE2CTL()
        |.RDHLD2_XCE2CTL()
        |.RDSTRB2_XCE2CTL()
        |.RDSETUP2_XCE2CTL()
        |.WRHLD2_XCE2CTL()
        |.WRSTRB2_XCE2CTL()
        |.WRSETUP2_XCE2CTL()
    )
    prop XCE2CTL_SETUP_update :: (
       .MTYPE2_SETUP = (  $a = ( $1 & 0x00000070),
                         ($a == 0x00000050) ? "32-bit FIFO" : "32-bit async."), 
       .RDHLD2_SETUP =   ($1 & 0x00000003),
       .RDSTRB2_SETUP =  ($1 & 0x00003F00) >> 8,
       .RDSETUP2_SETUP = ($1 & 0x000F0000) >> 16,
       .WRHLD2_SETUP =   ($1 & 0x00300000) >> 20,
       .WRSTRB2_SETUP =  ($1 & 0x0FC00000) >> 22,
       .WRSETUP2_SETUP = (($1 & 0xF0000000) >> 28) & 0xF
    )   
    
    inst XCE2CTL_VALUE :: .XCE2CTL_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "XCE2 Space Control Register(XCE2CTL) "
        prop Format :: "0x%08X"
	prop JSName :: "xbusXcectl2"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (   
                 $a = $1 & 0x00000070,
                 $b = $1 & 0x0000000C,
                 $c = $1 & 0x00000080,
                 $d = $1 & 0x0000C000,
                 if (($a != 0x00000020) && ($a != 0x00000050))  {
                     .error("Undefined memory type for XCE spaces, bit[4..6]") 
                 } else {   
                    if ($b != 0x00000000) {
                        .error("reserved space, bit[2..3]")
                    } else {
                        if ($c != 0x00000000) {
                            .error("reserved space, bit[7]")
                        } else {
                            if ($d != 0x00000000) {
                                .error("reserved space, bit[14..15]")
                            } else {
                                if(((($1 & 0xF0000000)>>28) & 0xF) == 0x00000000){
                                   .error("Write setup width, bit[28..31], requires minimum of 1 cycle")
                                } else {
                                    if((($1 & 0x0FC00000) >> 22) == 0x00000000){
                                       .error("Write strobe width, bit[22..27], requires minimum of 1 cycle")
                                    } else {
                                        if((($1 & 0x000F0000) >> 16) == 0x00000000){
                                           .error("Read setup width, bit[16..19], requires minimum of 1 cycle")
                                        } else {
                                            if((($1 & 0x00003F00) >> 8) == 0x00000000){
                                               .error("Read strobe width, bit[8..13], requires minimum of 1 cycle")
                                            } else {
                                                .XCE2CTL_VALUE = $1,
                                                .XCE2CTL_SETUP_update($1),
                                                "ok"
                                            }
                                        }
                                    }
                                }
                            }
                         }
                     }
                 }
             )
    }
    prop XCE3CTL_VALUE_update :: (
         .MTYPE3_XCE3CTL()
        |.RDHLD3_XCE3CTL()
        |.RDSTRB3_XCE3CTL()
        |.RDSETUP3_XCE3CTL()
        |.WRHLD3_XCE3CTL()
        |.WRSTRB3_XCE3CTL()
        |.WRSETUP3_XCE3CTL()
    )
    prop XCE3CTL_SETUP_update :: (
       .MTYPE3_SETUP = (  $a = ( $1 & 0x00000070),
                         ($a == 0x00000050) ? "32-bit FIFO" : "32-bit async."), 
       .RDHLD3_SETUP =   ($1 & 0x00000003),
       .RDSTRB3_SETUP =  ($1 & 0x00003F00) >> 8,
       .RDSETUP3_SETUP = ($1 & 0x000F0000) >> 16,
       .WRHLD3_SETUP =   ($1 & 0x00300000) >> 20,
       .WRSTRB3_SETUP =  ($1 & 0x0FC00000) >> 22,
       .WRSETUP3_SETUP = (($1 & 0xF0000000) >> 28) & 0xF
    )   
    
    inst XCE3CTL_VALUE :: .XCE3CTL_VALUE_update() {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "XCE3 Space Control Register(XCE3CTL) "
        prop Format :: "0x%08X"
	prop JSName :: "xbusXcectl3"
        prop Visible :: 1
        prop Writable :: CSL.XBUS_SUPPORT
        prop NoGen :: 0
        prop cGen :: 1
        prop cType :: "Uint32"
        prop TabName :: "Advanced"
        prop Set :: (   
                 $a = $1 & 0x00000070,
                 $b = $1 & 0x0000000C,
                 $c = $1 & 0x00000080,
                 $d = $1 & 0x0000C000,
                 if (($a != 0x00000020) && ($a != 0x00000050))  {
                     .error("Undefined memory type for XCE spaces, bit[4..6]") 
                 } else {   
                    if ($b != 0x00000000) {
                        .error("reserved space, bit[2..3]")
                    } else {
                        if ($c != 0x00000000) {
                            .error("reserved space, bit[7]")
                        } else {
                            if ($d != 0x00000000) {
                                .error("reserved space, bit[14..15]")
                            } else {
                                if(((($1 & 0xF0000000)>>28) & 0xF) == 0x00000000){
                                   .error("Write setup width, bit[28..31], requires minimum of 1 cycle")
                                } else {
                                    if((($1 & 0x0FC00000) >> 22) == 0x00000000){
                                       .error("Write strobe width, bit[22..27], requires minimum of 1 cycle")
                                    } else {
                                        if((($1 & 0x000F0000) >> 16) == 0x00000000){
                                           .error("Read setup width, bit[16..19], requires minimum of 1 cycle")
                                        } else {
                                            if((($1 & 0x00003F00) >> 8) == 0x00000000){
                                               .error("Read strobe width, bit[8..13], requires minimum of 1 cycle")
                                            } else {
                                                .XCE3CTL_VALUE = $1,
                                                .XCE3CTL_SETUP_update($1),
                                                "ok"
                                            }
                                        }
                                    }
                                }
                            }
                         }
                     }
                 }
             )
    }
    prop XBHC_VALUE_update :: (
        .XFRCT_XBHC()
       |.INTSRC_XBHC()
       |.START_XBHC()
       |.DSPINT_XBHC()
    )  
    
    prop XBHC_SETUP_update :: (
        .XFRCT_SETUP  = (($1 & 0xFFFF0000) >> 16) & 0xFFFF,
        .INTSRC_SETUP = ($1 & 0x00000020) ? "XFRCT Counter" : "DSPINT",
        .START_SETUP  = ($a =($1 & 0x00000018),
                        ($a == 0x00000010) ? "Read: XBEA-->XBIMA" :
                        ($a == 0x00000008) ? "Write: XBIMA-->XBEA" : "Abort Trnasfer"),
        .DSPINT_SETUP = ($1 & 0x00000002) ? "Clear" : "None"
    )
  
    inst XBHC_VALUE :: .XBHC_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "XBUS HPI Control Register(XBHC)"
	prop Format :: "0x%08X"
	prop JSName :: "xbusXbhc"
	prop Visible :: 1
	prop Writable :: CSL.XBUS_SUPPORT
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (
                 $a = $1 & 0x0000FFC0,
                 $b = $1 & 0x00000004,
                 $c = $1 & 0x00000001,
                 $d = $1 & 0x00000018,
                 if ($a != 0x00000000) {
                     .error("reserved space, bit[6..15]")
                 } else {
                     if ($b != 0x00000000) {
                         .error("reserved space, bit[2]")
                     } else {
                         if ($c != 0x00000000) {
                             .error("reserved space, bit[0]")
                         } else {
                             if ($d == 0x00000018) {
                                 .error("Undefined value for START, bit[3..4]")
                             } else {
                                 .XBHC_VALUE = $1,
                                 .XBHC_SETUP_update($1),
                                 "ok"
                             }
                         }
                     }
                 }
      )
   }
    prop XBIMA_VALUE_update :: (
        .XBIMA_XBIMA()
    )  
    
    prop XBIMA_SETUP_update :: (
        .XBIMA_SETUP  = $1 & 0xFFFFFFFF
    )
  
    inst XBIMA_VALUE :: .XBIMA_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "XBUS Internal Master Address Register(XBIMA)"
	prop Format :: "0x%08X"
	prop JSName :: "xbusXbimaAdv"
	prop Visible :: 1
	prop Writable :: CSL.XBUS_SUPPORT
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (
               .XBIMA_VALUE = $1,
               .XBIMA_SETUP_update($1),
               "ok"
      )
   }
    prop XBEA_VALUE_update :: (
        .XBEA_XBEA()
    )  
    
    prop XBEA_SETUP_update :: (
        .XBEA_SETUP  = $1 & 0xFFFFFFFF
    )
  
    inst XBEA_VALUE :: .XBEA_VALUE_update() {
      prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
      prop Label :: "XBUS External Address Register(XBEA)"
	prop Format :: "0x%08X"
	prop JSName :: "xbusXbeaAdv"
	prop Visible :: 1
	prop Writable :: CSL.XBUS_SUPPORT
	prop NoGen :: 0
	prop cGen :: 1
	prop cType :: "Uint32"
   	prop TabName :: "Advanced"
	prop Set :: (
               .XBEA_VALUE = $1,
               .XBEA_SETUP_update($1),
               "ok"
      )
   }
}  
type hXbus {
   prop IsContainedIn :: XBUSFOLDER
   prop name :: "hXbus"     	    	
   prop Label :: "XBUS Resource Manager"
   prop JSName :: "HXBUS"     	    	
   prop GlobalPropertyPage :: "{980E6520-6246-11d4-B5CC-0050DA2E2CC0}"
   prop InstancePropertyPage :: "{980E6521-6246-11d4-B5CC-0050DA2E2CC0}"
   prop GlobalIcon :: 163
   prop InstanceIcon :: 164
   prop NoGen :: 1
   prop cGen :: CSL.XBUS_SUPPORT
 
    prop GlobalHelpTopic :: 1072
   global XBUS_INIT_ENABLE :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Enable Pre-Initialization"
	  prop JSName :: "xbusEnablePreInit"
	  prop Visible :: 1
	  prop Writable :: (CSL.XBUS_SUPPORT == 1) ? 1 : 0
	  prop NoGen :: 0
          prop Set :: (
          $a = 0,
            scan ($b ; xbusCfg) { $a = $a + 1},
                  if ( $1 == 1 && $a ==1 &&  .XBUS_INIT == XBUS_NOTHING ) 
                 {         
                 " You must create a new configuration object"
                 } else { 
                      .XBUS_INIT_ENABLE = $1,
			"ok"
                  }      
	  )      
    	}
   global XBUS_INIT :: XBUS_NOTHING {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: xbusCfg
        prop Label :: " Pre-Initialize with"
	prop JSName :: "xbusPreInit"
        prop Visible :: 1
        prop Writable :: ((CSL.XBUS_SUPPORT == 1) && (.XBUS_INIT_ENABLE == 1)) ? 1 : 0 
   }
}
object XBUS_NOTHING :: xbusCfg {
       param iIsUsed :: 0
}
