/*
 *  Copyright 2010 by Texas Instruments Incorporated.
 *  @(#) DSP/BIOS_Kernel 5,2,5,28 02-10-2010 (cuda-u28)
 */
/*
 *  Do not modify this file; it's generated from c55xx.cdb.h
 *  via mkseed!
 */

//# c55xx.cdb 4.90.270
 
 
 
 
 
 
 
 
 
 
 
 
object DARAM :: MEM {
    param iAllocHeap :: 1
    param iId :: 0
    param iIsUsed :: 1                  
    param iDelUser :: "USER"
    param base :: 0x000100
    param len ::  0x007F00
    param space :: "code/data"
}
 
object SARAM :: MEM {
	
	
    param iAllocHeap :: 0
    param iId :: 0
    param iIsUsed :: 1                  
    param iDelUser :: "USER"
    param base :: 0x008000
    param len ::  0x020000
    param space :: "code/data"
}
object VECT :: MEM {
    param iComment :: .iDelMsg
    param iAllocHeap :: 0
    param iId :: 0
    param iIsUsed :: 1                  
    param iDelUser :: "MEM"
    param iDelMsg :: (
        "This object defines space for the DSP's interrupt vectors and can't be deleted"
    )
    param base :: 0x000080
    param len ::  0x000080
    param space :: "code/data"
}
class Module {
    prop Visible :: 1
    prop Writable :: 1
    prop IsConfMod :: (
	.gNumOf > 0 ? 1 : 0
    )
    prop NoGen	::  0
    prop IsDirty ::  (
	$a = .gDirty,
	.gDirty = 0,
	$a
    )
    
    prop dataSize :: 0
    
    
    prop error :: #(
	"Error: ", .name,
	$1
    )
    
    prop warning :: (
	"Warning ...", .name,
	$1
    )
    
    prop minBit	:: (
	$a = 0,
	while (($1 & (1 << $a)) && $a < 32) {
	    ++$a
	},
	$a
    )
    
    
    prop name :: (
	"<unnamed module>"
    )
    
    prop numBit :: (
	$a = $b = 0,
	while ($a < 32) {
	    if ($1 & (1 << $a)) {
		++$b
	    }
	},
	$b
    )
    
    
    global gInit ::= (
	$a = 0,
	$b = 0,
	scan ($i; self) {
	    if ($i.IsConfObj()) {
		$a += 1,
		if (self.isFinite) {
		    $b |= 1 << $i.iId
		}
	    }
	},
	.gNumOf = $a,
	.gSetOf = $b,
	if (.gInitFlag == 0) {
	    .localInit()
	},
	.gInitFlag = 1
    ) {
	prop Visible :: 0   
	prop Writable :: 0
	prop NoGen :: 1	    
    }
    global gInitFlag :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    global  gDirty :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global  gNumOf :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    global  gSetOf :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    global  gUser :: "USER" {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
}
class ObjectMgr {
    isa	    Module
    
    prop CanCreate :: (
	if (.gNumOf < .maxObjs()) {
	    .localCanCreate()
	}
	else {
	    .warning("Maximum number of objects already created")
	}
    )
    
    
    prop CanDelete :: (
	if (.iDelMsg == "ok" || (.iDelUser == .gUser)) {
	    if (.iId >= 0 && .iIsUsed) {
		.localCanDelete()
	    }
	    else {
		.warning("Object already deleted")
	    }
	}
	else {
	    .warning(.iDelMsg)
	}
    )
    
    
    prop Create	:: (
	(.gUser = ($0 > 0 ? $1 : "USER")),
	if (($a = .CanCreate()) == "ok") {
	    if (($a = .localCreate()) == "ok") {
		if (.iIsUsed == 0) {
		    .mkId($0 > 1 ? $2 : -1),
		    .iIsUsed = 1,
		    GlobalStatus.gDirty = 1,
		    .gDirty = 1
		}
	    }
	},
	(.gUser = "USER"),
	$a
    )
    
    prop Delete :: (
	(.gUser = ($0 > 0 ? $1 : "USER")),
	if (($a = .CanDelete()) == "ok") {
	    if (($a = .localDelete()) == "ok") {
		.rmId(.iId),
		.iIsUsed = 0,
		GlobalStatus.gDirty = 1,
		.gDirty = 1
	    }
	},
	(.gUser = "USER"),
	$a
    )
    
    
    prop GetSetOf :: (
	.gSetOf
    )
    
    
    prop GetNumOf :: (
	.gNumOf
    )
    
    
    prop GetObjId :: (
	.iId
    )
    
    prop GetPriority :: (
	.iId
    )
    
    
    prop SetPriority :: (
	.iId = $1
    )
    
    
    prop IsConfObj ::  (
	.iIsUsed
    )
    
    prop localCanCreate :: (
	"ok"
    )
    
    prop localCanDelete :: (
	"ok"
    )
    
    prop localCreate :: (
	"ok"
    )
    
    prop localDelete :: (
	"ok"
    )
    
    
    prop localInit :: (
	0
    )
    
    
    prop isFinite :: (
	.maxObjs() <= GBL.DSPWORDSIZE ? 1 : 0
    )
    
    
    prop mkId ::  (
	if (.isFinite()) {
	    if ($1 < 0) {
		.iId = .minBit(.gSetOf)
	    }
	    else {
		.iId = $1
	    },
	    (.gSetOf |= (1 << .iId))
	}
	else {
	    .iId = 0
	},
	++.gNumOf,
	.iId
    )
    
    
    prop rmId :: (
	if (.isFinite()) {
	    .gSetOf &= ~(1 << .iId)
	},
	--.gNumOf
    )
    
    
    prop maxObjs :: (
	GBL.DSPWORDSIZE
    )
    
    prop isDriver :: (
	0
    )
    
    prop SortChildHierView :: (
	1
    )
    inst iDelMsg :: "ok" {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    inst iDelUser :: "USER" {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iId :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst iIsUsed :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    inst iComment :: .iDelUser == "USER" ? "<add comments here>" : .iDelMsg {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "comment"
	prop JSName :: "comment"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER" ? 1 : 0
	prop NoGen :: 1
    }
}
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
					
				
				
				
				
					
				
					
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
					
				 
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
					
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
					
				
				
				
				
				
				
				
				
				 
				
				
				
					
				
				
				
				 
				
			        
				
				
				
				
				
				
				
				
				
				
				
				
type GlobalStatus {
    prop NoGen :: 1
    prop Visible :: 0
    prop Writable :: 0
    prop Label :: "Current Configuration Status"
    prop GlobalIcon :: 101
    prop InstanceIcon :: 101
    prop GlobalHelpTopic :: (
	100
    )
    prop GlobalPropertyPage :: (
	"{9D3AD931-847B-11d0-A621-0000C070F3E9}"
    )
    global GENLIB :: "bioscfg.dll" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Generation Library"
	prop NoGen :: 1
	prop Visible :: 0
	prop Writable :: 0
    }
    
    global DATE :: "" {		
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global GCONFVERS :: "" {	
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global SysDataSize ::= (
	$a = 0,
	scan ($i; nil) {		    
	    if ($i.dataSize() != nil) {	    
		$a = $a + $i.dataSize()	    
	    }
	},
	$a
    ) {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "Estimated Data Size: %d"
	prop StatusField :: 1
	prop NoGen :: 1
    }
    global MinStackSize ::= (
	$a = ((2) + (((2) + (4) + (2) + (2)))),	    
	$a = $a + ((1) + (((2) + (4) + (2) + (2)))),	    
	$a = $a + (0),	    
	$b = 0,
	scan ($i; CLK) {	    
	    if ($i.IsConfObj()) {
		$b |= 1
	    }
	},
	$a = $a + (((((5) + (2) + (12) + (14))) + (2) + (((2) + (4) + (2) + (2)))) * $b), 
	$b = 0,
	scan ($i; HWI) {	    
	    if ($i.IsConfObj()) {   
		if (($i.function != @HWI_unused) && ($i.function != @RESERVED)) {
		    $b++
		}
	    }
	},
	$a = $a + (((2) + (10) + (6)) * $b),    
	$b = 0,
	scan ($i; SWI) {	    
	    if ($i.IsConfObj()) {   
		if ($i.priority > $b) {
		    $b = $i.priority
		}
	    }
	},
	$a = $a + (((((2) + (10) + (6))) + (((((5) + (2) + (12) + (14))) + (2))) + (((6) + (((2) + (4) + (2) + (2)))))) * $b), 
	$b = 0,
	scan ($i; PRD) {	    
	    if ($i.IsConfObj()) {
		$b |= 1
	    }
	},
	$a = $a + (((2) + (((2) + (4) + (2) + (2)))) * $b), 
	$a
    ) {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "Est. Min. Stack Size (MAUs): %d"
	prop StatusField :: 1
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global ConfigWarnings ::= (
	if (.MinStackSize > MEM.STACKSIZE) {
	    "Application stack size is too small; decrease the number of SWI priorities or increase the stack in MEM."
	}
	else {
	    "None"
	}
    ) {
	prop Label :: "Warnings"
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global SeedVersion ::= "@(#)*** cuda-4.90.02.4" {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global gDirty :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    prop Status :: (#.SeedVersion, #.MinStackSize, #.SysDataSize)
}
class EModule {
    isa Module
    prop IsXMod :: (
        1
    )
    prop Vendor :: (
	""
    )
    prop Version :: (
	""
    )
}
class EObjectMgr {
    isa ObjectMgr
    prop IsXMod :: (
        1
    )
    prop Vendor :: (
        ""
    )
    prop Version :: (
        ""
    )
}
class ModuleFolder {
    isa Module
    prop NoGen :: 1
}
type SYSTEM {
    isa ModuleFolder
    prop Label :: "System"
    prop GlobalIcon :: 151
    prop GlobalHelpTopic :: (
	500
    )
    prop GlobalPropertyPage :: (
	"{B936FB91-52A5-11d4-947C-0050048381B7}"
    )
}
type INS {
    isa ModuleFolder
    prop Label :: "Instrumentation"
    prop GlobalIcon :: 152
    prop GlobalHelpTopic :: (
	501
    )
    prop GlobalPropertyPage :: (
	"{053C8F90-52A6-11d4-947C-0050048381B7}"
    )
}
type SCH {
    isa ModuleFolder
    prop Label :: "Scheduling"
    prop GlobalIcon :: 153
    prop GlobalHelpTopic :: (
	502
    )
    prop GlobalPropertyPage :: (
	"{053C8F91-52A6-11d4-947C-0050048381B7}"
    )
}
type SYN {
    isa ModuleFolder
    prop Label :: "Synchronization"
    prop GlobalIcon :: 154
    prop GlobalHelpTopic :: (
	503
    )
    prop GlobalPropertyPage :: (
	"{053C8F92-52A6-11d4-947C-0050048381B7}"
    )
}
type IOF {
    isa ModuleFolder
    prop Label :: "Input/Output"
    prop GlobalIcon :: 155
    prop GlobalHelpTopic :: (
	504
    )
    prop GlobalPropertyPage :: (
	"{053C8F93-52A6-11d4-947C-0050048381B7}"
    )
}
type CSL {
    isa ModuleFolder
    prop Label :: "Chip Support Library (CSL CDB Removal Warning, see docs/SPRA971.pdf)"
    prop GlobalIcon :: 156
    prop GlobalHelpTopic :: (
	1000
    )
    prop GlobalPropertyPage :: (
	"{053C8F94-52A6-11d4-947C-0050048381B7}"
    )
}
type PROJ {
    isa  ObjectMgr
    prop name :: "PROJ"
    prop maxObjs :: 0	
    prop Label :: "Project Manager"
    prop GlobalIcon :: 121
    prop InstanceIcon :: 122
    prop InstanceHelpTopic :: (
	201
    )
    
    prop GlobalHelpTopic :: (
	101
    )
    prop InstancePropertyPage :: (
	"{AC3C77D1-890B-11d0-A621-0000C070F3E9}"
    )
    
    prop GlobalPropertyPage :: (
	"{AC3C77D2-890B-11d0-A621-0000C070F3E9}"
    )
    prop NoGen :: 1
    prop Visible :: 0
    
    global ALIASALL :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Generate C Names for All Objects"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global IGNOREWARNING :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Ignore Warnings"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global LIBPATH :: ".;../../lib;$(BIOSROOT)/lib" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Library Search Path"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global INCPATH :: ".;../../include;$(BIOSROOT)/include" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Include File Search Path"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global OBJDIR :: "." {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Object file directory"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global EXTEXE :: "out" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Executable File Extension"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    global EXTLIB :: "lib" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Library File Extension"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    global EXTASM :: "asm" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Assembly Language Source File Extension"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    global EXTOBJ :: "obj" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Object File Extension"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst projType ::  "Executable" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "Executable,Library"
	prop Label :: "Target Type"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst projName :: "$(PROG)" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Target File Name"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst useRpt :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Use RPT Instruction"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst minimizeSpace :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Optimize for Space over Time"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    inst tmx :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Avoid TMX Silicon Bugs"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
}
type PROJ_FILE {
    isa ObjectMgr
    prop Visible :: 0
    
    prop Label :: "Project File Manager"
    
    prop InstanceHelpTopic :: (
	BIOSHELP_PROJ_FILE_INSTANCE
    )
    
    prop GlobalHelpTopic :: (
	BIOSHELP_PROJ_FILE_GLOBAL
    )
    prop InstancePropertyPage :: (
	"{AC3C77D3-890B-11d0-A621-0000C070F3E9}"
    )
    
    prop GlobalPropertyPage :: (
	"{AC3C77D4-890B-11d0-A621-0000C070F3E9}"
    )
    prop NoGen :: 1
    
    inst elemType ::  "C Source" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "C Source,ASM Source,Library,Linker Command File"
	prop Label :: "Input File Type"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst elemName :: "$(PROG)" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Input File Name"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst optLevel :: "register+local+global" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "register,register+local,register+local+global,register+local+global+file"
	prop Label :: "Optimization Level"
	prop Visible :: 0
	prop Writable :: .elemType == "C Source" ? 1 : 0
	prop NoGen :: 1
    }
    inst inline :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Inline Expansion"
	prop Visible :: 0
	prop Writable :: .elemType == "C Source" ? 1 : 0
	prop NoGen :: 1
    }
    inst definitions :: "" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Additional Definitions"
	prop Visible :: 0
	prop Writable :: .elemType == "C Source" ? 1 : 0
	prop NoGen :: 1
    }
    inst iParent :: 0 {
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
}
type GBL {
    isa Module
    prop name :: "GBL"
    prop Label :: "Global Settings"
    prop IsContainedIn :: SYSTEM
    prop cGen :: 1
    prop GenLinkPrologue :: GBL.CHIPTYPE == "5510PG2_2" ? (
	    "%10S\nSECTIONS {%4t\n.vers block(0x20000) (COPY): {} /* version information */%0t\n}\n\n-priority\n%1S-l%2S%3S\n%16S%4S%17S%5S%6S%12S%7S%15S\n%18S\n%19S\n%20s\n\0, _autoInitStr, _board, _librarySuffix, _devLibStr, _biosLibStr, _rtdxLibStr, _rtsLibStr, _librarySuffix, _compilerModel, _lnkCmdStr, _lnkCmdFile, _cslLibStr, _chipType, _devLibSuffix, clkLibStr, _chipStr, _sioLibStr, _pwrmLibStr, _pslLibStr1, _pslLibStr2"
   ) : ( "%10S\nSECTIONS {%4t\n.vers block(0x20000) (COPY): {} /* version information */%0t\n}\n\n-priority\n%1S-l%2S%3S\n%16S%4S%17S%5S%6S%12S%7S%15s\n\0, _autoInitStr, _board, _librarySuffix, _devLibStr, _biosLibStr, _rtdxLibStr, _rtsLibStr, _librarySuffix, _compilerModel, _lnkCmdStr, _lnkCmdFile, _cslLibStr, _chipType, _devLibSuffix, clkLibStr, _chipStr, _sioLibStr")
    
    prop ConfigurationClass :: "{2779A121-92CC-11d1-A63D-0000C070F3E9}"
    prop GlobalIcon :: 105
    prop InstanceIcon :: 106
	
    prop GlobalHelpTopic :: (
	103
    )
    prop InstanceHelpTopic :: (
	103
    )
    prop InstancePropertyPage :: (
	"{B7240DE4-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
	"{B7240DE5-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    prop localInit :: (
	RTA_toHost.Create("HST"),
	RTA_fromHost.Create("HST"),
	RTA_dispatcher.Create("HST"),
	IDL_busyObj.Create("IDL"),
	IDL.USEIDLBUSYOBJ = 1,
	IDL_cpuLoad.Create("IDL")
    )
    
    prop chipcall :: (
	"ok"
    )
    prop IsConfMod :: 1		
    
    prop L2Check :: (
	if (.DSPSUBTYPE == 6211 || .DSPSUBTYPE == 6711) {
	    .PCC = "mapped",            
	    if (.C641XL2CONFIGURE == 1) {
		.C641XL2CONFIGURE = 0,
		.L2CONFIGALLOC = 0
	    }
	}
	else {
	    if (.DSPSUBTYPE == 6400) {
		.PCC = "mapped",        
		if (.C621XL2CONFIGURE == 1) {
		    .C621XL2CONFIGURE = 0
		}
	    }
	    else {
		if (.C621XL2CONFIGURE == 1) {
		    .C621XL2CONFIGURE = 0
		}
		else {
		    if (.C641XL2CONFIGURE == 1) {
		        .C641XL2CONFIGURE = 0,
		        .L2CONFIGALLOC = 0
		    }
		}
	    }
	},
	.L2CacheSizeCheck()
    )
    prop C621xL2CacheSizeCheck :: (
	$e = "ok",
	$a = CACHE_L2.base,
	$b = CACHE_L2.len,
	if ( .C621XL2CONFIGURE == 0 ) {
	    CACHE_L2.Delete("MEM")
	}
	else {
	    if (.L2MODEOPTS == "SRAM" ) {
		CACHE_L2.base = 0x0,
		CACHE_L2.len = 0x0,
		CACHE_L2.Delete("MEM")
	    }
            else {
                if (.L2MODEOPTS == "1-way cache" ) {
		    CACHE_L2.Create("MEM"),
		    CACHE_L2.base = .CHIPTYPE == "6713" || .CHIPTYPE == "DA610" ? 0x3c000 : 0xc000,
		    CACHE_L2.len = 0x4000
                }
                else {
                    if (.L2MODEOPTS == "2-way cache" ) {
			CACHE_L2.Create("MEM"),
			CACHE_L2.base = .CHIPTYPE == "6713" || .CHIPTYPE == "DA610" ? 0x38000:0x8000,
			CACHE_L2.len = 0x8000
                    }
                    else {
                        if (.L2MODEOPTS == "3-way cache" ) {
			    CACHE_L2.Create("MEM"),
			    CACHE_L2.base = .CHIPTYPE == "6713" || .CHIPTYPE == "DA610" ? 0x34000:0x4000,
			    CACHE_L2.len = 0xc000
        	        }
        	        else {
        	            if (.L2MODEOPTS == "4-way cache" ) {
				CACHE_L2.Create("MEM"),
				CACHE_L2.base = .CHIPTYPE == "6713" || .CHIPTYPE == "DA610" ? 0x30000 : 0x0000,
				CACHE_L2.len = 0x10000
        	            }
        	        }
            	    }
                }
            }
       	},
        $e
    )
    
    prop C641xL2CacheSizeCheck :: (
	$e = "ok",
	$a = CACHE_L2.base,
	$b = CACHE_L2.len,
	if ( .C641XL2CONFIGURE == 0 ) {
	    CACHE_L2.Delete("MEM")
	}
	else {
            if (.C641XL2MODEOPTS == "4-way cache (0k)" ) {
		CACHE_L2.base = 0x0,
		CACHE_L2.len = 0x0,
		CACHE_L2.Delete("MEM")
	    }
            else {
                if (.C641XL2MODEOPTS == "4-way cache (32k)" ) {
		    CACHE_L2.Create("MEM"),
		    CACHE_L2.base = .CHIPTYPE == "6412" ||
			.CHIPTYPE == "DM642"
			? 0x38000 : 0xf8000,
		    CACHE_L2.len = 0x8000
                }
                else {
                    if (.C641XL2MODEOPTS == "4-way cache (64k)" ) {
			CACHE_L2.Create("MEM"),
			CACHE_L2.base = .CHIPTYPE == "6412" ||
			    .CHIPTYPE == "DM642"
			    ? 0x30000 : 0xf0000,
			CACHE_L2.len = 0x10000
                    }
                    else {
                        if (.C641XL2MODEOPTS == "4-way cache (128k)" ) {
			    CACHE_L2.Create("MEM"),
			    CACHE_L2.base = .CHIPTYPE == "6412" ||
				.CHIPTYPE == "DM642"
				? 0x20000 : 0xe0000,
			    CACHE_L2.len = 0x20000
        	        }
        	        else {
        	            if (.C641XL2MODEOPTS == "4-way cache (256k)" ) {
				CACHE_L2.Create("MEM"),
			    	CACHE_L2.base = .CHIPTYPE == "6412" ||
				    .CHIPTYPE == "DM642"
				    ? 0x0 : 0xc0000,
				CACHE_L2.len = 0x40000
        	            }
            	        }
            	    }
                }
            }
       	},
        $e
    )
    prop L2CacheSizeCheck :: (
    $e = "ok",
    scan ($i; MEM) {
	if ($i == CACHE_L2) {
            if (.C621XL2CONFIGURE)  {
	        $e = .C621xL2CacheSizeCheck()
            }
            else {
	        if (.C641XL2CONFIGURE) {
		    $e = .C641xL2CacheSizeCheck()
	        }
	        else {
		    if ((.DSPSUBTYPE == 6211 || .DSPSUBTYPE == 6711)) {
		        $e = .C621xL2CacheSizeCheck()
		    }
		    else {
		        if (.DSPSUBTYPE == 6400) {
		    	    $e = .C641xL2CacheSizeCheck()
		        }
		        else {
			    CACHE_L2.base = 0x0,
			    CACHE_L2.len = 0x0,
			    CACHE_L2.Delete("MEM")
		        } 
		    }
	        }    
            }
        }
    },
    $e
    )
    global PRODUCT :: 0 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
	prop Visible :: 0
	prop Writable :: 1      
	prop EnvField :: 1
    }
    
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global CHIPCHAIN :: nil {
	prop Visible ::0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global TRACE :: "CD-01234567" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Trace Mask"
	prop NoGen :: 1
	prop Visible :: 0
	prop Writable :: 0
    }
    global BOARD :: "c55xx" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Target Board Name"
	prop JSName :: "BOARDNAME"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global ROM :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Link to ROM Library"
	prop Visible :: 0
	prop Writable :: 0 
	prop NoGen :: 0
    }
    global CPUCLOCK :: GBL.DSPTYPE == 62 ? .MIPS : .MIPS * 2 {
	
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    global MIPS :: 140.0 {		
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style :: 0x04
	prop Format :: "%.4f"
	prop Label :: "DSP Speed In MHz (CLKOUT)"
	prop JSName :: "CLKOUT"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    $a = .MIPS,
	    $b = (GBL.DSPTYPE == 62) ? $1 : $1 * 2,
	    $e = "ok",
	    .MIPS = $1,
	    if (($e = .setCPUClock($b)) != "ok") {
		.MIPS = $a
	    },
	    $e
	)
    }
    prop setCPUClock :: (
	$e = "ok",
	if ($1 != .CPUCLOCK) {
	    $a = .CPUCLOCK,
	    .CPUCLOCK = $1,
	    if (GBL.CALLBACKOBJ != nil) {
		$e = GBL.CALLBACKOBJ.call()
	    },
	    if ($e != "ok") {
		.CPUCLOCK = $a,
		GBL.CALLBACKOBJ.call()
	    }
	},
	if ($e == "ok") {
	    "ok"
	}
	else {
	    .error($e)
	}
    )
    
    
    global OSTYPE :: "BIOS" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "BIOS"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    global DSPTYPE :: 55 {		
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "DSP Major Type"
	prop JSName :: "DSPTYPE"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
 
 
 	
 
 
 
    global DSPSUBTYPE :: 5510 {	
	prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "5509,5510"
	prop Label :: "DSP Type"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    
     global CHIPTYPE :: GBL.DSPSUBTYPE == 5510 ? "5510PG2_2": (GBL.DSPSUBTYPE == 5502) ? "5502" : "other"  {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: (GBL.DSPSUBTYPE == 5509) ? "5509,5509a,other" : "5509,5509a,5510PG1_2,5510PG2_0,5510PG2_1,5510PG2_2,custom,other"
	prop JSName :: "CHIPTYPE"
	prop Label :: "Chip Support Library (CSL)"
	prop NoGen :: 1
	prop Visible :: 1
	prop Writable :: GBL.DSPSUBTYPE == 0x55DA200 ? 0:1
	prop Set :: (
	    .CHIPTYPE = $1,
	    .CSLNAME = .setCSLNAME(),
	    $e = "ok",
	    if (GBL.CHIPCHAIN != nil) {
		$e = GBL.CHIPCHAIN.chipcall()
	    },
	    $e
	)
    }
    
    prop setCSLNAME :: (
	if (.MEMORYMODEL == "SMALL") {
	  .CHIPTYPE == "5502" ? "csl5502.lib" :
	    .CHIPTYPE == "5509" ? "csl5509.lib" :
	      .CHIPTYPE == "5509a" ? "csl5509a.lib" :
	      	.CHIPTYPE == "5509A" ? "csl5509a.lib" :
                  .CHIPTYPE == "5509PG1_0" ? "csl5509PG1_0.lib" :
                    .CHIPTYPE == "5509PG2_0" ? "csl5509PG2_0.lib" :
 	              .CHIPTYPE == "5510" ? "csl5510.lib" :
 	                .CHIPTYPE == "5510PG1_0" ? "csl5510PG1_0.lib" :
 	                  .CHIPTYPE == "5510PG1_2" ? "csl5510PG1_2.lib" :
 	                    .CHIPTYPE == "5510PG2_0" ? "csl5510PG2_0.lib" :
 		              .CHIPTYPE == "5510PG2_1" ? "csl5510PG2_1.lib" :
 		                .CHIPTYPE == "5510PG2_2" ? "csl5510PG2_2.lib" :
 			          ""
	}
	else {
	  .CHIPTYPE == "5502" ? "csl5502x.lib" :
	    .CHIPTYPE == "5509" ? "csl5509x.lib" :
	      .CHIPTYPE == "5509a" ? "csl5509ax.lib" :
	        .CHIPTYPE == "5509A" ? "csl5509ax.lib" :
                  .CHIPTYPE == "5509PG1_0" ? "csl5509PG1_0x.lib" :
                    .CHIPTYPE == "5509PG2_0" ? "csl5509PG2_0x.lib" :
 	              .CHIPTYPE == "5510" ? "csl5510x.lib" :
 	                .CHIPTYPE == "5510PG1_0" ? "csl5510PG1_0x.lib" :
 	                  .CHIPTYPE == "5510PG1_2" ? "csl5510PG1_2x.lib" :
 	                    .CHIPTYPE == "5510PG2_0" ? "csl5510PG2_0x.lib" :
 		              .CHIPTYPE == "5510PG2_1" ? "csl5510PG2_1x.lib" :
 		                .CHIPTYPE == "5510PG2_2" ? "csl5510PG2_2x.lib" :
 			          ""
	}
    )
    global CSLNAME ::= .setCSLNAME() {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label ::  "Chip Support Library Name"
	prop Visible :: 1
	prop Writable :: .CHIPTYPE == "custom"
	prop NoGen :: 1
    }
    global DISPCALLCSLCFGINIT ::= (
	    .CHIPTYPE != "other" && .CHIPTYPE != "custom"
	) {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Call CSL_cfgInit Initialization routine"
	prop Visible :: 0
	prop Writable :: .SUPPORTCSL
	prop NoGen :: 1
    }
    prop cGenCPrologue :: (
       "\n#ifdef __cplusplus\n#pragma CODE_SECTION(\".text:CSL_cfgInit\")\n#else\n#pragma CODE_SECTION(CSL_cfgInit,\".text:CSL_cfgInit\")\n#endif\n
\n#ifdef __cplusplus\n#pragma FUNC_EXT_CALLED()\n#else\n#pragma FUNC_EXT_CALLED(CSL_cfgInit)\n#endif\n"
    )
    global DSPNAME :: "TMS320C55XX" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    global MODIFYCLKMD :: 1 {
    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
    prop Label :: GBL.DSPSUBTYPE == 5502 ? "Modify PLL Registers" : "Modify CLKMD"
    prop JSName :: "MODIFYCLKMD"
    prop Visible ::  GBL.DSPSUBTYPE == 5561 ? 0: GBL.DSPSUBTYPE == 1510 ? 0 : 1
    prop Writable :: GBL.DSPSUBTYPE == 0x55DA200 ? 0:1
    prop NoGen :: 0
    prop Set :: (
            if ($1 != .MODIFYCLKMD) {   
                .MODIFYCLKMD = $1
            },
            "ok"
        )
     }  
     global CPUREVISION::= (GBL.DSPSUBTYPE == 5502) ? "1.0" : (GBL.DSPSUBTYPE == 5509) ? "1.2" : "2.2" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: (GBL.DSPSUBTYPE == 5502) ? "1.0" : (GBL.DSPSUBTYPE == 5509) ? "1.2" : "2.2,2.1,2.0,1.2"
        prop Label :: "CPU Revision"
	prop JSName :: "CPUREVISION"
        prop Visible :: 1
        prop Writable :: (GBL.DSPSUBTYPE == 5509) ? 0 : 1
        prop NoGen :: 1
	prop Set :: (
            if ($1 != .CPUREVISION) {   
                GBL.CPUREVISION = $1,
		if(GBL.DSPSUBTYPE == 5502) { 
		    GBL.BIOS_BOOTFXN = @GBL_F_biosbootfxn
		}
		else {
		  if(GBL.DSPSUBTYPE == 5509) { 
		    GBL.BIOS_BOOTFXN = @_FXN_F_nop
		  }
                  else {
                   
                    if(GBL.CPUREVISION == "1.2" || GBL.CPUREVISION == "2.0") {
		      GBL.BIOS_BOOTFXN = @_FXN_F_nop
		    }
		    else {
		      GBL.BIOS_BOOTFXN = @GBL_F_biosbootfxn
                    }
                  }
		}
            },
            "ok"
        )
     }   
     global CLKMD ::= (
	if (GBL.DSPSUBTYPE == 5502) {
          0x0001
        }
        else {
          if (GBL.CPUREVISION == "1.2") {
                0x0b50
          }
          else {
                0x2392
          }
        }
     )
     {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Label :: GBL.DSPSUBTYPE == 5502 ? "PLLCSR - PLL Control/Status Register" : "CLKMD - (PLL) Clock Mode Register"
	prop JSName :: "CLKMD"
        prop Visible :: (GBL.DSPSUBTYPE == 5502 || GBL.DSPSUBTYPE == 5561) ? 0 : GBL.DSPSUBTYPE == 1510 ? 0 :1
        prop Writable :: .MODIFYCLKMD
        prop NoGen :: 0
     }   
     global PLLM :: 0x000f
     {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Label :: "PLLM - PLL Multiplier Control Register"
	prop JSName :: "PLLM"
        prop Visible :: GBL.DSPSUBTYPE == 5502 ? 1 : 0
        prop Writable :: .MODIFYCLKMD
        prop NoGen :: 0
     }   
     global PLLDIV0 :: 0x8000
     {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Label :: "PLLDIV0 - PLL Divider 0 Register"
	prop JSName :: "PLLDIV0"
        prop Visible :: GBL.DSPSUBTYPE == 5502 ? 1 : 0
        prop Writable :: .MODIFYCLKMD
        prop NoGen :: 0
     }   
    global DSPARITHMETIC ::= (
	if (GBL.DSPTYPE == 62 && (GBL.DSPSUBTYPE / 100) == 67) {
	    "FLOAT"
	}
	else {
	    "FIXED"
	}
    ) {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "FIXED,FLOAT"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global DSPWORDSIZE :: = (
	if (GBL.DSPTYPE == 30 || GBL.DSPTYPE == 40 || GBL.DSPTYPE == 62) {
	    32		
	}
	else {
	    16		
	}
    ) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "DSP Word Size"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global DSPCHARSIZE :: = (GBL.DSPTYPE == 62 ? 8 : GBL.DSPWORDSIZE) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "DSP Byte Size"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    global DATAPTRSIZE ::= (
	if (GBL.DSPTYPE == 62) {
	    32
	}
	else {
	    if (GBL.DSPTYPE == 54) {
		16
	    }	
	    else {
		if (GBL.DSPTYPE == 55) {
		    if (GBL.MEMORYMODEL == "SMALL") {
			16	
		    }
		    else {
			23
		    }
		}
		else {
			if (GBL.DSPTYPE == 28) {
				22
			}
			else {	
		    		0
			}
		}
	    }
	})
    {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop iComment :: "Size of the Data Pointer"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global CODEPTRSIZE ::= (
	if (GBL.DSPTYPE == 62) {
	    32
	}
	else {
	    if (GBL.DSPTYPE == 54) {
		if (GBL.CALLMODEL == "near") {
		    16
		}
		else {
		    24
		}
	    }	
	    else {
		if (GBL.DSPTYPE == 55) {
		    24
		}
		else {
	            if (GBL.DSPTYPE == 28) {
			22
		    }
		    else {
			0
		    }
		}
	    }
	})
    {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop iComment :: "Size of Code Pointer"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
   
    global MEMORYMODEL ::GBL.DSPSUBTYPE == 0x55DA200 ? "LARGE":"SMALL" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "SMALL,LARGE"
	prop Label :: "Memory Model"
	prop JSName :: "MEMORYMODEL"
	prop Visible :: 1
	prop Writable :: GBL.DSPSUBTYPE == 0x55DA200 ? 0:1
	prop NoGen :: 1
	prop Set :: (
	    .MEMORYMODEL = $1,
	    .CSLNAME = .setCSLNAME(),
	    "ok"
	)
    }
    global AUTOINIT :: "ROM" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "ROM,RAM"
	prop Label :: "C Autoinitialization Model"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    global USERINIT :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Call User Init Function"
	prop JSName :: "CALLUSERINITFXN"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    if ($1 == 0) {	
		.USERINITFXN = @_FXN_F_nop,
		.USERINIT = $1
	    }
	    else {
		.USERINIT = $1
	    },
	    "ok"
	)
    }
    global USERINITFXN :: @_FXN_F_nop {
    	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
    	prop Label :: "User Init Function"
	prop JSName :: "USERINITFXN"
        prop Visible :: 1
        prop Writable :: .USERINIT
        prop NoGen :: 0
    }
    global OLDAUTOCALCULATE :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "previous value for autocalculate"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global ENABLEINST :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable Real Time Analysis"
	prop JSName :: "ENABLEINST"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    if ($1 != .ENABLEINST) {	
	        if ($1) {	
		    RTA_toHost.Create("HST"),
		    RTA_fromHost.Create("HST"),
		    RTA_dispatcher.Create("HST"),
		    IDL_busyObj.Create("IDL"),
		    IDL.USEIDLBUSYOBJ = 1,
		    IDL_cpuLoad.Create("IDL"),
		    IDL.AUTOCALCULATE = .OLDAUTOCALCULATE
		}
	        else {
		    RTA_toHost.Delete("HST"),
		    RTA_fromHost.Delete("HST"),
		    RTA_dispatcher.Delete("HST"),
		    IDL_busyObj.Delete("IDL"),
		    IDL.USEIDLBUSYOBJ = 0,
		    IDL_cpuLoad.Delete("IDL"),
		    .OLDAUTOCALCULATE = IDL.AUTOCALCULATE,
		    IDL.AUTOCALCULATE = 0
		},
		.ENABLEINST = $1
	    },
	    "ok"
	)
    }
    
    global CGENERATE :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Do C Generation"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    global LARGEMODEL ::= .MEMORYMODEL == "LARGE" ? 1 : 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
   
    global ENABLEICACHE :: 0{
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable I-Cache Programming"
	prop JSName :: "ENABLEICACHE"
	prop Visible ::  GBL.DSPSUBTYPE == 5561 ?1:0
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    if ($1 != .ENABLEICACHE) {	
		.ENABLEICACHE = $1
	    },
	    "ok"
	)
    }
    global CACHETYPE :: 2{ 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Nogen :: 0
    }
    global ICACHE :: "2-Way Two RAMset"{
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "2-Way no RAMset,2-Way One RAMset,2-Way Two RAMset" 
        prop Label :: "I-cache configuration"
        prop JSName :: "ICACHE"
        prop Visible ::   GBL.DSPSUBTYPE == 5561 ?1:0
        prop Writable :: .ENABLEICACHE == 1? 1: 0
        prop NoGen :: 1
	prop Set :: (
		.ICACHE = $1,
		if(.ICACHE == "2-Way no RAMset"){
			.CACHETYPE = 0,
			"ok"
		}
		else{
			if(.ICACHE == "2-Way One RAMset"){
			.CACHETYPE = 1,
			"ok" 
			}
			else{
			.CACHETYPE = 2,
			"ok" 
			}
		}
	)
    }
    global CACHEICRTAG1 :: 0x0f80000{
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style :: 0x20
        prop Label :: "ICRTAG1 address (24bit address)"
        prop JSName :: "CACHEICRTAG1"
	prop Format :: "0x%06x"
        prop Visible ::  GBL.DSPSUBTYPE == 5561 ?1:0
        prop Writable :: ((.ICACHE != "2-Way no RAMset") && (.ENABLEICACHE == 1))?1:0
        prop NoGen :: 0
    }
    global CACHEICRTAG2 :: 0x0f81000{
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style :: 0x20
        prop Label :: "ICRTAG2 address (24bit address)"
        prop JSName :: "CACHEICRTAG2"
	prop Format :: "0x%06x"
        prop Visible ::  GBL.DSPSUBTYPE == 5561 ?1:0
        prop Writable :: ((.ICACHE == "2-Way Two RAMset") && (.ENABLEICACHE == 1))?1:0
        prop NoGen :: 0
    }
    
    global SUPPORTCSL ::= .CHIPTYPE != "other" {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 0
    }
    global ENABLEALLTRC :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable All TRC Trace Event Classes"
	prop JSName :: "ENABLEALLTRC"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    if ($1) {
		.TRCMASKVALUE = 0xDBEF
	    }
	    else {
		.TRCMASKVALUE = 0x4000
	    },
	    .ENABLEALLTRC = $1,
	    "ok"
	)
    }
    global TRCMASKVALUE :: 0xDBEF {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 0
    }
    global CALLCSLCFGINIT ::= .DISPCALLCSLCFGINIT {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 0
    }
    global BIOS_BOOTFXN :: (GBL.DSPSUBTYPE == 1510 || GBL.DSPSUBTYPE == 0x55DA200 || GBL.DSPSUBTYPE == 5509)? @_FXN_F_nop : GBL.DSPSUBTYPE == 5510? .setBootFxn() : @GBL_F_biosbootfxn {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "BIOS boot function"
	prop JSName :: "BIOS_BOOTFXN"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
    }
    prop setBootFxn :: (
	.CPUREVISION == "1.2" ? @_FXN_F_nop :
	  .CPUREVISION == "2.0" ? @_FXN_F_nop :
	    @GBL_F_biosbootfxn
   )
 
    
    global CDBPATH :: "" { 
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "CDB search path in COFF file"
	prop JSName :: "CDBRELATIVEPATH"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    prop _cint00Str :: "-u_c_int00 %24t/* link with alternate boot.obj */%0t\n"
    prop _autoInitStr :: ""
    prop _board :: (
	if (HST.RTDX == 1) {
	    "lnkrtdx"
	}
	else {
	    if (HST.DSM == 1) {
	        "lnkdsm"
	    }
	    else {
		if(HST.EVM54 == 1) {
		    "lnkevm54"
	 	}
	        else {
	            "lnknone"
	        }
	    }
	}
    )
    prop _dsptype :: GBL.DSPTYPE
    prop _compilerModel :: .MEMORYMODEL == "SMALL" ? "" : "x"
    prop _librarySuffix :: .MEMORYMODEL == "SMALL" ? ".a55" : ".a55l"
    prop _rtdxLibStr :: RTDX.RTDXTYPE == "JTAG" ?
			"-lrtdx%9S.lib %24t/* RTDX JTAG support */%0t\n" :
			"-lrtdxsim%9S.lib %24t/* RTDX SIM support */%0t\n" 
    prop _rtsLibStr :: .MEMORYMODEL == "SMALL" ? "-lrts55.lib%24t/* C and C++ run-time library support */%0t\n" : "-lrts55x.lib%24t/* C and C++ run-time library support */%0t\n"
    prop _devLibSuffix :: .MEMORYMODEL == "SMALL" ? ".a55" : ".a55l"
    prop  clkLibStr  :: .MEMORYMODEL == "SMALL"   ?
			 .ENABLEINST == 1 	? "-lclki.a55" : "-lclk.a55" 
						  :
			 .ENABLEINST == 1 	? "-lclki.a55l" : "-lclk.a55l" 
 
    prop _chipStr :: ""
    
    prop _pwrmLibStr  :: (GBL.CHIPTYPE == "5510PG2_2") ?
	(.MEMORYMODEL == "SMALL" ? PWRM.PWRM_ENABLE == 1 ? "-lpwrm.a55" : "" : PWRM.PWRM_ENABLE == 1 ? "-lpwrm.a55l" : "") : ""
    prop _pslLibStr1  :: (GBL.CHIPTYPE == "5510PG2_2") ?
	(PWRM.PWRM_ENABLE == 1 ? (PWRM.PWRM_SCALING == 1 ? (.MEMORYMODEL == "SMALL" ? "-lPSL.lib" : "-lPSLx.lib") : (.MEMORYMODEL == "SMALL" ? "-lpslnull.a55" : "-lpslnull.a55l")) : "") : ""
    prop _pslLibStr2  :: (GBL.CHIPTYPE == "5510PG2_2") ?
	(PWRM.PWRM_ENABLE == 1 ? (PWRM.PWRM_SCALING == 1 ? (.MEMORYMODEL == "SMALL" ? "-lPSL_cfg.lib" : "-lPSL_cfgx.lib") : "") : "") : ""
    prop _biosLibStr :: .ENABLEINST ?
        "-lbiosi%8S %24t/* DSP/BIOS support */%0t\n"
    :
        "-lbios%8S %24t/* DSP/BIOS support */%0t\n"
    prop _sioLibStr :: SIO.USEISSUERECLAIM == 1 ?
	"-lsioir%8S %24t/* supports SIO Issue/Reclaim model only */%0t\n" :
	"-lsioboth%8S %24t/* supports both SIO models */%0t\n"
    prop _devLibStr :: "-ldrivers%14S %24t/* device drivers support */%0t\n"
    prop _lnkCmdFile :: MEM.LNKCMDFILE
    prop _lnkCmdStr :: (
	if (MEM.LNKCMDFILE == "") {
	    ""
	}
	else {
	    "-l%11S %24t/* User Specified Linker cmd file */%0t\n"
	}
    )
    prop _cslLibStr :: .CSLNAME == "" ? "" : "-l%13S\n"
    prop _chipType :: .CSLNAME
    prop AllocType :: (
	if (.SUPPORTCSL) {
	    "1\0,    _cslAllocDesc, _cslmemSeg, _placement"
	}
    )
    prop _cslAllocDesc :: (
	"%8t .csldata: block(0x20000) {%12t\n *(.csldata)%8t\n }"
    )
    
    prop _cslmemSeg :: MEM.BSSSEG
    prop _placement :: (0x7fffff / 2)
}
type MEM {
    isa ObjectMgr
    prop Label :: "MEM - Memory Section Manager"
    prop name :: "MEM"
    
    prop DependsOn :: "SEM"
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 115
    prop InstanceIcon :: 116
    prop GlobalHelpTopic :: (
	108
    )
    prop InstanceHelpTopic :: (
	208
    )
    prop InstancePropertyPage :: (
	    "{3D658E70-05E7-11d0-BD44-0020AFEE33C8}"
    )
    
    prop GlobalPropertyPage :: (
	    "{3D658E71-05E7-11d0-BD44-0020AFEE33C8}"
    )
    
    prop _cmd55stksz :: (MEM.STACKSIZE * 2)
    prop _cmd55systksz :: (MEM.SYSSTACKSIZE * 2)
    prop _cmd55origin :: (.base * 2)
    prop _cmd55len :: (.len * 2)
    prop _cmd55heapsize :: (.iHeapSize * 2)
    prop _cmd55heaplen :: (.iHeapSize * 2)
    prop GenLinkPrologue :: (
	if (GBL.DSPTYPE == 55) {
	    "-stack 0x%1x\n-sysstack 0x%2x\n\nSECTIONS { .sysstack : block(0x20000) fill = 0xfeeb {%12t\nGBL_sysstackbeg = .;\n*(.sysstack)\nGBL_sysstackend = GBL_sysstackbeg + 0x%2x -1 ;%12t\n _HWI_SYSSTKTOP = GBL_sysstackbeg; %12t\n _HWI_SYSSTKBOTTOM =
(GBL_sysstackend+1);\n%8t} > %3s}%0t\n\nMEMORY {%4t\0, _cmd55stksz, _cmd55systksz, _sysstackSeg"
	}
	else {
	    "-stack 0x%1x\nMEMORY {%4t\0, _stackSize"
	}
    )
    prop _stackSize :: MEM.STACKSIZE
    prop _sysstackSize :: MEM.SYSSTACKSIZE
    prop _sysstackSeg :: MEM.SYSSTACKSEG
    prop AllocType :: (
	if (.REUSE == 0 && .USERCMD == 0) {
	"19\0,	_argsString,	_argsSeg,	_midPlace, \
		_sysdataString,	_sysdataSeg,	_thirdPlace, \
		_trcinitString,	_trcinitSeg,	_midPlace, \
		_gblinitString,	_gblinitSeg,	_midPlace, \
		_memObjString,	_memObjSeg,	_midPlace, \
		_sysinitString,	_initSeg,	_sysinitPlace, \
		_sysregsString,	_regsSeg,	_midPlace, \
		_bssString,	_bssSeg,	_firstPlace, \
		_farString,	_farSeg,	_secondPlace, \
		_cinitString,	_cinitSeg,	_midPlace, \
		_pinitString,	_pinitSeg,	_midPlace, \
		_dataString,	_dataSeg,	_midPlace, \
		_constString,	_constSeg,	_midPlace, \
		_switchString,	_switchSeg,	_midPlace, \
		_cioString,	_cioSeg,	_midPlace, \
		_textString,	_textSeg,	_midPlace, \
		_frtString,	_frtSeg,	_midPlace, \
		_biosString,	_biosSeg,	_midPlace, \
		_stackString,	_stackSeg,	_midPlace"
	}
	else { if (.REUSE == 0 && .USERCMD == 1) {
	"9\0,	_argsString,	_argsSeg,	_midPlace, \
		_sysdataString,	_sysdataSeg,	_thirdPlace, \
		_trcinitString,	_trcinitSeg,	_midPlace, \
		_gblinitString,	_gblinitSeg,	_midPlace, \
		_memObjString,	_memObjSeg,	_midPlace, \
		_sysinitString,	_initSeg,	_sysinitPlace, \
		_sysregsString,	_regsSeg,	_midPlace, \
		_biosString,	_biosSeg,	_midPlace, \
		_stackString,	_stackSeg,	_midPlace"
	}
	else { if (.REUSE == 1 && .USERCMD == 0) {
	
	"18\0,	_argsString,	_argsSeg,	_midPlace, \
		_sysdataString,	_sysdataSeg,	_thirdPlace, \
		_trcinitString,	_trcinitSeg,	_midPlace, \
		_gblinitString,	_gblinitSeg,	_midPlace, \
		_memObjString,	_memObjSeg,	_midPlace, \
		_sysregsString,	_regsSeg,	_midPlace, \
		_bssString,	_bssSeg,	_firstPlace, \
		_farString,	_farSeg,	_secondPlace, \
		_cinitString,	_cinitSeg,	_midPlace, \
		_pinitString,	_pinitSeg,	_midPlace, \
		_dataString,	_dataSeg,	_midPlace, \
		_constString,	_constSeg,	_midPlace, \
		_switchString,	_switchSeg,	_midPlace, \
		_cioString,	_cioSeg,	_midPlace, \
		_textString,	_textSeg,	_midPlace, \
		_frtString,	_frtSeg,	_midPlace, \
		_biosString,	_biosSeg,	_midPlace, \
		_stackString,	_stackSeg,	_midPlace"
	}
	else { 
	"8\0,	_argsString,	_argsSeg,	_midPlace, \
		_sysdataString,	_sysdataSeg,	_thirdPlace, \
		_trcinitString,	_trcinitSeg,	_midPlace, \
		_gblinitString,	_gblinitSeg,	_midPlace, \
		_memObjString,	_memObjSeg,	_midPlace, \
		_sysregsString,	_regsSeg,	_midPlace, \
		_biosString,	_biosSeg,	_midPlace, \
		_stackString,	_stackSeg,	_midPlace"
	}}}
    )
 
    prop _firstPlace  :: 0 
    prop _secondPlace :: 0 + 1
    prop _thirdPlace :: 0 + 2
    prop _midPlace    :: (0x7fffff / 2)
    prop _sysinitPlace :: (0x7fffff / 2)
    prop _argsString    :: ("%8t .args: align = 0x4  fill=0 block(0x20000) {%12t\n *(.args)\n . += 0x%1x;%8t\n }\0, _argsSize")
    prop _bssString     :: ("%8t .bss: block(0x20000)    {}")
    prop _farString     :: ("%8t .far:     {}")
    prop _cinitString   :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.CINITSEG == MEM.LOADCINITSEG) {
		"%8t .cinit: block(0x20000)    {}"
	    }
	    else {
		"%8t .cinit:   {} load > %1s, run\0, _loadcinitSeg"
	    }
	}
	else {
		"%8t .cinit: block(0x20000)    {}"
	}
    )
    prop _pinitString   :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.PINITSEG == MEM.LOADPINITSEG) {
		"%8t .pinit: block(0x20000)    {}"
	    }
	    else {
		"%8t .pinit:   {} load > %1s, run\0, _loadpinitSeg"
	    }
	}
	else {
		"%8t .pinit: block(0x20000)    {}"
	}
    )
prop _trcinitString :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.TRCINITSEG == MEM.LOADTRCINITSEG) {
		"%8t .trcdata:   {}"
	    }
	    else {
		"%8t .trcdata:   {} load > %1s, run\0, _loadtrcinitSeg"
            }
        }
	else {
	    "%8t .trcdata:    {}"
	}
    )
    prop _gblinitString :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.BIOSINITSEG == MEM.LOADBIOSINITSEG) {
		"%8t .gblinit: block(0x20000)   {}"
    	    }
	    else {
		"%8t .gblinit:   {} load > %1s, run\0, _loadgblinitSeg"
   	    }
	}
	else {
		"%8t .gblinit: block(0x20000)   {}"
	}
    )
    prop _dataString    :: ("%8t .data: block(0x20000)  {}")
    prop _constString   :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.CONSTSEG == MEM.LOADCONSTSEG) {
		"%8t .const:   {}"
	    }
	    else {
		 if ((55 == 54) || (55 == 28)) {
	       "%8t .const:   {} load > %1s PAGE %2s, run\0, _loadconstSeg, _pg" 
              }
              else {
                "%8t .const: {} load > %1s, run\0, _loadconstSeg"
              }
	    }
	}
	else {
	    "%8t .const:    {}"
	}
    )
    prop _switchString  :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.SWITCHSEG == MEM.LOADSWITCHSEG) {
		"%8t .switch:   {}"
	    }
	    else {
		"%8t .switch:   {} load > %1s, run\0, _loadswitchSeg"
	    }
	}
	else {
	    "%8t .switch:    {}"
	}
    )
    prop _sysmemString	:: ("%8t .sysmem:  {}")
    prop _cioString	:: ("%8t .cio:     {}")
    prop _memObjString  :: ("%8t .mem: 	  {}")
    prop _sysdataString :: (
	if((GBL.ROM == 0) && (GBL.DSPTYPE == 54)) {
	    "%8t .sysdata: align = 128 {%12t\n GBL_A_SYSPAGE = .;\n GBL_A_SYSDP = GBL_A_SYSPAGE >> 7;\n %8t }"
	}
	else {
	    "%8t .sysdata: block(0x20000) {}"
	}
    )
    prop _sysinitString :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.INITSEG == MEM.LOADINITSEG) {
		"%8t .sysinit:   {}"
	    }
	    else {
		"%8t .sysinit:   {} load > %1s, run\0, _loadinitSeg"
	    }
        }
	else {
	    "%8t .sysinit:    {}"
	}
    )
    prop _sysregsString :: ("%8t .sysregs: {}")
    prop _textString  :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.TEXTSEG == MEM.LOADTEXTSEG) {
		"%8t .text:    {}"
	    }
	    else {
		"%8t .text:    {} load > %1s, run\0, _loadtextSeg"
	    }
        }
	else {
	    "%8t .text:    {}"
	}
    )
    prop _frtString	:: ("%8t frt:    {}")
    prop _biosString    :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.BIOSSEG == MEM.LOADBIOSSEG) {
		"%8t .bios:    {}"
	    }
	    else {
		"%8t .bios:    {} load > %1s, run\0, _loadbiosSeg"
    	   }
    	}
	else {
	    "%8t .bios:    {}"
	}
    )
    prop _stackString :: (
      if (GBL.DSPTYPE == 62) {
         "%8t .stack: fill=0xc0ffee {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = GBL_stackbeg + 0x%1x - 1;%12t\n _HWI_STKBOTTOM = GBL_stackbeg + 0x%1x - 4 & ~7;%12t\n _HWI_STKTOP = GBL_stackbeg;%8t\n }\0, _stackSize, _stackSize"
      }
      else {
	if (GBL.DSPTYPE == 54) {
             "%8t .stack: fill=0xbeef {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = ((GBL_stackbeg + 0x%1x - 1) & 0xfffe) ;%8t\n _HWI_STKBOTTOM = GBL_stackend;%12t\n _HWI_STKTOP = GBL_stackbeg;%8t\n }\0, _stackSize"
        }
        else {
	 if (GBL.DSPTYPE == 55) {
		"%8t .stack: block(0x20000) fill=0xbeef {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = (GBL_stackbeg + 0x%1x - 1) ;%12t\n _HWI_STKBOTTOM = (GBL_stackend+1);%12t\n _HWI_STKTOP = (GBL_stackbeg);%8t\n }\0, _cmd55stksz"
		 }
	  else
	   {  
             "%8t .stack: fill=0xbeef {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = GBL_stackbeg + 0x%1x - 1;%8t\n _HWI_STKBOTTOM = GBL_stackbeg;%12t\n _HWI_STKTOP = (GBL_stackend + 1);%8t\n }\0, _stackSize"
          }
        }
      }
    )
    prop _memHdrSize :: 8
    prop GenLinkEpilogue :: (
	"%0t}"
    )
    prop _stackSeg :: MEM.STACKSEG
    prop _textSeg :: MEM.TEXTSEG
    prop _frtSeg :: MEM.TEXTSEG
    prop _biosSeg :: MEM.BIOSSEG
    prop _dataSeg :: MEM.DATASEG
    prop _cioSeg :: MEM.CIOSEG
    prop _sysmemSeg :: MEM.SYSMEMSEG
    prop _constSeg :: MEM.CONSTSEG
    prop _initSeg :: MEM.INITSEG
    prop _pinitSeg :: MEM.PINITSEG              
    prop _trcinitSeg :: MEM.TRCINITSEG
    prop _gblinitSeg :: MEM.BIOSINITSEG
    prop _regsSeg :: MEM.SYSDATASEG		
    prop _sysdataSeg :: MEM.SYSDATASEG
    prop _argsSeg :: MEM.ARGSSEG
    prop _argsSize :: MEM.ARGSSIZE
    prop _bssSeg :: MEM.BSSSEG
    prop _farSeg :: MEM.FARSEG
    prop _cinitSeg :: MEM.CINITSEG
    prop _memObjSeg :: MEM.CFGOBJSEG
    prop _switchSeg :: MEM.SWITCHSEG
    prop _loadtextSeg :: MEM.LOADTEXTSEG
    prop _loadbiosSeg :: MEM.LOADBIOSSEG
    prop _loadconstSeg :: MEM.LOADCONSTSEG
    prop _loadinitSeg :: MEM.LOADINITSEG
    prop _loadpinitSeg :: MEM.LOADPINITSEG      
    prop _loadtrcinitSeg :: MEM.LOADTRCINITSEG
    prop _loadgblinitSeg :: MEM.LOADBIOSINITSEG
    prop _loadcinitSeg :: MEM.LOADCINITSEG
    prop _loadswitchSeg :: MEM.LOADSWITCHSEG
    prop AllocInst :: (
        if (.iAllocHeap == 1) {
        "1\0, _instAllocDesc, _objMemSeg, _placement"
        }
    )
    
    prop _instAllocDesc :: (
	.INITSEG.iAllocHeap && .REUSE && .INITSEG == self
	? "%8t .%0r$heap: {%12t\n %0r$B = .;\n%12t\n _%0r_base = .;\n . += 0x%2x;\n *(.sysinit)\n %0r$L = . + 0x%3x - %0r$B;\n _%0r_length = . + 0x%3x - %0r$B;\n . += 0x%1x;%8t\n }\0, _cmd55heapsize, _sysinitgap, _cmd55heaplen"
	: "%8t .%0r$heap: {%12t\n %0r$B = .;\n _%0r_base = .;\n %0r$L = 0x%2x;\n _%0r_length = 0x%2x;\n . += 0x%1x;%8t\n }\0, _cmd55heapsize, _cmd55heaplen"
	)
    prop _objMemSeg :: self
    prop _placement :: 0x7fffff - 1
    prop _heapsize :: (.iHeapSize)
    prop _heaplen ::  (.iHeapSize)
    
    prop _sysinitgap :: 2 * 1 
    prop GenInstLink :: (GBL.DSPTYPE == 62
	? "%0r %16t: origin = 0x%1x, %40tlen = 0x%2x%4t\0, _origin, _len"
	: GBL.DSPTYPE == 55
	
	? "%0r: %16torigin = 0x%1x, %40tlen = 0x%2x%4t\0, _cmd55origin, _cmd55len"
	: "PAGE %3d: %14t%0r: %26torigin = 0x%1x, %50tlen = 0x%2x%4t\0, _origin, _len, _page"
    )
    prop localInit :: (
	$d = "ok",
	scan ($i; MEM) {
	    if ($i.space == "code" && $i.iAllocHeap == 1) {
		$d = .error ("Code memory cannot have a heap")
	    }
	},
	if (.SEGZERO.iAllocHeap == 1) {
	    .SEGZERO.iReqHeapCount++
	}
	else {
	    $d = .error ("Segment for DSP/BIOS objects must be a memory segment with a heap")
	},
	if (.MALLOCSEG.iAllocHeap == 1) {
	    .MALLOCSEG.iReqHeapCount++
	}
	else {
	    $d = .error ("Segment for malloc()/free() must be a memory segment with a heap")
	},
	$d
    )
    prop _page :: (.page)
    prop _origin :: (.base)
    prop _len :: (.len)
    prop maxObjs :: (
	32767				
    )
    
    prop codeMember :: (
	GBL.DSPTYPE == 62
	    ? (($1.space == "code") || ($1.space == "code/data"))
	    : GBL.DSPTYPE == 54
	        ? ($1.space == "code")
	    : GBL.DSPTYPE == 28
	        ? ($1.space == "code")
	    : ($1.space == "code/data")
    )
    prop dataMember :: (
	GBL.DSPTYPE == 62
	    ? ($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL
	    : GBL.DSPTYPE == 54
	        ? (($1.space != "code") && ($1 != MEM_NULL)) && $1.space != "io"
	    : GBL.DSPTYPE == 28
	        ? (($1.space != "code") && ($1 != MEM_NULL)) && $1.space != "io"
	        : (($1.space == "code/data") && ($1 != MEM_NULL))
    )
    
    prop dataNullMember :: (
	GBL.DSPTYPE == 62
	    ? $1.space == "data" || $1.space == "code/data"
	    : GBL.DSPTYPE == 54
	        ? $1.space != "code" && $1.space != "io"
	    : GBL.DSPTYPE == 28
	        ? $1.space != "code" && $1.space != "io"
	        : $1.space == "code/data"
    )
    prop dataCodeMember :: (		
	GBL.DSPTYPE == 62
	    ? ($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL
	    : GBL.DSPTYPE == 54
	        ? $1.space == "code" && $1 != MEM_NULL	
							
	    : GBL.DSPTYPE == 28
	        ? $1.space == "code" && $1 != MEM_NULL	
							
	        : $1.space == "code/data" && $1 != MEM_NULL 
							    
    )
    
    prop memWritable :: (.iIsModifiable && .iDelUser != "MEM")
    
    global CALLBACKOBJ :: nil {
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumHeap ::= (
	    $a = 0,
	    scan($i; MEM) {
		if ($i != MEM_NULL) {
		    $a += $i.iAllocHeap
		}
	    },
	    $a
	)  {
	prop NoGen :: 0
    }
    global REUSE ::=
	    (.INITSEG.space != "code" && .INITSEG.iAllocHeap == 1 ? .SAVEREUSE : 0) {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Reuse Startup Code Space"
	prop JSName :: "REUSECODESPACE"
	prop Visible :: 1
	prop Writable  :: .INITSEG.space != "code" && .INITSEG.iAllocHeap == 1
	prop NoGen :: 1
	prop Set :: (
	    .SAVEREUSE = $1,
	    "ok"
	)
    }
    global SAVEREUSE :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    
    global doCheckOverlap :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    prop validate :: (
        $e = .checkMemOverlap($1),
        if ($e == "ok") {
            $e = .checkHeapSize($1)
        },
        $e
    )
    
    prop checkHeapSize :: (
        $e = "ok",
        if (MEM.NOHEAPS == 0) {
            if ($1.iAllocHeap && $1 != MEM_NULL) {
                if ($1.iHeapSize > $1.len) {
                    $e = ("MEM segment %s: heap cannot be larger than the length of segment that contains it.")
                }
            }
        },
        $e
    )
    
    prop checkMemOverlap :: (
        $e = "ok",
        if ($1 != MEM_NULL && $1.iIsUsed == 1) {
            if ($1.len == 0) {
                $a = $1.base
            }
            else {
                $a = ($1.base + $1.len - 1)
            },
            scan ($j; MEM) {
                if ($1 != $j && $j != MEM_NULL && $j.iIsUsed == 1 &&
                    (GBL.DSPTYPE == 62 || GBL.DSPTYPE == 55 ||
                    $1.space == $j.space)) {
                    if (!($j == CACHE_L2 && GBL.L2CONFIGURE == 0)) {
                        $b = $j.base,
                        if ($j.len == 0) {
			    $c = $j.base
			}
			else {
			    $c = ($j.base + $j.len - 1)
			},
                        
                        if ($a >= $b && $1.base <= $c) {
                            $e = ("MEM segment %s: overlaps with another segment or cache configuration."),
                            break
                        }
                    }
                }
            }
        },
        $e
    )
    
    global MAPSELECT :: BOARD_MAPMODE {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Map Mode"
	prop JSName :: "MAPMODE"
	prop Enum :: "Map 0,Map 1"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
					 
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
    global ARGSSIZE ::=  GBL.LARGEMODEL == 1 ?  16 :  8 {		
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04x"
	prop Style :: 0x01 | 0x02
	prop Label :: "Argument Buffer Size"
	prop JSName :: "ARGSSIZE"
	prop Visible :: 1	
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    if ($1 < 4) {
		.error("The 'arguments' section must have at least 4 words.")
	    }
	    else {
		.ARGSSIZE = $1 << 1,
		"ok"
	    }
	)
    }
    global ARGSSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataMember($1)
	prop Label :: "Argument Buffer Section (.args)"
	prop JSName :: "ARGSSEG"
	prop Visible :: 1	
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
    }
    
    global BIOSSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .codeMember($1)
	prop Label :: "BIOS Code Section (.bios)"
	prop JSName :: "BIOSSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Code"
    }
    global STACKSIZE :: GBL.DSPTYPE == 62 ? 1024 : (GBL.DSPTYPE == 55) ? 1024 : (GBL.DSPTYPE == 54)?256:256 { 
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04x"
	prop Style :: 0x01 | 0x02
	prop Label :: "Stack Size (MAUs)"
	prop JSName :: "STACKSIZE"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
		.STACKSIZE = $1,
		"ok"
	)
	prop PropSetOkUserMsg :: (MEM.STACKSIZE < GlobalStatus.MinStackSize)?"Warning: You are setting the stack size to a value that is less than the Estimated Minimum Stack Size!":"ok"
    }
    global USERCMD :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "User .cmd File For Non-DSP/BIOS Sections"
	prop JSName :: "USERCOMMANDFILE"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global STACKSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataMember($1)
	prop Label :: "Stack Section (.stack)"
	prop JSName :: "STACKSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
	prop Set :: (
	    if (GBL.DSPTYPE == 55) {
	        (MEM.STACKSEG = $1), 
		(MEM.SYSSTACKSEG = $1)
		}
		else {
		(MEM.STACKSEG = $1)
		},
		"ok"
	)
    }
    
    global SYSSTACKSIZE :: 256 { 
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04x"
	prop Style :: 0x01 | 0x02
	prop Label :: "System Stack Size (MAUs)"
	prop JSName :: "SYSSTACKSIZE"
	prop Visible :: GBL.DSPTYPE == 55 ? 1 : 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global SYSSTACKSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataMember($1)
	prop Label :: "System Stack Section (.sysstack)"
	prop JSName :: "SYSSTACKSEG"
	prop Visible :: GBL.DSPTYPE == 55 ? 1 : 0
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
	prop Set :: (
	    if (GBL.DSPTYPE == 55) {
	        (MEM.STACKSEG = $1), 
		(MEM.SYSSTACKSEG = $1)
		}
		else {
		(MEM.STACKSEG = $1)
		},
		"ok"
	)
	
    }
    global ENABLELOADSEG :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify Separate Load Addresses"
	prop JSName :: "ENABLELOADADDR"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global LOADBIOSSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .codeMember($1)
	prop Label :: "Load Address - BIOS Code Section (.bios)"
	prop JSName :: "LOADBIOSSEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global INITSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .codeMember($1)
	prop Label :: "Startup Code Section (.sysinit)"
	prop JSName :: "SYSINITSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Code"
    }
    global LOADINITSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .codeMember($1)
	prop Label :: "Load Address - Startup Code Section (.sysinit)"
	prop JSName :: "LOADSYSINITSEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global BIOSINITSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataCodeMember($1)
	prop Label ::"DSP/BIOS Init Tables (.gblinit)"
	prop JSName :: "GBLINITSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
    }
    global TRCINITSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataCodeMember($1)
	prop Label ::"TRC Initial Value (.trcdata)"
	prop JSName :: "TRCDATASEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
    }
    global LOADBIOSINITSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataCodeMember($1)
	prop Label ::"Load Address - DSP/BIOS Init Tables (.gblinit)"
	prop JSName :: "LOADGBLINITSEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global LOADTRCINITSEG ::= .TRCINITSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataCodeMember($1)
	prop Label ::"Load Address - TRC Initial Value (.trcdata)"
	prop JSName :: "LOADTRCDATASEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global SYSDATASEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataMember($1)
	prop Label :: "DSP/BIOS Kernel State (.sysdata)"
	prop JSName :: "SYSDATASEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
    }
    global CFGOBJSEG :: DARAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
	prop MemberTest :: .dataMember($1)
        prop Label :: "DSP/BIOS Conf Sections (.*obj)"
	prop JSName :: "OBJSEG"
        prop Visible :: 1
        prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
    }
    global NOHEAPS :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "No Dynamic Memory Heaps"
	prop JSName :: "NOMEMORYHEAPS"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    if ($1) {
		
		.SEGZERO.iReqHeapCount--,
		.SEGZERO = MEM_NULL,
		.MALLOCSEG.iReqHeapCount--,
		.MALLOCSEG = MEM_NULL,
		TSK.STACKSEG.iReqHeapCount--,
		TSK.STACKSEG = MEM_NULL,
		scan ($i; MEM) {
		    if ($i.iAllocHeap && $i != MEM_NULL) {
			$i.iAllocHeap = 0,
			$i.iHeapSize = 0
		    }
		}
	    },
	    .NOHEAPS = $1,
	    "ok"
	)
	prop PropSetOkUserMsg :: (MEM.NOHEAPS == 1)?"Currently specified heaps no longer valid":"Please reconfigure heaps under individual mem segments"
    }
    global SEGZERO :: DARAM { 
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataNullMember($1) && $1.iAllocHeap)
	prop Label :: "Segment For DSP/BIOS Objects"
	prop JSName :: "BIOSOBJSEG"
	prop Visible :: 1
	prop Writable :: MEM.NOHEAPS == 0
	prop NoGen :: 0
        prop Set :: (
            if (.SEGZERO.iReqHeapCount > 0) {
                .SEGZERO.iReqHeapCount--
            },
            .SEGZERO = $1,
            .SEGZERO.iReqHeapCount++,
            "ok"
        )
    }
    global MALLOCSEG :: DARAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
	prop MemberTest :: (.dataNullMember($1) && $1.iAllocHeap)
        prop Label :: "Segment For malloc() / free()"
	prop JSName :: "MALLOCSEG"
        prop Visible :: 1
	prop Writable :: (MEM.NOHEAPS == 0)
	prop NoGen :: 0
        prop Set :: (
            if (.MALLOCSEG.iReqHeapCount > 0) {
                .MALLOCSEG.iReqHeapCount--
            },
            .MALLOCSEG = $1,
            .MALLOCSEG.iReqHeapCount++,
            "ok"
        )
    }
    global LNKCMDFILE :: "" {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify User Linker cmd File"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    
    global TEXTSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.codeMember($1))
	prop Label :: "Text Section (.text)"
	prop JSName :: "TEXTSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global LOADTEXTSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.codeMember($1))
	prop Label :: "Load Address - Text Section (.text)"
	prop JSName :: "LOADTEXTSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0 && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global SWITCHSEG :: GBL.DSPTYPE == 62 ? MEM.BSSSEG :(GBL.DSPTYPE == 55 && GBL.DSPSUBTYPE == 5561)? SARAM: MEM.TEXTSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1))
	prop Label :: "Switch Jump Tables (.switch)"
	prop JSName :: "SWITCHSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global LOADSWITCHSEG :: GBL.DSPTYPE == 62 ? MEM.BSSSEG :(GBL.DSPTYPE == 55 && GBL.DSPSUBTYPE == 5561)? SARAM: MEM.TEXTSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1))
	prop Label :: "Load Address - Switch Jump Tables (.switch)"
	prop JSName :: "LOADSWITCHSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0 && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global BSSSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "C Variables Section (.bss)"
	prop JSName :: "BSSSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global FARSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "C Variables Section (.far)"
	prop JSName :: "FARSEG"
	prop Visible :: GBL.DSPTYPE == 62 ? 1 : 0
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global CINITSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1))
	prop Label :: "Data Initialization Section (.cinit)"
	prop JSName :: "CINITSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global LOADCINITSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1))
	prop Label :: "Load Address - Data Initialization Section (.cinit)"
	prop JSName :: "LOADCINITSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0 && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    
    global PINITSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1))
	prop Label :: "C Function Initialization Table (.pinit)"
	prop JSName :: "PINITSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    
    global LOADPINITSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1))
	prop Label :: "Load Address - C Function Initialization Table (.pinit)"
	prop JSName :: "LOADPINITSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0 && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global CONSTSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "Constant Section (.const)"
	prop JSName :: "CONSTSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global LOADCONSTSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "Load Address - Constant Section (.const)"
	prop JSName :: "LOADCONSTSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0 && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global DATASEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "Data Section (.data)"
	prop JSName :: "DATASEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global CIOSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "Data Section (.cio)"
	prop JSName :: "CIOSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global SYSMEMSEG ::= .CIOSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1))
	prop Label :: "Data Section (.sysmem)"
	prop JSName :: "SYSMEMSEG"
	prop Visible :: 0
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global STUBMEMSEG ::= HWI.STUBMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "Function Stub Memory (.hwi)"
	prop JSName :: "HWISEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Code"
	prop Set :: (
	    .STUBMEMSEG = $1,
	    HWI.STUBMEMSEG = $1,
	    "ok"
	)
    }
    
    global LOADSTUBMEMSEG :: HWI.STUBMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "Load Address - Function Stub Memory (.hwi)"
	prop JSName :: "LOADHWISEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global VECMEMSEG ::= HWI.VECMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "Interrupt Service Table Memory (.hwi_vec)"
	prop JSName :: "HWIVECSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Code"
	prop Set :: (
		.VECMEMSEG = $1,
		HWI.VECMEMSEG = $1,
		GlobalStatus.gDirty = 1,
		if ($1.base == 0) {
		    HWI.GENERATE_RESET_VEC = 0
		},
		"ok"
	)
    }
    global LOADVECMEMSEG :: HWI.VECMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "Load Address -Interrupt Service Table Memory (.hwi_vec)"
	prop JSName :: "LOADHWIVECSEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global RTDXTEXTMEMSEG ::= RTDX.TEXTMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "RTDX Text Segment (.rtdx_text)"
	prop JSName :: "RTDXTEXTSEG"
	prop Visible :: 1
	prop Writable :: RTDX.USERTDX
	prop NoGen :: 1
	prop TabName :: "BIOS Code"
	prop Set :: (
	    .RTDXTEXTMEMSEG = $1,
	    RTDX.TEXTMEMSEG = $1,
	    "ok"
	)
    }
    global LOADRTDXTEXTMEMSEG :: RTDX.TEXTMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "Load Address - RTDX Text Segment (.rtdx_text)"
	prop JSName :: "LOADRTDXTEXTSEG"
	prop Visible :: 1
	prop Writable :: (RTDX.USERTDX && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    inst base :: 0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: GBL.DSPTYPE == 62 ? "0x%08x" : "0x%06x"
	prop Style :: 0x02
	prop Label :: "base"
	prop JSName :: "base"
	prop Visible :: 1
	prop Writable :: (.iIsModifiable)
	prop NoGen :: 1
	prop Set :: (
	    .base = $1,
	    "ok"
	)
    }
    inst len :: 0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: GBL.DSPTYPE == 62 ? "0x%08x" : "0x%04x"
	prop Style :: 0x08
	prop Label :: "len"
	prop JSName :: "len"
	prop Visible :: 1
	prop Writable :: (.memWritable)
	prop NoGen :: 0
	prop Set :: (
	    .len = $1,
	    "ok"
	)
    }
    inst page ::= (
	
	GBL.DSPTYPE == 62
	    ? -1
	    : GBL.DSPTYPE == 55 
		? -1 
		:.space == "code"
		   ? 0
		   : .space == "data"
		       ? 1
		       	: .space == "io"
		      	    ? 2
			     : 3) {	
	prop Type  :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
	
    
    inst iAllocHeap :: MEM.NOHEAPS == 1 ? 0 : 1 {
	prop Type  :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "create a heap in this memory"
	prop JSName :: "createHeap"
	prop Visible :: 1
	prop Writable :: (.space == "data" || .space == "code/data")
		&& (MEM.NOHEAPS == 0) && .iIsModifiable
	prop NoGen :: 0
	prop Set :: (
	    $a = "ok",
	    if ($1 == 0 && .iReqHeapCount > 0) {
	        .error("This heap is used by one or more of: segment for DSP/BIOS objects, segment for malloc()/free(), TSK default stack segment")
	    }
	    else {
		if ($1 == 0) {
		    .iUserHeapId = 0,
		    .iHeapId = @segment_name
		},
		.iAllocHeap = $1,
		MEM.gDirty = 1,
		$a
	    }
	)
    }
    inst iHeapSize :: 0x007F00/2 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: GBL.DSPTYPE == 62 ? "0x%08x" : "0x%04x"
        prop Style :: 0x02
        prop Label :: "heap size"
	prop JSName :: "heapSize"
        prop Visible :: 1
        prop Writable :: (.iAllocHeap) && (.iIsModifiable) && (MEM.NOHEAPS == 0)
        prop Set :: (
            .iHeapSize =  $1,
            "ok"
        )
        prop NoGen :: 1
    }
    inst iSegZero ::= MEM.SEGZERO
    inst iUserHeapId :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "enter a user defined heap identifier label"
	prop JSName :: "enableHeapLabel"
	prop Set :: (
	    if ($1 == 0) {
		.iHeapId = @segment_name
	    },
	    .iUserHeapId = $1,
	    "ok"
	)
	prop Visible :: 1
	prop Writable :: (.iAllocHeap) && (.iIsModifiable) && (.NOHEAPS == 0)
	prop NoGen :: 1
    }
    inst iHeapId :: @segment_name {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "heap identifier label"
	prop JSName :: "heapLabel"
	prop Set :: (
	    $e = .checkHeapId($1),
	    if ($e == "ok") {
		.iHeapId = $1
	    },
	    $e
	)
	prop Writable :: (.iAllocHeap) && (.iIsModifiable) && (.NOHEAPS == 0) &&(.iUserHeapId)
	prop Visible :: 1
	prop NoGen :: 0
    }
    prop checkHeapId :: (
	$e = "ok",
	scan ($i; MEM) {
	    if ($i.iAllocHeap == 1 && $i.iUserHeapId == 1 && $i.iHeapId == $1 && $i.iHeapId != @segment_name) {
		$e = .error ("This identifier label is already in use"),
		break
	    }
	},
	$e
    ) 
    inst iReqHeapCount :: 0 {	
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    inst space :: ( GBL.DSPTYPE == 55 ? "code/data" : "data") {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	
	prop Enum :: GBL.DSPTYPE == 62
	    ? "code,data,code/data"
	    : GBL.DSPTYPE == 54
	        ? "code,data,io,other"
		: GBL.DSPTYPE == 28
		   ? "code,data,io,other"
	           : "code/data,io"
	prop JSName :: "space"
	prop Visible :: 1
	prop Writable :: (.memWritable)
	prop NoGen :: 1
	prop Set :: (
	    $e = "ok",
	    if ($1 != "data" && $1 != "code/data" && .iAllocHeap == 1) {
		$e = .error("Cannot select this space if a heap will be created")
	    }
	    else {
		.space = $1
	    },
	    $e
	)
    }
    inst iIsModifiable :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
}
object MEM_NULL :: MEM {
    param iComment :: "Place holder segment which allows user to disable heaps"
    param iAllocHeap :: 1
    param iIsUsed :: 0
}
type OBJ {
    isa ObjectMgr
    prop name :: "OBJ"
    prop Visible :: 0
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _objMemDesc, _memSeg, _placement"
	}
    )
    prop _objMemDesc :: ("%8t .obj: block(0x20000) {}")
    prop _memSeg :: MEM.CFGOBJSEG
    prop _placement :: (0x7fffff / 2)
}
   
 
type BUF {
    isa  ObjectMgr
    prop name :: "BUF"
    prop Label :: "BUF - Buffer pool Manager"
    prop IsContainedIn :: SYSTEM 
    prop GlobalIcon :: 199
    prop InstanceIcon :: 200
    prop InstanceHelpTopic :: (
	421
    )
    
    prop GlobalHelpTopic :: (
	321
    )
    prop InstancePropertyPage :: (
	"{B7240DE8-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
	"{B7240DE9-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    prop maxObjs :: (32767)
    
    
    prop AllocType :: (
      if (.gNumOf > 0) {
	"1\0,      _globalAllocDesc, _memSeg, _placement"
      }
    )
    prop _globalAllocDesc :: (
       "%8t.buf: block(0x20000){}"
    )
	    
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: .OBJMEMSEG
    
    prop AllocInst :: (
          "1\0, _instAllocDesc, _instMemSeg, _placement"
    )
    prop _instAllocDesc :: (
          "%8t .%0s$data: block(0x20000) align = 0x%1x {%12t\n %0s$databeg = .;\n .+= %2d; %8t\n }\0, _objAlign, _buflength"
    )
    prop _objAlign :: .align * 2  
    prop _instMemSeg :: .bufseg
    prop _buflength :: (.postalignsize *  .bufcount) * 2
    
    prop cGen :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "buf.h" : ""
    
    prop cGenHInst :: (
	if (GBL.DSPTYPE == 62) {
	    "extern far BUF_Obj %0r;\n\0"
	}
	else {
	    "extern BUF_Obj %0r;\n\0"
	}
    )
    
    
    prop dataSize :: (
	$d = 0,
	scan ($i; BUF) {
	    if ($i.IsConfObj()) {
		$d += $i.len 
	    },
	    $d += 12	
	},
	$d
    )
    
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global ENABLED :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Compile in logging"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    
    inst bufseg :: .OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Memory segment for buffer pool"
	prop JSName :: "bufSeg"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    
    inst bufcount :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Buffer count"
	prop JSName :: "bufCount"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    .bufcount = $1,
            .postalignsize = (.size + (.align - 1)) & ~(.align - 1),
	    .len = $1 * .postalignsize, 
	    "ok"
	)
    }
    
    inst size :: 4 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Buffer size (MADUs)"
	prop JSName :: "size"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
             if($1 < 4) {
                .error("Size should be atleast 4 words")
             }
             else { 
	        .size = $1,
                .postalignsize = ($1 + (.align - 1)) & ~(.align - 1),
                .len = .postalignsize * .bufcount,
	        "ok"
             }
	)
    }
    
    inst align :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Buffer alignment(Power of 2)"
	prop JSName :: "align"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0 
	prop Set :: (
             if($1 < 2) {
                .error("Alignment should be atleast 2 ")
             }
             else { 
	         .align = $1,
                 .postalignsize = (.size + ($1 - 1)) & ~($1 - 1),
                 .len = .postalignsize * .bufcount,
	         "ok"
             }
	 )
    }
    
    inst len :: .size {
	prop Label :: "Buffer pool length (MADUs)"
	prop JSName :: "len"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    inst postalignsize :: .size {
	prop Label :: "Buffer size after alignment (MADUs)"
	prop JSName :: "postalignsize"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: 0
	prop NoGen :: 0
    }
    
}
type CLK {
    isa ObjectMgr
    prop name :: "CLK"
    prop Label :: "CLK - Clock Manager"
    prop IsContainedIn :: SCH
    prop IsConfMod :: 1 		
    prop GlobalIcon :: 103
    prop InstanceIcon :: 104
    prop InstanceHelpTopic :: (
	202
    )
    prop GlobalHelpTopic :: (
	102
    )
    prop InstancePropertyPage :: (
	"{EEB2AB41-51E3-11d0-A61D-0000C070F3E9}"
    )
    prop GlobalPropertyPage :: (
	"{EEB2AB40-51E3-11d0-A61D-0000C070F3E9}"
    )
    prop GenLinkPrologue :: (
	"SECTIONS {%4t\n.%1L: block(0x20000){\n%8t _CLK_start = %6s;\n CLK_F_gethtime = %5s;\n %1U_A_TABBEG = .;\n %4S\n %1U_A_TABEND = .;\n %1U_A_TABLEN = (. - %1U_A_TABBEG) / %2d;\n%4t} > %3s \0, name, _objSize, _memSeg, _linkString, clkFxn, _clkStartFxn"
    )
    prop _clkStartFxn :: (GBL.SUPPORTCSL && .USETIMER) ? ((GBL.DSPSUBTYPE == 5502) ? @_CLK_start5502 : @_CLK_start55) : @FXN_F_nop
    prop GenLinkEpilogue :: (
      if (GBL.DSPSUBTYPE == 5502) {
	"%0t}\n_CLK_PRD = CLK_PRD;\n_CLK_PRDHIGH = CLK_PRDHIGH;\n_CLK_COUNTSPMS = CLK_COUNTSPMS;\n_CLK_REGS = CLK_REGS;\n_CLK_USETIMER = CLK_USETIMER;\n_CLK_TIMERNUM = CLK_TIMERNUM;\n_CLK_TCR = CLK_TCR;\n_CLK_TDDR = CLK_TDDR;\n_CLK_TDDRHIGH = CLK_TDDRHIGH;\n\0"
      }
      else {
	"%0t}\n_CLK_PRD = CLK_PRD;\n_CLK_COUNTSPMS = CLK_COUNTSPMS;\n_CLK_REGS = CLK_REGS;\n_CLK_USETIMER = CLK_USETIMER;\n_CLK_TIMERNUM = CLK_TIMERNUM;\n_CLK_TCR = CLK_TCR;\n_CLK_TDDR = CLK_TDDR;\n\0"
      }
    )
    prop _linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no CLK objs */"
    prop _memSeg :: CLK.OBJMEMSEG
    prop _objSize :: 2
    prop clkFxn :: (.USETIMER == 1) ? .CLKFXN : @FXN_F_zero
    prop maxObjs :: (
	32767				
    )
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    prop localInit :: (
	if (GBL.CALLBACKOBJ != CLK) {
	    CLK.gGBLChain = GBL.CALLBACKOBJ,
	    GBL.CALLBACKOBJ = CLK
	}
    )
    
    prop dataSize :: (
	2 * (CLK.gNumOf + 1)	
    )
    prop localCanCreate :: (
	.USETIMER ? "ok" : .error ("The CLK Manager must be enabled before inserting a CLK")
    )
    prop localCreate :: (
	CLK.HOOKFXN = @CLK_F_run,
	.seizeHwi(.WHICHHWI),
	"ok"
    )
    prop localDelete :: (
	if (.gNumOf == 1) {	
	    if (GBL.CALLMODEL == "far") {
	        CLK.HOOKFXN = @CLK_F_frete,
		.seizeHwi(.WHICHHWI)
	    }
	    else {
	        CLK.HOOKFXN = @CLK_F_rete,
		.seizeHwi(.WHICHHWI)
	    }
	},
	"ok"
    )
    global gGBLChain :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
 	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: .USETIMER
	prop NoGen :: 1
    }
   
   global IMR0TINTMASK  ::  0x10
   {
	prop Visible :: 0
	prop Writable :: .USETIMER
	prop NoGen :: 0
   }
   global IMR1TINTMASK  :: 0x0
   {
	prop Visible :: 0
	prop Writable :: .USETIMER
	prop NoGen :: 0
   }
    global WHICHHWI ::=  (
        .WHICHTIMER ==  "Timer 0" ? Timer_0.iHwi  : Timer_1.iHwi
                         )
    {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: HWI
        prop Label :: "CPU Interrupt"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
    }
 
    global INTBIT ::= (
        .WHICHTIMER ==  "Timer 0" ? 4  : 6
                        )
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: .USETIMER
        prop NoGen :: 0
    }
    global TIMERIMRMASK ::= (
        .WHICHTIMER ==  "Timer 0" ? .WHICHHWI.Ier0Mask : .WHICHHWI.Ier1Mask
                        )
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: .USETIMER
        prop NoGen :: 0
    }
    global WHICHTIMER :: "Timer 0"
    {
        prop Label :: "Timer Selection"
        prop JSName :: "TIMERSELECT"
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: (GBL.DSPSUBTYPE == 5502) ? "Timer 0,Timer 1,Timer 2" : "Timer 0,Timer 1"
        prop Visible :: 1
        prop Writable :: .USETIMER
        prop NoGen :: 1
        prop Set :: (
            if (.WHICHTIMER != $1) {
                if (.USETIMER == 0) {
                    $e = "ok"
                }
                else {   
                    if ($1 == "Timer 0") {
                        $a = Timer_0.iHwi
                    }
                    else  {
                         if ($1 == "Timer 1") {
                             $a = Timer_1.iHwi
                         }
                         else {
                             $a = Timer_2.iHwi
                         }
                    },
                    $e = .seizeHwi($a)
                },
                if ($e == "ok") {
		    .releaseHwi(.WHICHHWI),
                    if ($1 == "Timer 0") {
                        .seizeTimer("Timer 0")
                    }
                    else {
                        if ($1 == "Timer 1") {
                            .seizeTimer("Timer 1")
                        } 
                        else {
                          if ($1 == "Timer 2") {
                            .seizeTimer("Timer 2")
                          } 
                        }
                    },
                    .WHICHTIMER = $1,
                    .HOOKFXN = .gNumOf > 0 ? @CLK_F_run :  @CLK_F_rete,
		    .seizeHwi(.WHICHHWI)
                },
                $e
            }    
        )
        }
   global REGS :: 0x01000 {    
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
    }
      
   global TIMERIMR :: 0x00  {   
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
    }
      
   global TIMERIFR :: 0x01  {   
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
    }
    global TIMERNUM :: 0 {	
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
    }
    global USETIMER :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable CLK Manager"
 	prop JSName :: "ENABLECLK"
	prop Visible :: 1
	prop Writable :: .gNumOf > 0 ? 0 : 1
	prop NoGen :: 0
	prop Set :: (
	    if ($1 == 1 && .USETIMER == 0) {
                .WHICHHWI = Timer_0.iHwi,
                .WHICHTIMER = "Timer 0",
		if (($e = .seizeHwi(.WHICHHWI)) != "ok") {
                    .WHICHHWI = Timer_1.iHwi,
                    .WHICHTIMER = "Timer 1",
		    if (($e = .seizeHwi(.WHICHHWI)) != "ok") {
                        $e
	    }
                },
                if ( $e == "ok") {
		    .USETIMER = 1,
	    	    .TIMEFXN = CLK.HIRES ? CLK.clkFxn() : @CLK_F_getltime,
    		    .HOOKFXN = .gNumOf > 0 ? @CLK_F_run : @CLK_F_rete,
		    .seizeHwi(.WHICHHWI),
                    .seizeTimer(.WHICHTIMER),
		    GlobalStatus.gDirty = 1,
		    if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {
			.releaseHwi(.WHICHHWI),
			.TIMEFXN = @FXN_F_zero,
			.HOOKFXN = @FXN_F_nop,	
			.USETIMER = 0,
			GlobalStatus.gDirty = 1,
			.error("Current stack size inadequate to enable CLK")
		    }
		    else 
		    {
		        if (GBL.ENABLEINST == 1) {
		        IDL_busyObj.Create("IDL"),
			IDL.USEIDLBUSYOBJ = 1,
		        IDL_cpuLoad.Create("IDL"),
                        IDL.AUTOCALCULATE = GBL.OLDAUTOCALCULATE
			  },
			  "ok"
		    }
               },
            $e
	    }
	    else {
		if ($1 == 0 && .USETIMER == 1) {
			.releaseHwi(.WHICHHWI),
			.TIMEFXN = @FXN_F_zero,
			
			.HOOKFXN = @FXN_F_nop,	
			.USETIMER = 0,
		        if (GBL.ENABLEINST == 1) {
			    IDL_busyObj.Delete("IDL"),
			    IDL.USEIDLBUSYOBJ = 0,
			    IDL_cpuLoad.Delete("IDL"),
                            GBL.OLDAUTOCALCULATE = IDL.AUTOCALCULATE,
                            IDL.AUTOCALCULATE = 0
			},
			"ok"
		}
		else {
		    "ok"
		}
	    }
	)
    }
    
    global HIRES ::= 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Use high resolution time for internal timings"
 	prop JSName :: "HIRESTIME"
	prop Visible :: 1
	prop Writable :: .USETIMER
	prop NoGen :: 1
	prop Set :: (
	    if (CLK.USETIMER) {
		CLK.HIRES = $1,
		if (CLK.USETIMER) {
		    CLK.TIMEFXN = CLK.HIRES ? CLK.clkFxn() : @CLK_F_getltime
		},
		"ok"
	    }
	    else {
		.error("CLK Manager must be enabled in order to get high resolution timings.")
	    }
	)
    }
    global INSTRPERCLK :: 1 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    
    global MICROSECONDS :: (((float((CLK.PRD)) + CLK.adjustPrd) * ((CLK.TDDR) + 1.0) * 2 / GBL.CPUCLOCK)) {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style :: 0x04
	prop Format :: "%.4f"
	prop Label :: "Microseconds/Int"
 	prop JSName :: "MICROSECONDS"
	prop Set :: (
	    .setMicroseconds($1)
	)
	prop Visible :: 1
	prop Writable :: ((CLK.PROGTIMREGS != 0) | (.USETIMER == 0)) ? 0 : 1
	prop NoGen :: 0
    }
    
    global PROGTIMREGS ::= 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Directly configure on-chip timer registers"
	prop JSName :: "CONFIGURETIMER"
	prop Visible :: 1
	prop Writable :: .USETIMER
	prop NoGen :: 1
    }
    global TCR :: = 0x20 | CLK.TDDR {	
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global FIXTDDR :: (GBL.DSPTYPE == 62) ? 1 : 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Fix TDDR"
 	prop JSName :: "FIXTDDR"
	prop Visible :: GBL.DSPTYPE != 62
	prop Writable :: CLK.PROGTIMREGS && GBL.DSPTYPE != 62
	prop NoGen :: 1
    }
    
    global TDDR :: (GBL.DSPTYPE == 62) ? 0 : (GBL.DSPSUBTYPE == 5502) ? 0 : (int(round(1000.0 * GBL.CPUCLOCK/2)) >> 16) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: GBL.DSPSUBTYPE == 5502 ? 0x02 :
		GBL.DSPWORDSIZE == 16 ? 0x01 | 0x02
		: 0x02
	prop Label :: GBL.DSPSUBTYPE == 5561 ? "TDDR Register (PREMD=0)" : 
						"TDDR Register"
 	prop JSName :: "TCRTDDR"
	prop Set :: (
	    if ( (GBL.DSPSUBTYPE != 5502) && ($1 > 0xf) ) {
	        .error("The on-chip timer does not have enough range to support this value, maximum is 15.")
	    }
	    else {
		CLK.TDDR = $1,
		CLK.MICROSECONDS = ((float((CLK.PRD)) + CLK.adjustPrd) * ((CLK.TDDR) + 1.0) * 2 / GBL.CPUCLOCK),
		if (CLK.CALLBACKOBJ != nil) {
		    CLK.CALLBACKOBJ.call()
		},
		"ok"
	    }
	)
	prop Visible :: GBL.DSPTYPE != 62
	prop Writable :: CLK.PROGTIMREGS && GBL.DSPTYPE != 62
	prop NoGen :: 0 
    }
    
    global TDDRHIGH ::= ((.TDDR & 0xffff0000) >> 16) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    global PRD :: int(round((1000.0 * GBL.CPUCLOCK / (CLK.TDDR + 1) / 2) - CLK.adjustPrd))  { 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: GBL.DSPSUBTYPE == 5502 ? 0x02 :
		GBL.DSPWORDSIZE == 16 ? 0x01 | 0x02
		: 0x02
	prop Label :: "PRD Register"
 	prop JSName :: "PRD"
	prop Set :: (
	    
	    CLK.PRD = $1,
	    CLK.MICROSECONDS = ((float((CLK.PRD)) + CLK.adjustPrd) * ((CLK.TDDR) + 1.0) * 2 / GBL.CPUCLOCK),
	    if (CLK.CALLBACKOBJ != nil) {
		CLK.CALLBACKOBJ.call()
	    },
	    "ok"
	)
	prop Visible :: 1
	prop Writable :: ((.PROGTIMREGS) && (.USETIMER)) ? 1 : 0
	prop NoGen :: 0
    }
    
    
    global PRDHIGH ::= ((.PRD & 0xffff0000) >> 16) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    
    global COUNTSPMS ::= int(round(GBL.CPUCLOCK * 1000.0 / (CLK.TDDR + 1) / 2)) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    
    
    global COUNTSPMSHIGH ::= ((.COUNTSPMS & 0xffff0000) >> 16) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    prop adjustPrd :: (GBL.DSPTYPE == 62 ? 0 : 1)
    
     	
    prop seizeHwi :: (
	if ($1.client == "USER" && $1.function != @HWI_unused) {
	    .error("Interrupt mapped to selected timer is already in use.")
	}
	else {
	    if( $1.client == "CSL") {
	    .error("Interrupt mapped to selected timer is already in use by CSL.")
	    }
	    else {
	    	$1.function = @CLK_F_isr,
	    	$1.client = "CLK",
	    	$1.iUseDispatcher = (CLK.HOOKFXN == @CLK_F_run ? 1 : 0),
	    	$1.iArg = ($1.iUseDispatcher == 1 ? @CLK_A_TABBEG : 0),
	    	HWI.gDirty = 1,
	    	"ok"
	    }
	}
    )
    prop releaseHwi :: (
	$1.function = @HWI_unused,
	$1.client = "USER",
	$1.iUseDispatcher = 0,
	$1.iArg = 0,
	HWI.gDirty = 1,
	"ok"
    )
    prop seizeTimer :: (
        if( $1 == "Timer 0") {
            .WHICHTIMER = "Timer 0",
            .WHICHHWI = Timer_0.iHwi,
            .REGS = 0x01000,
            .TIMERNUM = 0,
            .TIMERIMR = 0x0,
            .TIMERIFR = 0x1,
            .INTBIT = 4,
            .TIMERIMRMASK = .WHICHHWI.Ier0Mask,
            .IMR0TINTMASK = .WHICHHWI.Ier0Mask,
            .IMR1TINTMASK = 0x0,
            .setMicroseconds(.MICROSECONDS)
        }
        else {
          if ($1 == "Timer 1") {
            .WHICHTIMER = "Timer 1",
            .WHICHHWI = Timer_1.iHwi,
            .REGS = 0x2400,
            .TIMERNUM = 1,
            .TIMERIMR = 0x45,
            .TIMERIFR = 0x46,
            .INTBIT = 6,
            .TIMERIMRMASK = .WHICHHWI.Ier1Mask,
            .IMR0TINTMASK =  0x0,
            .IMR1TINTMASK =  .WHICHHWI.Ier1Mask,
            .setMicroseconds(.MICROSECONDS)
          } 
          else {
            if ($1 == "Timer 2") {
              .WHICHTIMER = "Timer 2",
              .WHICHHWI = Timer_2.iHwi,
              .REGS = 0x4000,
              .TIMERNUM = 2,
              .TIMERIMR = 0x0,
              .TIMERIFR = 0x1,
              .INTBIT = 11,
              .TIMERIMRMASK = .WHICHHWI.Ier0Mask,
              .IMR0TINTMASK = .WHICHHWI.Ier0Mask,
              .IMR1TINTMASK =  0x0,
              .setMicroseconds(.MICROSECONDS)
            } 
          }
        },
            "ok"
    )
    prop setMicroseconds :: (
	
	
	$a = FIXTDDR == 1 ? .TDDR : (GBL.DSPSUBTYPE == 5502 ? 0xffffffff : 0xf),
	$b = GBL.DSPSUBTYPE == 5502 ? 0xffffffff : 0xffff,
	$c = (float($a) + 1.0) * ((float($b) + .adjustPrd) / (GBL.CPUCLOCK / 2)),
	if ($1 < $c && $1 > 0.1) {
	    if (.FIXTDDR == 0) {
		.TDDR = int((1.0 * $1 * GBL.CPUCLOCK / 2) / (float($b) + .adjustPrd))
	    },
	    
	    .PRD = int((1.0 * $1 * GBL.CPUCLOCK) / (2 * (.TDDR + 1.0))) - .adjustPrd,
	    .MICROSECONDS = ((float((.PRD)) + CLK.adjustPrd) * ((.TDDR) + 1.0) * 2 / GBL.CPUCLOCK),
	    if (.CALLBACKOBJ != nil) {
		.CALLBACKOBJ.call()
	    },
	    "ok"
	}
	else {
	    .error("The on-chip timer does not have enough range to support this combination of DSP MIPS and Microseconds/Int")
	}
    )
    
    prop call :: (
	$a = ((float((CLK.PRD)) + CLK.adjustPrd) * ((CLK.TDDR) + 1.0) * 2 / GBL.CPUCLOCK),
	$b = CLK.MICROSECONDS,
	$e = "ok",
	if (($e = .setMicroseconds(CLK.MICROSECONDS)) == "ok") {
	    if (CLK.gGBLChain != nil) {
		$e = CLK.gGBLChain.call()
	    },
	    if ($e != "ok") {
		.setMicroseconds($b),
		.error($e)
	    }
	    else {
		"ok"
	    }
	}
	else {
	    $e
	}
    )
    global INSTRUCTIONS ::= (
	1.0 * (float(CLK.PRD) + CLK.adjustPrd) * (CLK.TDDR + 1.0) * 1
    ) {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style :: 0x04
	prop Format :: "%.0f"
	prop Label :: "Instructions/Int"
	prop Visible :: 1
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    global TIMEFXN ::= CLK.clkFxn() {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    
    
    global HOOKFXN ::= (.gNumOf > 0 ? @CLK_F_run : @CLK_F_rete) {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    
    global CLKFXN ::= (GBL.DSPSUBTYPE == 5502 ? @CLK_F_getBIOStime :
		(CLK.PRD == 0xffff) ? @CLK_F_getfhtime : @CLK_F_getshtime) {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst function :: @FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "function"
 	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
    
    inst Order :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
	prop NoGen :: 1
	prop Writable :: 1
    }
    
    inst iPri :: 0 {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}
type PRD {
    isa ObjectMgr
    prop name :: "PRD"
    prop Label :: "PRD - Periodic Function Manager"
    prop IsContainedIn :: SCH
    
    prop IsConfMod :: 1
    prop GlobalIcon :: 119
    prop InstanceIcon :: 120
    prop InstanceHelpTopic :: (
	210
    )
    
    prop GlobalHelpTopic :: (
	110
    )
    prop InstancePropertyPage :: (
	"{B7240DE0-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
	"{B7240DE1-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    prop STSGetMaxFmt :: (
	"%g ticks"
    )
    prop STSGetSumFmt :: (
	PRD.STSGetMaxFmt()
    )
    prop STSGetAvgFmt :: (
	"%.2f ticks"
    )
    prop GetPeriod :: .period
    prop IsOneShot :: .mode == "one-shot" ? 1 : 0
    
    prop GenLinkPrologue :: (
	"SECTIONS {%4t\n.%1L: block(0x20000){\n%8t %1U_A_TABBEG = .;\n %4S\n %1U_A_TABEND = .;\n %1U_A_TABLEN = (. - %1U_A_TABBEG) / %2d;\n%4t} > %3s%5s\0, name, objSize, memSeg, linkString, pageString"
    )
    prop GenLinkEpilogue :: (
	"%0t}\n\0"
    )
    prop linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop pageString :: GBL.DSPTYPE == 62 ? "" : GBL.DSPTYPE == 55 ? "" : GBL.DSPTYPE == 28 ? " PAGE 1 " : " PAGE 1"
    prop memSeg :: PRD.OBJMEMSEG
    prop objSize :: GBL.DSPTYPE == 55 ? (10 * 1) * 2 : (10 * 1)
    prop dataSize :: (
	(10 * 1) * PRD.gNumOf
    )
    prop localInit :: (
	if (CLK.CALLBACKOBJ != nil) {
	    .error("PRD initialization failure")
	},
	CLK.CALLBACKOBJ = PRD,
	if (PRD.USECLK && PRD_clock.iIsUsed == 0) {
	    PRD_clock.Create("PRD")
	},
	if (PRD_clock.iIsUsed == 1) {
	  if (.gNumOf == 0) {
            if (TSK.USETSK == 1 && TSK.TSKTICK == "PRD") {
  	      PRD_clock.function = @PRD_F_tick
            }
            else {
  	      PRD_clock.function = @FXN_F_nop
            }
          }
          else {
  	    PRD_clock.function = @PRD_F_tick
          }
        }
    )
    prop localCanCreate :: (
	if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {
	  .error(" System Stack Size too small")
	  }
        else {
	.myCreate("can")
	}
    )
    
    prop localCreate :: (
	STS.gNumEmbed += 1,
	if (($a = .myCreate("do")) == "ok") {
	  if (PRD_clock.iIsUsed == 1) {
	    if (.gNumOf == 0) {
  	      PRD_clock.function = @PRD_F_tick
            }
          }
        },
        $a
    )
    
    prop localCanDelete :: (
	.myDelete("can")
    )
    prop localDelete :: (
	STS.gNumEmbed -= 1,
	if (($a = .myDelete("do")) == "ok") {
	  if (.gNumOf == 1) {
	    if (PRD_clock.iIsUsed == 1) {
              if (TSK.USETSK == 1 && TSK.TSKTICK == "PRD") {
  	        PRD_clock.function = @PRD_F_tick
              }
              else {
  	        PRD_clock.function = @FXN_F_nop
              }
            }
	  }
	},
        $a
    )
    
    prop maxObjs :: (
	32767				
    )
    prop myCreate :: (
	if (PRD_swi.function != @PRD_F_swi) {
	    PRD_swi.function = @PRD_F_swi
	},
	if (PRD_swi.iIsUsed) {
	    "ok"
	}
	else {
	    if (SWI.CanCreate() == "ok") {
		if ($1 == "do") {
		    if (KNL_swi.iIsUsed == 1 && PRD_swi.pri == 0) {
			PRD_swi.pri = 1
		    },
		    PRD_swi.Create("PRD")
		}
		else {
		    "ok"
		}
	    }
	    else {
		.error("Can't create an SWI for PRD (try deleting a SWI)")
	    }
	}
    )
    
    prop myDelete :: (
	if (PRD_swi.function != @PRD_F_swi) {
	    PRD_swi.function = @PRD_F_swi
	},
	if (.gNumOf == 1) {
	    if ($1 == "do") {
		PRD_swi.Delete("PRD")
	    }
	    else {
		"ok"
	    }
	}
	else {
	    "ok"
	}
    )
    
    prop call :: (
	if (CLK.USETIMER != 0) {
	    PRD.MICROSECONDS = CLK.MICROSECONDS
	},
	PRD.CALLBACKOBJ.call()
    )
    
    prop cGen :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "prd.h" : ""
    
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far PRD_Obj %0r;\n\0"
	}
	else {
	    "extern PRD_Obj %0r;\n\0"
	}
    )
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global USECLK :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Use CLK Manager to drive PRD"
	prop JSName :: "USECLK"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    if ($1 == 1 && .USECLK == 0) {
		if (CLK.USETIMER == 0) {
		    .error("In order to drive periodic functions, the CLK Manager must be enabled")
		}
		else {
		    .USECLK = 1,
		    .MICROSECONDS = CLK.MICROSECONDS,
		    CLK.CALLBACKOBJ = PRD,
		    PRD_clock.Create("PRD"),
		    GlobalStatus.gDirty = 1,
		    if (GlobalStatus.MinStackSize >= MEM.STACKSIZE){
                      .USECLK = 0,
		      .MICROSECONDS = 0.0,
                      CLK.CALLBACKOBJ = nil,
                      PRD_clock.Delete("PRD"),
                      .error("Current Stack size inadequate to enable this option")
		      }
		    else {
		      "ok"
		    }
		}
	    }
	    else {
		if ($1 == 0 && .USECLK == 1) {
		    .USECLK = 0,
		    .MICROSECONDS = 0.0,
		    CLK.CALLBACKOBJ = nil,
		    PRD_clock.Delete("PRD")
		},
		      "ok"
	    }
	)
	prop NoGen :: 1
    }
   
    
    
    global MICROSECONDS ::= CLK.MICROSECONDS {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style :: 0x04
	prop Format :: "%.1f"
	prop Label :: "Microseconds/Tick"
	prop JSName :: "MICROSECONDS"
	prop Visible :: 1
	prop Writable :: .USECLK == 0
	prop NoGen :: 1
    }
    global SCALAR ::= (		
	$d = 2,
	$f = 0,
	
	while ($d <= 0x4000 && $f == 0) {
	    scan ($i; PRD) {
		if (($i.period / $d) * $d != $i.period) {
		    $f = 1
		}
	    },
	    if ($f == 0) {
		$d = 2 * $d
	    }
	},
	$d / 2
    ) {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    
    prop DEFAULT_THOOKFXN :: @KNL_tick_stub 
    global THOOKFXN :: .DEFAULT_THOOKFXN {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "System Tick Hook Function"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
    }
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst period :: 0xffff {	
	prop Label :: "period (ticks)"
	prop JSName :: "period"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    if ($1 > 0) {
		.period = $1,
		.gDirty = 1,
		"ok"
	    }
	    else {
		.error("Periodic function periods must be greater than 0")
	    }
	)
    }
    inst mode :: "continuous" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "continuous,one-shot"
	prop JSName :: "mode"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst function :: @FXN_F_nop {	
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst arg0 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg0"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst arg1 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg1"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst milliseconds ::= (
	(.period * PRD.MICROSECONDS) / 1000.0
    ) {
	prop Label :: "period (ms)"
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style :: 0x04
	prop Format :: "%.1f"
	prop Visible :: 1
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    inst Order :: 0 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
        prop NoGen :: 1
        prop Writable :: 1
    }
    
    inst iPri :: 0 {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}
object PRD_swi :: SWI {
    param function :: @PRD_F_swi
    param iComment :: "This Software ISR executes all configured PRD functions"
    param iDelUser :: "PRD"
    param iDelMsg  :: (
	"This object is automatically deleted when all PRD objects are deleted"
    )
}
object PRD_clock :: CLK {
    param function :: @PRD_F_tick
    param iComment :: "This clock function calls PRD_tick from within the on-chip timer ISR"
    param iDelUser :: "PRD"
    param iDelMsg  :: (
	"This object is automatically deleted by disabling the 'Use CLK Manager to drive PRD' option of PRD"
    )
}
type RTDX {
    isa ObjectMgr
    prop Label :: "RTDX - Real-Time Data Exchange Settings"
    prop name :: "RTDX"
    prop IsConfMod :: .USERTDX		
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 145
    prop InstanceIcon :: 146
    prop GlobalHelpTopic :: (
	113
    )
    prop InstanceHelpTopic :: (
	213	
    )
    prop InstancePropertyPage :: (		
	"{f80273c0-3838-11d2-a32c-006097656921}"
    )
    
    prop GlobalPropertyPage :: (		
	"{050a0600-3839-11d2-a32c-006097656921}"
    )
    prop AllocType :: (.USERTDX ?
	"2\0, _rtdxDataAllocDesc, _rtdxDataSeg, _placement,
	     _rtdxTextAllocDesc, _rtdxTextSeg, _placement"
	:
	""
    )
    prop _rtdxDataAllocDesc :: (
	" .%1L_data: block(0x20000){} \0, name"	
    )
    prop _rtdxTextAllocDesc :: (
	if (MEM.ENABLELOADSEG == 1) {
	    if (MEM.RTDXTEXTMEMSEG == MEM.LOADRTDXTEXTMEMSEG) {
		" .%1L_text: {} \0, name"	
	    }
	    else {
		" .%1L_text: {} load > %2s, run \0, name, _loadRtdxTextMemSeg"
	    }
	}
	else {
	    " .%1L_text: {} \0, name"
	}
    )
    prop _rtdxDataSeg :: RTDX.DATAMEMSEG
    prop _rtdxTextSeg :: MEM.RTDXTEXTMEMSEG
    prop _loadRtdxTextMemSeg :: MEM.LOADRTDXTEXTMEMSEG
    prop _placement :: (0x7fffff / 2)
    prop _objSize :: RTDX.BUFMEMSIZE
    prop GenLinkPrologue :: (.USERTDX ?
         "_RTDX_interrupt_mask = 0x%1x;\n\0, _interruptMask"
	:
	""
    )
    prop _interruptMask :: RTDX.MASK
    
    prop cGen :: 1
    
    
    prop noObjectAlias :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "rtdx.h" : ""
    
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
            if (.iChannelMode == "output") {
	        "extern far RTDX_outputChannel %0r;\n\0"
	    }
	    else {
	        "extern far RTDX_inputChannel %0r;\n\0"
	    }
	}
        else {
            if (.iChannelMode == "output") {
                "extern RTDX_outputChannel %0r;\n\0"
	    }
	    else {
	        "extern RTDX_inputChannel %0r;\n\0"
	    }
        }
    )
    prop cGenCInst :: (
	if (.iChannelMode == "output") {
	    "RTDX_CreateOutputChannel(%0r);\n\0"
	}
	else {
	    "RTDX_CreateInputChannel(%0r);\n\0"
	}
    )
    prop dataSize :: (
	$d = 0,
	if (.USERTDX) {
	    $d = RTDX.BUFMEMSIZE
	}
	else {
	    $d = 0
	},
	scan ($a; RTDX) {
	    if ($a.iChannelMode == "output") {
		$d += 1
	    }
	    else {
		$d += 3
	    }
	},
	$d
    )
    prop localCanCreate :: (
	$e = "ok",
	if (RTDX.USERTDX != 1) {
	    $e = .error("RTDX manager not enabled")
	},
	$e
    )
    global USERTDX ::= 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable Real-Time Data Exchange (RTDX)"
	prop JSName :: "ENABLERTDX"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
        prop Set :: (
            if($1 == 0) {
                if(HST.LNKTYPE == "RTDX") {
                    .error("RTDX is being used by HST; select a different host link type before attempting to disable RTDX") 
                }
                else {
		    if (.gNumOf > 0) {
			.error("Cannot disable RTDX until all RTDX objects are deleted.")
		    }
		    else {
		        GlobalStatus.gDirty = 1,   
                        .USERTDX = $1,
	                if (RTDX.CALLBACKOBJ != nil) {
		            RTDX.CALLBACKOBJ.call()
                        },
                        "ok"
		    }
                }
            }
	    else {
		GlobalStatus.gDirty = 1,	
                .USERTDX = $1,
		if (RTDX.CALLBACKOBJ != nil) {
		    RTDX.CALLBACKOBJ.call()
                },
                "ok"
            }
        )
    }
    global USERTEXECUTION ::= 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable Real-Time Execution Control"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global RTDXTYPE :: "JTAG" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "JTAG,Simulator"
	prop Label :: "RTDX Mode"
	prop JSName :: "MODE"
	prop Visible :: 1
	prop Writable :: .USERTDX
	prop NoGen :: 1
	prop Set :: (
	    .RTDXTYPE = $1,
	    if (RTDX.CALLBACKOBJ != nil) {
		RTDX.CALLBACKOBJ.call()
	    },
	    "ok"
	)
     }
    global DATAMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "RTDX Data Segment (.rtdx_data)"
	prop JSName :: "RTDXDATASEG"
	prop Visible :: 1
	prop Writable :: .USERTDX 
	prop NoGen :: 0
    }
    
    global BUFMEMSIZE ::= (256 + 2) * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE) {  
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop Label :: "RTDX Buffer Size (MAUs)"
	prop JSName :: "BUFSIZE"
	prop Visible :: 1
	prop Writable :: .USERTDX 
	prop NoGen :: 0
        prop Set :: (
	    if (HST.RTDX == 0) {
                .BUFMEMSIZE = $1,
		GlobalStatus.gDirty = 1,	
		"ok"
	    }
	    else {
                if ($1 < (HST.MAXFRAMESET + 2) * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) {
                    .error("size (in MAUs) must be at least: (largest configured HST channel framesize in words + 2) * (MAUs per word)")
                }
                else {
                    .BUFMEMSIZE = $1,
		    GlobalStatus.gDirty = 1, 	
		    if (HST.LNKTYPE == "RTDX") {
			HST.MAXFRAMEALLOWED = (.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 2,
			"ok"
		    }
		    else {
			"ok"
		    }
                }
	    }
        )
    }
    global TEXTMEMSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.codeMember($1)
	prop Label :: "RTDX Text Segment (.rtdx_text)"
	prop Visible :: 0
	prop Writable :: .USERTDX 
	prop NoGen :: 1
    }
    global MASK :: 0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%08x"
	prop Style :: 0x02
	prop Label :: "RTDX Interrupt Mask"
	prop JSName :: "INTERRUPTMASK"
	prop Visible :: 1
	prop Writable :: .USERTDX 
	prop NoGen :: 1
	prop Set :: (
	    .MASK = $1,
	    "ok"
	)
    }
    
    inst iChannelMode :: "output" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Channel Mode"
	prop JSName :: "channelMode"
	prop Enum :: "input,output"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    GlobalStatus.gDirty = 1,
	    .iChannelMode = $1,
	    "ok"
	)
    }
    
     global CALLBACKOBJ :: nil {
	 prop Visible :: 0
	 prop Writable :: 0
	 prop NoGen :: 1
    }
}
type HST {
    isa  ObjectMgr
    prop name :: "HST"
    prop Label :: "HST - Host Channel Manager"
    prop IsContainedIn :: IOF
    prop FileStream :: 1
    prop GlobalIcon :: 107
    prop InstanceIcon :: 108
    prop GlobalHelpTopic :: (
	104
    )
    prop InstanceHelpTopic :: (
	204
    )
    prop maxObjs :: (
	GBL.DSPWORDSIZE
    )
    prop dataSize :: (
	$b = 0,
	scan ($i; HST) {
	    if ($i.IsConfObj()) {
		$b += ((6) + $i.framesize) * $i.numframes + ((50) * 2) + (8 * 1)
	    }
	},
	$b
    )
    prop InstancePropertyPage :: (
	    "{B7240DEA-AA51-11cf-9BFE-0000C0AC14C8}"
    )
    
    prop GlobalPropertyPage :: (
	    "{B7240DEB-AA51-11cf-9BFE-0000C0AC14C8}"
    )
    prop DependsOn :: "HWI"
    prop localCreate :: (
	PIP.gNumEmbed += 1,
	if (.gNumOf == 0) {
	    (LNK_dataPump.Create("HST"))
	},
     	"ok"
    )
    prop localDelete :: (
	PIP.gNumEmbed -= 1,
	$b = 0,			
	scan ($i; HST) {
	    if ($i != self) {
	        if($i.IsConfObj()) {
	            if($i.framesize > $b) {
	                $b = $i.framesize 
	            } 
	        }
	    }
        },
	.MAXFRAMESET = $b,
	if (.gNumOf == 1) {
	    (LNK_dataPump.Delete("HST"))
	},
	"ok"
    )
    prop AllocType :: (
	"2\0, _globalAllocDesc, _memSeg, _placement, \
	      _dsmAllocDesc, _dsmMemSeg, _placement"
    )
    prop _globalAllocDesc :: (
	"%8t .%1L: block(0x20000){%12t\n  %1U_A_TABBEG = .;\n _%1U_A_TABBEG = .;\n %2S\n %1U_A_TABEND = .;\n _%1U_A_TABEND = .;\n  %1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;\n _%1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;%8t\n }\0, name, _linkString, _objSize"
    )
    prop _dsmAllocDesc :: (
	"%8t .dsm: block(0x20000) {}"
    )
    prop _placement :: (0x7fffff / 2)
    prop AllocInst :: (
	"1\0, _instAllocDesc, _objMemSeg, _placement"
    )
    prop _instAllocDesc :: (
	"/* %0s buffer */\n.hst%2d: block(0x20000) %3S\0, name, _objId, _alignString, _objAlign"
    )
    prop _alignString :: .bufalign > 1 ? "align = 0x%4x {}" : ""
    prop _objId :: .iId
    prop _objAlign :: .bufalign
    prop _objMemSeg :: .bufseg
    prop _linkString :: (.gNumOf + .gNumEmbed) > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop _memSeg :: HST.OBJMEMSEG
    prop _dsmMemSeg :: HST.DSMBUFSEG
    prop _objSize :: (8 * 1)
    
    prop cGen :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "hst.h" : ""
    
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far HST_Obj %0r;\n\0"
	}
	else {
	    "extern HST_Obj %0r;\n\0"
        }
    )
    prop modifiable :: (
	(.iDelUser == "USER" ? 1 : 0)
    )
    global gNumEmbed :: 0 {     
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global LNKTYPE :: (
		if (0 == 0) {
		     "RTDX"
		}
		else {
		    if (0 == 1) {
			"Shared Memory"
		    }
		    else {
		        if (0 == 3) {
			    "EVM54"
		        }
		        else {
			    "NONE"
		        }
		    }
		} ) {
        prop Label :: "Host Link Type"
	prop JSName :: "HOSTLINKTYPE"
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "RTDX,NONE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (
	    if ($1 == "RTDX") {
		if (RTDX.USERTDX == 0) {
                    .error("RTDX module must be enabled before it can be used by HST")
		}
		else {
                    if ((RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 2 < .MAXFRAMESET) {
                        .error("RTDX buffer size too small for largest configured HST channel")
                    }
                    else {
			if (.LNKTYPE == "NONE") {
                    	    GlobalStatus.gDirty = 1,
                            .LNKTYPE = $1,
	    		    $b = 0,
	    		    scan ($i; HST) {
	        	        if($i.IsConfObj()) {
	             		    if($i.framesize > $b) {
	                 	        $b = $i.framesize 
	             	    	    } 
	         	        }
            		    },
			    .MAXFRAMESET = $b,
    			    .MAXFRAMEALLOWED = (RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 2, 
                            "ok"
			}
			else {
                            .LNKTYPE = $1,
    			    .MAXFRAMEALLOWED = (RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 2, 
                            "ok"
			}
                    }
		}
	    }
	    else {
		if ($1 == "Shared Memory") {
                    if ((.DSMMEMSIZE/4) < .MAXFRAMESET) {
                        .error("Shared memory buffer too small for largest configured HST channel")
                    }
                    else {
			if (.LNKTYPE == "NONE") {
                    	    GlobalStatus.gDirty = 1,
                            .LNKTYPE = $1,
	    		    $b = 0,
	    		    scan ($i; HST) {
	        	        if ($i.IsConfObj()) {
	             		    if($i.framesize > $b) {
	                 	        $b = $i.framesize 
	             	    	    } 
	         	        }
            		    },
			    .MAXFRAMESET = $b,
    			    .MAXFRAMEALLOWED  = .DSMMEMSIZE/4,
                            "ok"
			}
			else {
                            .LNKTYPE = $1,
    			    .MAXFRAMEALLOWED  = .DSMMEMSIZE/4,
                            "ok"
			}
                    }
		}
		else {
                    GlobalStatus.gDirty = 1,
                    .LNKTYPE = $1,
                    "ok"
		}
            }
        )
    }
    global RTDX ::= .LNKTYPE == "RTDX" ? 1 : 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use RTDX for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global DSM ::= .LNKTYPE == "Shared Memory" ? 1 : 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Shared Memory for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global EVM54 ::= .LNKTYPE == "EVM54" ? 1 : 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use EVM54's I/O ports for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global NONE ::= .LNKTYPE == "NONE" ? 1 : 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "No host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global MAXFRAMESET ::= (
	    $b = 0,		
	    scan ($i; HST) {
	        if($i.IsConfObj()) {
	             if($i.framesize > $b) {
	                 $b = $i.framesize 
	             } 
	         }
            }
	) {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAXFRAMESET"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global MAXFRAMEALLOWED ::= .RTDX == 1 ? (RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 2 : .DSMMEMSIZE /4 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAXFRAMEALLOWED"
        prop Visible :: 0 	
        prop Writable :: 1
        prop NoGen :: 0
    }
    global DSMBUFSEG ::= .OBJMEMSEG {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Shared Memory Segment"
        prop Visible :: 0			
        prop Writable :: .DSM 
        prop NoGen :: 0
    }
 
    global DSMMEMSIZE ::= 1024 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop Label :: "Shared Memory Frame Size (MAUs)"
        prop Visible :: 0
        prop Writable :: .DSM
        prop NoGen :: 0
        prop Set :: (
            if ($1 < HST.MAXFRAMESET *4) {
                .error("size (in MAUs) must be at least: 4 * largest configured HST channel framesize (in words)")
            }
            else {
                .DSMMEMSIZE = $1,
                GlobalStatus.gDirty = 1,    
	        if (.LNKTYPE == "Shared Memory") {
	            .MAXFRAMEALLOWED  = .DSMMEMSIZE/4,
                    "ok"
		}
		else {
		    "ok"
		}
            }
        )
    }
    inst mode :: "output" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "mode"
	prop Enum :: "input,output"
	prop Visible :: 1
	prop Writable :: .modifiable()
	prop NoGen :: 0
    }
    inst bufseg ::= .OBJMEMSEG {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "bufseg"
	prop JSName :: "bufSeg"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst bufalign :: 4 { 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "bufAlign"
	prop Visible :: 1
	prop Writable :: .modifiable()
	prop NoGen :: 1
	prop Set :: (	        
	    if ($1 < 4) {		
	        .error("Alignment must be greater than or equal to 4")
	    }
	    else {
		if (($1 % 2) != 0) {  	
	            .error("Alignment must be a power of 2")
		}
		else {
		    $i = $1,	
		    while ((($i % 2) == 0) && ($i != 2)) {
		        $i = $i / 2
		    },
		    if(($i % 2) != 0) {	
	                .error("Alignment must be a power of 2")
		    }
		    else {	     	
		        .bufalign = $1,
	  	        "ok"
		    }
		}
	    }
	)
    }
    inst buf :: "<NULL>" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst framesize :: 0x80 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "framesize (words)"
	prop JSName :: "frameSize"
	prop Style :: 0x01 | 0x02
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    if ($1 < 1) {
		.error("framesize must be >= 1.")
	    }
	    else {
		if (($1 > .MAXFRAMEALLOWED) && ((.RTDX == 1) || (.DSM == 1)) ) {
		    if (.RTDX == 1) {
		        .error("size (in words) is limited to: (RTDX buffer size in MAUs) / (MAUs per word) - 2")
		    }
		    else {
		            .error("size (in words) is limited to: shared memory frame size (in MAUs)/4")
		    }
		}
		else {
		    .framesize = $1,		
		    $b = 0,			
		    scan ($i; HST) {
	        	if($i.IsConfObj()) {
	            	    if($i.framesize > $b) {
	                	$b = $i.framesize 
	            	    } 
	        	}
        	    },
		    .MAXFRAMESET = $b,		
	  	    GlobalStatus.gDirty = 1,	
		    "ok"
		}
	    }
	)
    }
    inst numframes :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01
	prop JSName :: "numFrames"
	prop Visible :: 1
	prop Writable :: .modifiable()
	prop NoGen :: 0
	prop Set :: (
	    if ($1 < 1) {
		.error("Channels must contain at least 1 frame.")
	    }
	    else {
		GlobalStatus.gDirty = 1,
		.numframes = $1,
		"ok"
	    }
	)
    }
    inst stsflg :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "statistics"
	prop JSName :: "statistics"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst notify :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyFxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "DHL" || .iDelUser != "USER" ? 0 : 1)
	prop NoGen :: 0
	prop TabName :: "Notify Function"
    }
    inst arg0 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg0"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "DHL" || .iDelUser != "USER" ? 0 : 1)
	prop NoGen :: 0
	prop TabName :: "Notify Function"
    }
    inst arg1 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg1"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "DHL" || .iDelUser != "USER" ? 0 : 1)
	prop NoGen :: 0
	prop TabName :: "Notify Function"
    }
    
    inst lnk ::= .RTDX ? "RTDX" : "NOTRTDX" {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "link type"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst iDHLAvailable :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Make this channel available for a new DHL device"
	prop JSName :: "availableForDHL"
        prop Set :: (
	    if (($1 == 0) && (.iDHLAvailable == 1)) {
		DHL.gChannelsAvailable--
	    }
	    else {
		if (($1 == 1) && (.iDHLAvailable == 0)) {
		    DHL.gChannelsAvailable++
		}
	    },
	    .iDHLAvailable = $1,
	    "ok"
	)
	prop Writable :: .modifiable()
        prop Visible :: 1
	prop NoGen :: 1
    }
    
    inst bufFrameAlign ::= .bufalign  { 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
}
object LNK_dataPump :: IDL {
    param function :: @LNK_F_dataPump
    param cycles :: 0			
    param iDelUser :: "HST"
    param iDelMsg  :: (
	"This object cannot be deleted"
    )
}
object RTA_dispatcher :: IDL {
    param function :: @RTA_F_dispatch
    param cycles :: 0			
    param iDelUser :: "HST"
    param iDelMsg  :: (
	"This object cannot be deleted"
    )
}
object RTA_fromHost :: HST {
    param iComment  :: (
	"Used to access LOG and STS data"
    )
    param mode :: "input"
    param framesize :: 8 
    param numframes :: 1 
    param iDelUser :: "HST"
    param iDelMsg  :: (
	"This object cannot be deleted"
    )
    param iDHLAvailable :: 0 
} 
object RTA_toHost :: HST {
    param iComment  :: (
	"Used to access LOG and STS data"
    )
    param mode :: "output"
    param framesize :: 64 
    param numframes :: 1 
    param iDelUser :: "HST"
    param iDelMsg  :: (
	"This object cannot be deleted"
    )
    param iDHLAvailable :: 0
}
 
type HWI {
    isa	 ObjectMgr
    prop name :: "HWI"
    prop Label :: "HWI - Hardware Interrupt Service Routine Manager"
    prop IsContainedIn :: SCH
    prop SortChildHierView :: 0
    prop GlobalIcon :: 109
    prop InstanceIcon :: 110
    prop InstanceHelpTopic :: (
	205
    )
    
    prop GlobalHelpTopic :: (
	105
    )
    prop dataSize :: (
	 0 * HWI.gNumOf
    )
    prop localCanCreate :: (
	.error("New hardware interrupt objects cannot be created")
    )
    prop InstancePropertyPage :: (
	    "{B7240DE6-AA51-11cf-9BFE-0000C0AC14C7}"
    )
   
    prop GlobalPropertyPage :: (
	    "{B7240DE7-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    prop DependsOn :: "GBL,OBJ,CLK,IDL,LCK,LOG,MBX,MEM,PIP,PRD,QUE,RTDX,SEM,STS,SYS"
   prop AllocType :: (
	"3\0,	_stubsAllocDesc,	_memSeg,	_placement,
		_vectAllocDesc,  	_vecSeg,	_minplace,
		_dispAllocDesc,		_dispSeg,       _minplace "
    )
   prop  _dispAllocDesc :: (
        "%8t .hwi_disp_sec:     {}"
		)
    prop _stubsAllocDesc :: (
	"%8t .%1L:  {} \0, name"
    )
	
	
		
	
	
	
    prop _vectAllocDesc :: (
        "%8t .%1L_vec:  align = 0x100{%12t\n %1U_A_VECS = .;\n_%1U_A_VECS = . ; \n*(.hwi_vec)%8t\n }\0 , name, name"
  )
    
    prop _placement :: (0x7fffff / 2)
    prop _minplace  :: 0
    prop localInit :: (
	if (RTDX.CALLBACKOBJ != nil) {
	    .error("HWI initialization failure.")
        },
	RTDX.CALLBACKOBJ = HWI
    )
	
        
        
        
	
    prop call :: (
	if ( RTDX.USERTDX == 0 ) {
	    HWI_DLOG.function = @HWI_unused,
	    HWI_DLOG.iUseDispatcher = 0,
	    if (HWI_RTOS.function == @_RTDX_H2TPoll) {
		HWI_RTOS.function = @HWI_unused,
		HWI_RTOS.iUseDispatcher = 0
	    }
        }
	else {
	    HWI_DLOG.function = @_RTDX_Poll,
	    HWI_DLOG.iUseDispatcher = 1,
	    HWI_RTOS.function = @_RTDX_H2TPoll,
	    HWI_RTOS.iUseDispatcher = 1
        }
    )
  prop GenLinkPrologue :: ( CLK.TIMERNUM  ==  0
                        ?"HWI_TINT = HWI_INT4;\n_HWI_TINT = HWI_TINT;"
                        :"HWI_TINT = HWI_INT22;\n_HWI_TINT = HWI_TINT;"
                        ) 
    prop _dispSeg :: MEM.BSSSEG 
    prop _memSeg :: MEM.STUBMEMSEG
    prop _loadstubSeg :: MEM.LOADSTUBMEMSEG
    prop _linkString :: (
	$b = 0,
	scan ($a; HWI) {
	    if ($a.monitor != "Nothing") {
		$b = 1
	    }
	},
	if ($b == 1) {
	    "*(.hwi)"
	}
	else {
	    "/* no HWI stubs are necessary */"
	}
    )
    
    prop name2addr :: (
	$i = 0,
	$b = nil,
	scan ($a; { "Nothing","Data Value","xsp", "ac0g", "ac0h", "ac0l", "ac1g", "ac1h", "ac1l", "ac2g", "ac2h", "ac2l", "ac3g", "ac3h", "ac3l", "xar0", "xar1", "xar2", "xar3", "xar4", "xar5", "xar6", "xar7", "t0", "t1", "t2", "t3", "xssp", "tim", "st0_55", "st1_55", "st2_55", "st3_55", "trn0", "bk03", "brc0", "xdp", "xcdp", "dph", "mdp05", "mdp67", "pdp", "bk47", "bkc", "bsa01", "bsa23", "bsa45", "bsa67","bsac", "trn1", "brc1", "csr", "rptc"}) {		
	    if ($b == nil) {		
		if ($a == $1) {		
		    $b = { 0, 0, 0x18, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0x24, 0x25, 0x26, 0x28, 0x29, 0x2a, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x20, 0x21, 0x21, 0x23, 0x4b, 0, 0x6, 0x7, 0x4c, 0x37, 0xf, 0x19, 0x1a, 0x2e, 0x27, 0x2b, 0x2c, 0x2d, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x38, 0x39, 0x3b, 0x44 }[$i]	
		},
		$i++
	    }
	},
	if ($b == nil) {		
	    $b = 0			
	},
	$b
    )
    
    prop name2type :: (
	$i = 0,
	$b = nil,
	scan ($a; { "Nothing","Data Value","xsp", "ac0g", "ac0h", "ac0l", "ac1g", "ac1h", "ac1l", "ac2g", "ac2h", "ac2l", "ac3g", "ac3h", "ac3l", "xar0", "xar1", "xar2", "xar3", "xar4", "xar5", "xar6", "xar7", "t0", "t1", "t2", "t3", "xssp", "tim", "st0_55", "st1_55", "st2_55", "st3_55", "trn0", "bk03", "brc0", "xdp", "xcdp", "dph", "mdp05", "mdp67", "pdp", "bk47", "bkc", "bsa01", "bsa23", "bsa45", "bsa67","bsac", "trn1", "brc1", "csr", "rptc"}) {		
	    if ($b == nil) {		
		if ($a == $1) {		
		    if ($i < 5) {
			$b = {"unsigned", "signed", "unsigned", "unsigned", "unsigned"}[$i] 
		    }
		},
		$i++
	    }
	},
	if ($b == nil) {		
	    $b = "unsigned"		
	},
	$b
    )
    
    global STUBMEMSEG :: SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
	prop Label :: "Function Stub Memory"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global ZEROTAB ::= MEM.VECMEMSEG.base == 0xffff00 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Writable :: 0
	prop Visible :: 0
    }
    prop _vecSeg :: MEM.VECMEMSEG
    prop _loadvecSeg :: MEM.LOADVECMEMSEG
    global VECMEMSEG :: VECT {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop Label :: "Interrupt Service Table Memory"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
        prop MemberTest :: GBL.DSPTYPE == 55
		? ($1.space != "data")
		: ($1.space == "code")
    }
    
    global STACKMODEL :: "C54X_STK" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "C54X_STK,USE_RETA,NO_RETA"
	prop Label :: "Stack Mode"
	prop JSName :: "STACKMODE"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    
    
    inst function :: @HWI_unused {
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: (( .function == @RESERVED ) || ( .client != "USER" )) ? 0 : 1
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop NoGen :: 0
	prop Set :: (
		.function = $1,
		GlobalStatus.gDirty = 1,
		"ok"
	)
    }
    inst iSTSObj :: HWI_RESETSTS {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    inst monitor :: "Nothing" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "Nothing,Data Value,xsp,ac0g,ac0h,ac0l,ac1g,ac1h,ac1l,ac2g,ac2h,ac2l,ac3g,ac3h,ac3l,xar0,xar1,xar2,xar3,xar4,xar5,xar6,xar7,t0,t1,t2,t3,xssp,tim,st0_55,st1_55,st2_55,st3_55,trn0,bk03,brc0,xdp,xcdp,dph,mdp05,mdp67,pdp,bk47,bkc,bsa01,bsa23,bsa45,bsa67,bsac,trn1,brc1,csrrptc"
	prop JSName :: "monitor"
	prop Visible :: 1
	prop Writable :: ((.function != @HWI_unused && .function != @RESERVED) && (.iId != 0))
	prop NoGen :: 0
	prop Set :: (
	    if ($1 != .monitor) {	
		$e = "ok",
		if ($1 == "Nothing") {
		    if (($e = .iSTSObj.Delete("HWI")) == "ok") {
			.monitor = "Nothing",
			.addr = .name2addr(.monitor),
			.dataType = .name2type(.monitor)
		    }
		}
		else {
		    if (.iSTSObj.iIsUsed || ($e = .iSTSObj.Create("HWI")) == "ok") {
			.monitor = $1,
			if (.monitor == "Data Value") {
			    .addr = .saveAddr,
			    .dataType = .saveType
			}
			else {
			    .addr = .name2addr(.monitor),
			    .dataType = .name2type(.monitor)
			}
		    }
		    else {
			.monitor = "Nothing"
		    }
		},
		$e
	    }
	    else {
		"ok"
	    }
	)
    }
    inst saveAddr :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    inst saveType :: "signed" {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    inst addr :: 0 {
	prop JSName :: "addr"
	prop Visible :: 1
	prop Writable :: (.monitor == "Data Value" ? 1 : 0)
	prop NoGen :: 0
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Format :: GBL.DSPTYPE == 62 ? "0x%08x" : "0x%04x"
	prop Set :: (
	    .addr = $1,
	    .saveAddr = $1,
	    "ok"
	)
    }
    inst dataType :: "signed" {
	prop Visible :: 1
	prop Writable :: (.monitor == "Nothing" ? 0 : 1)
	prop NoGen :: 0
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "signed,unsigned"
	prop Label :: "type"
	prop JSName :: "dataType"
	prop Set :: (
	    if (.monitor != "Nothing") {
		.dataType = $1,
		.saveType = $1,
		"ok"
	    }
	    else {
		.error("The monitor field must set to modify this field")
	    }
	)
    }
    inst operation :: "STS_add(*addr)" {
	prop Visible :: 1
	prop Writable :: (.monitor == "Nothing" ? 0 : 1)
	prop NoGen :: 0
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "operation"
	prop Enum :: "STS_add(*addr),STS_delta(*addr),STS_add(-*addr),STS_delta(-*addr),STS_add(|*addr|),STS_delta(|*addr|)"
	prop Set :: (
	    if (.monitor != "Nothing") {
		.operation = $1,
		"ok"
	    }
	    else {
		.error("The monitor field must set to modify this field")
	    }
	)
    }
    inst client :: "USER" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
     inst iUseDispatcher :: 0 {
 	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
 	prop Label :: "Use Dispatcher"
	prop JSName :: "useDispatcher"
 	prop Visible :: 1
 	prop Writable :: ( .client == "USER" ) ? 1 : 0
 	prop NoGen :: 0
 	prop TabName :: "Dispatcher"
 	prop Set :: (
 	    if ( .function == @CLK_F_isr ) {
 		.error("This HWI is being used by the system and cannot be modified")
 	    }
 	    else {
 		.iUseDispatcher = $1,
 		"ok"
 	    }
 	)
     }
 
     inst iArg :: 0 {
 	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
 	prop Label :: "Arg"
	prop JSName :: "arg"
 	prop Visible :: 1
 	prop Writable :: (( .iUseDispatcher == 1 ) && ( .client == "USER" )) ? 1 : 0
 	prop NoGen :: 0
 	prop TabName :: "Dispatcher"
 	prop Set :: (
 	    .iArg = $1,
 	    "ok"
 	)
     }
 
     inst iIer0Mask :: "self" {
 	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
 	prop Label :: "Interrupt Mask IER0"
	prop JSName :: "interruptMask0"
 	prop Enum :: "all,none,self,bitmask"
 	prop Visible :: 1
 	prop Writable :: ( .iUseDispatcher == 1 ) ? 1 : 0
 	prop NoGen :: 1
 	prop TabName :: "Dispatcher"
 	prop Set :: (
 	    if ( $1 == "all" ) {
 		.Ier0Mask = 0xffff
 	    }
 	    else {
 		if ( $1 == "self" ) {
 		   if (.iId < 16) {
 		   	.Ier0Mask = (1 << .iId)
 		   }
 		   else {
 			.warning("This Interrupt is NOT maskable via IER0")
 		   	.Ier0Mask = 0
 		   }
 		}
 		else {
 		    if ( $1 == "none" ) {
 			.Ier0Mask = 0
 		    }
 		}
 	    },
 	    .iIer0Mask = $1,
 	    "ok"
 	)
     }
 	
     inst Ier0Mask :: (.iId < 16) ? (1 << .iId) : 0 {
 	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
 	prop Format :: "0x%04x"
 	prop Style :: 0x02
 	prop Label :: "Interrupt Bit Mask IER0"
	prop JSName :: "interruptBitMask0"
 	prop Visible :: 1
 	prop Writable :: ((.iUseDispatcher == 1) && (.iIer0Mask == "bitmask" )) ? 1 : 0
 	prop NoGen :: 0
 	prop TabName :: "Dispatcher"
 	prop Set :: (
 	    if ( $1 > 0xffff) {
 		.error("Invalid Number")
 	    }
 	    else {
 		.Ier0Mask = $1,
 		"ok"
 	    }
 	)
     }
 
     inst iIer1Mask :: "self" {
 	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
 	prop Label :: "Interrupt Mask IER1"
	prop JSName :: "interruptMask1"
 	prop Enum :: "all,none,self,bitmask"
 	prop Visible :: 1
 	prop Writable :: ( .iUseDispatcher == 1 ) ? 1 : 0
 	prop NoGen :: 1
 	prop TabName :: "Dispatcher"
 	prop Set :: (
 	    if ( $1 == "all" ) {
 		.Ier1Mask = 0xffff
 	    }
 	    else {
 		if ( $1 == "self" ) {
 		   if (.iId < 16) {
 			.warning("This Interrupt is NOT maskable via IER1")
 		        .Ier1Mask = 0
 		   }
 		   else {
 		        .Ier1Mask = (1 << (.iId - 16))
 		   }
 		}
 		else {
 		    if ( $1 == "none" ) {
 			.Ier1Mask = 0
 		    }
 		}
 	    },
 	    .iIer1Mask = $1,
 	    "ok"
 	)
     }
 	
     inst Ier1Mask :: (.iId > 16) ? (1 << (.iId - 16)) : 0 {
 	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
 	prop Format :: "0x%04x"
 	prop Style :: 0x02
 	prop Label :: "Interrupt Bit Mask IER1"
	prop JSName :: "interruptBitMask1"
 	prop Visible :: 1
 	prop Writable :: ((.iUseDispatcher == 1) && (.iIer1Mask == "bitmask" )) ? 1 : 0
 	prop NoGen :: 0
 	prop TabName :: "Dispatcher"
 	prop Set :: (
 	    if ( $1 > 0xffff) {
 		.error("Invalid Number")
 	    }
 	    else {
 		.Ier1Mask = $1,
 		"ok"
 	    }
 	)
     }
}
object HWI_RESET_STS :: STS {
    param iComment :: "provides statistics for the RESET ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_RESET :: HWI {
    param iComment :: "defines function for the RESET ISR"
    param iId :: 0			
    param function :: @_c_int00
    param iIsUsed :: 1
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_RESET_STS
}
object HWI_NMI_STS :: STS {
    param iComment :: "provides statistics for the NMI ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_NMI :: HWI {
    param iComment :: "defines function for the NMI ISR"
    param iId :: 1			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_NMI_STS
}
object HWI_INT2_STS :: STS {
    param iComment :: "provides statistics for the INT2 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT2 :: HWI {
    param iComment :: "defines the INT2 Interrupt"
    param iId :: 2			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT2_STS
}
object HWI_INT3_STS :: STS {
    param iComment :: "provides statistics for the INT5 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT3 :: HWI {
    param iComment :: "defines the INT3 Interrupt"
    param iId :: 3	
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT3_STS
}
object HWI_INT4_STS :: STS {
    param iComment :: "provides statistics for the INT4 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT4 :: HWI {
    param iComment :: "defines the INT4 Interrupt"
    param iIsUsed :: 1			
    param iId :: 4			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param function :: CLK.WHICHHWI == self ? @CLK_F_isr : @HWI_unused
    param client   :: CLK.WHICHHWI == self ? "CLK" : "USER"
    param iUseDispatcher :: (CLK.WHICHHWI == self )
? 1 : 0
    param iArg :: (.iUseDispatcher && CLK.WHICHHWI == self) ? @CLK_A_TABBEG : 0
    param iSTSObj :: HWI_INT4_STS
}
object HWI_INT5_STS :: STS {
    param iComment :: "provides statistics for the INT5 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT5 :: HWI {
    param iComment :: "defines the INT5 Interrupt"
    param iId :: 5			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT5_STS
}
object HWI_INT6_STS :: STS {
    param iComment :: "provide statistics for  INT6  Interrupt"
    param iId :: 6			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT6 :: HWI {
    param iComment :: "defines the INT6 Interrupt"
    param iId :: 6			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT6_STS
}
object HWI_INT7_STS :: STS {
    param iComment :: "provides statistics for the INT7 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT7 :: HWI {
    param iComment :: "defines the INT7 Interrupt"
    param iId :: 7			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT7_STS
}
object HWI_INT8_STS :: STS {
    param iComment :: "provides statistics for the INT8 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT8 :: HWI {
    param iComment :: "defines the INT8 Interrupt"
    param iId :: 8			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT8_STS
}
object HWI_INT9_STS :: STS {
    param iComment :: "provides statistics for the INT 9  ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT9:: HWI {
    param iComment :: "defines the INT9  Interrupt"
    param iId :: 9			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT9_STS
}
object HWI_INT10_STS :: STS {
    param iComment :: "provides statistics for the INT10 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT10 :: HWI {
    param iComment :: "defines the INT10 Interrupt"
    param iId :: 10			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT10_STS
}
object HWI_INT11_STS :: STS {
    param iComment :: "provides statistics for the INT11 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT11 :: HWI {
    param iComment :: "defines the INT11 Interrupt"
    param iId :: 11			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param function :: CLK.WHICHHWI == self ? @CLK_F_isr : @HWI_unused
    param client   :: CLK.WHICHHWI == self ? "CLK" : "USER"
    param iUseDispatcher :: (CLK.WHICHHWI == self && CLK.HOOKFXN != @CLK_F_run)
    param iSTSObj :: HWI_INT11_STS
}
object HWI_INT12_STS :: STS {
    param iComment :: "provides statistics for the INT12 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT12 :: HWI {
    param iComment :: "defines the INT12 Interrupt"
    param iId :: 12			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT12_STS
}
object HWI_INT13_STS :: STS {
    param iComment :: "provides statistics for the INT13 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT13 :: HWI {
    param iComment :: "defines the INT13 Interrupt"
    param iId :: 13			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT13_STS
}
object HWI_INT14_STS :: STS {
    param iComment :: "provides statistics for the INT14 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT14 :: HWI {
    param iComment :: "defines the INT14 Interrupt"
    param iId :: 14			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT14_STS
}
object HWI_INT15_STS :: STS {
    param iComment :: "provides statistics for the INT15 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT15 :: HWI {
    param iComment :: "defines the INT15 Interrupt"
    param iId :: 15			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT15_STS
}
object HWI_INT16_STS :: STS {
    param iComment :: "provides statistics for the INT16 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT16 :: HWI {
    param iComment :: "defines the INT16 Interrupt"
    param iId :: 16			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT16_STS
}
object HWI_INT17_STS :: STS {
    param iComment :: "provides statistics for the INT17 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT17 :: HWI {
    param iComment :: "defines the INT17 Interrupt"
    param iId :: 17			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT17_STS
}
object HWI_INT18_STS :: STS {
    param iComment :: "provides statistics for the INT18 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT18 :: HWI {
    param iComment :: "defines the INT18 Interrupt"
    param iId :: 18			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT18_STS
}
object HWI_INT19_STS :: STS {
    param iComment :: "provides statistics for the INT19 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT19 :: HWI {
    param iComment :: "defines the INT19 Interrupt"
    param iId :: 19			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT19_STS
}
object HWI_INT20_STS :: STS {
    param iComment :: "provides statistics for the INT20 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT20 :: HWI {
    param iComment :: "defines the INT20 Interrupt"
    param iId :: 20			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT20_STS
}
object HWI_INT21_STS :: STS {
    param iComment :: "provides statistics for the INT21 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT21 :: HWI {
    param iComment :: "defines the INT21 Interrupt"
    param iId :: 21			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT21_STS
}
object HWI_INT22_STS :: STS {
    param iComment :: "provides statistics for the INT22 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT22 :: HWI {
    param iComment :: "defines the INT22 Interrupt"
    param iId :: 22			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param function :: CLK.WHICHHWI == self ? @CLK_F_isr : @HWI_unused
    param client   :: CLK.WHICHHWI == self ? "CLK" : "USER"
    param iUseDispatcher :: (CLK.WHICHHWI == self )
? 1 : 0
    param iArg :: (.iUseDispatcher && CLK.WHICHHWI == self) ? @CLK_A_TABBEG : 0
    param iSTSObj :: HWI_INT22_STS
}
object HWI_INT23_STS :: STS {
    param iComment :: "provides statistics for the INT23 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT23 :: HWI {
    param iComment :: "defines the INT23 Interrupt"
    param iId :: 23			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT23_STS
}
object HWI_BERR_STS :: STS {
    param iComment :: "provides statistics for the BERRINT ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_BERR :: HWI {
    param iComment :: "defines the BERR Interrupt"
    param iId :: 24			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_BERR_STS
}
object HWI_DLOG_STS :: STS {
    param iComment :: "provides statistics for the DLOGINT ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_DLOG :: HWI {
    param iComment :: "RESERVED for RTDX"
    param iId :: 25			
    param function :: (RTDX.USERTDX == 1) ? @_RTDX_Poll : @HWI_unused
    param client :: "RTDX"
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_DLOG_STS
    param iUseDispatcher :: (RTDX.USERTDX == 1) ? 1 : 0
}
object HWI_RTOS_STS :: STS {
    param iComment :: "provides statistics for the RTOSINT ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_RTOS :: HWI {
    param iComment :: "defines the RTOS Interrupt"
    param iId :: 26			
    param function :: (RTDX.USERTDX ==1) ? @_RTDX_H2TPoll : @HWI_unused
    param iUseDispatcher :: (RTDX.USERTDX == 1) ? 1 : 0
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_RTOS_STS
}
object HWI_SINT27_STS :: STS {
    param iComment :: "provides statistics for the SINT27 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_SINT27 :: HWI {
    param iComment :: "defines the SINT27 Interrupt"
    param iId :: 27			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_SINT27_STS
}
object HWI_SINT28_STS :: STS {
    param iComment :: "provides statistics for the SINT28 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_SINT28 :: HWI {
    param iComment :: "defines the SINT28 Interrupt"
    param iId :: 28			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_SINT28_STS
}
object HWI_SINT29_STS :: STS {
    param iComment :: "provides statistics for the SINT29 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_SINT29 :: HWI {
    param iComment :: "defines the SINT29 Interrupt"
    param iId :: 29			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_SINT29_STS
}
object HWI_SINT30_STS :: STS {
    param iComment :: "provides statistics for the SINT30 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_SINT30 :: HWI {
    param iComment :: "defines the SINT30 Interrupt"
    param iId :: 30			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_SINT30_STS
}
object HWI_SINT31_STS :: STS {
    param iComment :: "provides statistics for the SINT31 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_SINT31 :: HWI {
    param iComment :: "defines the SINT31 Interrupt"
    param iId :: 31			
    param iIsUsed :: 1			
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_SINT31_STS
}
type SWI {
    isa	ObjectMgr
    prop name :: "SWI"
    prop Label :: "SWI - Software Interrupt Manager"
    prop IsContainedIn :: SCH
    prop GlobalIcon :: 123
    prop InstanceIcon :: 124
    prop InstanceHelpTopic :: (
	211
    )
    
    prop GlobalHelpTopic :: (
	111
    )
    
    prop HighTimeBased :: (
        CLK.HIRES == 1 ? 1 : 0
    )
    prop LowTimeBased :: (
        CLK.HIRES == 1 ? 0 : 1
    )
    prop STSGetMaxFmt :: (
	if (SWI.STSUNITS == "raw") {
	    CLK.HIRES ? "%g inst" : "%g ints"
	}
	else {
	    SWI.STSUNITS == "microseconds" ? "%.1f us" : "%.2f ms"
	}
    )
    prop STSGetSumFmt :: (
	SWI.STSGetMaxFmt()
    )
    prop STSGetAvgFmt :: (
	if (SWI.STSUNITS == "raw") {
	    CLK.HIRES ? "%.2f inst" : "%.2f ints"
	}
	else {
	    SWI.STSUNITS == "microseconds" ? "%.1f us" : "%.2f ms"
	}
    )
    prop STSFilterMax :: (
	$a = (CLK.HIRES) ? $1 * CLK.INSTRPERCLK : $1,
	$a = $a * (CLK.TDDR + 1),
	$a
    )
    prop STSFilterSum :: (
	SWI.STSFilterMax($1)
    )
    
    prop GetPriority :: (
	.pri
    )
prop GenLinkPrologue :: (
	"SECTIONS {%4t\n.%1L: block(0x20000){%8t\n %1U_A_TABBEG = .;\n %4S\n %1U_A_TABEND = .;\n %1U_A_TABLEN = (. - %1U_A_TABBEG) / %2d;%4t\n} > %3s%5s\0, name, objSize, memSeg, linkString, pageString"
    )
    
    prop GenLinkEpilogue :: (
	"%0t}\n\0"
    )
    prop linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop pageString :: GBL.DSPTYPE == 62 ? "" : GBL.DSPTYPE == 55 ? "" : " PAGE 1"
    prop memSeg :: SWI.OBJMEMSEG
    
    prop objSize :: GBL.DSPTYPE == 55 ? (2 * (11 * 1)) : (11 * 1)
    prop maxObjs :: (
	32767				
    )
    prop dataSize :: (
	(11 * 1) * SWI.gNumOf
    )
    prop localCanCreate :: (
	if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {
	    .error("System stack size (see MEM) is too small to support a new SWI priority level.")
	}
	else {
	    "ok"
	}
    )
    prop localCreate :: (
	STS.gNumEmbed += 1,
        SWI.EXECFXN = @SWI_F_exec,
	SWI.RUNFXN = @SWI_F_run,
	"ok"
    )
    prop localDelete :: (
	STS.gNumEmbed -= 1,
	if (.gNumOf == 1) {	
	    
	    SWI.EXECFXN = @FXN_F_nop,
	    SWI.RUNFXN = @FXN_F_nop
	},
	"ok"
    )
    prop SortByField :: "pri"
    prop SortGroups :: 15
    prop InstancePropertyPage :: (
	    "{B7240DEC-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
	    "{B7240DED-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    prop DependsOn :: "HWI,SIO"
    
    prop cGen :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "swi.h" : ""
    
    prop cGenHInst :: (
	if (GBL.DSPTYPE == 62) {
	    "extern far SWI_Obj %0r;\n\0"
	}
	else {
	    "extern SWI_Obj %0r;\n\0"
	}
    )
    global EHOOKFXN :: @GBL_NULL {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Enable Scheduler and Return to Idle Function"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
    }
    global IHOOKFXN :: @GBL_NULL {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Exit Scheduler and Return to Idle Function"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
    }
    global EXECFXN :: @FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Configured SWI executive"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global RUNFXN :: @FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Configured SWI executive body"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global STSUNITS :: "raw" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "raw,milliseconds,microseconds"
	prop Label :: "Statistics Units"
	prop Visible :: 0		
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst priority :: = (.pri + 1) {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "priority"
	prop JSName :: ""
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst function :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
    inst pri :: 1 {		
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	
	prop Enum :: "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14"
	prop Label :: "priority"
	prop JSName :: "priority"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
            $a = .pri,
            .pri = $1,
	    if (self == KNL_swi) {
		if ($1 != 0) {
		    .pri = $a,
		    .error("KNL_swi must remain at Priority 0.")
		}
		else {
		    "ok"
		}
	    }
	    else {
		if ($1 == 0 && KNL_swi.iIsUsed == 1) {
		    .pri = $a,
		    .error("Priority 0 reserved for KNL_swi only.")
		}
		else {
		    GlobalStatus.gDirty = 1,
		    if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {
			.pri = $a,
			.error("System stack size (see MEM) is too small to support a new SWI priority level.")
		    }
		    else {
			if ($1 > 14) {
			    .pri = $a,
			    .error("SWI can only support 15 priority levels.")
			}
			else {
			    "ok"
			}
		    }
		}
	    }
	)
    }
    inst mailbox :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "mailbox"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
    inst arg0 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg0"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
    inst arg1 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg1"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
    inst dorta :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    
    inst Order :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
	prop NoGen :: 1
	prop Writable :: 1
     }
}    
type TSK {
    isa ObjectMgr
    prop name :: "TSK"
    prop Label :: "TSK - Task Manager"
    prop IsConfMod :: .USETSK
    prop IsContainedIn :: SCH
    
    prop DependsOn :: "SWI,HOOK"
    prop GlobalIcon :: 143
    prop InstanceIcon :: 144
    prop GlobalHelpTopic :: (
	314
    )
    prop InstanceHelpTopic :: (
	414
    )
    prop InstancePropertyPage :: (
	"{473C4A64-B1A8-11d0-9885-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{473C4A65-B1A8-11d0-9885-0020AFEE33C6}"
    )
    prop SortByField :: "iPRI"
    prop SortGroups :: 17
    prop AllocType :: (
	if (.USETSK) {
	    "1\0,    _bssAllocDesc, _bssmemSeg, _placement"
	}
	else {
	    ""
	}
    )
    prop _objAllocDesc :: (   
	"%8t .TSK$obj: {}"
    )
    prop _bssAllocDesc :: (
	"%8t .tsk: block(0x20000){%12t\n *(.tsk)%8t\n }"
    )
    prop _bssmemSeg :: .OBJMEMSEG
    prop _objmemSeg :: MEM.CFGOBJSEG	
    prop AllocInst :: (
	.iAUTOSTK ? "1\0, _instStackDesc, _instStackSeg, _placement" : "0\0"
    )
    prop _instStackDesc :: (
        if (GBL.DSPTYPE == 40) {
	    "%8t .%0s$stk: fill = 0xC0FFEE {%12t\n %0s$stack = .;\n . += %1d;%8t\n }\0, _instStackSize"
	}
	else {
	    "%8t .%0s$stk: block(0x20000){%12t\n *(.%0s$stk)%8t\n }\0"
	}
    )
    prop _self :: self
    prop _instStackSize :: .iSTKSZ * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    prop _instsyStackSize :: .iSYSTKSZ * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    prop _instStackSeg :: .iSTKSEG
    prop _placement :: (0x7fffff / 2)
    prop localInit :: (
	KNL_swi.Create("SWI"),
 	if (.STACKSEG.iAllocHeap == 1) {
	    .STACKSEG.iReqHeapCount++,
	    "ok"
	}
	else {
	    .error ("TSK default stack segment must be a memory segment with a heap")
	}
    )
    
    prop HighTimeBased :: (
        CLK.HIRES == 1 ? 1 : 0
    )
    prop LowTimeBased :: (
        CLK.HIRES == 1 ? 0 : 1
    )
    prop STSGetMaxFmt :: (
	if (TSK.STSUNITS == "raw") {
	    CLK.HIRES ? "%g inst" : "%g ints"
	}
	else {
	    TSK.STSUNITS == "microseconds" ? "%.1f us" : "%.2f ms"
	}
    )
    prop STSGetSumFmt :: (
	TSK.STSGetMaxFmt()
    )
    prop STSGetAvgFmt :: (
	if (TSK.STSUNITS == "raw") {
	    CLK.HIRES ? "%.2f inst" : "%.2f ints"
	}
	else {
	    TSK.STSUNITS == "microseconds" ? "%.1f us" : "%.2f ms"
	}
    )
    
    prop STSFilterMax :: (
	$a = (CLK.HIRES) ? $1 * CLK.INSTRPERCLK : $1,
	$a = $a * (CLK.TDDR + 1),
	$a
    )
    prop STSFilterSum :: (
	TSK.STSFilterMax($1)
    )
    prop localCreate :: (
	STS.gNumEmbed += 1,
	"ok"
    )
    prop localCanCreate :: (
	$e = "ok",
	if (TSK.USETSK != 1) {
	    $e = .error("TSK manager not enabled")
	},
	$e
    )
    prop localDelete :: (
	STS.gNumEmbed -= 1,
	"ok"
    )
    
    prop GenLinkPrologue :: (
	if (.USETSK == 0) {
		"_KNL_swi = 0;"
	}
    )
    
    prop cGen :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "tsk.h" : ""
    
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far TSK_Obj %0r;\n\0"
        }
	else {
	    "extern TSK_Obj %0r;\n\0"
        }
    )
    global USETSK :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable TSK Manager"
	prop JSName :: "ENABLETSK"
	prop Visible :: 1
	prop Writable :: GBL.DSPSUBTYPE == 0x55DA200 ? 0:1
	prop NoGen :: 1
	prop Set :: (
	    if ($1 == 0) {
		if (.gNumOf > 1) {
		    .error("Cannot disable TSK until all TSK objects are deleted.")
		}
		else {
		    .STACKSEG.iReqHeapCount--,
		    TSK.STACKSEG = MEM_NULL,	
		    TSK.OBJMEMSEG = MEM_NULL,
		    TSK_idle.iSTKSEG = MEM_NULL,
		    TSK_idle.Delete("TSK"),
		    KNL_swi.Delete("TSK"),
		    PRD.THOOKFXN = @FXN_F_nop,
                    if (PRD.gNumOf == 0) {
                      if (PRD_clock.iIsUsed == 1) {
                        PRD_clock.function = @FXN_F_nop
                      }
                    },
		    .USETSK = $1,
		    "ok"
		}
	    } else {
		$e = "ok",
	        GlobalStatus.gDirty = 1,
	        if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {
                    $e = .error("Current stack size inadequate to enable TSK"),
		    break
		    },
		scan ($a; SWI) {
		    if ($a != KNL_swi && $a.pri == 0 && $a.iIsUsed == 1) {
			$e = .error("Cannot enable TSK when there are SWI objects at Priority 0."),
			break
		    }
		},
		if ($e == "ok") {
		    TSK.STACKSEG = MEM_NULL,  
		    scan($b; MEM) {
			if ($b.iAllocHeap && $b != MEM_NULL) {
		    	    
		    	    TSK.STACKSEG = $b,
			    break
			}
		    },
		    .STACKSEG.iReqHeapCount++,
		    .USETSK = $1,
		    				
		    TSK.OBJMEMSEG = SWI.OBJMEMSEG,
		    TSK_idle.iSTKSEG = .OBJMEMSEG,  
		    TSK_idle.Create("TSK"),
		    KNL_swi.Create("TSK"),
		    PRD.THOOKFXN = PRD.DEFAULT_THOOKFXN,
                    if (TSK.TSKTICK == "PRD") {
                      if (PRD_clock.iIsUsed == 1) {
                        PRD_clock.function = @PRD_F_tick
                      }
                    },
		    if ( MEM.NOHEAPS ) {
			.STACKSEG.iReqHeapCount++,
			$e = "No Memory Heaps Are Allocated for Dynamic TSK creation"
		    },
		    $e
		}
		else {
		    $e
		}
	    }
	)
    }
    
    prop _objId :: .iId
    prop dataSize :: (
	$d = 0,
	scan ($i; TSK) {
	    
	    $d += ($i.iSTKSZ + (6 + 34) * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE))
	},
	$d
    )
    
    prop minStackSize :: (
	$a = .STACKSIZE,
	scan ($i; TSK) {
	    if ($i.STACKSIZE < $a) {
		$a = $i.STACKSIZE
	    }
	},
	$a
    )
    prop maxObjs :: (32767)			
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "OBJMEMSEG"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataNullMember($1)
	prop Label :: "Object Memory"
	prop Visible :: 1
	prop Writable :: .USETSK
	prop NoGen :: 1
    }
    
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global STACKSIZE :: GBL.DSPTYPE == 62 ? 1024 : (GBL.DSPTYPE == 55) ? 1024 :(GBL.DSPTYPE == 28) ? 128 : 256 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01
	prop Label :: "Default stack size (MAUs)"
	prop JSName :: "STACKSIZE"
	prop Visible :: 1
	prop Writable :: .USETSK
    }	
    global SYSTACKSIZE ::  256 {
	    prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Style :: 0x01
	    prop Label :: "Default systack size (MAUs)"
	    prop JSName :: "SYSSTACKSIZE"
	    prop Visible :: 1
	    prop Writable :: .USETSK
	}  
    
    global STACKSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataNullMember($1) && $1.iAllocHeap
	prop Label :: "Stack segment for dynamic tasks"
	prop JSName :: "STACKSEG"
	prop Visible :: 1
	prop Writable :: .USETSK && (MEM.NOHEAPS == 0)
	prop Set :: (
	    if (.STACKSEG.iReqHeapCount > 0) {
		.STACKSEG.iReqHeapCount--
	    },
	    .STACKSEG = $1,
	    .STACKSEG.iReqHeapCount++,
	    "ok"
	)
    }	
    global PRIORITY :: 1 {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "PRIORITY"
	prop Enum :: "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
	prop Label :: "Default task priority"
	prop Visible :: 1
	prop Writable :: .USETSK
    }
    global CREATEFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Create function"
	prop JSName :: "CREATEFXN"
	prop Visible :: 1
	prop Writable :: .USETSK
	prop TabName :: "Function Hooks"
	prop Set :: (
	    .CREATEFXN = $1,
	    HOOK_KNL.createFxn = .CREATEFXN,
	    "ok"
	)
	prop NoGen :: 1
    }
    global VCREATEFXN ::= HOOK_KNL.iIsUsed == 1 ? @__HOOK_doCreate : .CREATEFXN {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
    }
    global DELETEFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Delete function"
	prop JSName :: "DELETEFXN"
	prop Visible :: 1
	prop Writable :: .USETSK
	prop TabName :: "Function Hooks"
	prop Set :: (
	    .DELETEFXN = $1,
	    HOOK_KNL.deleteFxn = .DELETEFXN,
	    "ok"
	)
	prop NoGen :: 1
    }
    global VDELETEFXN ::= HOOK_KNL.iIsUsed == 1 ? @__HOOK_doDelete : .DELETEFXN {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
    }
    global EXITFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Exit function"
	prop JSName :: "EXITFXN"
	prop Visible :: 1
	prop Writable :: .USETSK
	prop TabName :: "Function Hooks"
	prop Set :: (
	    .EXITFXN = $1,
	    HOOK_KNL.exitFxn = .EXITFXN,
	    "ok"
	)
	prop NoGen :: 1
    }
    global VEXITFXN ::= HOOK_KNL.iIsUsed == 1 ? @__HOOK_doExit : .EXITFXN {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
    }
    global DOSWITCH :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Call switch function"
	prop JSName :: "CALLSWITCHFXN"
	prop Writable :: .USETSK
	prop Visible :: 1
	prop NoGen :: 1
	prop Set :: (
	    .DOSWITCH = $1,
	    HOOK_KNL.callSwitchFxn = .DOSWITCH,
	    "ok"
	)
	prop TabName :: "Function Hooks"
    }
    global VSWFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Switch function"
	prop JSName :: "SWITCHFXN"
	prop Visible :: 1
	prop NoGen :: 1
	prop Writable :: .DOSWITCH && .USETSK
	prop Set :: (
	    .VSWFXN = $1,
	    HOOK_KNL.switchFxn = .VSWFXN,
	    "ok"
	)
	prop TabName :: "Function Hooks"
    }
    global SWITCHFXN ::= .DOSWITCH ? (HOOK_KNL.iIsUsed == 1 ? @__HOOK_doSwitch : .VSWFXN) : 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: ""
	prop TabName :: "Function Hooks"
    }
    global DOREADY :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Call ready function"
	prop JSName :: "CALLREADYFXN"
	prop Writable :: .USETSK
	prop Visible :: 1
	prop NoGen :: 1
	prop Set :: (
	    .DOREADY = $1,
	    HOOK_KNL.callReadyFxn = .DOREADY,
	    "ok"
	)
	prop TabName :: "Function Hooks"
    }
    global VRDYFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Ready function"
	prop JSName :: "READYFXN"
	prop Visible :: 1
	prop Writable :: .DOREADY && .USETSK
	prop NoGen :: 1
	prop Set :: (
	    .VRDYFXN = $1,
	    HOOK_KNL.readyFxn = .VRDYFXN,
	    "ok"
	)
	prop TabName :: "Function Hooks"
    }
    global READYFXN ::= .DOREADY ? (HOOK_KNL.iIsUsed == 1 ? @__HOOK_doReady : .VRDYFXN) : 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: ""
	prop TabName :: "Function Hooks"
    }
    global NUM_HOOKS ::= HOOK.gNumOf {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
    }
    global STSUNITS :: "raw" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "raw,milliseconds,microseconds"
	prop Label :: "Statistics Units"
	prop Visible :: 0
	prop Writable :: .USETSK
	prop NoGen :: 1
    }
    
    global TSKTICK :: "PRD" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "PRD,User"
	prop Label :: "TSK tick driven by"
	prop JSName :: "DRIVETSKTICK"
	prop Visible :: 1
	prop Writable :: .USETSK
	prop NoGen :: 1
	prop Set :: (
	    if ($1 != .TSKTICK) {
		if ($1 == "PRD") {
                    PRD.THOOKFXN = PRD.DEFAULT_THOOKFXN,
                    if (TSK.USETSK == 1) {
                      if (PRD_clock.iIsUsed == 1) {
                        PRD_clock.function = @PRD_F_tick
                      }
                    }
		},
		if ($1 == "User") {
                    PRD.THOOKFXN = @_FXN_F_nop,
                    if (PRD.gNumOf == 0) {
                      if (PRD_clock.iIsUsed == 1) {
                        PRD_clock.function = @FXN_F_nop
                      }
                    }
		},
		if ($1 != "PRD" && $1 != "User") {
		    .error ("Invalid TSK tick driver selection")
		}
	    },
	    .TSKTICK = $1,
	    "ok"
	)
    }
    
    
    prop GetPriority :: (
	.iPRI
    )
    
    
    inst iFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Task function"
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG0 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 0"
	prop JSName :: "arg0"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG1 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 1"
	prop JSName :: "arg1"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG2 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 2"
	prop JSName :: "arg2"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG3 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 3"
	prop JSName :: "arg3"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG4 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 4"
	prop JSName :: "arg4"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG5 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 5"
	prop JSName :: "arg5"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG6 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 6"
	prop JSName :: "arg6"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG7 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 7"
	prop JSName :: "arg7"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    
    inst iAUTOSTK :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Automatically allocate stack"
	prop JSName :: "autoAllocateStack"
        prop Set :: (
            if (($1 == 1) && (.iAUTOSTK == 0)) {
                .iSTKSZ = TSK.STACKSIZE
            },
            .iAUTOSTK = $1,
            "ok"
        )
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
    }
    
    inst iMANSTK :: @null {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Manually allocated stack"
	prop JSName :: "manualStack"
	prop Visible :: 1
	prop Writable :: .iAUTOSTK == 0
    }
    inst iSTKSZ :: TSK.STACKSIZE {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01
	prop Label :: "Stack size (MAUs)"
	prop JSName :: "stackSize"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    $a = $1,
	    .iSTKSZ = ($1 - ($1 - 1) % 2 + 1),
 	    GlobalStatus.gDirty = 1,
	    "ok"
	)
    }
    inst iSYSTKSZ :: TSK.SYSTACKSIZE {
	    prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Style :: 0x01
	    prop Label :: "SyStack size (MAUs)"
	    prop JSName :: "sysStackSize"
	    prop Visible :: 1
	    prop Writable :: 1
	    prop Set :: (
		$a = $1,
                .iSYSTKSZ = ($1 - ($1 - 1) % 2 + 1),
		GlobalStatus.gDirty = 1,
	        "ok"
	    )
	}
   
    
    inst iSTKSEG ::= .OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: $1 == MEM_NULL || MEM.dataMember($1)
	prop Label :: "Stack Memory Segment"
	prop JSName :: "stackMemSeg"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iPRI :: TSK.PRIORITY {
	prop Label :: "Priority"
	prop JSName :: "priority"
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    if (self == TSK_idle) {
		if ($1 == 0) {
		    "ok"
		}
		else {
		    .error("Cannot change the priority of the idle task.")
		}
	    }
	    else {
	    if ($1 == 0) {
		.error("Priority 0 is reserved for the system idle task")
	    }
	    else {
		.iPRI = $1,
		"ok"
	    }
	    }
	)
    }
    inst iENV :: 0 {
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Environment pointer"
	prop JSName :: "envPointer"
	prop Visible :: 1
	prop Writable :: .iDelUser != "TSK"
	prop TabName :: "Advanced"
    }
    inst iEXITFLAG :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Don't shut down system while this task is still running"
	prop JSName :: "exitFlag"
	prop Visible :: 1
	prop Writable :: 1
	prop TabName :: "Advanced"
    }
    inst iUSETSKNAME :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Allocate Task Name on Target"
	prop JSName :: "allocateTaskName"
	prop Visible :: 1
	prop Writable :: 1
	prop TabName :: "Advanced"
    }
    inst iSTATREG :: 0x0000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%08x"
	prop Label :: "Initial Status Register value"
	prop Visible :: 0
	prop Writable :: 1
    }
    
    inst Order :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
	prop NoGen :: 1
	prop Writable :: 1
    }
}
object TSK_idle :: TSK {
    param iComment :: "This is the idle task; it only runs when no other task is ready"
    param iDelUser :: "TSK"
    param iDelMsg :: "This task executes all IDL functions and cannot be deleted"
    param iFXN :: GBL.DSPTYPE == 54
		? @_IDL_loop
		: @IDL_F_loop
    param iPRI :: 0
    param iIsUsed :: TSK.USETSK
}
object KNL_swi :: SWI {
    param function :: @_KNL_run
    param iComment :: "This Software Interrupt calls the TSK scheduler"
    param iDelUser :: "TSK"
    param iIsUsed :: TSK.USETSK
    param iDelMsg  :: (
        "This object cannot be deleted in DSP/BIOS."
    )
    param pri :: 0
    param dorta :: 1
}
type IDL {
    isa ObjectMgr
    prop Label :: "IDL - Idle Function Manager"
    prop name :: "IDL"
    prop IsContainedIn :: SCH
    prop GlobalIcon :: 111
    prop InstanceIcon :: 112
    prop GlobalHelpTopic :: (
	106
    )
    prop InstanceHelpTopic :: (
	206
    )
    prop InstancePropertyPage :: (
	"{586735F1-770B-11d0-A61F-0000C070F3E9}"
    )
    
    prop GlobalPropertyPage :: (
	"{586735F0-770B-11d0-A61F-0000C070F3E9}"
    )
    prop GenLinkPrologue :: (
        "SECTIONS {%4t\n.%1L: block(0x20000){%8t\n %1U_A_TABBEG = .;\n %3S\n %1U_A_TABEND = .;\n %1U_A_TABLEN = (. - %1U_A_TABBEG) / %2d;\0, name, _objSize, _linkString"
    )
    prop GenLinkEpilogue :: (
        "%8t %1U_A_CALBEG = .;\n %4S\n %1U_A_CALEND = .;\n %1U_A_CALLEN = (. - %1U_A_CALBEG) / %2d;%4t\n} > %3s%5s%0t\n}\n%6S\n\0, name, _objSize, _memSeg, _linkCalString, _pageString, _nilBusyObj"
    )
    prop _linkString :: "*(.%1L)" 
    prop _linkCalString :: "*(.%1Lcal)"
    prop _pageString :: GBL.DSPTYPE == 62 ? "" : GBL.DSPTYPE == 55 ? "":" PAGE 1"
    prop _nilBusyObj :: ( ((IDL.USEIDLBUSYOBJ == 0) && (GBL.ROM == 1)) ?
         "IDL_busyObj = 0;\n"
        :
         ""
    )
    prop _memSeg :: IDL.OBJMEMSEG
    
    prop _objSize :: GBL.DSPTYPE == 55 ? (2 * (2 * 1)) : (2 * 1)
    prop dataSize :: (
	(2 * 1) * (IDL.gNumOf + 1)	
    )
    prop maxObjs :: (
	32767				
    )
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    
    prop idlFxnSum :: (
	$a = 0,
	scan ($i; IDL) {
	   $a += $i.cycles
	},
	$a
    )
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global AUTOCALCULATE :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Auto calculate idle loop instruction count"
	prop JSName :: "AUTOCALCULATE"
	prop Visible :: 1
	prop Writable :: CLK.USETIMER
	prop Set :: (
	    if ($1 == 1 && CLK.USETIMER == 0) {
		.error("CLK must be enabled to do idle loop intruction count")
	    }
	    else {
		if ($1 == 1 && GBL.ENABLEINST == 0) {
		    .error("Real Time Analysis must be enabled to do idle loop instuction count")
		}
		else {
		    .AUTOCALCULATE = $1,
		    "ok"
		}
	    }
	)
	prop NoGen :: 1
    }
    
    global USECLKIDLTIME ::= IDL.AUTOCALCULATE {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    
    global USEIDLBUSYOBJ ::= 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
 
    global CALIBRFXN :: = (
	if (IDL.AUTOCALCULATE == 1) {
	    TSK.USETSK ? (GBL.DSPSUBTYPE == 5502 ? @IDL_F_stub5502 : @IDL_F_stub) : (GBL.DSPSUBTYPE == 5502) ? 
			 @IDL_F_calibrate5502 : @IDL_F_calibrate
	}
	else {
	    @GBL_NULL
	}
    ) {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Idle Loop Auto-Calibrate Function"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
    }
    
    global CALIBRERROR :: = (
	if (GBL.DSPTYPE == 62 && IDL.CALIBRFXN == @IDL_F_stub) {
	    6
	}
	else {
	    0
	}
    ) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Idle Loop Auto-Calibrate Error"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
  
    global LOOPOVERHEAD :: 0 {
	prop Label :: "Idle Loop Instruction Count"
	prop JSName :: "LOOPINSTCOUNT"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: .AUTOCALCULATE == 0
	prop NoGen :: 1
    }
    inst function :: @_FXN_F_nop {	
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
    inst cycles :: 0 {
	prop Label :: "CPU cycles"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0		
	prop Writable :: (.iDelUser == "USER") ? 1 : 0
	prop NoGen :: 1
    }
    inst calibration :: 1 {
	prop Label :: "Include in CPU load calibration"
	prop JSName :: "calibration"
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1		
	prop Writable :: (.iDelUser == "USER") ? 1 : 0
	prop NoGen :: 0
    }
    
    inst Order :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
	prop NoGen :: 1
	prop Writable :: 1
    }
    
    inst iPri :: 0 {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}
object IDL_cpuLoad :: IDL {
    param iComment :: "This object is required by the system to acquire CPU load data"
    param iId :: 0			
    param iIsUsed :: GBL.ENABLEINST
    param cycles :: 0			
    param iDelUser :: "IDL"
    param iDelMsg :: (
	"This object is required to compute CPU load and can't be deleted"
    )
    param function :: @IDL_F_busy
}
object IDL_busyObj :: STS {
    param iComment :: "This object is required by the system to accumulate CPU load statistics"
    param iIsUsed :: GBL.ENABLEINST
    param iDelUser :: "IDL"
    param iDelMsg :: (
	"This object is required to accumulate CPU load data and can't be deleted"
    )
}
type ISRC {
    isa ObjectMgr
    prop name :: "ISRC"
    prop Label :: "ISRC - Interrupt Sources"
    prop IsConfMod :: 1         
    prop Visible :: 0
    inst iHwi :: HWI_UNUSED {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: HWI
        prop MemberTest :: 1
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }  
}
object Timer_0 :: ISRC {
    param iHwi :: HWI_INT4
}
object Timer_1 :: ISRC {
    param iHwi :: HWI_INT22
}
object Timer_2 :: ISRC {
    param iHwi :: HWI_INT11
}
type LOG {
    isa  ObjectMgr
    prop name :: "LOG"
    prop Label :: "LOG - Event Log Manager"
    prop IsContainedIn :: INS
    prop GlobalIcon :: 113
    prop InstanceIcon :: 114
    prop InstanceHelpTopic :: (
	207
    )
    
    prop GlobalHelpTopic :: (
	107
    )
    prop InstancePropertyPage :: (
	"{B7240DE8-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
	"{B7240DE9-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    prop maxObjs :: (32767)
    
    prop AllocType :: (
	"2\0, _globalAllocDesc, _memSeg, _placement, _printfAllocDesc, _memSeg, _placement"
    )
    prop _globalAllocDesc :: (
	"%8t .%1L: block(0x20000){%12t\n  %1U_A_TABBEG = .;\n _%1U_A_TABBEG = .;\n %2S\n %1U_A_TABEND = .;\n _%1U_A_TABEND = .;\n  %1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;\n _%1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;%8t\n }\0, name, _linkString, _objSize"
    )
    
    prop _printfAllocDesc :: (
	"%8t .printf (COPY): {}"
    )
    prop _placement :: (0x7fffff / 2)
    prop AllocInst :: (
	"1\0, _instAllocDesc, _objMemSeg, _placement"
    )
    prop _fillValue :: GBL.DSPWORDSIZE == 16 ? 0xffff : 0xffffffff
    prop _instAllocDesc :: (
	"%8t /* %0s buffer */\n .%0s$buf: block(0x20000) align = 0x%1x fill = 0x%2x {}\0, _objAlign, _fillValue"
    )
    
    prop _objSize :: GBL.DSPTYPE == 55 ? (2 * 10) : 10
    prop _memSeg :: LOG.OBJMEMSEG
    prop _linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no %1U objects */"
    
    prop _objAlign :: GBL.DSPTYPE == 55 
               ? .buflen * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)*2  
                : .buflen * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)  
    prop _objMemSeg :: .bufseg
    prop LogType :: .iType
    prop LogFormat :: .iFormat
    
    prop cGen :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "log.h" : ""
    
    prop cGenHInst :: (
	if (GBL.DSPTYPE == 62) {
	    "extern far LOG_Obj %0r;\n\0"
	}
	else {
	    "extern LOG_Obj %0r;\n\0"
	}
    )
    prop dataSize :: (
	$d = 0,
	scan ($i; LOG) {
	    if ($i.IsConfObj()) {
		$d += $i.buflen
	    },
	    $d += 10	
	},
	$d
    )
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global ENABLED :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Compile in logging"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst bufseg ::= .OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "bufseg"
	prop JSName :: "bufSeg"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst buflen :: 64 {
	prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	
	prop Enum :: "0,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768"
	prop Label :: "buflen (words)"
	prop JSName :: "bufLen"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    GlobalStatus.gDirty = 1,
	    .buflen = $1,
	    "ok"
	)
    }
    inst logtype :: "circular" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "circular,fixed"
	prop Label :: "logtype"
	prop JSName :: "logType"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst iType :: "printf" {
	prop Label :: "datatype"
	prop JSName :: "dataType"
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "printf,raw data"
	prop Visible :: 1
	prop Writable :: .iType == "system" ? 0 : 1
	prop NoGen :: 1
    }
    inst iFormat :: "0x%x, 0x%x, 0x%x" {
	prop Label :: "format"
	prop JSName :: "format"
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: .iType == "raw data" ? 1 : 0
	prop NoGen :: 1
    }
}
object LOG_system :: LOG {
    param iComment :: "This object is required by the system to accumulate execution trace information"
    param iId :: 0
    param iIsUsed :: 1			
    param iType :: "system"
    param iDelUser :: "LOG"
    param iDelMsg :: (
	"LOG_system is a system log and cannot be deleted."
    )
}
type PIP {
    isa  ObjectMgr
    prop Label :: "PIP - Buffered Pipe Manager"
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 117
    prop InstanceIcon :: 118
    prop GlobalHelpTopic :: (
	109
    )
    prop InstanceHelpTopic :: (
	209
    )
    prop name :: "PIP"
    prop maxObjs :: (
	32767				
    )
    prop dataSize :: (
	$b = 0,
	scan ($i; PIP) {
	    if ($i.IsConfObj()) {
		$b += ((6) + $i.framesize) * $i.numframes + ((50) * 2)
	    }
	},
	$b
    )
    prop InstancePropertyPage :: (
	    "{B7240DF0-AA51-11cf-9BFE-0000C0AC14C8}"
    )
    
    prop GlobalPropertyPage :: (
	    "{B7240DF1-AA51-11cf-9BFE-0000C0AC14C8}"
    )
    prop localCreate :: (
	"ok"
    )
    prop AllocType :: (
	"1\0, _globalAllocDesc, _memSeg, _placement"
    )
    prop _globalAllocDesc :: (
	"%8t .%1L: block(0x20000){%12t\n  %1U_A_TABBEG = .;\n _%1U_A_TABBEG = .;\n %2S\n %1U_A_TABEND = .;\n _%1U_A_TABEND = .;\n  %1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;\n _%1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;%8t\n }\0, name, _linkString, _objSize"
    )
    prop AllocInst :: (
	"1\0, _instAllocDesc, _objMemSeg, _placement"
    )
    prop _instAllocDesc :: (
	.bufalign > 1 ? "%8t /* %0s buffer */\n .pip%1d: block(0x20000) align = 0x%2x {}\0, _objId, _objAlign" : "%8t /* %0s buffer */\n .pip%1d: block(0x20000){}\0, _objId"
    )
    prop _placement :: (0x7fffff / 2)
    prop _objId :: .iId
    prop _objAlign :: .bufalign * 2
    prop _objMemSeg :: .bufseg
    prop _linkString :: (.gNumOf + .gNumEmbed) > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop _memSeg :: PIP.OBJMEMSEG
    prop _objSize :: ((50) * 2)
    prop mkId :: (
	.iId = .gNextId++,
	.gNumOf++,
	.iId
    )
    
    prop cGen :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "pip.h" : ""
    
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far PIP_Obj %0r;\n\0"
	}
	else {
	    "extern PIP_Obj %0r;\n\0"
	}
    )
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global gNumEmbed :: 0 {	
	prop NoGen :: 0
    }
    global gNextId :: 0
    inst bufseg ::= .OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "bufSeg"
	prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 1
    }
    inst bufalign :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "bufAlign"
	prop Style :: 0x01 | 0x02
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 1
	prop Set :: (
	    $e = "ok",
	    if ($1 == 0) {
		$e = .error("Cannot set align value to 0")
	    }
	    else {
		.bufalign = $1
	    },
	    $e
	)
    }
    inst buf :: "<NULL>" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst framesize :: 8 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "framesize (words)"
	prop JSName :: "frameSize"
	prop Style :: GBL.DSPTYPE == 62 ? 0x02 : 0x01 |0x02
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop Set :: (
	    if ($1 < 1) {
		.error("framesize must be >= 1.")
	    }
	    else {
		GlobalStatus.gDirty = 1,
		.framesize = $1,
		"ok"
	    }
	)
    }
    inst numframes  :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01
	prop JSName :: "numFrames"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop Set :: (
	    if ($1 < 1) {
		.error("Pipes must contain at least 1 frame.")
	    }
	    else {
		GlobalStatus.gDirty = 1,
		.numframes = $1,
		"ok"
	    }
	)
    }
    inst monitor :: "reader" {
    	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "monitor"
	prop Enum :: "reader,writer,none"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst notifyWriter :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyWriterFxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    inst nwarg0 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyWriterArg0"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    inst nwarg1 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyWriterArg1"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    inst notifyReader :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyReaderFxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    inst nrarg0 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyReaderArg0"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    inst nrarg1 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyReaderArg1"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    
    inst bufFrameAlign ::= ._objAlign  {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
}
type SEM {
    isa ObjectMgr
    prop name :: "SEM"
    prop Label :: "SEM - Semaphore Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 137
    prop InstanceIcon :: 138
    prop GlobalHelpTopic :: (
	310
    )
    prop InstanceHelpTopic :: (
	410
    )
    prop InstancePropertyPage :: (
	"{D01ACC04-38DD-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{D01ACC05-38DD-11d1-988B-0020AFEE33C6}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: (
	"%8t .sem: block(0x20000){}"
    )
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: .OBJMEMSEG
    prop dataSize :: (
	(14 + 6) * SEM.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    )
    
    prop cGen :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "sem.h" : ""
    
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far SEM_Obj %0r;\n\0"
	}
	else {
	    "extern SEM_Obj %0r;\n\0"
        }
    )
    
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst iCount :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Label :: "Initial semaphore count"
	prop JSName :: "count"
	prop Visible :: 1
	prop Writable :: 1
    }
}
type MBX {
    isa ObjectMgr
    prop name :: "MBX"
    prop Label :: "MBX - Mailbox Manager"
    prop IsContainedIn :: SYN 
    prop GlobalIcon :: 131
    prop InstanceIcon :: 132
    prop GlobalHelpTopic :: (
	307
    )
    prop InstanceHelpTopic :: (
	407
    )
    prop InstancePropertyPage :: (
	"{0EB45D44-38C1-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{0EB45D45-38C1-11d1-988B-0020AFEE33C6}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0,	_bssAllocDesc, _memSeg, _placement"
	    }
    )
    prop _bssAllocDesc :: (
	    "%8t .mbx: block(0x20000){}"
    )
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: .OBJMEMSEG
    prop AllocInst :: (
	"1\0 _instAllocDesc, _instMemSeg, _placement"
    )
    prop _instAllocDesc :: (
	"%8t .%0s$que: block(0x20000) align = 0x4 {%12t\n %0s$queElems = .;\n . += %1d;%8t\n }\0, _qElemSize"
    )
    prop _instMemSeg :: .iMbxSeg
    prop _qElemSize :: (
	if ((GBL.DSPTYPE == 55) || (GBL.DSPTYPE == 28)) {
            
            $a = .iMsgSize,
            if ($a & 0x1) {
                $a += 1
            },
	    
	    (4 + $a) * .iMbxLength * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE) * 2
	}
	else {
	    (4 + .iMsgSize) * .iMbxLength * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
	}
    )
    prop dataSize :: (
	$d = 0,
	scan ($i; MBX) {
	    $d += (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE) * (($i.iMsgSize + 2) * $i.iMbxLength + 46)
	},
	$d
    )
    
    prop cGen :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "mbx.h" : ""
    
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far MBX_Obj %0r;\n\0"
	}
	else {
	    "extern MBX_Obj %0r;\n\0"
	}
    )
    
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst iMsgSize :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Label :: "Message Size"
	prop JSName :: "messageSize"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    if ($1  == 0) {
		.error ("Message size cannot be zero")
	    }
	    else {
	    	GlobalStatus.gDirty = 1,
		.iMsgSize = $1,
		"ok"
	    }
	)
    }
    inst iMbxLength :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Label :: "Mailbox Length"
	prop JSName :: "length"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    if ($1  == 0) {
		.error ("Mailbox length cannot be zero")
	    }
	    else {
	    	GlobalStatus.gDirty = 1,
		.iMbxLength = $1,
		"ok"
	    }
	)
    }
    inst iMbxSeg :: MBX.OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Element memory segment"
	prop JSName :: "elementSeg"
	prop Visible :: 1
	prop Writable :: 1
    }
}
type QUE {
    isa ObjectMgr
    prop name :: "QUE"
    prop Label :: "QUE - Atomic Queue Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 133
    prop InstanceIcon :: 134
    prop IsConfMod :: 1		
    prop GlobalHelpTopic :: (
	309
    )
    prop InstanceHelpTopic :: (
	409
    )
    prop InstancePropertyPage :: (
	"{D01ACC01-38DD-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{D01ACC02-38DD-11d1-988B-0020AFEE33C6}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: (
	"%8t .que: block(0x20000){}"
    )
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: .OBJMEMSEG
    prop dataSize :: (
	2 * QUE.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    )
    
    prop cGen :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "que.h" : ""
    
    prop cGenHInst :: (
	if (GBL.DSPTYPE == 62) {
	    "extern far QUE_Obj %0r;\n\0"
	}
	else {
	    "extern QUE_Obj %0r;\n\0"
	}
    )
    
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
}
type LCK {
    isa ObjectMgr
    prop name :: "LCK"
    prop Label :: "LCK - Resource Lock Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 129
    prop InstanceIcon :: 130
    prop IsConfMod :: 1		
    prop GlobalHelpTopic :: (
	306
    )
    prop InstanceHelpTopic :: (
	406
    )
    prop InstancePropertyPage :: (
	"{0EB45D40-38C1-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{0EB45D41-38C1-11d1-988B-0020AFEE33C6}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _bssAllocDesc, _memSeg, _placement"
	}
    )
    prop _bssAllocDesc :: (
	"%8t .lck: block(0x20000){}"
    )
    prop _objAllocDesc :: (
	"%8t .LCK$obj: block(0x20000){}"
    )
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: .OBJMEMSEG
    prop dataSize :: (
	(8 + 2) * LCK.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    )
    
    prop cGen :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "lck.h" : ""
    
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
            "extern far LCK_Obj %0r;\n\0"
        }
        else {
            "extern LCK_Obj %0r;\n\0"
        }
    )
    
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
}
type SIO {
    isa ObjectMgr
    prop name :: "SIO"
    prop Label :: "SIO - Stream Input and Output Manager"
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 139
    prop InstanceIcon :: 140
    prop GlobalHelpTopic :: (
	311
    )
    prop InstanceHelpTopic :: (
	411
    )
    prop InstancePropertyPage :: (
	"{7C4C9A60-763E-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{7C4C9A61-763E-11d1-988B-0020AFEE33C6}" 
    )
    prop DependsOn :: "DEV,UDEV,DGN,DHL,DPI"
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "2\0, _bssAllocDesc, _memSeg, _placement,
	          _objAllocDesc, _memSeg, _placement"
	}
    )
    prop _bssAllocDesc :: (
        "%8t .SIO$bss: block(0x20000) {%12t\n *(.SIO$bss)%8t\n }"
    )
    prop _objAllocDesc :: (
        "%8t .SIO$obj: block(0x20000) {%12t\n *(.SIO$obj)%8t\n }"
    )
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: .OBJMEMSEG
    prop AllocInst ::  (
	"1\0, _instBufDesc, _instBufSeg, _placement"
    )
    prop _instBufDesc :: (
	.iAlign > 1? "%8t .%0s$bufs: block(0x20000) align = 0x%1x {}\0, _objAlign" : "%8t .%0s$bufs: block(0x20000) {}"
    )
    prop _objAlign :: .iAlign * 2
    
    prop _instBufSeg :: .iBufSegid
    prop defDev :: (
	$h = nil,
	$i = nil,
	$j = nil,
	scan ($h; nil) {
	    if ($h.isDriver == 1) {
		scan ($i; $h) {
	            if ($j == nil
		        && $i.iIsTerminal != 0 && $i.iIsVirtual == 0) {
			
			$j = $i,
			break
		    }
		}
	    }
	},
	$j
    )
    prop devList :: (
	$h = nil,
	$i = nil,
	$j = nil,
	scan ($h; nil) {
	    if ($h.isDriver == 1) {
		scan ($i; $h) {
	            if ($j == nil
			&& $i.iIsTerminal != 0 && $i.iIsVirtual == 0) {
			
			$j = $i,
			scan ($a; DIO) {
			    if ($a == $i) {
				$i.numTimeUse++
			    }
			},
		        break
	            }
		}
	    }
	},
	$j
    )
    
    prop setDev :: (
	$h = nil,
	$i = nil,
	$j = nil,
	scan ($h; nil) {
	    if ($h.isDriver == 1) {
		scan ($i; $h) {
		    if ($i == $1) {
			$j = $i
		    }
		}
	    }
	},
	$j
    )
    prop localCanCreate :: (
	if (.defDev == nil) {
	    .error ("A driver device must be created before creating a stream.")
	}
	else {
	    "ok"
	}
    )
    prop localDelete :: (
	scan ($a; DIO) {
	    if ($a == .iDevice) {
		.iDevice.numTimeUse--
	    }
	},
	"ok"
    )
    
    prop cGen :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "sio.h" : ""
    
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far SIO_Obj %0r;\n\0"
	}
	else {
	    "extern SIO_Obj %0r;\n\0"
        }
    )
    global gNumEmbed :: 0 {  
	prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global USEISSUERECLAIM :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Use Only Issue/Reclaim Model"
	prop JSName :: "USEISSUERECLAIM"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    .USEISSUERECLAIM = $1,
	    if ($1 == 1) {
		scan ($i; SIO) {
		    $i.iModelName = "Issue/Reclaim"
		}
	    },
	    "ok"
	)
    }
    
    inst iDevice :: SIO.devList {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop TypeTest :: $1.isDriver == 1
	prop MemberTest :: $1.driverType != "DEV_IOMTYPE"
	prop Label :: "Device"
	prop JSName :: "deviceName"
	prop Set :: (
	    if (($1.iIsTerminal == 0) && (.iDevCtrlParam == "")) {
		    .error("To select a stacking device, enter first a terminal device in Device Control String")
	    }
	    else {
		if ($1.iIsVirtual == 1) {
		    .error("The device you have selected is a virtual instance, you must select a non-virtual device")
		}
		else {
		    scan($a; DIO) {
			if ($a == .iDevice) {
			    .iDevice.numTimeUse--
			}
		    },
		    scan($b; DIO) {
			if ($b == $1) {
			    $1.numTimeUse++
			}
		    },
		    .iDevice = .setDev($1),
		    "ok"
		}
	    }
	)
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iDevCtrlParam :: "" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Device Control String"
	prop JSName :: "controlParameter"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iDevId ::= .iDevice.iDevId
    inst iFxns  ::= .iDevice.iFxns
    inst iMode :: "input" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "input,output"
	prop Label :: "Mode"
	prop JSName :: "mode"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iBufsize :: 0x80 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Label :: "Buffer size"
	prop JSName :: "bufSize"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iNbufs :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01
	prop Label :: "Number of buffers"
	prop JSName :: "numBufs"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iBufSegid ::= .OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Place buffers in memory segment"
	prop JSName :: "bufSegId"
	prop Visible :: 1
	prop Writable :: .iAllocBuf == 1
    }
    inst iAlign :: 1 {
	prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768"
	prop Label :: "Buffer alignment"
	prop JSName :: "bufAlign"
	prop Visible :: 1
	prop Writable :: .iAllocBuf == 1
    }
    
    inst iFlush :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Flush"
	prop JSName :: "flush"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iModelName :: "Standard" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "Standard,Issue/Reclaim"
	prop Label :: "Model"
	prop JSName :: "modelName"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    $e = "ok",
	    if (.USEISSUERECLAIM == 1) {
		if ($1 == "Standard") {
	    	    $e = .error("SIO Issue/Reclaim model support selected")
	        }
	        else {
		    .iModel = $1 == "Standard"
			? "SIO_STANDARD"
			: "SIO_ISSUERECLAIM",
	            .iModelName = $1
	        }
	    }
	    else {
		.iModel = $1 == "Standard"
		    ? "SIO_STANDARD"
		    : "SIO_ISSUERECLAIM",
	        .iModelName = $1
	    },
	    $e
	)
    }
    inst iAllocBuf ::= .iSaveAllocBuf {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Allocate Static Buffer(s)"
	prop JSName :: "allocStaticBuf"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    .iSaveAllocBuf = $1,
	    "ok"
	)
    }
    inst iSaveAllocBuf :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    inst iModel :: "SIO_STANDARD" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "SIO_STANDARD,SIO_ISSUERECLAIM"
	prop Visible :: 0
	prop Writable :: 0
    }
    inst iTimeout ::= .iModel == "SIO_ISSUERECLAIM" ? .iSaveTimeout : -1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Timeout for I/O operation"
	prop JSName :: "timeout"
	prop Visible :: 1
	prop Writable :: .iModel == "SIO_ISSUERECLAIM"
	prop Set :: (
	    .iSaveTimeout = $1,
	    "ok"
	)
    }
    inst iSaveTimeout :: -1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    
    inst useCallBackFxn :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "use callback function"
	prop JSName :: "useCallBackFxn"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop TabName :: "Callback"
    }
    inst callBackFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "callback function"
	prop JSName :: "callBackFxn"
	prop Visible :: 1
	prop Writable :: .useCallBackFxn
	prop NoGen :: 0
	prop TabName :: "Callback"
    }
    inst arg0 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "argument 0"
	prop JSName :: "arg0"
	prop Visible :: 1
	prop Writable :: .useCallBackFxn
	prop NoGen :: 0
	prop TabName :: "Callback"
    }
    inst arg1 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "argument 1"
	prop JSName :: "arg1"
	prop Visible :: 1
	prop Writable :: .useCallBackFxn
	prop NoGen :: 0
	prop TabName :: "Callback"
    }
}
type STS {
    isa  ObjectMgr
    prop name :: "STS"
    prop Label :: "STS - Statistics Object Manager"
    prop IsContainedIn :: INS
    prop GlobalIcon :: 125
    prop InstanceIcon :: 126
    prop InstanceHelpTopic :: (
	212
    )
    
    prop GlobalHelpTopic :: (
	112
    )
    prop AllocType :: (
	"1\0, _globalAllocDesc, _memSeg, _placement"
    )
    prop _globalAllocDesc :: (
	"%8t .%1L: block(0x20000){%12t\n  %1U_A_TABBEG = .;\n _%1U_A_TABBEG = .;\n %2S\n %1U_A_TABEND = .;\n _%1U_A_TABEND = .;\n  %1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;\n _%1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;%8t\n }\0, name, _linkString, _objSize"
    )
    prop localInit :: (
	if (PRD.CALLBACKOBJ != nil) {
	    .error("STS initialization failure")
	},
	PRD.CALLBACKOBJ = STS
    )
    prop _placement :: (0x7fffff / 2)
    prop _linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop _memSeg :: STS.OBJMEMSEG
    
    prop _objSize :: GBL.DSPTYPE == 55 ? (2 * (4 * 2)) : (4 * 2)
    prop dataSize :: (
	(4 * 2) * (STS.gNumOf + STS.gNumEmbed)
    )
    prop maxObjs :: (
	32767			
    )
    prop InstancePropertyPage :: (
	"{B7240DEE-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
	"{B7240DEF-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    prop STSGetMaxFmt :: (
	.format
    )
    prop STSGetSumFmt :: (
	.format
    )
    prop STSGetAvgFmt :: (
	"%.2f"
    )
    prop STSFilterSum :: (
	(.iA * $1 + .iB * $2) / (1.0 * .iC)
    )
    prop STSFilterMax :: (
	(.iA * $1 + .iB) / (1.0 * .iC)
    )
    prop HighTimeBased :: (
	.unittype == "High resolution time based" ? 1 : 0
    )
    prop LowTimeBased :: (
	.unittype == "Low resolution time based" ? 1 : 0
    )
    
    prop cGen :: 1
    
    prop cHeaderName :: .gNumOf > 0 ? "sts.h" : ""
    
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far STS_Obj %0r;\n\0"
	}
	else {
	    "extern STS_Obj %0r;\n\0"
        }
    )
    prop modifiable :: (
	((.iDelUser == "USER" || .iDelUser == "HWI") ? 1 : 0)
    )
    prop call :: (
	scan($a; STS) {
	    if ($a.unittype == "High resolution time based") {
	        $a.iA = CLK.INSTRPERCLK * (CLK.TDDR + 1)
	    }
	}
    )
    
    global OBJMEMSEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global gNumEmbed :: 0 {	
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst prev :: 0 {		
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: .modifiable()
	prop JSName :: "previousVal"
	prop NoGen :: GBL.DSPTYPE != 40 && GBL.DSPTYPE != 62
	prop Set :: (
	    .prev = $1,
	    .prevlow = $1 & 0xffff,
	    .prevhigh = ($1 >> 16) & 0xffff,
	    "ok"
	)
    }
    inst format :: "%g" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "format"
	prop NoGen :: 1
    }
    
    inst unittype :: "Not time based" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "Not time based,High resolution time based,Low resolution time based"
	prop Label :: "unit type"
	prop JSName :: "unitType"
	prop Visible :: 1
	prop Writable :: .modifiable()
	prop NoGen :: 1
	prop Set :: (
	    .unittype = $1,
	    if ($1 == "High resolution time based") {
		.iA = CLK.INSTRPERCLK * (CLK.TDDR + 1),
		.iB = 0,
		.iC = 1,
		.operation = "A * x"
	    }
	    else {
		if ($1 == "Low resolution time based") {
		    .iA = 1,
		    .iB = 0,
		    .iC = 1,
		    .operation = "A * x"
		}
		else {
		    .iA = 1,
		    .iB = 0,
		    .iC = 1,
		    .operation = "Nothing"
		}
	    },
	    "ok"
	)
    }
    inst operation :: "Nothing" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "Nothing,A * x,A * x + B,(A * x + B) / C"
	prop Label :: "host operation"
	prop JSName :: "operation"
	prop Visible :: 1
	prop Writable :: (
	    (.unittype != "Low resolution time based") && .modifiable()
	)
	prop NoGen :: 1
	prop Set :: (
	    .operation = $1,
	    if ($1 == "Nothing" && .unittype != "High resolution time based") {
		.iA = 1,
		.iB = 0,
		.iC = 1
	    }
	    else {
		if ($1 == "A * x") {
		    .iB = 0,
		    .iC = 1
		}
		else {
		    if ($1 == "A * x + B") {
			.iC = 1
		    }
		}
	    },
	    "ok"
	)
    }
    inst iA :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: (.modifiable() &&
	    !(.unittype != "Not time based" || .operation == "Nothing")
	)
	prop Label :: "A"
	prop JSName :: "numA"
	prop NoGen :: 1
    }
    inst iB :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: (.modifiable() &&
	    !(.unittype == "Low resolution time based" || .operation == "Nothing" || .operation == "A * x")
	)
	prop Label :: "B"
	prop JSName :: "numB"
	prop NoGen :: 1
    }
    inst iC :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: (.modifiable() &&
	    (.unittype == "Not time based" && .operation == "(A * x + B) / C"))
	prop Label :: "C"
	prop JSName :: "numC"
	prop NoGen :: 1
    }
    inst prevhigh :: 0 {	
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: GBL.DSPTYPE == 40 || GBL.DSPTYPE == 62
    }
    
    inst prevlow :: 0 {		
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
}
type SYS {
    isa Module
    prop name :: "SYS"
    prop Label :: "SYS - System Settings"
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 141
    prop InstanceIcon :: 142
    prop IsConfMod :: 1		
    prop GlobalHelpTopic :: (
	313
    )
    prop InstanceHelpTopic :: (
	413
    )
    prop InstancePropertyPage :: (
	"{473C4A62-B1A8-11d0-9885-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{473C4A63-B1A8-11d0-9885-0020AFEE33C6}"
    )
    prop AllocType :: ( .PUTCFXN == @_UTL_doPutc ?
	"2\0, _globalAllocDesc,	_memSeg, _midPlace, \
	      _traceString, _traceSeg, _midPlace"
	:
	"1\0, _globalAllocDesc,	_memSeg, _midPlace"
    )
    prop _globalAllocDesc :: (
	"%8t .sys: block(0x20000)    {}"
    )
    prop _traceString   :: (
	"%8t .trace: block(0x20000) fill = 0x0 {%12t\n_SYS_PUTCBEG = .;\n. += 0x%1x;\n_SYS_PUTCEND = . - 1;%8t\n }\0, _traceSize"
    )
    prop _midPlace :: (0x7fffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    prop _traceSeg :: SYS.TRACESEG
    prop _traceSize :: SYS.TRACESIZE
    
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global TRACESIZE :: 512 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "%d"
	prop Style :: 0x01 | 0x02
	prop Label :: "Trace Buffer Size"
	prop JSName :: "TRACESIZE"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global TRACESEG :: DARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1) 
	prop Label :: "Trace Buffer Memory"
	prop JSName :: "TRACESEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global ABORTFXN :: @_UTL_doAbort {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Abort Function"
	prop JSName :: "ABORTFXN"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    global ERRORFXN :: @_UTL_doError {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Error Function"
	prop JSName :: "ERRORFXN"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    global EXITFXN :: @_UTL_halt {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Exit Function"
	prop JSName :: "EXITFXN"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    global PUTCFXN :: @_UTL_doPutc {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Putc Function"
	prop JSName :: "PUTCFXN"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
}
type GIO {
    isa Module
    prop Visible :: 1
    prop name :: "GIO"
    prop Label :: "GIO - General Input/Output Manager"
    prop IsConfMod :: .USEGIO 
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 141
    prop InstanceIcon :: 142
    prop GlobalHelpTopic :: (
	320
    )
    prop InstanceHelpTopic :: (
	420
    )
    prop InstancePropertyPage :: (
	"{473C4A62-B1A8-11d0-9885-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{473C4A63-B1A8-11d0-9885-0020AFEE33C6}"
    )
    prop DependsOn :: "DEV,UDEV"
    prop AllocType :: (
	"1\0, _globalAllocDesc, _memSeg, _midPlace"
    )
    prop _globalAllocDesc :: (
	"%8t .gio: block(0x20000)    {}"
    )
    prop _midPlace :: (0x7fffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global USEGIO :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable General Input/Output Manager"
	prop JSName :: "ENABLEGIO"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global CREATEFXN ::= .USEGIO == 1 ? @_SEM_create : @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Create Function"
	prop JSName :: "CREATEFXN"
	prop Visible :: 1
	prop Writable :: .USEGIO
	prop NoGen :: 0
    }
    global DELETEFXN ::= .USEGIO == 1 ? @_SEM_delete : @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Delete Function"
	prop JSName :: "DELETEFXN"
	prop Visible :: 1
	prop Writable :: .USEGIO
	prop NoGen :: 0
    }
    global PENDFXN ::= .USEGIO == 1 ? @_SEM_pend : @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Pend Function"
	prop JSName :: "PENDFXN"
	prop Visible :: 1
	prop Writable :: .USEGIO
	prop NoGen :: 0
    }
    global POSTFXN ::= .USEGIO == 1 ? @_SEM_post : @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Post Function"
	prop JSName :: "POSTFXN"
	prop Visible :: 1
	prop Writable :: .USEGIO
	prop NoGen :: 0
    }
}
       
type SIODRIVER {
    isa ModuleFolder
    prop Label :: "Device Drivers"
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 127
    prop GlobalHelpTopic :: (
	BIOSHELP_DEV_FOLDER
    )
    prop GlobalPropertyPage :: (
        "{A2BCEC70-5365-11d4-947C-0050048381B7}"
    )
}
type DEV {
    isa ObjectMgr
    prop name :: "DEV"
    prop Visible :: 0
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _bssAllocDesc, _memSeg, _placement"
	},
	
	if ( DGN.gNumOf || DHL.gNumOf || DPI.gNumOf || DIO.gNumOf || UDEV.gNumOf ){
	    "1\0, _devtableDesc, _memSeg, _placement"
	}
    )
    prop _bssAllocDesc :: (
	"%8t .dev: block(0x20000){}"
    )
    prop _devtableDesc :: (
	"%8t .devtable: block(0x20000){}"
    )
    prop _memSeg :: MEM.CFGOBJSEG
    prop _placement :: (0x7fffff / 2)
    prop DependsOn :: "HWI"
}
type UDEV {
    isa ObjectMgr
    prop name :: "UDEV"
    prop Label :: "User-Defined Devices"
    prop IsContainedIn :: SIODRIVER
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop GlobalHelpTopic :: (
	315
    )
    prop InstanceHelpTopic :: (
	415
    )
    prop InstancePropertyPage :: (
	"{7AE86AA0-35C0-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{7AE86AA1-35C0-11d1-988B-0020AFEE33C6}"
    )
    prop maxObjs :: (32767)
    prop isDriver :: (
	1
    )
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: (
        "%8t .udev: block(0x20000){}"
    )
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    prop _driverType :: (
	.fxnTableType == "DEV_Fxns" ? "DEV_SIOTYPE" : "DEV_IOMTYPE"
    )
    inst iInit :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"	
	prop Label :: "init function"
	prop JSName :: "initFxn"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    .iInit = $1,
	    .initFxn = .iInit,
	    "ok"
	)
    }
    inst iFxns :: 0 {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"	
	prop Label    :: "function table ptr"
	prop JSName :: "fxnTable"
	prop Visible  :: 1
	prop Writable :: 1
    }
    
    inst fxnTableType :: "DEV_Fxns" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "DEV_Fxns,IOM_Fxns"
	prop Label :: "function table type"
	prop JSName :: "fxnTableType"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    inst driverType ::= ._driverType {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "DEV_SIOTYPE,DEV_IOMTYPE"
	prop Visible :: 0
    }
    
    inst iDevId :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "device id"
	prop JSName :: "deviceId"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    .iDevId = $1,
	    .deviceId = .iDevId,
	    "ok"
	)
    }
    inst iParams :: 0 {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label    :: "device params ptr"
	prop JSName :: "params"
	prop Visible  :: 1
	prop Writable :: 1
    }
    inst deviceId :: 0 {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName   :: ""
	prop Visible  :: 0
    }
    inst initFxn :: 0 {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"	
	prop JSName   :: ""
	prop Visible  :: 0
    }
    inst iIsStacking ::0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Stacking Device"
	prop JSName :: "stackingDevice"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst deviceGlobalDataPtr :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "device global data ptr"
	prop JSName :: "deviceGlobalDataPtr"
	prop Visible :: 1
	prop Writable :: .fxnTableType == "IOM_Fxns"
    }
    inst iIsTerminal ::= .fxnTableType == "DEV_Fxns" ? 1 : 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    inst iIsVirtual :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
}
type DGN {
    isa ObjectMgr
    prop name :: "DGN"
    prop Label :: "DGN - Software Generator Driver"
    prop IsContainedIn :: SIODRIVER
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop GlobalHelpTopic :: (
	302
    )
    prop InstanceHelpTopic :: (
	402
    )
    prop InstancePropertyPage :: (
	"{054FE166-B014-11d0-9885-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{054FE167-B014-11d0-9885-0020AFEE33C6}"
    )
    prop DependsOn :: "DEV"
    prop maxObjs :: (32767)
    prop isDriver :: (
	1
    )
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: (
	"%8t .dgn: block(0x20000){}"
    )
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    inst iDevice :: "user" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: GBL.DSPARITHMETIC == "FLOAT" ?
		"user,sine,random,constant,printFloat,printHex,printInt"
		:"user,sine,random,constant,printHex,printInt"
	prop Label :: "Device category"
	prop JSName :: "device"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    $a = $1,
	    if ($a != .iDevice) {
		.iDevice = $a,
		.iUserFxn = @_FXN_F_nop	
	    },
	    if ($a == "user") {
		.iUserFxn = .iSaveUserFxn
	    },
	    if ($a == "printFloat") {
		.iUserFxn = @_DGN_printFloat
	    },
	    if ($a == "printHex") {
		.iUserFxn = @_DGN_printHex
	    },
	    if ($a == "printInt") {
		.iUserFxn = @_DGN_printInt
	    },
	    "ok"
	)
    }
    inst iUseDefaults :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Use default parameters"
	prop Visible :: 1
	prop JSName :: "useDefaultParam"
	prop Writable :: .iDevice == "sine" || .iDevice == "constant" || .iDevice == "random" || .iDevice == "user"
    }
    inst iDevId ::= .iDevice == "constant" ? @DGN_CONST : .iDevice == "random" ? @DGN_RAND : .iDevice == "sine" ? @DGN_SINE : @DGN_USER {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Device ID"
	prop JSName :: "deviceId"
	prop Visible :: 1
	prop Writable :: 0
    }
    inst iIsTerminal :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    inst iIsVirtual :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    
    inst iConstant :: GBL.DSPARITHMETIC == "FIXED" ? 1 : 1.0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label  :: "Constant value"
	prop JSName :: "constant"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "constant" || .iDevice == "user")
    }
    inst iRandSeed :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Seed value"
	prop JSName :: "seedValue"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "random" || .iDevice == "user")
    }
    inst iRandLower :: GBL.DSPARITHMETIC == "FIXED" ? -32767 : 0.0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label :: "Lower limit"
	prop JSName :: "lowerLimit"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "random" || .iDevice == "user")
    }
    inst iRandUpper :: GBL.DSPARITHMETIC == "FIXED" ? 32767 : 1.0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label :: "Upper limit"
	prop JSName :: "upperLimit"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "random" || .iDevice == "user")
    }
    inst iSineGain :: GBL.DSPARITHMETIC == "FIXED" ? 32767 : 1.0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label :: "Gain"
	prop JSName :: "gain"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "sine" || .iDevice == "user")
    }
    inst iSineFreq :: GBL.DSPARITHMETIC == "FIXED" ? 1 : 1000.0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label :: "Frequency (Hz)"
	prop JSName :: "frequency"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "sine" || .iDevice == "user")
    }
    inst iSinePhase :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0.0{
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label :: "Phase (radians)"
	prop JSName :: "phase"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "sine" || .iDevice == "user")
    }
    inst iSineRate :: GBL.DSPARITHMETIC == "FIXED" ? 256 : 44000 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Sample rate (samples/sec)"
	prop JSName :: "rate"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "sine" || .iDevice == "user")
    }
    inst iUserFxn :: .iDevice == "printFloat" ? @_DGN_printFloat : .iDevice == "printHex" ? @_DGN_printHex : .iDevice == "printInt" ? @_DGN_printInt : @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "User function"
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: .iDevice == "user"
	
	prop Set :: (
	    .iUserFxn = $1,
	    .iSaveUserFxn = .iUserFxn,
	    "ok"
	)
    }
    inst iSaveUserFxn :: @_FXN_F_nop {
	prop Visible :: 0
	prop Writable ::0
	prop NoGen :: 1
    }
    inst iUserArg ::= 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "User function argument"
	prop JSName :: "arg"
	prop Visible :: 1
	prop Writable :: .iDevice == "user"
    }
    
    inst iFxns :: @_DGN_FXNS {
	prop NoGen :: 1
    }
}
type DHL {
    isa ObjectMgr
    prop name :: "DHL"
    prop Label :: "DHL - Host Link Driver"
    prop IsContainedIn :: SIODRIVER
    prop GlobalHelpTopic :: (303)
    prop InstanceHelpTopic :: (403)
    prop InstancePropertyPage :: ("{9C29DA20-90F9-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{9C29DA21-90F9-11d1-988B-0020AFEE33C6}")
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop DependsOn :: "DEV"
    prop Visible :: 1
    prop isDriver :: 1
    prop dataSize :: (
	8 + 11 * DHL.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    )
    global gChannelsAvailable :: (
        $a = 0,
        scan ($i; HST) {
            if ($i.iDHLAvailable == 1) {
                $a++
            }
        },
        $a
    ) 
    prop localCanCreate :: (
        if (.gChannelsAvailable > 0) {
            "ok"
        }
	else {
	    .warning("No HST channels are available for a new DHL device.")
	}
    )
    prop localCreate :: (
        .gChannelsAvailable--,
	.seizeHSTChannel(.iHSTChannel),
        "ok"
    )
       
    prop seizeHSTChannel :: (
	$1.iDelUser = "DHL",
	$1.iDHLAvailable = 0,
	$1.notify = @_DHL_notify,
	$1.arg0 = $1.iId,
	"ok"
    )
    prop localDelete ::(
        .gChannelsAvailable++,
	.releaseHSTChannel(.iHSTChannel),
        "ok"
    )
    prop releaseHSTChannel :: (
	$1.iDelUser = "USER",
	$1.iDHLAvailable = 1,
	$1.notify = @_FXN_F_nop,
	$1.arg0 = 0,
	"ok"
    )
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: "%8t .dhl: block(0x20000){}"
    prop _memSeg :: .OBJMEMSEG
    prop _placement :: (0x7fffff / 2)
    global OBJMEMSEG :: DARAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iHSTChannel :: (
        scan ($i; HST) {
            if ($i.iDHLAvailable == 1) {
                $a = $i 
            }
        },
        $a
    ) {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Underlying HST Channel"
	prop JSName :: "hstChannel"
        prop MemberType :: HST
	prop MemberTest :: ((($1.iDHLAvailable == 1) || ($1 == .iHSTChannel)) ? 1 : 0)
        prop Set :: (
            if ($1.iDHLAvailable != 1) {
		
                .error("This channel is already in use.")
            }
            else {
                .releaseHSTChannel(.iHSTChannel),
		.seizeHSTChannel($1),
                .iHSTChannel = $1,
                "ok"
            }
        )
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst iMode ::= .iHSTChannel.mode {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Mode"
	prop JSName :: "mode"
	prop Visible :: 1
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst iDevId ::= (.iHSTChannel.iId) {
	prop NoGen :: 0
    }
    
    inst iIsTerminal :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    inst iIsVirtual :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iFxns :: @_DHL_FXNS {
	prop NoGen :: 1
    }
}
type DPI {
    isa ObjectMgr
    prop name :: "DPI"
    prop Label :: "DPI - Pipe Driver"
    prop IsContainedIn :: SIODRIVER
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop GlobalHelpTopic :: (
	304
    )
    prop InstanceHelpTopic :: (
	404
    )
    prop InstancePropertyPage :: (
	"{7FE06FA0-2DE9-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{7FE06FA1-2DE9-11d1-988B-0020AFEE33C6}"
    )
    prop DependsOn :: "DEV"
    prop maxObjs :: (32767)
    prop isDriver :: (
	1
    )
    prop localCreate :: (
	.gCurDevId += 1,
	"ok"
    )
    global gCurDevId :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iDevId :: DPI.gCurDevId {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
	prop Set :: (
	    .error("DPI.iDevId parameter no longer settable, it is now handled automatically")
	)
    }
    inst iIsVirtual :: 0 {
        prop Label :: "Allow virtual instances of this device."
	prop JSName :: "allowVirtual"
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
	prop Set :: (
	    if ($1 == 1) {
		$a = "ok",
		$b = 1,
		scan ($i; SIO) {
		    if ($i.iDevice == self) {
			$a = .error("This DPI instance is being used by one or more SIO instances, cannot reconfigure"),
			$b = 0
		    }
		},
		if ($b == 1) {
		    .iIsVirtual = 1
		},
		$a
	    }
	    else {
		.iIsVirtual = 0,
		"ok"
	    }
	)
    }
    inst iIsTerminal :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    
    inst iFxns :: @_DPI_FXNS {
	prop NoGen :: 1
    }
}
type HOOK {
    isa ObjectMgr
    prop name :: "HOOK"
    prop Label :: "HOOK - Module Hook Manager"
    prop IsContainedIn :: SYSTEM
    prop DependsOn :: "SWI"
    prop InstancePropertyPage :: (
	"{473C4A64-B1A8-11d0-9885-0020AFEE33C6}"
    )
    prop GlobalIcon :: 181
    prop InstanceIcon :: 182
    prop GlobalHelpTopic :: (
	318
    )
    prop InstanceHelpTopic :: (
	418
    )
    prop localCreate :: (
	if (.gNumOf == 0) {
	    HOOK_KNL.iIsUsed = 1,
	    .mkId(0)
	},
	"ok"
    )
    
    prop localDelete :: (
	if (.gNumOf == 2) {
	    HOOK_KNL.iIsUsed = 0,
	    .rmId
	},
	"ok"
    )
    prop maxObjs :: (32767)	
    
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    global KNLID ::= (HOOK_KNL.Order - 1) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    inst initFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Initialization function"
	prop JSName :: "initFxn"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst createFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Create function"
	prop JSName :: "createFxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER"
    }
    inst deleteFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Delete function"
	prop JSName :: "deleteFxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER"
    }
    inst exitFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Exit function"
	prop JSName :: "exitFxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER"
    }
    inst callSwitchFxn :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Call switch function"
	prop JSName :: "callSwitchFxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER"
    }
    inst switchFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Switch function"
	prop JSName :: "switchFxn"
	prop Visible :: 1
	prop Writable :: .callSwitchFxn
    }
    inst callReadyFxn :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Call ready function"
	prop JSName :: "callReadyFxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER"
    }
    inst readyFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Ready function"
	prop JSName :: "readyFxn"
	prop Visible :: 1
	prop Writable :: .callReadyFxn
    }
    
    inst Order :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
	prop NoGen :: 1
	prop Writable :: 1
    }
    
    inst iPri :: 0 {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}
object HOOK_KNL :: HOOK {
    param Order :: 1
    param iComment :: "Used to support TSK function hooks (cannot be deleted)"
    param iIsUsed :: 0
    param iDelUser :: "HOOK"
    param iDelMsg :: "This hook instance is used by TSK and cannot be deleted"
    param initFxn :: @_FXN_F_nop
    param createFxn :: TSK.CREATEFXN
    param deleteFxn :: TSK.DELETEFXN
    param exitFxn :: TSK.EXITFXN
    param callSwitchFxn :: TSK.DOSWITCH
    param switchFxn :: TSK.VSWFXN
    param callReadyFxn :: TSK.DOREADY
    param readyFxn :: TSK.VRDYFXN
}
type DIO {
    isa ObjectMgr
    prop Visible :: 1
    prop Label :: "DIO - Class Driver"
    prop name :: "DIO"
    prop IsContainedIn :: SIODRIVER
    prop GlobalIcon :: 127
    prop InstanceIcon :: 127
    prop GlobalHelpTopic :: (
	319
    )
    prop InstanceHelpTopic :: (
	419	
    )
    prop InstancePropertyPage :: (		
	"{f80273c0-3838-11d2-a32c-006097656921}"
    )
    
    prop GlobalPropertyPage :: (		
	"{050a0600-3839-11d2-a32c-006097656921}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: (
	"%8t .dio: {}"
    )
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: .OBJMEMSEG
    prop isDriver :: (
	1
    )
    prop mdObject :: (
	$h = nil,
	$j = nil,
	scan ($h; UDEV) {
	    if ($h.driverType == "DEV_IOMTYPE" ) {
		$j = $h,
                break
	    }
	},
	$j
    )
    prop localCanCreate :: (
	if (.mdObject == nil) {
	    .error ("An IOM type device must be created first.")
	}
	else {
	    "ok"
	}
    )
    prop numTsk :: (
	$a = 0,
	$h = nil,
	scan ($h; DIO) {
	    if ($h.useCallBackFxn == 0) {
		$a = $a + $h.numTimeUse
	    }
	},
	$a
    )
    prop numSwi :: (
	$a = 0,
	$h = nil,
	scan ($h; DIO) {
	    if ($h.useCallBackFxn == 1) {
		$a = $a + $h.numTimeUse
	    }
	},
	$a
    )
	
    prop functionTablePtr :: (
	if (.STATIC) {
	    if (.useCallBackFxn) {
		@_DIO_cbStaticFxns
	    }
	    else {
		@_DIO_tskStaticFxns
	    }
	}
	else {
	    if (.useCallBackFxn) {
		@_DIO_cbDynamicFxns
	    }
	    else {
		@_DIO_tskDynamicFxns
	    }
	}
    )
    global OBJMEMSEG :: DARAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global STATIC :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Create all DIO Objects Statically"
	prop JSName :: "STATICCREATE"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    global NUMTSKBASE ::= .numTsk  {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "TSK based"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global NUMSWIBASE ::= .numSwi  {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "SWI based"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst useCallBackFxn :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "use callback version of DIO function table"
	prop JSName :: "useCallBackFxn"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    inst fxnsTable ::= .functionTablePtr {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible  :: 1
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst initFxn :: @_DIO_init {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible  :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst deviceName :: .mdObject {
        prop Type     :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: UDEV
	prop MemberTest :: $1.driverType == "DEV_IOMTYPE"
        prop Label    :: "device name"
        prop JSName   :: "deviceName"
        prop Visible  :: 1
        prop Writable :: 1
	prop NoGen :: 0
    }
    inst chanParams :: 0 {
        prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label    :: "channel parameters"
        prop JSName   :: "chanParams"
        prop Visible  :: 1
        prop Writable :: 1
	prop NoGen :: 0
    }
    inst numTimeUse :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iDevId :: 0 {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible  :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iFxns ::= .functionTablePtr {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible  :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iIsTerminal :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iIsVirtual :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
}
type PWRM {
    isa Module
    prop name :: "PWRM"
    prop Label :: "PWRM - Power Manager"
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 185	
    prop InstanceIcon :: 186
    prop GlobalHelpTopic :: (
	322
    )
    prop InstanceHelpTopic :: (
	422
    )
    prop IsConfMod :: 1		
    prop Visible :: 0		
    prop InstancePropertyPage :: (
	"{000FFB50-0419-11d3-B053-0020AFEF4449}"
    )
    
    prop GlobalPropertyPage :: (
	"{43959450-0419-11d3-B053-0020AFEF4449}"
    )
    prop _placement :: (0x7fffff / 2)
    
    global PWRM_ENABLE :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable PWRM Manager"
	prop JSName :: "ENABLE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: ( 
                      $e="ok",
                      if($1 == 0) {
                          if(.PWRM_IDLEDOMAINS == 1) {
                              $e = .error("Idling of DSP domains (Idling page) must be disabled before disabling the Power Manager")
                          }
                          else {
                              .PWRM_ENABLE = $1
                          }
                      }
                      else {
                          .PWRM_ENABLE = $1 
                      },
                      $e
                    )
    }
    
    global PWRM_BOOTHOOK :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call user hook function at boot time"
	prop JSName :: "BOOTHOOK"
        prop Visible :: 1
        prop Writable :: .PWRM_ENABLE
        prop NoGen :: 1
        prop Set :: ( 
                      $e="ok",
                      if($1 == 0) {
                          .PWRM_BOOTHOOKFXN = @_FXN_F_nop
                      },
		      .PWRM_BOOTHOOK = $1, 
                      .PWRM_CAPSMASK = .PWRM_capsmask_update(),
                      $e
                    )
    }
    global PWRM_BOOTHOOKFXN :: @_FXN_F_nop {
        prop Label :: "Function"
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "BOOTHOOKFXN"
        prop Visible :: 1
        prop Writable :: .PWRM_BOOTHOOK && .PWRM_ENABLE
        prop NoGen :: 0
    }
    
    global PWRM_ADAPTCLK :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Reprogram BIOS clock after frequency scaling"
	prop JSName :: "ADAPTCLK"
        prop Visible :: 1
        prop Writable :: CLK.USETIMER && .PWRM_ENABLE
        prop NoGen :: 0
        prop Set :: ( 
                      .PWRM_ADAPTCLK = $1, 
                      .PWRM_CAPSMASK = .PWRM_capsmask_update(),
                      "ok"  
                    )
    }
    global OLDAUTOCALCULATE :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "previous value for autocalculate before PWRM insert "
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    
    global PWRM_IDLEDOMAINS :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Idle DSP domains in the BIOS idle loop"
	prop JSName :: "IDLEDOMAINS"
        prop Visible :: 1
        prop Writable :: .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Idling"
        prop Set :: ( 
                      $e = "ok",
                      if ($1 != .PWRM_IDLEDOMAINS) { 
                          if ($1 == 1) {
                              PWRM_idleDomains.Create("IDL"),
				PWRM_idleDomains.function = @_PWRM_F_idleDomains,
                              .OLDAUTOCALCULATE = IDL.AUTOCALCULATE,
                              IDL.AUTOCALCULATE = 0 
                          }
                          else {
                              PWRM_idleDomains.Delete("IDL"),
                              IDL.AUTOCALCULATE = .OLDAUTOCALCULATE
                          },
                          .PWRM_IDLEDOMAINS = $1, 
                          .PWRM_CAPSMASK = .PWRM_capsmask_update()
                      },
                     $e
                    )
    }
    global PWRM_EMIF :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    EMIF"
	prop JSName :: "IDLEEMIF"
        prop Visible :: 1
        prop Writable :: .PWRM_IDLEDOMAINS && .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Idling"
        prop Set :: ( 
                      .PWRM_EMIF = $1, 
                      .PWRM_IDLEMASK = .PWRM_idlemask_update(),
                      "ok"  
                    )
    }
    global PWRM_CLKGEN :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    CLKGEN"
	prop JSName :: "IDLECLKGEN"
        prop Visible :: 1
        prop Writable :: .PWRM_IDLEDOMAINS && .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Idling"
        prop Set :: ( 
                      $e="ok",
                      if($1 == 1) {
                          if(.PWRM_DMA == 0) {
                              $e = .error("The DMA domain must be idled before idling CLKGEN")
                          }
                          else {
                              if(.PWRM_CPU == 0) {
                                  $e = .error("The CPU domain must be idled before idling CLKGEN")
                              }
                              else {
                                  if(.PWRM_CACHE == 0) {
                                      $e = .error("The CACHE domain must be idled before idling CLKGEN")
                                  }
                                  else {
                                      .PWRM_CLKGEN = $1, 
                                      .PWRM_IDLEMASK = .PWRM_idlemask_update()
                                  }
                              }
                          }
                      }
                      else {
                          .PWRM_CLKGEN = $1,
                          .PWRM_IDLEMASK = .PWRM_idlemask_update()
                      },
                      $e
                    )
    }
    global PWRM_PERIPH :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    PERIPHS"
	prop JSName :: "IDLEPERIPH"
        prop Visible :: 1
        prop Writable :: .PWRM_IDLEDOMAINS && .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Idling"
        prop Set :: ( 
                      .PWRM_PERIPH = $1, 
                      .PWRM_IDLEMASK = .PWRM_idlemask_update(),
                      "ok"  
                    )
    }
    global PWRM_CACHE :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    CACHE"
	prop JSName :: "IDLECACHE"
        prop Visible :: 1
        prop Writable :: .PWRM_IDLEDOMAINS && .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Idling"
        prop Set :: ( 
                      $e="ok",
                      if($1 == 0) {
                          if(.PWRM_CLKGEN == 1) {
                              $e = .error("The CACHE domain must remain idled while CLKGEN is idled")
                          }
                          else {
                              .PWRM_CACHE = $1, 
                              .PWRM_IDLEMASK = .PWRM_idlemask_update()
                          }
                      }
                      else {
                          .PWRM_CACHE = $1, 
                          .PWRM_IDLEMASK = .PWRM_idlemask_update()
                      },
                      $e
                    )
    }
    global PWRM_DMA :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    DMA"
	prop JSName :: "IDLEDMA"
        prop Visible :: 1
        prop Writable :: .PWRM_IDLEDOMAINS && .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Idling"
        prop Set :: ( 
                      $e="ok",
                      if($1 == 0) {
                          if(.PWRM_CLKGEN == 1) {
                              $e = .error("The DMA domain must remain idled while CLKGEN is idled")
                          }
                          else {
                              .PWRM_DMA = $1, 
                              .PWRM_IDLEMASK = .PWRM_idlemask_update()
                          }
                      }
                      else {
                          .PWRM_DMA = $1, 
                          .PWRM_IDLEMASK = .PWRM_idlemask_update()
                      },
                      $e
                    )
    }
    global PWRM_CPU :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    CPU"
	prop JSName :: "IDLECPU"
        prop Visible :: 1
        prop Writable :: .PWRM_IDLEDOMAINS && .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Idling"
        prop Set :: ( 
                      $e="ok",
                      if($1 == 0) {
                          if(.PWRM_CLKGEN == 1) {
                              $e = .error("The CPU domain must remain idled while CLKGEN is idled")
                          }
                          else {
                              .PWRM_CPU = $1, 
                              .PWRM_IDLEMASK = .PWRM_idlemask_update()
                          }
                      }
                      else {
                          .PWRM_CPU = $1, 
                          .PWRM_IDLEMASK = .PWRM_idlemask_update()
                      },
                      $e
                    )
    }
    global PWRM_IDLEMASK :: ( .PWRMCPUMASK |
                              .PWRMCPUMASK |
                              .PWRMDMAMASK |
                              .PWRMCACHEMASK |
                              .PWRMPERIPHMASK |
                              .PWRMCLKGENMASK |
                              .PWRMEMIFMASK ) {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Clock domain bitmask for IDL loop"
        prop Format :: "0x%04x"
        prop Visible :: 0
        prop Writable :: .PWRM_IDLEDOMAINS 
        prop NoGen :: 0
        prop TabName :: "Idling"
    }
    prop PWRM_idlemask_update :: (
          .PWRMCPUMASK |
          .PWRMDMAMASK |
          .PWRMCACHEMASK |
          .PWRMPERIPHMASK |
          .PWRMCLKGENMASK |
          .PWRMEMIFMASK
    )
    prop PWRMCPUMASK :: ((.PWRM_CPU == 1) ? 0x01 : 0x0)
    prop PWRMDMAMASK :: ((.PWRM_DMA == 1) ? 0x02 : 0x0)
    prop PWRMCACHEMASK :: ((.PWRM_CACHE == 1) ? 0x04 : 0x0)
    prop PWRMPERIPHMASK :: ((.PWRM_PERIPH == 1) ? 0x08 : 0x0)
    prop PWRMCLKGENMASK :: ((.PWRM_CLKGEN == 1) ? 0x10 : 0x0)
    prop PWRMEMIFMASK :: ((.PWRM_EMIF == 1) ? 0x20 : 0x0)
 
    
    global PWRM_CAPSMASK :: (  
                               .PWRMBOOTHOOKF |
                               .PWRMIDLEDOMAINSF |
                               .PWRMVFSCALINGF |
                               .PWRMSCALEVF |
                               .PWRMWAITFORVF |
                               .PWRMDEEPSLEEPF |
                               .PWRMWAITRESTARTF |
                               .PWRMSNOOZEF |
                               .PWRMADAPTCLKF
                                     ) {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "PWRM caps mask"
        prop Format :: "0x%04x"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    prop PWRM_capsmask_update :: (
               .PWRMBOOTHOOKF |
               .PWRMIDLEDOMAINSF |
               .PWRMVFSCALINGF |
               .PWRMSCALEVF |
               .PWRMWAITFORVF |
               .PWRMDEEPSLEEPF |
               .PWRMWAITRESTARTF |
               .PWRMSNOOZEF |
               .PWRMADAPTCLKF
    )
    prop PWRMBOOTHOOKF :: ((.PWRM_BOOTHOOK == 1) ? 0x100 : 0x0)
    prop PWRMADAPTCLKF :: ((.PWRM_ADAPTCLK == 1) ? 0x80 : 0x0)
    prop PWRMIDLEDOMAINSF :: ((.PWRM_IDLEDOMAINS == 1) ? 0x40 : 0x0)
    prop PWRMVFSCALINGF :: ((.PWRM_SCALING == 1) ? 0x8 : 0x0)
    prop PWRMSCALEVF :: ((.PWRM_SCALEV == 1) ? 0x10 : 0x0)
    prop PWRMWAITFORVF :: ((.PWRM_WAITV == 1) ? 0x20 : 0x0)
    prop PWRMDEEPSLEEPF :: ((.PWRM_ENSLEEP == 1) ? 0x1 : 0x0)
    prop PWRMWAITRESTARTF :: ((.PWRM_ENSLEEPUNTILRESTART == 1) ? 0x2 : 0x0)
    prop PWRMSNOOZEF :: ((.PWRM_ENSNOOZE == 1) ? 0x4: 0x0)
    
    global PWRM_SCALING :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Voltage and Frequency Scaling"
	prop JSName :: "SCALING"
        prop Visible :: 1
        prop Writable :: .PWRM_ENABLE 
        prop NoGen :: 0
        prop TabName :: "V/F Scaling"
        prop Set :: ( 
                      .PWRM_SCALING = $1, 
                      .PWRM_CAPSMASK = .PWRM_capsmask_update(),
                      "ok"  
                    )
    }
    global PWRM_INITSP :: 15 {
        prop Label :: "Initial frequency (index to frequency table)"
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x01 | 0x02
	prop JSName :: "INITIALFREQ"
        prop Visible :: 1
        prop Writable :: .PWRM_SCALING && .PWRM_ENABLE
        prop NoGen :: 0
        prop TabName :: "V/F Scaling"
    }
    global PWRM_INITVOLTS :: 1.6 {
        prop Label :: "Initial voltage (volts)"
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.2f"
	prop JSName :: "INITVOLTS"
        prop Visible :: 1
        prop Writable :: .PWRM_SCALING && .PWRM_ENABLE
        prop NoGen :: 0
        prop TabName :: "V/F Scaling"
    }
    global PWRM_SCALEV :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Scale voltage along with frequency"
	prop JSName :: "SCALEVOLT"
        prop Visible :: 1
        prop Writable :: .PWRM_SCALING && .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "V/F Scaling"
        prop Set :: ( 
                      .PWRM_SCALEV = $1, 
                      .PWRM_CAPSMASK = .PWRM_capsmask_update(),
                      "ok"  
                    )
    }
    global PWRM_WAITV :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Wait while voltage is being scaled down"
	prop JSName :: "WAITVOLT"
        prop Visible :: 1
        prop Writable :: .PWRM_SCALING && .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "V/F Scaling"
        prop Set :: ( 
                      .PWRM_WAITV = $1, 
                      .PWRM_CAPSMASK = .PWRM_capsmask_update(),
                      "ok"  
                    )
    }
    
    global PWRM_ENSLEEP :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable deep sleep"
	prop JSName :: "ENABLESLEEP"
        prop Visible :: 1
        prop Writable :: .PWRM_ENABLE 
        prop NoGen :: 1
        prop TabName :: "Sleep"
        prop Set :: ( 
                      .PWRM_ENSLEEP = $1, 
                      .PWRM_CAPSMASK = .PWRM_capsmask_update(),
                      "ok"  
                    )
    }
    global PWRM_DS_EMIF :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    EMIF"
	prop JSName :: "SLEEPEMIF"
        prop Visible :: 1
        prop Writable :: .PWRM_ENSLEEP && .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Sleep"
        prop Set :: (
                      .PWRM_DS_EMIF = $1,
                      .PWRM_DS_IDLEMASK = .PWRM_DS_idlemask_update(),
                      "ok"
                    )
    }
    global PWRM_DS_CLKGEN :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    CLKGEN"
	prop JSName :: "SLEEPCLKGEN"
        prop Visible :: 1
        prop Writable :: .PWRM_ENSLEEP && .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Sleep"
        prop Set :: (
                      $e="ok",
                      if($1 == 1) {
                          if(.PWRM_DS_DMA == 0) {
                              $e = .error("The DMA domain must be idled before idling CLKGEN")
                          }
                          else {
                              if(.PWRM_DS_CPU == 0) {
                                  $e = .error("The CPU domain must be idled before idling CLKGEN")
                              }
                              else {
                                  if(.PWRM_DS_CACHE == 0) {
                                      $e = .error("The CACHE domain must be idled before idling CLKGEN")
                                  }
                                  else {
                                      .PWRM_DS_CLKGEN = $1,
                                      .PWRM_DS_IDLEMASK = .PWRM_DS_idlemask_update()
                                  }
                              }
                          }
                      }
                      else {
                          .PWRM_DS_CLKGEN = $1,
                          .PWRM_DS_IDLEMASK = .PWRM_DS_idlemask_update()
                      },
                      $e
                    )
    }
    global PWRM_DS_PERIPH :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    PERIPHS"
	prop JSName :: "SLEEPPERIPH"
        prop Visible :: 1
        prop Writable :: .PWRM_ENSLEEP && .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Sleep"
        prop Set :: (
                      .PWRM_DS_PERIPH = $1,
                      .PWRM_DS_IDLEMASK = .PWRM_DS_idlemask_update(),
                      "ok"
                    )
    }
    global PWRM_DS_CACHE :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    CACHE"
	prop JSName :: "SLEEPCACHE"
        prop Visible :: 1
        prop Writable :: .PWRM_ENSLEEP && .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Sleep"
        prop Set :: (
                      $e="ok",
                      if($1 == 0) {
                          if(.PWRM_DS_CLKGEN == 1) {
                              $e = .error("The CACHE domain must remain idled while CLKGEN is idled")
                          }
                          else {
                              .PWRM_DS_CACHE = $1,
                              .PWRM_DS_IDLEMASK = .PWRM_DS_idlemask_update()
                          }
                      }
                      else {
                          .PWRM_DS_CACHE = $1,
                          .PWRM_DS_IDLEMASK = .PWRM_DS_idlemask_update()
                      },
                      $e
                    )
    }
    global PWRM_DS_DMA :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    DMA"
	prop JSName :: "SLEEPDMA"
        prop Visible :: 1
        prop Writable :: .PWRM_ENSLEEP && .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Sleep"
        prop Set :: (
                      $e="ok",
                      if($1 == 0) {
                          if(.PWRM_DS_CLKGEN == 1) {
                              $e = .error("The DMA domain must remain idled while CLKGEN is idled")
                          }
                          else {
                              .PWRM_DS_DMA = $1,
                              .PWRM_DS_IDLEMASK = .PWRM_DS_idlemask_update()
                          }
                      }
                      else {
                          .PWRM_DS_DMA = $1,
                          .PWRM_DS_IDLEMASK = .PWRM_DS_idlemask_update()
                      },
                      $e
                    )
    }
    global PWRM_DS_CPU :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "    CPU"
	prop JSName :: "SLEEPCPU"
        prop Visible :: 1
        prop Writable :: .PWRM_ENSLEEP && .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Sleep"
        prop Set :: (
                      $e="ok",
                      if($1 == 0) {
                          if(.PWRM_DS_CLKGEN == 1) {
                              $e = .error("The CPU domain must remain idled while CLKGEN is idled")
                          }
                          else {
                              .PWRM_DS_CPU = $1,
                              .PWRM_DS_IDLEMASK = .PWRM_DS_idlemask_update()
                          }
                      }
                      else {
                          .PWRM_DS_CPU = $1,
                          .PWRM_DS_IDLEMASK = .PWRM_DS_idlemask_update()
                      },
                      $e
                    )
    }
    global PWRM_DS_IDLEMASK :: ( .PWRMDSCPUMASK |
                              .PWRMDSCPUMASK |
                              .PWRMDSDMAMASK |
                              .PWRMDSCACHEMASK |
                              .PWRMDSPERIPHMASK |
                              .PWRMDSCLKGENMASK |
                              .PWRMDSEMIFMASK ) {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Clock domain bitmask for deep sleep"
        prop Format :: "0x%04x"
        prop Visible :: 0
        prop Writable :: .PWRM_ENSLEEP
        prop NoGen :: 0
        prop TabName :: "Sleep"
    }
    prop PWRM_DS_idlemask_update :: (
          .PWRMDSCPUMASK |
          .PWRMDSDMAMASK |
          .PWRMDSCACHEMASK |
          .PWRMDSPERIPHMASK |
          .PWRMDSCLKGENMASK |
          .PWRMDSEMIFMASK
    )
    prop PWRMDSCPUMASK :: ((.PWRM_DS_CPU == 1) ? 0x01 : 0x0)
    prop PWRMDSDMAMASK :: ((.PWRM_DS_DMA == 1) ? 0x02 : 0x0)
    prop PWRMDSCACHEMASK :: ((.PWRM_DS_CACHE == 1) ? 0x04 : 0x0)
    prop PWRMDSPERIPHMASK :: ((.PWRM_DS_PERIPH == 1) ? 0x08 : 0x0)
    prop PWRMDSCLKGENMASK :: ((.PWRM_DS_CLKGEN == 1) ? 0x10 : 0x0)
    prop PWRMDSEMIFMASK :: ((.PWRM_DS_EMIF == 1) ? 0x20 : 0x0)
    global PWRM_IER0 :: 0 {
        prop Label :: "Wakeup interrupt mask, IER0"
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
	prop JSName :: "WKUPIER0"
        prop Visible :: 1
        prop Writable :: .PWRM_ENSLEEP && .PWRM_ENABLE
        prop NoGen :: 0
        prop TabName :: "Sleep"
    }
    global PWRM_IER1 :: 0 {
        prop Label :: "Wakeup interrupt mask, IER1"
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
	prop JSName :: "WKUPIER1"
        prop Visible :: 1
        prop Writable :: .PWRM_ENSLEEP && .PWRM_ENABLE
        prop NoGen :: 0
        prop TabName :: "Sleep"
    }
    
    global PWRM_ENSLEEPUNTILRESTART :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable sleep until restart"
	prop JSName :: "SLEEPUNTILRESTART"
        prop Visible :: 1
        prop Writable :: .PWRM_ENABLE
        prop NoGen :: 1
        prop TabName :: "Sleep"
        prop Set :: ( 
                      .PWRM_ENSLEEPUNTILRESTART = $1, 
                      .PWRM_CAPSMASK = .PWRM_capsmask_update(),
                      "ok"  
                    )
    }
    
    global PWRM_ENSNOOZE :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable snooze mode"
	prop JSName :: "ENABLESNOOZE"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "Sleep"
        prop Set :: ( 
                      .PWRM_ENSNOOZE = $1, 
                      .PWRM_CAPSMASK = .PWRM_capsmask_update(),
                      "ok"  
                    )
    }
    global PWRM_WHICHTIMER :: "Timer 1" {
        prop Label :: "Timer to be used for snooze mode:"
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Timer 0,Timer 1"
	prop JSName :: "TIMERFORSNOOZE"
        prop Visible :: 1
        prop Writable :: .PWRM_ENSNOOZE
        prop NoGen :: 1
        prop TabName :: "Sleep"
        }
}
    
object PWRM_idleDomains :: IDL {
    param iComment :: "This object idles select clock domains from the BIOS IDL loop "
    param iIsUsed :: PWRM.PWRM_IDLEDOMAINS
    param cycles :: 0         
    param calibration :: 0         
    param iDelUser :: "IDL"
    param iDelMsg :: (
        "This object is used by PWRM and can't be deleted"
    )
    param function :: @_FXN_F_nop
}
type CHIPFOLDER {
    
    prop Label :: "CHIP - Global CSL Device Configuration"
    prop GlobalIcon :: 177
    prop GlobalPropertyPage :: "{B016FB95-52A5-11d4-967C-0750048381B7}"
    prop GlobalHelpTopic :: 1020
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}
type chipCfg
{
	isa ObjectMgr
	prop name :: "CHIP"
	prop Label :: "CHIP Configuration"
      prop JSName :: "CHIP"
	prop GlobalHelpTopic :: 1021
	prop InstanceHelpTopic :: 1021
	prop GlobalIcon :: 177
	prop InstanceIcon :: 178
	prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-00105A98CA0B}"
      prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-0000C070F3E9}"
    	prop Vendor :: "vendor1"
    	prop Version :: "1.00.00"
	
	prop IsContainedIn :: CHIPFOLDER
	prop cGen :: 1
    	prop cStruct :: 0
	prop cHeaderName :: (GBL.CHIPTYPE == "5509")? "csl_chip.h" : ""
	prop maxObjs :: 0
	prop NoGen :: 1
	global ADDRESS :: .address_update() {
          prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Label :: "Address Signals Used "
	    prop Visible :: 0
	    prop Writable :: 1
	    prop NoGen :: 1
	    prop cGen :: 0
      }
	prop address_update :: (
	    ((.PP_SETUP == "Full EMIF") || (.PP_SETUP == "Non-Multiplexed EHPI")) ? 0 : 1
	)
      global CHIP_CFG_ENABLE :: 0 {
            prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
            prop Visible :: 1
            prop Writable :: (GBL.CHIPTYPE == "5509")
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "Settings"
      }
      global SP2_SETUP :: "McBSP2" {
            prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
            prop Enum :: "McBSP2,MMC/SD2,Memory Stick2"
            prop Label :: "Serial Port2 Mode"
            prop JSName :: "chipXbsrSp2Mode"
            prop Visible :: 1
            prop Writable :: (chipCfg.CHIP_CFG_ENABLE) && (GBL.CHIPTYPE == "5509")
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "Settings"
            prop Set :: ( .SP2_SETUP = $1,
				  .XBSR_VALUE = .XBSR_VALUE_update(),
                          "ok"
                        )
      }
      global SP1_SETUP :: "McBSP1" {
            prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
            prop Enum :: "McBSP1,MMC/SD1,Memory Stick1"
            prop Label :: "Serial Port1 Mode"
            prop JSName :: "chipXbsrSp1Mode"
            prop Visible :: 1
            prop Writable :: (chipCfg.CHIP_CFG_ENABLE) && (GBL.CHIPTYPE == "5509")
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "Settings"
            prop Set :: ( .SP1_SETUP = $1,
				  .XBSR_VALUE = .XBSR_VALUE_update(),
                          "ok"
                        )
      }
      global PP_SETUP :: "Data EMIF" {
            prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
            prop Enum :: "Data EMIF,Full EMIF,Non-Multiplexed EHPI,Multiplexed EHPI"
            prop Label :: "Parallel Port Mode "
            prop JSName :: "chipXbsrPPMode"
            prop Visible :: 1
            prop Writable :: (chipCfg.CHIP_CFG_ENABLE) && (GBL.CHIPTYPE == "5509")
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "Settings"
            prop Set :: ( .PP_SETUP = $1,
				  .XBSR_VALUE = .XBSR_VALUE_update(),
				  .ADDRESS = .address_update(),
                          "ok"
                        )
      }
	global XBSR_VALUE :: 0  {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "External Bus Selection Register "
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
	  prop cGen :: 1
	  prop cType :: "Uint16" 
    	}
	prop XBSR_VALUE_update :: (
		.SP2_VALUE
		|.SP1_VALUE
		|.PP_VALUE
	)
	prop SP2_VALUE :: ( 
			(.SP2_SETUP == "McBSP2") ? 0x0000 : 
			(.SP2_SETUP == "MMC/SD2") ? 0x0010 : 
			0x0030
	)
	prop SP1_VALUE :: ( 
			(.SP1_SETUP == "McBSP1") ? 0x0000 : 
			(.SP1_SETUP == "MMC/SD1") ? 0x0004 : 
			0x000c
	)
	prop PP_VALUE :: ( 
			(.PP_SETUP == "Data EMIF") ? 0x0000 : 
			(.PP_SETUP == "Full EMIF") ? 0x0001 : 
			(.PP_SETUP == "Non-Multiplexed EHPI") ? 0x0002 : 
			0x0003
	)
      prop xbsrValue :: .XBSR_VALUE
	prop xbsrStr :: ((chipCfg.CHIP_CFG_ENABLE) && (GBL.CHIPTYPE == "5509")) ? "\nCHIP_RSET(XBSR, %1d);\n" : ""
      prop cGenFxnPrologue :: (
              "%5t%2S%0t\0, xbsrValue,xbsrStr"
      )
	prop chipInclStr :: ((chipCfg.CHIP_CFG_ENABLE) && (GBL.CHIPTYPE == "5509")) ? "#include <csl_chiphal.h>\n" : ""
	prop cGenCPrologue :: (
        "%1S\n\0, chipInclStr"
	)
}
type DMAFOLDER {
    
    prop Label :: "DMA - Direct Memory Access Controller"
    prop GlobalIcon :: 157
    prop GlobalPropertyPage :: "{B016FB95-52A5-11d4-967C-0750048381B7}"
    prop GlobalHelpTopic :: 1030
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}
type dmaCfg {
	isa ObjectMgr
	prop name :: "DMA"
	prop Label :: "DMA Configuration Manager"
	prop JSName :: "DMA"
	prop GlobalHelpTopic :: 1031
	prop InstanceHelpTopic :: 1031
	prop GlobalIcon :: 157
	prop InstanceIcon :: 158
	prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-00105A98CA0B}"
      prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-0000C070F3E9}"
    	prop Vendor :: "vendor1"
    	prop Version :: "1.00.00"
	
	prop IsContainedIn :: DMAFOLDER
	prop cGen :: 1
    	prop cStruct :: 1
    	prop cStructType :: "DMA_Config"
	prop cHeaderName :: ((.gNumOf > 0) || (hDMA.gDMAconfig==1)) ? "csl_dma.h" : ""
	prop NoGen :: 1
      
      
      
      
      
      
      
      
      
      
      
      
       prop PG2_MODE :: (
                           (hDMA.MODE_SETUP == "Independent index for src/dst")
       )
       prop PG1_MODE :: (
                           (hDMA.MODE_SETUP == "Same index for src/dst")
       )
       prop CEI_SUPPORT :: (  
                              (GBL.CHIPTYPE == "5509") ||
                              (GBL.CHIPTYPE == "5509PG1_0") ||
                              (GBL.CHIPTYPE == "5510") ||
                              (GBL.CHIPTYPE == "5510PG1_0") ||
                              (GBL.CHIPTYPE == "5510PG1_2") ||
                              (((GBL.CHIPTYPE == "5510PG2_0") || 
                                (GBL.CHIPTYPE == "5510PG2_1") ||
                                (GBL.CHIPTYPE == "5510PG2_2") ||
                                (GBL.CHIPTYPE == "5509PG2_0") ||
                                (GBL.CHIPTYPE == "5509A")
                               ) && (dmaCfg.PG1_MODE))
       )
       prop CFI_SUPPORT :: (  
                              (GBL.CHIPTYPE == "5509") ||
                              (GBL.CHIPTYPE == "5509PG1_0") ||
                              (GBL.CHIPTYPE == "5510") ||
                              (GBL.CHIPTYPE == "5510PG1_0") ||
                              (GBL.CHIPTYPE == "5510PG1_2") ||
                              (((GBL.CHIPTYPE == "5510PG2_0") ||
                                (GBL.CHIPTYPE == "5510PG2_1") ||
                                (GBL.CHIPTYPE == "5510PG2_2") ||
                                (GBL.CHIPTYPE == "5509PG2_0") ||
                                (GBL.CHIPTYPE == "5509A")
                               ) && (dmaCfg.PG1_MODE))
       )
       prop CSFI_SUPPORT :: (  
                              ( ( (GBL.CHIPTYPE == "5510PG2_0") ||
                                  (GBL.CHIPTYPE == "5510PG2_1") ||
                                  (GBL.CHIPTYPE == "5510PG2_2") ||
                                  (GBL.CHIPTYPE == "5509PG2_0") ||
                                  (GBL.CHIPTYPE == "5509A")
                                ) 
                                && (dmaCfg.PG2_MODE)
                              )
       )
       prop CSEI_SUPPORT :: (  
                              ( ( (GBL.CHIPTYPE == "5510PG2_0") ||
                                  (GBL.CHIPTYPE == "5510PG2_1") ||
                                  (GBL.CHIPTYPE == "5510PG2_2") ||
                                  (GBL.CHIPTYPE == "5509PG2_0") ||
                                  (GBL.CHIPTYPE == "5509A")
                                ) 
                                && (dmaCfg.PG2_MODE)
                              )
       )
       prop CDFI_SUPPORT :: (  
                              ( ( (GBL.CHIPTYPE == "5510PG2_0") ||
                                  (GBL.CHIPTYPE == "5510PG2_1") ||
                                  (GBL.CHIPTYPE == "5510PG2_2") ||
                                  (GBL.CHIPTYPE == "5509PG2_0") ||
                                  (GBL.CHIPTYPE == "5509A")
                                ) 
                                && (dmaCfg.PG2_MODE)
                              )
       )
       prop CDEI_SUPPORT :: (  
                              ( ( (GBL.CHIPTYPE == "5510PG2_0") ||
                                  (GBL.CHIPTYPE == "5510PG2_1") ||
                                  (GBL.CHIPTYPE == "5510PG2_2") ||
                                  (GBL.CHIPTYPE == "5509PG2_0") ||
                                  (GBL.CHIPTYPE == "5509A")
                                ) 
                                && (dmaCfg.PG2_MODE)
                              )
       )
      
	
      
      
	inst DATA_TYPE_SETUP :: "8-bit" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "8-bit,16-bit,32-bit"
	  prop JSName :: "dmaCsdpDataType"
        prop Label :: "DATA TYPE"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Frame"
	  prop Set ::  (	.DATA_TYPE_SETUP = $1,
				.CSDP_VALUE = .CSDP_VALUE_update(),
				"ok"
			   )
	}
	prop DATA_TYPE_CSDP :: (
		(.DATA_TYPE_SETUP == "8-bit") ? 0x0000 : 
            (.DATA_TYPE_SETUP == "16-bit") ? 0x0001 :
            0x0002
	)
      
	inst SRC_BEN_SETUP :: "Single Access (No Burst)" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Single Access (No Burst),Burst of 4"
	  prop JSName :: "dmaCsdpSrcBen"
        prop Label :: "Burst Enable (SRC BEN)"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Source"
	  prop Set ::  (	.SRC_BEN_SETUP = $1,
				.CSDP_VALUE = .CSDP_VALUE_update(),
				"ok"
			   )
	}
	prop SRC_BEN_CSDP :: (
		(.SRC_BEN_SETUP == "Single Access (No Burst)") ? 0x0000 : 0x0100
	)
      
	inst SRC_PACK_SETUP :: "No Packed Accesses" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "No Packed Accesses,Packed Accesses"
        prop Label :: "Packing (SRC PACK)"
	  prop JSName :: "dmaCsdpSrcPack"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Source"
	  prop Set ::  (	.SRC_PACK_SETUP = $1,
				.CSDP_VALUE = .CSDP_VALUE_update(),
				"ok"
			   )
	}
	prop SRC_PACK_CSDP :: (
		(.SRC_PACK_SETUP == "Packed Accesses") ? 0x0040 : 0x0000
	)
      
	inst SRC_SPACE_SETUP :: "Data Space" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Data Space,Program Space"
        prop Label :: "Source Space"
	  prop JSName :: "dmaSrcSpace"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Source"
	  prop Set ::  (	.SRC_SPACE_SETUP = $1,
                        .SRC_SPACE_ADSETUP = $1,
				"ok"
			   )
	}
	inst srcAddrFormat :: "Symbolic" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Symbolic,Numeric"
        prop Label :: "Source Address Format"
	  prop JSName :: "dmaSrcAddrFormat"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Source"
	  prop cGen :: 0
	  prop cType :: "Uint16"
	  prop Set :: (	.srcAddrFormat = $1,
                        .srcAddrFormatAd = $1,
				"ok"
			  )
    	}
	inst CSSA_HC_SETUP :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%06x"
        prop Label :: "Start Address (CSSA) - Numeric(Byte Address)"
	  prop JSName :: "dmaCssaNumeric"
        prop Visible :: 1
        prop Writable :: !(.DMA_man) && (.srcAddrFormat == "Numeric")
        prop NoGen :: 1
        prop TabName :: "Source"
	  prop Set ::  (	.CSSA_HC_SETUP = $1,
				.CSSAL_HC_VALUE = $1,
                        .CSSAU_HC_VALUE = (($1 >> 16) & 0xFFFF),
				"ok"
			   )
	}
	inst CSSA_SYM_SETUP :: "NULL" {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Start Address (CSSA) - Symbolic(Byte Address)"
	prop JSName :: "dmaCssaSymbolic"
        prop Visible :: 1
        prop Writable :: !(.DMA_man) && (.srcAddrFormat == "Symbolic")
        prop NoGen :: 1
        prop TabName :: "Source"
	  prop Set ::  (	.CSSA_SYM_SETUP = $1,
				.CSSAL_SYM_VALUE = $1,
				"ok"
			   )
	}
      
	inst SRC_AMODE_SETUP :: "Constant" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Constant,Post-incremented,Single index,Double index"
	prop JSName :: "dmaCcrSrcAmode"
        prop Label :: "Addressing Mode (SRC AMODE)"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Source"
	  prop Set ::  (	.SRC_AMODE_SETUP = $1,
				.CCR_VALUE = .CCR_VALUE_update(),
				"ok"
			   )
	}
	prop SRC_AMODE_CCR :: (
            (.SRC_AMODE_SETUP == "Constant") ? 0x0000 :
            (.SRC_AMODE_SETUP == "Post-incremented") ? 0x1000 :
            (.SRC_AMODE_SETUP == "Single index") ? 0x2000 :
            0x3000
      )
      
	inst SRC_SETUP :: "SARAM" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "SARAM,DARAM,EMIF,Peripheral Bus"
        prop Label :: "Transfer Source (SRC)"
	prop JSName :: "dmaCsdpSrc"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Source"
	  prop Set ::  (	.SRC_SETUP = $1,
				.CSDP_VALUE = .CSDP_VALUE_update(),
				"ok"
			   )
	}
	prop SRC_CSDP :: (
		(.SRC_SETUP == "SARAM") ? 0x0000 : 
            (.SRC_SETUP == "DARAM") ? 0x0004 :
		(.SRC_SETUP == "EMIF") ? 0x0008 : 
            0x000C
	)
      
	
      
	inst CSEI_SETUP :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Source Element index (CSEI) "
	  prop JSName :: "dmaCeiSrc"
        prop Visible :: 1
        prop Writable :: !(.DMA_man) && (dmaCfg.CSEI_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Source"
	  prop Set ::  (	.CSEI_SETUP = $1,
				.CSEI_VALUE = .CSEI_SETUP,
				"ok"
			   )
	}
      
	
      
	inst CSFI_SETUP :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Source Frame index (CSFI) "
	  prop JSName :: "dmaCfiSrc"
        prop Visible :: 1
        prop Writable :: !(.DMA_man) && (dmaCfg.CSFI_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Source"
	  prop Set ::  (	.CSFI_SETUP = $1,
				.CSFI_VALUE = .CSFI_SETUP,
				"ok"
			   )
	}
      
	inst DST_BEN_SETUP :: "Single Access (No Burst)" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Single Access (No Burst),Burst of 4"
        prop Label :: "Burst Enable (DST BEN)"
	prop JSName :: "dmaCsdpDstBen"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Destination"
	  prop Set ::  (	.DST_BEN_SETUP = $1,
				.CSDP_VALUE = .CSDP_VALUE_update(),
				"ok"
			   )
	}
	prop DST_BEN_CSDP :: (
		(.DST_BEN_SETUP == "Single Access (No Burst)") ? 0x0000 : 0x8000
	)
      
	inst DST_PACK_SETUP :: "No Packed Accesses" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "No Packed Accesses,Packed Accesses"
        prop Label :: "Packing (DST PACK)"
	  prop JSName :: "dmaCsdpDstPack"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Destination"
	  prop Set ::  (	.DST_PACK_SETUP = $1,
				.CSDP_VALUE = .CSDP_VALUE_update(),
				"ok"
			   )
	}
	prop DST_PACK_CSDP :: (
		(.DST_PACK_SETUP == "Packed Accesses") ? 0x2000 : 0x0000
	)
      
	inst DST_SPACE_SETUP :: "Data Space" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Data Space,Program Space"
        prop Label :: "Destination Space"
	  prop JSName :: "dmaDstSpace"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Destination"
	  prop Set ::  (	.DST_SPACE_SETUP = $1,
                        .DST_SPACE_ADSETUP = $1,
				"ok"
			   )
	}
	inst dstAddrFormat :: "Symbolic" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Symbolic,Numeric"
        prop Label :: "Destination Address Format"
	prop JSName :: "dmaDstAddrFormat"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Destination"
	  prop cGen :: 0
	  prop cType :: "Uint16"
	  prop Set :: (	.dstAddrFormat = $1,
                        .dstAddrFormatAd = $1,
				"ok"
			  )
    	}
	inst CDSA_HC_SETUP :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%06x"
        prop Label :: "Start Address (CDSA) - Numeric(Byte Address)"
	prop JSName :: "dmaCdsaNumeric"
        prop Visible :: 1
        prop Writable :: !(.DMA_man) && (.dstAddrFormat == "Numeric")
        prop NoGen :: 1
        prop TabName :: "Destination"
	  prop Set ::  (	.CDSA_HC_SETUP = $1,
				.CDSAL_HC_VALUE = $1,
                        .CDSAU_HC_VALUE = (($1 >> 16) & 0xFFFF),
				"ok"
			   )
	}
	inst CDSA_SYM_SETUP :: "NULL" {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Start Address (CDSA) - Symbolic(Byte Address)"
	  prop JSName :: "dmaCdsaSymbolic"
        prop Visible :: 1
        prop Writable :: !(.DMA_man) && (.dstAddrFormat == "Symbolic")
        prop NoGen :: 1
        prop TabName :: "Destination"
	  prop Set ::  (	.CDSA_SYM_SETUP = $1,
				.CDSAL_SYM_VALUE = $1,
				"ok"
			   )
	}
      
	inst DST_AMODE_SETUP :: "Constant" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Constant,Post-incremented,Single index,Double index"
        prop Label :: "Addressing Mode (DST AMODE)"
	prop JSName :: "dmaCcrDstAmode"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Destination"
	  prop Set ::  (	.DST_AMODE_SETUP = $1,
				.CCR_VALUE = .CCR_VALUE_update(),
				"ok"
			   )
	}
	prop DST_AMODE_CCR :: (
            (.DST_AMODE_SETUP == "Constant") ? 0x0000 :
            (.DST_AMODE_SETUP == "Post-incremented") ? 0x4000 :
            (.DST_AMODE_SETUP == "Single index") ? 0x8000 :
            0xC000
      )
      
	inst DST_SETUP :: "SARAM" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "SARAM,DARAM,EMIF,Peripheral Bus"
        prop Label :: "Transfer Destination (DST)"
	prop JSName :: "dmaCsdpDst"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Destination"
	  prop Set ::  (	.DST_SETUP = $1,
				.CSDP_VALUE = .CSDP_VALUE_update(),
				"ok"
			   )
	}
	prop DST_CSDP :: (
		(.DST_SETUP == "SARAM") ? 0x0000 : 
            (.DST_SETUP == "DARAM") ? 0x0200 :
		(.DST_SETUP == "EMIF") ? 0x0400 : 
            0x0600
	)
      
	
      
	inst CDEI_SETUP :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Destination Element index (CDEI) "
	  prop JSName :: "dmaCeiDst"
        prop Visible :: 1
        prop Writable :: (!(.DMA_man)) && (dmaCfg.CDEI_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Destination"
	  prop Set ::  (	.CDEI_SETUP = $1,
				.CDEI_VALUE = .CDEI_SETUP,
				"ok"
			   )
	}
      
	
      
	inst CDFI_SETUP :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Destination Frame index (CDFI) "
	  prop JSName :: "dmaCfiDst"
        prop Visible :: 1
        prop Writable :: (!(.DMA_man)) && (dmaCfg.CDFI_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Destination"
	  prop Set ::  (	.CDFI_SETUP = $1,
				.CDFI_VALUE = .CDFI_SETUP,
				"ok"
			   )
	}
      
	
      
      
	inst SYNC_SETUP :: "No Event" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "No Event,McBSP 0 Receive Event (REVT0),McBSP 0 Transmit Event (XEVT0),McBSP 0 Receive EventA (REVTA0),McBSP 0 Transmit EventA (XEVTA0),McBSP 1 Receive Event (REVT1),McBSP 1 Transmit Event (XEVT1),McBSP 1 Receive EventA (REVTA1),McBSP 1 Transmit EventA (XEVTA1),McBSP 2 Receive Event (REVT2),McBSP 2 Transmit Event (XEVT2),McBSP 2 Receive EventA (REVTA2),McBSP 2 Transmit EventA (XEVTA2),Timer 1 Interrupt,Timer 2 Interrupt,External Interrupt 0,External Interrupt 1,External Interrupt 2,External Interrupt 3,External Interrupt 4,External Interrupt 5"
        prop Label :: "Sync Event (SYNC)"
	  prop JSName :: "dmaCcrSync"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Control"
	  prop Set ::  (	.SYNC_SETUP = $1,
				.CCR_VALUE = .CCR_VALUE_update(),
				"ok"
			   )
	}
	prop SYNC_CCR :: (
            (.SYNC_SETUP == "No Event") ? 0x0000 :
            (.SYNC_SETUP == "McBSP 0 Receive Event (REVT0)") ? 0x0001 :
            (.SYNC_SETUP == "McBSP 0 Transmit Event (XEVT0)") ? 0x0002 :
            (.SYNC_SETUP == "McBSP 0 Receive EventA (REVTA0)") ? 0x0003 :
            (.SYNC_SETUP == "McBSP 0 Transmit EventA (XEVTA0)") ? 0x0004 :
            (.SYNC_SETUP == "McBSP 1 Receive Event (REVT1)") ? 0x0005 :
            (.SYNC_SETUP == "McBSP 1 Transmit Event (XEVT1)") ? 0x0006 :
            (.SYNC_SETUP == "McBSP 1 Receive EventA (REVTA1)") ? 0x0007 :
            (.SYNC_SETUP == "McBSP 1 Transmit EventA (XEVTA1)") ? 0x0008 :
            (.SYNC_SETUP == "McBSP 2 Receive Event (REVT2)") ? 0x0009 :
            (.SYNC_SETUP == "McBSP 2 Transmit Event (XEVT2)") ? 0x000A :
            (.SYNC_SETUP == "McBSP 2 Receive EventA (REVTA2)") ? 0x000B :
            (.SYNC_SETUP == "McBSP 2 Transmit EventA (XEVTA2)") ? 0x000C :
            (.SYNC_SETUP == "Timer 1 Interrupt") ? 0x000D :
            (.SYNC_SETUP == "Timer 2 Interrupt") ? 0x000E :
            (.SYNC_SETUP == "External Interrupt 0") ? 0x000F :
            (.SYNC_SETUP == "External Interrupt 1") ? 0x0010 :
            (.SYNC_SETUP == "External Interrupt 2") ? 0x0011 :
            (.SYNC_SETUP == "External Interrupt 3") ? 0x0012 :
            (.SYNC_SETUP == "External Interrupt 4") ? 0x0013 :
            0x0014
      )            
      
	inst REPEAT_SETUP :: "Only if END PROG = 1"{
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Only if END PROG = 1,Unconditionally"
        prop Label :: "Repetitive Operations (REPEAT)"
	prop JSName :: "dmaCcrRepeat"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Control"
	  prop Set ::  (	.REPEAT_SETUP = $1,
				.CCR_VALUE = .CCR_VALUE_update(),
				"ok"
			   )
	}
	prop REPEAT_CCR :: (
            (.REPEAT_SETUP == "Unconditionally") ? 0x0200 : 0x0000
      )
      
	inst END_PROG_SETUP :: "Delay re-initialization" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Delay re-initialization,Allow re-initialization"
        prop Label :: "End of Programmation (END PROG)"
	prop JSName :: "dmaCcrEndProg"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Control"
	  prop Set ::  (	.END_PROG_SETUP = $1,
				.CCR_VALUE = .CCR_VALUE_update(),
				"ok"
			   )
	}
	prop END_PROG_CCR :: (
            (.END_PROG_SETUP == "Allow re-initialization") ? 0x0800 : 0x0000
      )
      
	inst FS_SETUP :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Enabled"
        prop Label :: "Frame Synchronization (FS)"
	  prop JSName :: "dmaCcrFs"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Control"
	  prop Set ::  (	.FS_SETUP = $1,
				.CCR_VALUE = .CCR_VALUE_update(),
				"ok"
			   )
	}
	prop FS_CCR :: (
            (.FS_SETUP == "Enabled") ? 0x0020 : 0x0000
      )
      
	inst PRIO_SETUP :: "Low" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Low,High"
        prop Label :: "Channel Priority (PRIO)"
	prop JSName :: "dmaCcrPrio"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Control"
	  prop Set ::  (	.PRIO_SETUP = $1,
				.CCR_VALUE = .CCR_VALUE_update(),
				"ok"
			   )
	}
	prop PRIO_CCR :: (
            (.PRIO_SETUP == "High") ? 0x0040 : 0x0000
      )
      
	inst EN_SETUP :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Enabled"
        prop Label :: "Channel Enable (EN)"
	prop JSName :: "dmaCcrEn"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Control"
	  prop Set ::  (	.EN_SETUP = $1,
				.CCR_VALUE = .CCR_VALUE_update(),
				"ok"
			   )
	}
	prop EN_CCR :: (
            (.EN_SETUP == "Enabled") ? 0x0080 : 0x0000
      )
      
	inst AUTO_INIT_SETUP :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Enabled"
        prop Label :: "Auto-initialization (AUTO INIT)"
	prop JSName :: "dmaCcrAutoinit"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Control"
	  prop Set ::  (	.AUTO_INIT_SETUP = $1,
				.CCR_VALUE = .CCR_VALUE_update(),
				"ok"
			   )
	}
	prop AUTO_INIT_CCR :: (
            (.AUTO_INIT_SETUP == "Enabled") ? 0x0100 : 0x0000
      )
      
      
      
	
      
      
	inst TIMEOUT_IE_SETUP :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Enabled"
        prop Label :: "Timeout (TIMEOUT IE)"
	prop JSName :: "dmaCicrTimeoutIe"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Interrupts"
	  prop Set ::  (	.TIMEOUT_IE_SETUP = $1,
				.CICR_VALUE = .CICR_VALUE_update(),
				"ok"
			   )
	}
	prop TIMEOUT_IE_CICR :: (
            (.TIMEOUT_IE_SETUP == "Enabled") ? 0x0001 : 0x0000
      )
      
	inst DROP_IE_SETUP :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Enabled"
        prop Label :: "Synchronization event drop (DROP IE)"
	prop JSName :: "dmaCicrDropIe"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Interrupts"
	  prop Set ::  (	.DROP_IE_SETUP = $1,
				.CICR_VALUE = .CICR_VALUE_update(),
				"ok"
			   )
	}
	prop DROP_IE_CICR :: (
            (.DROP_IE_SETUP == "Enabled") ? 0x0002 : 0x0000
      )
      
	inst HALF_IE_SETUP :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Enabled"
        prop Label :: "Half frame (HALF IE)"
	prop JSName :: "dmaCicrHalfIe"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Interrupts"
	  prop Set ::  (	.HALF_IE_SETUP = $1,
				.CICR_VALUE = .CICR_VALUE_update(),
				"ok"
			   )
	}
	prop HALF_IE_CICR :: (
            (.HALF_IE_SETUP == "Enabled") ? 0x0004 : 0x0000
      )
      
	inst FRAME_IE_SETUP :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Enabled"
        prop Label :: "Frame complete (FRAME IE)"
	prop JSName :: "dmaCicrFrameIe"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Interrupts"
	  prop Set ::  (	.FRAME_IE_SETUP = $1,
				.CICR_VALUE = .CICR_VALUE_update(),
				"ok"
			   )
	}
	prop FRAME_IE_CICR :: (
            (.FRAME_IE_SETUP == "Enabled") ? 0x0008 : 0x0000
      )
      
	inst LAST_IE_SETUP :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Enabled"
        prop Label :: "Last frame (LAST IE)"
	prop JSName :: "dmaCicrLastIe"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Interrupts"
	  prop Set ::  (	.LAST_IE_SETUP = $1,
				.CICR_VALUE = .CICR_VALUE_update(),
				"ok"
			   )
	}
	prop LAST_IE_CICR :: (
            (.LAST_IE_SETUP == "Enabled") ? 0x0010 : 0x0000
      )
      
	inst BLOCK_IE_SETUP :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Enabled"
        prop Label :: "End block (BLOCK IE)"
	prop JSName :: "dmaCicrBlockIe"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Interrupts"
	  prop Set ::  (	.BLOCK_IE_SETUP = $1,
				.CICR_VALUE = .CICR_VALUE_update(),
				"ok"
			   )
	}
	prop BLOCK_IE_CICR :: (
            (.BLOCK_IE_SETUP == "Enabled") ? 0x0020 : 0x0000
      )
      
	
      
      
	
      
      
	
      
	inst CEN_SETUP :: 1 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Number of Elements (CEN)"
	prop JSName :: "dmaCen"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Frame"
	  prop Set ::  (	if (($1 > 0) && ($1 < 65536)) {
                            .CEN_SETUP = $1,
				    .CEN_VALUE = .CEN_SETUP,
				    "ok"
                        }
                        else {
                            .error("Entered value exceeds limits")
                        }
			   )
	}
      
	
      
	inst CFN_SETUP :: 1 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Number of Frames (CFN)"
	prop JSName :: "dmaCfn"
        prop Visible :: 1
        prop Writable :: !(.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Frame"
	  prop Set ::  (	if (($1 > 0) && ($1 < 65536)) {
                            .CFN_SETUP = $1,
				    .CFN_VALUE = .CFN_SETUP,
				    "ok"
                        }
                        else {
                            .error("Entered value exceeds limits")
                        }
			   )
	}
      
	
      
	inst CFI_SETUP :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Frame index (CFI) "
	prop JSName :: "dmaCfi"
        prop Visible :: 1
        prop Writable :: (!(.DMA_man)) && (dmaCfg.CFI_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Frame"
	  prop Set ::  (	.CFI_SETUP = $1,
				.CFI_VALUE = .CFI_SETUP,
				"ok"
			   )
	}
      
	
      
	inst CEI_SETUP :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Element index (CEI) "
	  prop JSName :: "dmaCei"
        prop Visible :: 1
        prop Writable :: (!(.DMA_man)) && (dmaCfg.CEI_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Frame"
	  prop Set ::  (	.CEI_SETUP = $1,
				.CEI_VALUE = .CEI_SETUP,
				"ok"
			   )
	}
      
	inst DMA_man :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Set Manually"
	  prop JSName :: "dmaSetManually"
	  prop Visible :: 1
	  prop Writable :: 1
	  prop NoGen :: 1
	  prop TabName :: "Advanced"
      }
      
      
      
      
	inst CSDP_VALUE :: .CSDP_VALUE_update() {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Source Destination Register (CSDP)"
	prop JSName :: "dmaCsdp"
        prop Visible :: 1
        prop Writable :: .DMA_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set :: (	.CSDP_VALUE = $1,
				.CSDP_SETUP_update($1),
				"ok"
			  )
    	}
      
	inst CCR_VALUE :: .CCR_VALUE_update() {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Control Register (CCR)"
	prop JSName :: "dmaCcr"
        prop Visible :: 1
        prop Writable :: .DMA_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set :: (	.CCR_VALUE = $1,
				.CCR_SETUP_update($1),
				"ok"
			  )
    	}
      
	inst CICR_VALUE :: .CICR_VALUE_update() {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Interrupt Control Register (CICR)"
	prop JSName :: "dmaCicr"
        prop Visible :: 1
        prop Writable :: .DMA_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set :: (	.CICR_VALUE = $1,
				.CICR_SETUP_update($1),
				"ok"
			  )
    	}
      
	inst SRC_SPACE_ADSETUP :: "Data Space" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Data Space,Program Space"
        prop Label :: "Source Space"
	prop JSName :: "dmaSrcSpaceAdv"
        prop Visible :: 1
        prop Writable :: (.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop Set ::  (	.SRC_SPACE_ADSETUP = $1,
                        .SRC_SPACE_SETUP = $1,
				"ok"
			   )
	}
	inst srcAddrFormatAd :: "Symbolic" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Symbolic,Numeric"
        prop Label :: "Source Address Format"
	  prop JSName :: "dmaSrcAddrFormatAdv"
        prop Visible :: 1
        prop Writable :: .DMA_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: 0
	  prop cType :: "Uint16"
	  prop Set :: (	.srcAddrFormatAd = $1,
                        .srcAddrFormat = $1,
				"ok"
			  )
    	}
      
	inst CSSAL_HC_VALUE :: .CSSAL_HC_SETUP {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Lower Source Address (CSSA_L)- Numeric(Byte Address)"
	  prop JSName :: "dmaCssalNumeric"
        prop Visible :: 1
        prop Writable :: (.DMA_man) && (.srcAddrFormatAd == "Numeric")
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: (.srcAddrFormat == "Numeric")
	  prop cType :: "Uint16"
        prop cPreVal :: "(DMA_AdrPtr)"
	  prop Set :: (	.CSSAL_HC_VALUE = $1,
				.CSSAL_HC_SETUP_update($1),
				"ok"
			  )
    	}
	inst CSSAL_SYM_VALUE :: .CSSA_SYM_SETUP {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Lower Source Address (CSSA_L) - Symbolic(Byte Address)"
	  prop JSName :: "dmaCssalSymbolic"
        prop Visible :: 1
        prop Writable :: (.DMA_man) && (.srcAddrFormatAd == "Symbolic")
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: (.srcAddrFormat == "Symbolic")
	  prop cType :: "char[]"
        prop cPreVal :: (.CSSAL_SYM_VALUE != "NULL") ? "(DMA_AdrPtr)&" : ""
	  prop Set :: (	.CSSAL_SYM_VALUE = $1,
				.CSSA_SYM_SETUP = $1,
				"ok"
			  )
    	}
      
	inst CSSAU_HC_VALUE :: .CSSAU_HC_SETUP {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Upper Source Address (CSSA_U) - Numeric(Byte Address)"
	  prop JSName :: "dmaCssauNumeric"
        prop Visible :: 1
        prop Writable :: (.DMA_man) && (.srcAddrFormatAd == "Numeric")
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: (.srcAddrFormat == "Numeric")
	  prop cType :: "Uint16"
	  prop Set :: (	.CSSAU_HC_VALUE = $1,
				.CSSAU_HC_SETUP_update($1),
				"ok"
			  )
    	}
	inst CSSAU_SYM_VALUE :: .CSSA_SYM_SETUP {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Upper Source Address (CSSA_U) - Symbolic(Byte Address)"
	  prop JSName :: "dmaCssauSymbolic"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: (.srcAddrFormat == "Symbolic")
	  prop cType :: "char[]"
        prop cPreVal :: (.CSSAU_SYM_VALUE != "NULL") ? "(Uint16)&" : ""
	  prop Set :: (	.CSSAU_SYM_VALUE = $1,
                        .CSSA_SYM_SETUP = $1,
				"ok"
			  )
    	}
      
	inst DST_SPACE_ADSETUP :: "Data Space" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Data Space,Program Space"
        prop Label :: "Destination Space"
	  prop JSName :: "dmaDstSpaceAdv"
        prop Visible :: 1
        prop Writable :: (.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop Set ::  (	.DST_SPACE_ADSETUP = $1,
                        .DST_SPACE_SETUP = $1,
				"ok"
			   )
	}
	inst dstAddrFormatAd :: "Symbolic" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Symbolic,Numeric"
        prop Label :: "Destination Address Format"
	  prop JSName :: "dmaDstAddrFormatAdv"
        prop Visible :: 1
        prop Writable :: (.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: 0
	  prop cType :: "Uint16"
	  prop Set :: (	.dstAddrFormatAd = $1,
                        .dstAddrFormat = $1,
				"ok"
			  )
    	}
      
	inst CDSAL_HC_VALUE :: .CDSAL_HC_SETUP {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Lower Destination Address (CDSA_L)- Numeric(Byte Address)"
	prop JSName :: "dmaCdsalNumeric"
        prop Visible :: 1
        prop Writable :: (.DMA_man) && (.dstAddrFormatAd == "Numeric")
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: (.dstAddrFormat == "Numeric")
	  prop cType :: "Uint16"
        prop cPreVal :: "(DMA_AdrPtr)"
	  prop Set :: (	.CDSAL_HC_VALUE = $1,
				.CDSAL_HC_SETUP_update($1),
				"ok"
			  )
    	}
	inst CDSAL_SYM_VALUE :: .CDSA_SYM_SETUP {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Lower Destination Address (CDSA_L) - Symbolic(Byte Address)"
	  prop JSName :: "dmaCdsalSymbolic"
        prop Visible :: 1
        prop Writable :: (.DMA_man) && (.dstAddrFormatAd == "Symbolic")
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: (.dstAddrFormat == "Symbolic")
	  prop cType :: "char[]"
        prop cPreVal :: (.CDSAL_SYM_VALUE != "NULL") ? "(DMA_AdrPtr)&" : ""
	  prop Set :: (	.CDSAL_SYM_VALUE = $1,
				.CDSA_SYM_SETUP = $1,
				"ok"
			  )
    	}
      
	inst CDSAU_HC_VALUE :: .CDSAU_HC_SETUP {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Upper Destination Address (CDSA_U) - Numeric(Byte Address)"
	prop JSName :: "dmaCdsauNumeric"
        prop Visible :: 1
        prop Writable :: (.DMA_man) && (.dstAddrFormatAd == "Numeric")
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: (.dstAddrFormat == "Numeric")
	  prop cType :: "Uint16"
	  prop Set :: (	.CDSAU_HC_VALUE = $1,
				.CDSAU_HC_SETUP_update($1),
				"ok"
			  )
    	}
	inst CDSAU_SYM_VALUE :: .CDSA_SYM_SETUP {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Upper Destination Address (CDSA_U) - Symbolic(Byte Address)"
	prop JSName :: "dmaCdsauSymbolic"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: (.dstAddrFormat == "Symbolic")
	  prop cType :: "char[]"
        prop cPreVal :: (.CDSAU_SYM_VALUE != "NULL") ? "(Uint16)&" : ""
	  prop Set :: (	.CDSAU_SYM_VALUE = $1,
				.CDSA_SYM_SETUP = $1,
				"ok"
			  )
    	}
      
	inst CEN_VALUE :: .CEN_SETUP {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Element Number (CEN)"
	  prop JSName :: "dmaCenAdv"
        prop Visible :: 1
        prop Writable :: .DMA_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set ::  (	if (($1 > 0) && ($1 < 65536)) {
                            .CEN_VALUE = $1,
				    .CEN_SETUP = $1,
				    "ok"
                        }
                        else {
                            .error("Entered value exceeds limits")
                        }
		   )
    	}
      
	inst CFN_VALUE :: .CFN_SETUP {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Frame Number (CFN)"
	  prop JSName :: "dmaCfnAdv"
        prop Visible :: 1
        prop Writable :: .DMA_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set ::  (	if (($1 > 0) && ($1 < 65536)) {
                            .CFN_VALUE = $1,
				    .CFN_SETUP = $1,
				    "ok"
                        }
                        else {
                            .error("Entered value exceeds limits")
                        }
		   )
    	}
      
	inst CFI_VALUE :: .CFI_SETUP {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Frame Index (CFI)"
	  prop JSName :: "dmaCfiAdv"
        prop Visible :: 1
        prop Writable :: .DMA_man && (dmaCfg.CFI_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: (dmaCfg.CFI_SUPPORT)
	  prop cType :: "Uint16"
	  prop Set :: (	.CFI_VALUE = $1,
				.CFI_SETUP = $1,
				"ok"
			  )
    	}
      
	inst CSFI_VALUE :: .CSFI_SETUP {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Source Frame Index (CSFI)"
	  prop JSName :: "dmaCfiSrcAdv"
        prop Visible :: 1
        prop Writable :: .DMA_man && (dmaCfg.CSFI_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: (dmaCfg.CSFI_SUPPORT)
	  prop cType :: "Uint16"
	  prop Set :: (	.CSFI_VALUE = $1,
				.CSFI_SETUP = $1,
				"ok"
			  )
    	}
      
	inst CEI_VALUE :: .CEI_SETUP {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Element Index (CEI)"
	  prop JSName :: "dmaCeiAdv"
        prop Visible :: 1
        prop Writable :: .DMA_man && (dmaCfg.CEI_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: (dmaCfg.CEI_SUPPORT)
	  prop cType :: "Uint16"
	  prop Set :: (	.CEI_VALUE = $1,
				.CEI_SETUP = $1,
				"ok"
			  )
    	}
      
	inst CSEI_VALUE :: .CSEI_SETUP {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Source Element Index (CSEI)"
	  prop JSName :: "dmaCeiSrcAdv"
        prop Visible :: 1
        prop Writable :: .DMA_man && (dmaCfg.CSEI_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: (dmaCfg.CSEI_SUPPORT)
	  prop cType :: "Uint16"
	  prop Set :: (	.CSEI_VALUE = $1,
				.CSEI_SETUP = $1,
				"ok"
			  )
    	}
        
      
	inst CDFI_VALUE :: .CDFI_SETUP {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Destination Frame Index (CDFI)"
	  prop JSName :: "dmaCfiDstAdv"
        prop Visible :: 1
        prop Writable :: .DMA_man && (dmaCfg.CDFI_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: (dmaCfg.CDFI_SUPPORT)
	  prop cType :: "Uint16"
	  prop Set :: (	.CDFI_VALUE = $1,
				.CDFI_SETUP = $1,
				"ok"
			  )
    	}
      
	inst CDEI_VALUE :: .CDEI_SETUP {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Destination Element Index (CDEI)"
	  prop JSName :: "dmaCeiDstAdv"
        prop Visible :: 1
        prop Writable :: .DMA_man && (dmaCfg.CDEI_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: (dmaCfg.CDEI_SUPPORT)
	  prop cType :: "Uint16"
	  prop Set :: (	.CDEI_VALUE = $1,
				.CDEI_SETUP = $1,
				"ok"
			  )
    	}
      
      
      
      
	prop CSDP_VALUE_update :: (
		   .DATA_TYPE_CSDP()
		|  .SRC_CSDP()
		|  .SRC_PACK_CSDP()
		|  .SRC_BEN_CSDP()
		|  .DST_CSDP()
		|  .DST_PACK_CSDP()
		|  .DST_BEN_CSDP()
	)
      
	prop CCR_VALUE_update :: (
		   .SYNC_CCR()
		|  .FS_CCR()
		|  .PRIO_CCR()
		|  .EN_CCR()
		|  .AUTO_INIT_CCR()
		|  .REPEAT_CCR()
		|  .END_PROG_CCR()
		|  .SRC_AMODE_CCR()
		|  .DST_AMODE_CCR()
	)
      
	prop CICR_VALUE_update :: (
		   .TIMEOUT_IE_CICR()
		|  .DROP_IE_CICR()
		|  .HALF_IE_CICR()
		|  .FRAME_IE_CICR()
		|  .LAST_IE_CICR()
		|  .BLOCK_IE_CICR()
	)
      
	prop CEN_VALUE_update :: (
		.CEN_SETUP
	)
      
	prop CFN_VALUE_update :: (
		.CFN_SETUP
	)
      
	prop CFI_VALUE_update :: (
		.CFI_SETUP
	)
      
	prop CEI_VALUE_update :: (
		.CEI_SETUP
	)
      
      
      
      
	prop CSDP_SETUP_update :: (
		.DATA_TYPE_SETUP = ($a = $1 & 0x0003,
                               ($a == 0x0002) ? "32-bit" :
                               ($a == 0x0001) ? "16-bit" :
                               "8-bit"),
		.SRC_SETUP = ($a = $1 & 0x000C,
                         ($a == 0x000C) ? "Peripheral Bus" :
                         ($a == 0x0008) ? "EMIF" :
                         ($a == 0x0004) ? "DARAM" :
                         "SARAM"),
		.SRC_PACK_SETUP = ($1 & 0x0040) ? "Packed Accesses" : "No Packed Accesses",
		.SRC_BEN_SETUP = ($a = $1 & 0x0180,
                             ($a == 0x0100) ? "Burst of 4" :
                             "Single Access (No Burst)"),
		.DST_SETUP = ($a = $1 & 0x0600,
                         ($a == 0x0600) ? "Peripheral Bus" :
                         ($a == 0x0400) ? "EMIF" :
                         ($a == 0x0200) ? "DARAM" :
                         "SARAM"),
		.DST_PACK_SETUP = ($1 & 0x2000) ? "Packed Accesses" : "No Packed Accesses",
		.DST_BEN_SETUP = ($a = $1 & 0xC000,
                             ($1 & 0x8000) ? "Burst of 4" :
                             "Single Access (No Burst)")
	)
      
	prop CCR_SETUP_update :: (
            .SYNC_SETUP = ($a = $1 & 0x001F,
                          ($a == 0x0001) ? "McBSP 0 Receive Event (REVT0)" :
                          ($a == 0x0002) ? "McBSP 0 Transmit Event (XEVT0)" :
                          ($a == 0x0003) ? "McBSP 0 Receive EventA (REVTA0)" :
                          ($a == 0x0004) ? "McBSP 0 Transmit EventA (XEVTA0)" :
                          ($a == 0x0005) ? "McBSP 1 Receive Event (REVT1)" :
                          ($a == 0x0006) ? "McBSP 1 Transmit Event (XEVT1)" :
                          ($a == 0x0007) ? "McBSP 1 Receive EventA (REVTA1)" :
                          ($a == 0x0008) ? "McBSP 1 Transmit EventA (XEVTA1)" :
                          ($a == 0x0009) ? "McBSP 2 Receive Event (REVT2)" :
                          ($a == 0x000A) ? "McBSP 2 Transmit Event (XEVT2)" :
                          ($a == 0x000B) ? "McBSP 2 Receive EventA (REVTA2)" :
                          ($a == 0x000C) ? "McBSP 2 Transmit EventA (XEVTA2)" :
                          ($a == 0x000D) ? "Timer 1 Interrupt" :
                          ($a == 0x000E) ? "Timer 2 Interrupt" :
                          ($a == 0x000F) ? "External Interrupt 0" :
                          ($a == 0x0010) ? "External Interrupt 1" :
                          ($a == 0x0011) ? "External Interrupt 2" :
                          ($a == 0x0012) ? "External Interrupt 3" :
                          ($a == 0x0013) ? "External Interrupt 4" :
                          ($a == 0x0014) ? "External Interrupt 5" :
                          "No Event"),
		.FS_SETUP = ($1 & 0x0020) ? "Enabled" : "Disabled",
		.PRIO_SETUP = ($1 & 0x0040) ? "High" : "Low",
            .EN_SETUP = ($1 & 0x0080) ? "Enabled" : "Disabled",
            .AUTO_INIT_SETUP = ($1 & 0x0100) ? "Enabled" : "Disabled",
            .REPEAT_SETUP = ($1 & 0x0200) ? "Unconditionally" : "Only if END PROG = 1",
            .END_PROG_SETUP = ($1 & 0x0800) ? "Allow re-initialization" : "Delay re-initialization",
		.SRC_AMODE_SETUP = ($a = $1 & 0x3000,
                               ($a == 0x1000) ? "Post-incremented" :
                               ($a == 0x2000) ? "Single index" :
                               ($a == 0x3000) ? "Double index" :
                               "Constant"),
		.DST_AMODE_SETUP = ($a = $1 & 0x0C000,
                               ($a == 0x4000) ? "Post-incremented" :
                               ($a == 0x8000) ? "Single index" :
                               ($a == 0xC000) ? "Double index" :
                               "Constant")
	)
      
	prop CICR_SETUP_update :: (
		.TIMEOUT_IE_SETUP = ($1 & 0x0001) ? "Enabled" : "Disabled",
		.DROP_IE_SETUP = ($1 & 0x0002) ? "Enabled" : "Disabled",
		.HALF_IE_SETUP = ($1 & 0x0004) ? "Enabled" : "Disabled",
		.FRAME_IE_SETUP = ($1 & 0x0008) ? "Enabled" : "Disabled",
		.LAST_IE_SETUP = ($1 & 0x0010) ? "Enabled" : "Disabled",
		.BLOCK_IE_SETUP = ($1 & 0x0020) ? "Enabled" : "Disabled"
      )
      
	prop CSSAL_HC_SETUP_update :: (
                .CSSA_HC_SETUP &= 0x00000000,
                .CSSA_HC_SETUP |= $1
      )
	prop CSSAU_HC_SETUP_update :: (
                .CSSA_HC_SETUP &= 0x0000FFFF,
                .CSSA_HC_SETUP |= $1 << 16
      )
      
	prop CDSAL_HC_SETUP_update :: (
                .CDSA_HC_SETUP &= 0x00000000,
                .CDSA_HC_SETUP |= $1
      )
	prop CDSAU_HC_SETUP_update :: (
                .CDSA_HC_SETUP &= 0x0000FFFF,
                .CDSA_HC_SETUP |= $1 << 16
      )
      
	prop CEN_SETUP_update :: (
            .CEN_SETUP = $1
      )
      
	prop CFN_SETUP_update :: (
            .CFN_SETUP = $1
      )
      
	prop CFI_SETUP_update :: (
            .CFI_SETUP = $1
      )
      
	prop CEI_SETUP_update :: (
            .CEI_SETUP = $1
      )
    prop srcSym :: ((.srcAddrFormat == "Symbolic") && (.CSSAL_SYM_VALUE != "NULL")) ? .CSSAL_SYM_VALUE : ""
    prop dstSym :: ((.dstAddrFormat == "Symbolic") && (.CDSAL_SYM_VALUE != "NULL")) ? .CDSAL_SYM_VALUE : ""
    prop externStr :: (((.dstAddrFormat == "Symbolic") && (.CDSAL_SYM_VALUE != "NULL")) || ((.srcAddrFormat == "Symbolic") && (.CSSAL_SYM_VALUE != "NULL"))) ? "extern Uint16 " : ""
    prop srcStr :: ((.srcAddrFormat == "Symbolic") && (.CSSAL_SYM_VALUE != "NULL")) ? "%5s" : ""
    prop comma :: ((.dstAddrFormat == "Symbolic") && (.CDSAL_SYM_VALUE != "NULL") && (.srcAddrFormat == "Symbolic") && (.CSSAL_SYM_VALUE != "NULL") && (.CDSAL_SYM_VALUE != .CSSAL_SYM_VALUE)) ? ", " : ""
    prop dstStr :: ((.dstAddrFormat == "Symbolic") && (.CDSAL_SYM_VALUE != "NULL") && (.CDSAL_SYM_VALUE != .CSSAL_SYM_VALUE)) ? "%6s" : ""
    prop termStr :: (((.dstAddrFormat == "Symbolic") && (.CDSAL_SYM_VALUE != "NULL")) || ((.srcAddrFormat == "Symbolic") && (.CSSAL_SYM_VALUE != "NULL"))) ? ";\n" : ""
    prop cGenCInst :: (
        "%1S%2S%3S%4S%7S\n\0, externStr,srcStr,comma,dstStr,srcSym,dstSym,termStr"
    )
    prop cssalSymbol :: .CSSAL_SYM_VALUE
    prop cssauSymbol :: .CSSA_SYM_SETUP
    prop cdsalSymbol :: .CDSAL_SYM_VALUE
    prop cdsauSymbol :: .CDSA_SYM_SETUP
    prop configStruct :: self
    prop pdmcssalShift :: ((.srcAddrFormat == "Symbolic") && (.SRC_SPACE_SETUP == "Program Space") && (.CSSAL_SYM_VALUE != "NULL")) ? "%5t%9s.dmacssal = (DMA_AdrPtr)((Uint32)(&%10s) & 0xFFFF);\n%0t" : ""
    prop ddmcssalShift :: ((.srcAddrFormat == "Symbolic") && (.SRC_SPACE_SETUP == "Data Space") && (.CSSAL_SYM_VALUE != "NULL")) ? "%5t%9s.dmacssal = (DMA_AdrPtr)(((Uint32)(&%10s) << 1) & 0xFFFF);\n%0t" : ""
    prop pdmcssauShift :: ((.srcAddrFormat == "Symbolic") && (.SRC_SPACE_SETUP == "Program Space") && (.CSSA_SYM_SETUP != "NULL")) ? "%5t%9s.dmacssau = (Uint16)((Uint32)(&%11s) >> 16);\n%0t" : ""
    prop ddmcssauShift :: ((.srcAddrFormat == "Symbolic") && (.SRC_SPACE_SETUP == "Data Space") && (.CSSA_SYM_SETUP != "NULL")) ? "%5t%9s.dmacssau = (Uint16)((Uint32)(&%11s) >> 15);\n%0t" : ""
    prop pdmcdsalShift :: ((.dstAddrFormat == "Symbolic") && (.DST_SPACE_SETUP == "Program Space") && (.CDSAL_SYM_VALUE != "NULL")) ? "%5t%9s.dmacdsal = (DMA_AdrPtr)((Uint32)(&%12s) & 0xFFFF);\n%0t" : ""
    prop ddmcdsalShift :: ((.dstAddrFormat == "Symbolic") && (.DST_SPACE_SETUP == "Data Space") && (.CDSAL_SYM_VALUE != "NULL")) ? "%5t%9s.dmacdsal = (DMA_AdrPtr)(((Uint32)(&%13s) << 1) & 0xFFFF);\n%0t" : ""
    prop pdmcdsauShift :: ((.dstAddrFormat == "Symbolic") && (.DST_SPACE_SETUP == "Program Space") && (.CDSA_SYM_SETUP != "NULL")) ? "%5t%9s.dmacdsau = (Uint16)((Uint32)(&%13s) >> 16);\n%0t" : ""
    prop ddmcdsauShift :: ((.dstAddrFormat == "Symbolic") && (.DST_SPACE_SETUP == "Data Space") && (.CDSA_SYM_SETUP != "NULL")) ? "%5t%9s.dmacdsau = (Uint16)((Uint32)(&%13s) >> 15);\n%0t" : ""
    prop cGenFxnPreInst :: (
        "%1S%2S%3S%4S%5S%6S%7S%8S\0, pdmcssalShift,ddmcssalShift,pdmcssauShift,ddmcssauShift,pdmcdsalShift,ddmcdsalShift,pdmcdsauShift,ddmcdsauShift,configStruct,cssalSymbol,cssauSymbol,cdsalSymbol,cdsauSymbol"
    )
}
type hDMA {
	isa ObjectMgr
	prop name :: "hDMA"
	prop Label :: "DMA Resource Manager"
	prop JSName :: "HDMA"
	prop GlobalHelpTopic :: 1032
	prop InstanceHelpTopic :: 1033
	prop GlobalIcon :: 157
	prop InstanceIcon :: 158
	prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-00105A98CA0B}"
      prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-0000C070F3E9}"
    	prop Vendor :: "vendor1"
    	prop Version :: "1.00.00"
	prop IsContainedIn :: DMAFOLDER
	
	prop maxObjs :: (
		(GBL.CHIPTYPE == "5510") ? 6 :
		6
	)
	prop NoGen :: 1
	prop cGen :: 1
	prop cHandle :: .cOpenGen
	prop cHeaderName :: .c55dma == 1 ? "csl_dma.h" : ""
	prop cHandleType :: "DMA_Handle"
	prop cOpenName :: "DMA_open"
	prop cConfigName :: "DMA_config"
	prop cHandleName :: .handleName
	global c55dma :: 0 {
          prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Label :: "C55x DMA opened "
	    prop Visible :: 0
	    prop Writable :: 1
	    prop NoGen :: 1
	    prop cGen :: 0
      }
	inst cOpenGen :: 0 {
	    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Label :: "Open Handle to DMA "
	    prop JSName :: "dmaHandleEnable"
	    prop Visible :: 1
	    prop Writable :: 1
	    prop NoGen :: 1
	    prop cGen :: 1
          prop Set :: (
               .cOpenGen = $1,
               if ($1 == 1) {
                   .c55dma = 1
               }
               else {
                   .c55dma = 0
               },
               "ok"
          )
	}
	inst cOpenArg0 :: "DMA_CHA0" {
	     prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	     prop Label :: "Open Arg 0"
	     prop Visible :: 0
	     prop Writable :: 1
	     prop NoGen :: 1
	}
	inst cOpenArg1 :: "DMA_OPEN_RESET" {
	     prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	     prop Label :: "Open Arg 1"
	     prop Visible :: 0
	     prop Writable :: 0
	     prop NoGen :: 1
	}
    	inst handleName :: self {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Specify Handle Name "
	  prop JSName :: "dmaHandleName"
	  prop Visible :: 1
	  prop Writable :: (.cOpenGen)
	  prop NoGen :: 1
	  prop Set :: (
             .handleName = $1,
             .cConfigArg0 = $1,
             "ok"
        )
    	}
    	inst PINIT_ENABLE :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Enable pre-initialization "
	  prop JSName :: "dmaEnablePreInit"
	  prop Visible :: 1
	  prop Writable :: .cOpenGen
	  prop NoGen :: 1
	  prop Set :: (
		$a = 0,
		scan ($b; dmaCfg) {
			$a = 1
		},
		if ($a == 0) {
			"You must create a configuration object"
		}
		else {
			.PINIT_ENABLE = $1,
			"ok"
		}
	  )
    	}
	inst cConfigGen ::= ((.cOpenGen == 1) && (.PINIT_ENABLE == 1) && (.cConfigArg1 != DMA_NOTHING)) {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
      }
	inst cConfigArg0 :: .handleName {
            prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
            prop Label :: "Config argument 0"
            prop Visible :: 0
        }
	
     	inst cConfigArg1 :: DMA_NOTHING {
	  prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	  prop MemberType :: dmaCfg
	  prop Label :: "Pre-initialize "
	  prop JSName :: "dmaPreInit"
	  prop Visible :: 1
	  prop Writable :: (.PINIT_ENABLE == 1) && (.cOpenGen)
	  prop NoGen :: 0
	  prop cPreVal :: "&"
        prop Set :: (
              .cConfigArg1 = $1,
              "ok"
        )
    	}
      
      
	
      
      prop DMA_GSCR_SUPPORT :: (
                                  (GBL.CHIPTYPE == "5510PG2_0") ||
                                  (GBL.CHIPTYPE == "5510PG2_1") ||
                                  (GBL.CHIPTYPE == "5510PG2_2") ||
                                  (GBL.CHIPTYPE == "5509PG2_0")
      )
	global MODE_SETUP :: "Same index for src/dst" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Same index for src/dst,Independent index for src/dst"
        prop Label :: "PG1.0 Compatibility Mode Select "
	  prop JSName :: "dmaModeSelect"
        prop Visible :: 1
        prop Writable :: (hDMA.DMA_GSCR_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Global"
	  prop Set ::  (	.MODE_SETUP = $1,
                        if ($1 == "Independent index for src/dst")
                        {
                            .GSCR_VALUE = 0x0001
                        }
                        else
                        {
                            .GSCR_VALUE = 0x0000
                        },
				"ok"
			   )
	}
	global gDMAconfig :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Generate Global DMA Configuration and Function Call"
	  prop JSName :: "dmaGenerateGlobalCall"
        prop Visible :: 1
	  prop Writable :: 1
	  prop NoGen :: 1
	  prop TabName :: "Global"
      }
      
	global gDMA_man :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Set Manually"
	  prop JSName :: "dmaSetManually"
	  prop Visible :: 1
	  prop Writable :: .gDMAconfig
	  prop NoGen :: 1
	  prop TabName :: "Global"
      }
      
	
      
	global GSCR_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Global Software Compatibility Register (GSCR)"
        prop Visible :: 0
        prop Writable :: (hDMA.DMA_GSCR_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Global"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set :: (	.GSCR_VALUE = $1 & 0x0001,
                        if ($1 & 0x0001)
                        {
                            .MODE_SETUP = "Independent index for src/dst"
                        }
                        else
                        {
                            .MODE_SETUP = "Same index for src/dst"
                        },
				"ok"
			  )
    	}
      
	
      
	global GCR_VALUE :: .GCR_VALUE_update() {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Global Control Register (GCR)"
	  prop JSName :: "dmaGcr"
        prop Visible :: 1
        prop Writable :: (.gDMAconfig && .gDMA_man)
        prop NoGen :: 1
        prop TabName :: "Global"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set :: (	.GCR_VALUE = $1 & 0x000F,
				.GCR_SETUP_update($1 & 0x000F),
				"ok"
			  )
    	}
	
      
	
      
      
	global EHPI_PRIO_SETUP :: "Low" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Low,High"
        prop Label :: "EHPI PRIO"
        prop JSName :: "dmaGcrEhpiPrio"
        prop Visible :: 1
        prop Writable :: (.gDMAconfig && !(.gDMA_man))
        prop NoGen :: 1
        prop TabName :: "Global"
	  prop Set ::  (	.EHPI_PRIO_SETUP = $1,
				.GCR_VALUE = .GCR_VALUE_update(),
				"ok"
			   )
	}
	prop EHPI_PRIO_GCR :: (
		(.EHPI_PRIO_SETUP == "High") ? 0x0001 : 0x0000
	)
      
	global EHPI_EXCL_SETUP :: "Non-Exclusive" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Non-Exclusive,Exclusive"
        prop Label :: "EHPI EXCL"
        prop JSName :: "dmaGcrEhpiExcl"
        prop Visible :: 1
        prop Writable :: (.gDMAconfig && !(.gDMA_man))
        prop NoGen :: 1
        prop TabName :: "Global"
	  prop Set ::  (	.EHPI_EXCL_SETUP = $1,
				.GCR_VALUE = .GCR_VALUE_update(),
				"ok"
			   )
	}
	prop EHPI_EXCL_GCR :: (
		(.EHPI_EXCL_SETUP == "Exclusive") ? 0x0002 : 0x0000
	)
      
	global FREE_SETUP :: "Stop Clock At Breakpoint" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Stop Clock At Breakpoint,Continue After Breakpoint"
        prop Label :: "FREE"
        prop JSName :: "dmaGcrFree"
        prop Visible :: 1
        prop Writable :: (.gDMAconfig && !(.gDMA_man))
        prop NoGen :: 1
        prop TabName :: "Global"
	  prop Set ::  (	.FREE_SETUP = $1,
				.GCR_VALUE = .GCR_VALUE_update(),
				"ok"
			   )
	}
	prop FREE_GCR :: (
		(.FREE_SETUP == "Continue After Breakpoint") ? 0x0004 : 0x0000
	)
      
	
      
	prop GCR_VALUE_update :: (
		   .FREE_GCR()
		|  .EHPI_EXCL_GCR()
		|  .EHPI_PRIO_GCR()
	)
      
      
      
	prop GCR_SETUP_update :: (
		.FREE_SETUP = ($1 & 0x0004) ? "Continue After Breakpoint" : "Stop Clock At Breakpoint",
		.EHPI_EXCL_SETUP = ($1 & 0x0002) ? "Exclusive" : "Non-Exclusive",
		.EHPI_PRIO_SETUP = ($1 & 0x0001) ? "High" : "Low"
	)
      prop gblFxnName :: "DMA_RSET(DMAGCR, "
      prop gblRegValue :: hDMA.GCR_VALUE
      prop gblBracket :: (hDMA.gDMAconfig) ? ");\n%0t" : ""
      prop gblFxnNameStr :: (hDMA.gDMAconfig) ? "%5t%7s" : ""
      prop gblRegValueStr :: (hDMA.gDMAconfig) ? "%4d" : ""
      prop gscrFxnName :: "DMA_RSET(DMAGSCR, "
      prop gscrRegValue :: hDMA.GSCR_VALUE
      prop gscrBracket :: ((hDMA.gDMAconfig) && (hDMA.DMA_GSCR_SUPPORT)) ? ");\n%0t" : ""
      prop gscrNameStr :: ((hDMA.gDMAconfig) && (hDMA.DMA_GSCR_SUPPORT)) ? "%5t%9s" : ""
      prop gscrValueStr :: ((hDMA.gDMAconfig) && (hDMA.DMA_GSCR_SUPPORT))? "%10x" : ""
	prop comment :: "/* You must use DMA_start() in your main code to start the DMA. */"
      prop cGenFxnEpilogue :: (
	        "%1S%2S%3S%4S%5S%6S\n%5t%11S%0t\n\0, gblFxnNameStr, gblRegValueStr, gblBracket, gscrNameStr, gscrValueStr, gscrBracket, gblFxnName, gblRegValue, gscrFxnName, gscrRegValue, comment"
      )
}
object DMA_NOTHING :: dmaCfg {
    param iIsUsed :: 0
}
object DMA0 :: hDMA {
    param iComment :: .iDelMsg
    param iIsUsed :: 1  
    param iDelUser :: "hDMA"
    param iDelMsg :: ("DMA Channel 0")
    param handleName :: "hDma0"
    param cOpenArg0 :: "DMA_CHA0"
}
object DMA1 :: hDMA {
    param iComment :: .iDelMsg
    param iIsUsed :: 1  
    param iDelUser :: "hDMA"
    param iDelMsg :: ("DMA Channel 1")
    param handleName :: "hDma1"
    param cOpenArg0 :: "DMA_CHA1"
}
object DMA2 :: hDMA {
    param iComment :: .iDelMsg
    param iIsUsed :: 1  
    param iDelUser :: "hDMA"
    param iDelMsg :: ("DMA Channel 2")
    param handleName :: "hDma2"
    param cOpenArg0 :: "DMA_CHA2"
}
object DMA3 :: hDMA {
    param iComment :: .iDelMsg
    param iIsUsed :: 1  
    param iDelUser :: "hDMA"
    param iDelMsg :: ("DMA Channel 3")
    param handleName :: "hDma3"
    param cOpenArg0 :: "DMA_CHA3"
}
object DMA4 :: hDMA {
    param iComment :: .iDelMsg
    param iIsUsed :: 1  
    param iDelUser :: "hDMA"
    param iDelMsg :: ("DMA Channel 4")
    param handleName :: "hDma4"
    param cOpenArg0 :: "DMA_CHA4"
}
object DMA5 :: hDMA {
    param iComment :: .iDelMsg
    param iIsUsed :: 1  
    param iDelUser :: "hDMA"
    param iDelMsg :: ("DMA Channel 5")
    param handleName :: "hDma5"
    param cOpenArg0 :: "DMA_CHA5"
}
type EMIFFOLDER {
    
    prop Label :: "EMIF - External Memory Interface"
    prop GlobalIcon :: 163
    prop GlobalPropertyPage :: "{B016FB95-52A5-11d4-967C-0750048381B7}"
    prop GlobalHelpTopic :: 1040
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}
type emifCfg
{
	isa ObjectMgr
	prop name :: "EMIF"
	prop Label :: "EMIF Configuration Manager"
	prop JSName :: "EMIF"
	prop GlobalHelpTopic :: 1041
	prop InstanceHelpTopic :: 1041
	prop GlobalIcon :: 163
	prop InstanceIcon :: 164
	prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-00105A98CA0B}"
        prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-0000C070F3E9}"
    	prop Vendor :: "vendor1"
    	prop Version :: "1.00.00"
	
	prop IsContainedIn :: EMIFFOLDER
	prop cGen :: 1
    	prop cStruct :: 1
    	prop cStructType :: "EMIF_Config"
	prop cHeaderName :: .gNumOf > 0 ? "csl_emif.h" : ""
	prop NoGen :: 1
	global SYNCH :: .synch_update() {
          prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Label :: "Synchronous Memory Chosen "
	    prop Visible :: 0
	    prop Writable :: 1
	    prop NoGen :: 1
	    prop cGen :: 0
      }
	prop synch_update :: (
		$a = 0,
		scan ($b; emifCfg) {
	    (($b.CE0_MTYPE_SETUP == "32-bit wide SDRAM") || ($b.CE0_MTYPE_SETUP == "32-bit wide SBSRAM") ||
	     ($b.CE1_MTYPE_SETUP == "32-bit wide SDRAM") || ($b.CE1_MTYPE_SETUP == "32-bit wide SBSRAM") ||
	     ($b.CE2_MTYPE_SETUP == "32-bit wide SDRAM") || ($b.CE2_MTYPE_SETUP == "32-bit wide SBSRAM") ||
	     ($b.CE3_MTYPE_SETUP == "32-bit wide SDRAM") || ($b.CE3_MTYPE_SETUP == "32-bit wide SBSRAM")) ? 1 : 0
		}
	)
	
      
      inst CE0_MTYPE_SETUP :: "32-bit wide Asynchronous" {
            prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
            prop Enum :: "8-bit wide Asynchronous,16-bit wide Asynchronous,32-bit wide Asynchronous,32-bit wide SDRAM,32-bit wide SBSRAM"
            prop Label :: "Memory Type "
	    prop JSName :: "emifCe0Mtype"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man)
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE0"
            prop Set :: ( .CE0_MTYPE_SETUP = $1,
                          .CE0_SCR1_VALUE = .CE0_SCR1_VALUE_update(),
 	                    .SYNCH = .synch_update(),
                          "ok"
                        )
      }
      prop CE0_MTYPE_SCR1 :: (
          (.CE0_MTYPE_SETUP == "8-bit wide Asynchronous") ? 0x0000 : 
          (.CE0_MTYPE_SETUP == "16-bit wide Asynchronous") ? 0x1000 :
          (.CE0_MTYPE_SETUP == "32-bit wide Asynchronous") ? 0x2000 :
          (.CE0_MTYPE_SETUP == "32-bit wide SDRAM") ? 0x3000 :
          0x4000
      )
      inst CE0_RDSET_SETUP :: 0xF {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "Read Setup Width "
	    prop JSName :: "emifCe0ReadSetup"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE0_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE0_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE0_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE0"
            prop Set :: ( if (($1 >= 0) && ($1 <= 63)) {
                              .CE0_RDSET_SETUP = $1,
                              .CE0_SCR1_VALUE = .CE0_SCR1_VALUE_update()
                          }
                          else {
                              .error("Read Setup value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE0_RDSET_SCR1 :: (.CE0_RDSET_SETUP << 8)
      inst CE0_WRSET_SETUP :: 0xF {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "Write Setup Width "
	      prop JSName :: "emifCe0WriteSetup"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE0_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE0_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE0_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE0"
            prop Set :: ( if (($1 >= 0) && ($1 <= 63)) {
                              .CE0_WRSET_SETUP = $1,
                              .CE0_SCR2_VALUE = .CE0_SCR2_VALUE_update()
                          }
                          else {
                              .error("Write Setup value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE0_WRSET_SCR2 :: (.CE0_WRSET_SETUP << 8)
      inst CE0_RDSTROBE_SETUP :: 0x3F {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%02x"
            prop Label :: "Read Strobe Width "
	      prop JSName :: "emifCe0ReadStrobe"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE0_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE0_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE0_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE0"
            prop Set :: ( if (($1 >= 0) && ($1 <= 63)) {
                              .CE0_RDSTROBE_SETUP = $1,
                              .CE0_SCR1_VALUE = .CE0_SCR1_VALUE_update()
                          }
                          else {
                              .error("Read Strobe value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE0_RDSTROBE_SCR1 :: (.CE0_RDSTROBE_SETUP << 2)
      inst CE0_WRSTROBE_SETUP :: 0x3F {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%02x"
            prop Label :: "Write Strobe Width "
	    prop JSName :: "emifCe0WriteStrobe"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE0_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE0_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE0_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE0"
            prop Set :: ( if (($1 >= 0) && ($1 <= 63)) {
                              .CE0_WRSTROBE_SETUP = $1,
                              .CE0_SCR2_VALUE = .CE0_SCR2_VALUE_update()
                          }
                          else {
                              .error("Write Strobe value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE0_WRSTROBE_SCR2 :: (.CE0_WRSTROBE_SETUP << 2)
      inst CE0_RDHOLD_SETUP :: 0x3 {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "Read Hold Width "
	    prop JSName :: "emifCe0ReadHold"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE0_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE0_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE0_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE0"
            prop Set :: ( if (($1 >= 0) && ($1 <= 3)) {
                              .CE0_RDHOLD_SETUP = $1,
                              .CE0_SCR1_VALUE = .CE0_SCR1_VALUE_update()
                          }
                          else {
                              .error("Read Hold value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE0_RDHOLD_SCR1 :: (.CE0_RDHOLD_SETUP)
      inst CE0_WRHOLD_SETUP :: 0x3 {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "Write Hold Width "
	    prop JSName :: "emifCe0WriteHold"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE0_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE0_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE0_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE0"
            prop Set :: ( if (($1 >= 0) && ($1 <= 3)) {
                              .CE0_WRHOLD_SETUP = $1,
                              .CE0_SCR2_VALUE = .CE0_SCR2_VALUE_update()
                          }
                          else {
                              .error("Write Setup value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE0_WRHOLD_SCR2 :: (.CE0_WRHOLD_SETUP)
      inst CE0_EXRDHOLD_SETUP :: 0x1 {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "Extended Read Hold Width "
	    prop JSName :: "emifCe0ReadExtHold"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE0_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE0_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE0_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE0"
            prop Set :: ( if (($1 >= 0) && ($1 <= 3)) {
                              .CE0_EXRDHOLD_SETUP = $1,
                              .CE0_SCR2_VALUE = .CE0_SCR2_VALUE_update()
                          }
                          else {
                              .error("Extended Read Hold value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE0_EXRDHOLD_SCR2 :: (.CE0_EXRDHOLD_SETUP << 14)
      inst CE0_EXWRHOLD_SETUP :: 0x1 {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "Extended Write Hold Width "
	    prop JSName :: "emifCe0WriteExtHold"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE0_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE0_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE0_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE0"
            prop Set :: ( if (($1 >= 0) && ($1 <= 3)) {
                              .CE0_EXWRHOLD_SETUP = $1,
                              .CE0_SCR2_VALUE = .CE0_SCR2_VALUE_update()
                          }
                          else {
                              .error("Extended Write Setup value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE0_EXWRHOLD_SCR2 :: (.CE0_EXWRHOLD_SETUP << 12)
      inst CE0_TIMEOUT_SETUP :: 0 {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%02x"
            prop Label :: "Length of Bus Error Timeout "
	    prop JSName :: "emifCe0Timeout"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE0_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE0_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE0_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE0"
            prop Set :: ( if (($1 >= 0) && ($1 <= 255)) {
                              .CE0_TIMEOUT_SETUP = $1,
                              .CE0_SCR3_VALUE = $1
                          }
                          else {
                              .error("Timeout value exceeds limits")
                          },
                          "ok"
                        )
      }
      
      inst CE1_MTYPE_SETUP :: "32-bit wide Asynchronous" {
            prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
            prop Enum :: "8-bit wide Asynchronous,16-bit wide Asynchronous,32-bit wide Asynchronous,32-bit wide SDRAM,32-bit wide SBSRAM"
            prop Label :: "Memory Type "
	      prop JSName :: "emifCe1Mtype"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man)
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE1"
            prop Set :: ( .CE1_MTYPE_SETUP = $1,
                          .CE1_SCR1_VALUE = .CE1_SCR1_VALUE_update(),
 	                    .SYNCH = .synch_update(),
                          "ok"
                        )
      }
      prop CE1_MTYPE_SCR1 :: (
          (.CE1_MTYPE_SETUP == "8-bit wide Asynchronous") ? 0x0000 : 
          (.CE1_MTYPE_SETUP == "16-bit wide Asynchronous") ? 0x1000 :
          (.CE1_MTYPE_SETUP == "32-bit wide Asynchronous") ? 0x2000 :
          (.CE1_MTYPE_SETUP == "32-bit wide SDRAM") ? 0x3000 :
          0x4000
      )
      inst CE1_RDSET_SETUP :: 0xF {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "Read Setup Width "
	    prop JSName :: "emifCe1ReadSetup"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE1_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE1_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE1_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE1"
            prop Set :: ( if (($1 >= 0) && ($1 <= 63)) {
                              .CE1_RDSET_SETUP = $1,
                              .CE1_SCR1_VALUE = .CE1_SCR1_VALUE_update()
                          }
                          else {
                              .error("Read Setup value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE1_RDSET_SCR1 :: (.CE1_RDSET_SETUP << 8)
      inst CE1_WRSET_SETUP :: 0xF {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "Write Setup Width "
	      prop JSName :: "emifCe1WriteSetup"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE1_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE1_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE1_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE1"
            prop Set :: ( if (($1 >= 0) && ($1 <= 63)) {
                              .CE1_WRSET_SETUP = $1,
                              .CE1_SCR2_VALUE = .CE1_SCR2_VALUE_update()
                          }
                          else {
                              .error("Write Setup value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE1_WRSET_SCR2 :: (.CE1_WRSET_SETUP << 8)
      inst CE1_RDSTROBE_SETUP :: 0x3F {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%02x"
            prop Label :: "Read Strobe Width "
	      prop JSName :: "emifCe1ReadStrobe"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE1_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE1_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE1_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE1"
            prop Set :: ( if (($1 >= 0) && ($1 <= 63)) {
                              .CE1_RDSTROBE_SETUP = $1,
                              .CE1_SCR1_VALUE = .CE1_SCR1_VALUE_update()
                          }
                          else {
                              .error("Read Strobe value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE1_RDSTROBE_SCR1 :: (.CE1_RDSTROBE_SETUP << 2)
      inst CE1_WRSTROBE_SETUP :: 0x3F {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%02x"
            prop Label :: "Write Strobe Width "
	      prop JSName :: "emifCe1WriteStrobe"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE1_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE1_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE1_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE1"
            prop Set :: ( if (($1 >= 0) && ($1 <= 63)) {
                              .CE1_WRSTROBE_SETUP = $1,
                              .CE1_SCR2_VALUE = .CE1_SCR2_VALUE_update()
                          }
                          else {
                              .error("Write Strobe value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE1_WRSTROBE_SCR2 :: (.CE1_WRSTROBE_SETUP << 2)
      inst CE1_RDHOLD_SETUP :: 0x3 {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "Read Hold Width "
	      prop JSName :: "emifCe1ReadHold"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE1_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE1_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE1_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE1"
            prop Set :: ( if (($1 >= 0) && ($1 <= 3)) {
                              .CE1_RDHOLD_SETUP = $1,
                              .CE1_SCR1_VALUE = .CE1_SCR1_VALUE_update()
                          }
                          else {
                              .error("Read Hold value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE1_RDHOLD_SCR1 :: (.CE1_RDHOLD_SETUP)
      inst CE1_WRHOLD_SETUP :: 0x3 {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "Write Hold Width "
	      prop JSName :: "emifCe1WriteHold"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE1_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE1_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE1_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE1"
            prop Set :: ( if (($1 >= 0) && ($1 <= 3)) {
                              .CE1_WRHOLD_SETUP = $1,
                              .CE1_SCR2_VALUE = .CE1_SCR2_VALUE_update()
                          }
                          else {
                              .error("Write Setup value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE1_WRHOLD_SCR2 :: (.CE1_WRHOLD_SETUP)
      inst CE1_EXRDHOLD_SETUP :: 0x1 {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "Extended Read Hold Width "
	      prop JSName :: "emifCe1ReadExtHold"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE1_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE1_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE1_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE1"
            prop Set :: ( if (($1 >= 0) && ($1 <= 3)) {
                              .CE1_EXRDHOLD_SETUP = $1,
                              .CE1_SCR2_VALUE = .CE1_SCR2_VALUE_update()
                          }
                          else {
                              .error("Extended Read Hold value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE1_EXRDHOLD_SCR2 :: (.CE1_EXRDHOLD_SETUP << 14)
      inst CE1_EXWRHOLD_SETUP :: 0x1 {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "Extended Write Hold Width "
	      prop JSName :: "emifCe1WriteExtHold"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE1_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE1_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE1_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE1"
            prop Set :: ( if (($1 >= 0) && ($1 <= 3)) {
                              .CE1_EXWRHOLD_SETUP = $1,
                              .CE1_SCR2_VALUE = .CE1_SCR2_VALUE_update()
                          }
                          else {
                              .error("Extended Write Setup value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE1_EXWRHOLD_SCR2 :: (.CE1_EXWRHOLD_SETUP << 12)
      inst CE1_TIMEOUT_SETUP :: 0 {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%02x"
            prop Label :: "Length of Bus Error Timeout "
	      prop JSName :: "emifCe1Timeout"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE1_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE1_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE1_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE1"
            prop Set :: ( if (($1 >= 0) && ($1 <= 255)) {
                              .CE1_TIMEOUT_SETUP = $1,
                              .CE1_SCR3_VALUE = $1
                          }
                          else {
                              .error("Timeout value exceeds limits")
                          },
                          "ok"
                        )
      }
      
      inst CE2_MTYPE_SETUP :: "32-bit wide Asynchronous" {
            prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
            prop Enum :: "8-bit wide Asynchronous,16-bit wide Asynchronous,32-bit wide Asynchronous,32-bit wide SDRAM,32-bit wide SBSRAM"
            prop Label :: "Memory Type "
	      prop JSName :: "emifCe2Mtype"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man)
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE2"
            prop Set :: ( .CE2_MTYPE_SETUP = $1,
                          .CE2_SCR1_VALUE = .CE2_SCR1_VALUE_update(),
 	                    .SYNCH = .synch_update(),
                          "ok"
                        )
      }
      prop CE2_MTYPE_SCR1 :: (
          (.CE2_MTYPE_SETUP == "8-bit wide Asynchronous") ? 0x0000 : 
          (.CE2_MTYPE_SETUP == "16-bit wide Asynchronous") ? 0x1000 :
          (.CE2_MTYPE_SETUP == "32-bit wide Asynchronous") ? 0x2000 :
          (.CE2_MTYPE_SETUP == "32-bit wide SDRAM") ? 0x3000 :
          0x4000
      )
      inst CE2_RDSET_SETUP :: 0xF {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "Read Setup Width "
	      prop JSName :: "emifCe2ReadSetup"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE2_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE2_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE2_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE2"
            prop Set :: ( if (($1 >= 0) && ($1 <= 63)) {
                              .CE2_RDSET_SETUP = $1,
                              .CE2_SCR1_VALUE = .CE2_SCR1_VALUE_update()
                          }
                          else {
                              .error("Read Setup value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE2_RDSET_SCR1 :: (.CE2_RDSET_SETUP << 8)
      inst CE2_WRSET_SETUP :: 0xF {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "Write Setup Width "
	      prop JSName :: "emifCe2WriteSetup"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE2_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE2_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE2_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE2"
            prop Set :: ( if (($1 >= 0) && ($1 <= 63)) {
                              .CE2_WRSET_SETUP = $1,
                              .CE2_SCR2_VALUE = .CE2_SCR2_VALUE_update()
                          }
                          else {
                              .error("Write Setup value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE2_WRSET_SCR2 :: (.CE2_WRSET_SETUP << 8)
      inst CE2_RDSTROBE_SETUP :: 0x3F {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%02x"
            prop Label :: "Read Strobe Width "
	      prop JSName :: "emifCe2ReadStrobe"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE2_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE2_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE2_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE2"
            prop Set :: ( if (($1 >= 0) && ($1 <= 63)) {
                              .CE2_RDSTROBE_SETUP = $1,
                              .CE2_SCR1_VALUE = .CE2_SCR1_VALUE_update()
                          }
                          else {
                              .error("Read Strobe value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE2_RDSTROBE_SCR1 :: (.CE2_RDSTROBE_SETUP << 2)
      inst CE2_WRSTROBE_SETUP :: 0x3F {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%02x"
            prop Label :: "Write Strobe Width "
	      prop JSName :: "emifCe2WriteStrobe"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE2_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE2_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE2_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE2"
            prop Set :: ( if (($1 >= 0) && ($1 <= 63)) {
                              .CE2_WRSTROBE_SETUP = $1,
                              .CE2_SCR2_VALUE = .CE2_SCR2_VALUE_update()
                          }
                          else {
                              .error("Write Strobe value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE2_WRSTROBE_SCR2 :: (.CE2_WRSTROBE_SETUP << 2)
      inst CE2_RDHOLD_SETUP :: 0x3 {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "Read Hold Width "
	      prop JSName :: "emifCe2ReadHold"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE2_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE2_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE2_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE2"
            prop Set :: ( if (($1 >= 0) && ($1 <= 3)) {
                              .CE2_RDHOLD_SETUP = $1,
                              .CE2_SCR1_VALUE = .CE2_SCR1_VALUE_update()
                          }
                          else {
                              .error("Read Hold value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE2_RDHOLD_SCR1 :: (.CE2_RDHOLD_SETUP)
      inst CE2_WRHOLD_SETUP :: 0x3 {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "Write Hold Width "
	      prop JSName :: "emifCe2WriteHold"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE2_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE2_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE2_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE2"
            prop Set :: ( if (($1 >= 0) && ($1 <= 3)) {
                              .CE2_WRHOLD_SETUP = $1,
                              .CE2_SCR2_VALUE = .CE2_SCR2_VALUE_update()
                          }
                          else {
                              .error("Write Setup value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE2_WRHOLD_SCR2 :: (.CE2_WRHOLD_SETUP)
      inst CE2_EXRDHOLD_SETUP :: 0x1 {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "Extended Read Hold Width "
	      prop JSName :: "emifCe2ReadExtHold"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE2_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE2_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE2_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE2"
            prop Set :: ( if (($1 >= 0) && ($1 <= 3)) {
                              .CE2_EXRDHOLD_SETUP = $1,
                              .CE2_SCR2_VALUE = .CE2_SCR2_VALUE_update()
                          }
                          else {
                              .error("Extended Read Hold value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE2_EXRDHOLD_SCR2 :: (.CE2_EXRDHOLD_SETUP << 14)
      inst CE2_EXWRHOLD_SETUP :: 0x1 {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "Extended Write Hold Width "
	      prop JSName :: "emifCe2WriteExtHold"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE2_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE2_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE2_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE2"
            prop Set :: ( if (($1 >= 0) && ($1 <= 3)) {
                              .CE2_EXWRHOLD_SETUP = $1,
                              .CE2_SCR2_VALUE = .CE2_SCR2_VALUE_update()
                          }
                          else {
                              .error("Extended Write Setup value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE2_EXWRHOLD_SCR2 :: (.CE2_EXWRHOLD_SETUP << 12)
      inst CE2_TIMEOUT_SETUP :: 0 {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%02x"
            prop Label :: "Length of Bus Error Timeout "
	      prop JSName :: "emifCe2Timeout"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE2_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE2_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE2_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE2"
            prop Set :: ( if (($1 >= 0) && ($1 <= 255)) {
                              .CE2_TIMEOUT_SETUP = $1,
                              .CE2_SCR3_VALUE = $1
                          }
                          else {
                              .error("Timeout value exceeds limits")
                          },
                          "ok"
                        )
      }
      
      inst CE3_MTYPE_SETUP :: "32-bit wide Asynchronous" {
            prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
            prop Enum :: "8-bit wide Asynchronous,16-bit wide Asynchronous,32-bit wide Asynchronous,32-bit wide SDRAM,32-bit wide SBSRAM"
            prop Label :: "Memory Type "
	      prop JSName :: "emifCe3Mtype"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man)
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE3"
            prop Set :: ( .CE3_MTYPE_SETUP = $1,
                          .CE3_SCR1_VALUE = .CE3_SCR1_VALUE_update(),
 	                    .SYNCH = .synch_update(),
                          "ok"
                        )
      }
      prop CE3_MTYPE_SCR1 :: (
          (.CE3_MTYPE_SETUP == "8-bit wide Asynchronous") ? 0x0000 : 
          (.CE3_MTYPE_SETUP == "16-bit wide Asynchronous") ? 0x1000 :
          (.CE3_MTYPE_SETUP == "32-bit wide Asynchronous") ? 0x2000 :
          (.CE3_MTYPE_SETUP == "32-bit wide SDRAM") ? 0x3000 :
          0x4000
      )
      inst CE3_RDSET_SETUP :: 0xF {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "Read Setup Width "
	      prop JSName :: "emifCe3ReadSetup"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE3_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE3_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE3_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE3"
            prop Set :: ( if (($1 >= 0) && ($1 <= 63)) {
                              .CE3_RDSET_SETUP = $1,
                              .CE3_SCR1_VALUE = .CE3_SCR1_VALUE_update()
                          }
                          else {
                              .error("Read Setup value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE3_RDSET_SCR1 :: (.CE3_RDSET_SETUP << 8)
      inst CE3_WRSET_SETUP :: 0xF {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "Write Setup Width "
	      prop JSName :: "emifCe3WriteSetup"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE3_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE3_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE3_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE3"
            prop Set :: ( if (($1 >= 0) && ($1 <= 63)) {
                              .CE3_WRSET_SETUP = $1,
                              .CE3_SCR2_VALUE = .CE3_SCR2_VALUE_update()
                          }
                          else {
                              .error("Write Setup value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE3_WRSET_SCR2 :: (.CE3_WRSET_SETUP << 8)
      inst CE3_RDSTROBE_SETUP :: 0x3F {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%02x"
            prop Label :: "Read Strobe Width "
	      prop JSName :: "emifCe3ReadStrobe"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE3_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE3_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE3_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE3"
            prop Set :: ( if (($1 >= 0) && ($1 <= 63)) {
                              .CE3_RDSTROBE_SETUP = $1,
                              .CE3_SCR1_VALUE = .CE3_SCR1_VALUE_update()
                          }
                          else {
                              .error("Read Strobe value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE3_RDSTROBE_SCR1 :: (.CE3_RDSTROBE_SETUP << 2)
      inst CE3_WRSTROBE_SETUP :: 0x3F {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%02x"
            prop Label :: "Write Strobe Width "
	      prop JSName :: "emifCe3WriteStrobe"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE3_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE3_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE3_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE3"
            prop Set :: ( if (($1 >= 0) && ($1 <= 63)) {
                              .CE3_WRSTROBE_SETUP = $1,
                              .CE3_SCR2_VALUE = .CE3_SCR2_VALUE_update()
                          }
                          else {
                              .error("Write Strobe value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE3_WRSTROBE_SCR2 :: (.CE3_WRSTROBE_SETUP << 2)
      inst CE3_RDHOLD_SETUP :: 0x3 {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "Read Hold Width "
	      prop JSName :: "emifCe3ReadHold"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE3_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE3_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE3_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE3"
            prop Set :: ( if (($1 >= 0) && ($1 <= 3)) {
                              .CE3_RDHOLD_SETUP = $1,
                              .CE3_SCR1_VALUE = .CE3_SCR1_VALUE_update()
                          }
                          else {
                              .error("Read Hold value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE3_RDHOLD_SCR1 :: (.CE3_RDHOLD_SETUP)
      inst CE3_WRHOLD_SETUP :: 0x3 {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "Write Hold Width "
	      prop JSName :: "emifCe3WriteHold"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE3_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE3_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE3_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE3"
            prop Set :: ( if (($1 >= 0) && ($1 <= 3)) {
                              .CE3_WRHOLD_SETUP = $1,
                              .CE3_SCR2_VALUE = .CE3_SCR2_VALUE_update()
                          }
                          else {
                              .error("Write Setup value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE3_WRHOLD_SCR2 :: (.CE3_WRHOLD_SETUP)
      inst CE3_EXRDHOLD_SETUP :: 0x1 {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "Extended Read Hold Width "
	      prop JSName :: "emifCe3ReadExtHold"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE3_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE3_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE3_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE3"
            prop Set :: ( if (($1 >= 0) && ($1 <= 3)) {
                              .CE3_EXRDHOLD_SETUP = $1,
                              .CE3_SCR2_VALUE = .CE3_SCR2_VALUE_update()
                          }
                          else {
                              .error("Extended Read Hold value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE3_EXRDHOLD_SCR2 :: (.CE3_EXRDHOLD_SETUP << 14)
      inst CE3_EXWRHOLD_SETUP :: 0x1 {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "Extended Write Hold Width "
	      prop JSName :: "emifCe3WriteExtHold"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE3_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE3_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE3_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE3"
            prop Set :: ( if (($1 >= 0) && ($1 <= 3)) {
                              .CE3_EXWRHOLD_SETUP = $1,
                              .CE3_SCR2_VALUE = .CE3_SCR2_VALUE_update()
                          }
                          else {
                              .error("Extended Write Setup value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop CE3_EXWRHOLD_SCR2 :: (.CE3_EXWRHOLD_SETUP << 12)
      inst CE3_TIMEOUT_SETUP :: 0 {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%02x"
            prop Label :: "Length of Bus Error Timeout "
	      prop JSName :: "emifCe3Timeout"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE3_MTYPE_SETUP == "8-bit wide Asynchronous") || (.CE3_MTYPE_SETUP == "16-bit wide Asynchronous") || (.CE3_MTYPE_SETUP == "32-bit wide Asynchronous"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "CE3"
            prop Set :: ( if (($1 >= 0) && ($1 <= 255)) {
                              .CE3_TIMEOUT_SETUP = $1,
                              .CE3_SCR3_VALUE = $1
                          }
                          else {
                              .error("Timeout value exceeds limits")
                          },
                          "ok"
                        )
      }
      inst RESET_SETUP :: 0 {
            prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
            prop Label :: "Reset EMIF State Machine "
	      prop JSName :: "emifRst"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man)
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "Global Settings"
            prop Set :: ( .RESET_SETUP = $1,
                          if ($1 == 1) {
                              hEMIF.GblEmifReset = 1,
                              .GRR_VALUE = 0xFFFF
                          }
                          else {
                              hEMIF.GblEmifReset = 0,
                              .GRR_VALUE = 0x0000
                          },
                          "ok"
                        )
      }
      prop RESET_GCR :: (
          (.RESET_SETUP == "CLKMEM Enabled to Clock") ? 0x0020 : 0x0000
      )
      inst MEMCEN_SETUP :: "CLKMEM Enabled to Clock" {
            prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
            prop Enum :: "CLKMEM Enabled to Clock,CLKMEM Held High"
            prop Label :: "Memory Clock Enable              "
	      prop JSName :: "emifGcrMemcen"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE0_MTYPE_SETUP == "32-bit wide SDRAM") || (.CE0_MTYPE_SETUP == "32-bit wide SBSRAM") || (.CE1_MTYPE_SETUP == "32-bit wide SDRAM") || (.CE1_MTYPE_SETUP == "32-bit wide SBSRAM") || (.CE2_MTYPE_SETUP == "32-bit wide SDRAM") || (.CE2_MTYPE_SETUP == "32-bit wide SBSRAM") || (.CE3_MTYPE_SETUP == "32-bit wide SDRAM") || (.CE3_MTYPE_SETUP == "32-bit wide SBSRAM"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "Global Settings"
            prop Set :: ( .MEMCEN_SETUP = $1,
                          .GCR_VALUE = .GCR_VALUE_update(),
                          "ok"
                        )
      }
      prop MEMCEN_GCR :: (
          (.MEMCEN_SETUP == "CLKMEM Enabled to Clock") ? 0x0020 : 0x0000
      )
      inst MEMFREQ_SETUP :: "CLKMEM = DSP Clock" {
            prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
            prop Enum :: "CLKMEM = DSP Clock,CLKMEM = DSP Clock / 2"
            prop Label :: "Memory Clock Frequency              "
	      prop JSName :: "emifGcrMemfreq"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man) && ((.CE0_MTYPE_SETUP == "32-bit wide SDRAM") || (.CE0_MTYPE_SETUP == "32-bit wide SBSRAM") || (.CE1_MTYPE_SETUP == "32-bit wide SDRAM") || (.CE1_MTYPE_SETUP == "32-bit wide SBSRAM") || (.CE2_MTYPE_SETUP == "32-bit wide SDRAM") || (.CE2_MTYPE_SETUP == "32-bit wide SBSRAM") || (.CE3_MTYPE_SETUP == "32-bit wide SDRAM") || (.CE3_MTYPE_SETUP == "32-bit wide SBSRAM"))
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "Global Settings"
            prop Set :: ( .MEMFREQ_SETUP = $1,
                          .GCR_VALUE = .GCR_VALUE_update(),
                          "ok"
                        )
      }
      prop MEMFREQ_GCR :: (
          (.MEMFREQ_SETUP == "CLKMEM = DSP Clock") ? 0x0000 :
	    0x0200
      )
      inst NOHOLD_SETUP :: "Hold Enabled" {
            prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
            prop Enum :: "Hold Enabled,Hold Disabled"
            prop Label :: "External HOLD Disable "
	      prop JSName :: "emifGcrNohold"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man)
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "Global Settings"
            prop Set :: ( .NOHOLD_SETUP = $1,
                          .GCR_VALUE = .GCR_VALUE_update(),
                          "ok"
                        )
      }
      prop NOHOLD_GCR :: (
          (.NOHOLD_SETUP == "Hold Enabled") ? 0x0000 : 0x0001
      )
      inst WPE_SETUP :: "Disabled" {
            prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
            prop Enum :: "Disabled,Enabled"
            prop Label :: "Write Posting Enable "
	      prop JSName :: "emifGcrWpe"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man)
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "Global Settings"
            prop Set :: ( .WPE_SETUP = $1,
                          .GCR_VALUE = .GCR_VALUE_update(),
                          "ok"
                        )
      }
      prop WPE_GCR :: (
          (.WPE_SETUP == "Disabled") ? 0x0000 : 0x0080
      )
      inst SDINIT_SETUP :: 0 {
            prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
            prop Label :: "Initialize SDRAM "
	      prop JSName :: "emifSdinit"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man)
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "SDRAM"
            prop Set :: ( .SDINIT_SETUP = $1,
                          if ($1 == 1) {
                              .SDINIT_VALUE = 0x0FFF
                          }
                          else {
                              .SDINIT_VALUE = 0x0000
                          },
                          "ok"
                        )
      }
      inst SDACC_SETUP :: "16-bits wide (D[15:0])" {
            prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
            prop Enum :: "16-bits wide (D[15:0]),32-bits wide (D[31:0])"
            prop Label :: "SDRAM Data Bus Interface Width "
	      prop JSName :: "emifSdcr2Sdacc"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man)
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "SDRAM"
            prop Set :: ( .SDACC_SETUP = $1,
                          .SDCR2_VALUE = .SDCR2_VALUE_update(),
                          "ok"
                        )
      }
      prop SDACC_SDCR2 :: (
          (.SDACC_SETUP == "16-bits wide (D[15:0])") ? 0x0000 : 0x0400
      )
      inst SDSIZE_SETUP :: "64Mbit" {
            prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
            prop Enum :: "64Mbit,128Mbit"
            prop Label :: "SDRAM Size Select "
	      prop JSName :: "emifSdcr1Sdsize"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man)
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "SDRAM"
            prop Set :: ( .SDSIZE_SETUP = $1,
                          .SDCR1_VALUE = .SDCR1_VALUE_update(),
                          "ok"
                        )
      }
      prop SDSIZE_SDCR1 :: (
          (.SDSIZE_SETUP == "64Mbit") ? 0x0000 : 0x0400
      )
      inst SDWID_SETUP :: "16-bits" {
            prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
            prop Enum :: "16-bits,32-bits"
            prop Label :: "SDRAM Width Select "
	      prop JSName :: "emifSdcr1Sdwid"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man)
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "SDRAM"
            prop Set :: ( .SDWID_SETUP = $1,
                          .SDCR1_VALUE = .SDCR1_VALUE_update(),
                          "ok"
                        )
      }
      prop SDWID_SDCR1 :: (
          (.SDWID_SETUP == "16-bits") ? 0x0000 : 0x0200
      )
      inst RFEN_SETUP :: "Enabled" {
            prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
            prop Enum :: "Disabled,Enabled"
            prop Label :: "Refresh Enable "
	      prop JSName :: "emifSdcr1Rfen"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man)
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "SDRAM"
            prop Set :: ( .RFEN_SETUP = $1,
                          .SDCR1_VALUE = .SDCR1_VALUE_update(),
                          "ok"
                        )
      }
      prop RFEN_SDCR1 :: (
          (.RFEN_SETUP == "Disabled") ? 0x0000 : 0x0100
      )
      inst SDPERIOD_SETUP :: 0x080 {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%03x"
            prop Label :: "Refresh Period "
	      prop JSName :: "emifSdperiod"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man)
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "SDRAM"
            prop Set :: ( if (($1 >= 0) && ($1 <= 0x0FFF)) {
                              .SDPERIOD_SETUP = $1,
                              .SDPERIOD_VALUE = $1
                          }
                          else {
                              .error("PERIOD value exceeds limits")
                          },
                          "ok"
                        )
      }
      inst TRP_SETUP :: 0x8 {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "TRP Value [(Trp /SDCLK) - 1] "
	      prop JSName :: "emifSdcr1Trp"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man)
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "SDRAM"
            prop Set :: ( if (($1 >= 0) && ($1 <= 15)) {
                              .TRP_SETUP = $1,
                              .SDCR1_VALUE = .SDCR1_VALUE_update()
                          }
                          else {
                              .error("TRP value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop TRP_SDCR1 :: (.TRP_SETUP)
      inst TRC_SETUP :: 0x1F {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%02x"
            prop Label :: "TRC Value [(Trc /SDCLK) - 1] "
	      prop JSName :: "emifSdcr1Trc"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man)
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "SDRAM"
            prop Set :: ( if (($1 >= 0) && ($1 <= 31)) {
                              .TRC_SETUP = $1,
                              .SDCR1_VALUE = .SDCR1_VALUE_update()
                          }
                          else {
                              .error("TRC value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop TRC_SDCR1 :: (.TRC_SETUP << 11)
      inst TRCD_SETUP :: 0x4 {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "TRCD Value [(Trcd /SDCLK) - 1] "
	      prop JSName :: "emifSdcr1Trcd"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man)
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "SDRAM"
            prop Set :: ( if (($1 >= 0) && ($1 <= 15)) {
                              .TRCD_SETUP = $1,
                              .SDCR1_VALUE = .SDCR1_VALUE_update()
                          }
                          else {
                              .error("TRCD value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop TRCD_SDCR1 :: (.TRCD_SETUP << 4)
      inst TRAS_SETUP :: 0xF {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "TRAS Value [(Tras /SDCLK) - 1] "
	      prop JSName :: "emifSdcr2Tras"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man)
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "SDRAM"
            prop Set :: ( if (($1 >= 0) && ($1 <= 15)) {
                              .TRAS_SETUP = $1,
                              .SDCR2_VALUE = .SDCR2_VALUE_update()
                          }
                          else {
                              .error("TRAS value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop TRAS_SDCR2 :: (.TRAS_SETUP << 4)
      inst TMRD_SETUP :: 0x3 {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "TMRD Value [(Tmrd /SDCLK) - 1] "
	      prop JSName :: "emifSdcr2Tmrd"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man)
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "SDRAM"
            prop Set :: ( if (($1 >= 0) && ($1 <= 3)) {
                              .TMRD_SETUP = $1,
                              .SDCR2_VALUE = .SDCR2_VALUE_update()
                          }
                          else {
                              .error("TMRD value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop TMRD_SDCR2 :: (.TMRD_SETUP << 8)
      inst TACTV_SETUP :: 0xF {
            prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
            prop Format :: "0x%01x"
            prop Label :: "Delay from ACTV to ACTV Command [(Tactv2actv /SDCLK) - 1] "
	      prop JSName :: "emifSdcr2Tactv"
            prop Visible :: 1
            prop Writable :: !(.EMIF_man)
            prop NoGen :: 1
            prop cGen :: 0
            prop TabName :: "SDRAM"
            prop Set :: ( if (($1 >= 0) && ($1 <= 15)) {
                              .TACTV_SETUP = $1,
                              .SDCR2_VALUE = .SDCR2_VALUE_update()
                          }
                          else {
                              .error("TACTV2ACTV value exceeds limits")
                          },
                          "ok"
                        )
      }
      prop TACTV_SDCR2 :: (.TACTV_SETUP)
      
      prop CE0_SCR1_VALUE_update :: (
            .CE0_RDHOLD_SCR1
          | .CE0_RDSTROBE_SCR1
          | .CE0_RDSET_SCR1
          | .CE0_MTYPE_SCR1
      )
      prop CE0_SCR2_VALUE_update :: (
            .CE0_WRHOLD_SCR2
          | .CE0_WRSTROBE_SCR2
          | .CE0_WRSET_SCR2
          | .CE0_EXRDHOLD_SCR2
          | .CE0_EXWRHOLD_SCR2
      )
      prop CE1_SCR1_VALUE_update :: (
            .CE1_RDHOLD_SCR1
          | .CE1_RDSTROBE_SCR1
          | .CE1_RDSET_SCR1
          | .CE1_MTYPE_SCR1
      )
      prop CE1_SCR2_VALUE_update :: (
            .CE1_WRHOLD_SCR2
          | .CE1_WRSTROBE_SCR2
          | .CE1_WRSET_SCR2
          | .CE1_EXRDHOLD_SCR2
          | .CE1_EXWRHOLD_SCR2
      )
      prop CE2_SCR1_VALUE_update :: (
            .CE2_RDHOLD_SCR1
          | .CE2_RDSTROBE_SCR1
          | .CE2_RDSET_SCR1
          | .CE2_MTYPE_SCR1
      )
      prop CE2_SCR2_VALUE_update :: (
            .CE2_WRHOLD_SCR2
          | .CE2_WRSTROBE_SCR2
          | .CE2_WRSET_SCR2
          | .CE2_EXRDHOLD_SCR2
          | .CE2_EXWRHOLD_SCR2
      )
      prop CE3_SCR1_VALUE_update :: (
            .CE3_RDHOLD_SCR1
          | .CE3_RDSTROBE_SCR1
          | .CE3_RDSET_SCR1
          | .CE3_MTYPE_SCR1
      )
      prop CE3_SCR2_VALUE_update :: (
            .CE3_WRHOLD_SCR2
          | .CE3_WRSTROBE_SCR2
          | .CE3_WRSET_SCR2
          | .CE3_EXRDHOLD_SCR2
          | .CE3_EXWRHOLD_SCR2
      )
      prop GCR_VALUE_update :: (
            .NOHOLD_GCR
          | .MEMCEN_GCR
          | .MEMFREQ_GCR
          | .WPE_GCR
      )
      prop SDCR1_VALUE_update :: (
            .TRP_SDCR1
          | .TRC_SDCR1
          | .TRCD_SDCR1
          | .RFEN_SDCR1
          | .SDSIZE_SDCR1
          | .SDWID_SDCR1
      )
      prop SDCR2_VALUE_update :: (
            .TACTV_SDCR2
          | .TMRD_SDCR2
          | .TRAS_SDCR2
          | .SDACC_SDCR2
      )
      
      prop GCR_SETUP_update :: (
          .NOHOLD_SETUP = ($1 & 0x0001) ? "Hold Disabled" : "Hold Enabled",
          .MEMCEN_SETUP = ($1 & 0x0020) ? "CLKMEM Enabled to Clock" : "CLKMEM Held High",
          .WPE_SETUP = ($1 & 0x0080) ? "Enabled" : "Disabled",
          .MEMFREQ_SETUP = ($a = $1 & 0x0E00,
              ($a == 0x0000) ? "CLKMEM = DSP Clock" :
              ($a == 0x0200) ? "CLKMEM = DSP Clock / 2" :
              ($a == 0x0400) ? "CLKMEM = DSP Clock / 4" :
              ($a == 0x0600) ? "CLKMEM = DSP Clock / 8" :
              "CLKMEM = DSP Clock / 16")
      )
      prop SDCR1_SETUP_update :: (
          .TRP_SETUP = ($1 & 0x000F),
          .TRCD_SETUP = (($1 >> 4) & 0x000F),
          .TRC_SETUP = (($1 >> 11) & 0x001F),
          .RFEN_SETUP = ($1 & 0x0100) ? "Enabled" : "Disabled",
          .SDSIZE_SETUP = ($1 & 0x0400) ? "128Mbit" : "64Mbit",
          .SDWID_SETUP = ($1 & 0x0200) ? "32-bits" : "16-bits"
      )
      prop SDCR2_SETUP_update :: (
          .TACTV_SETUP = ($1 & 0x000F),
          .TRAS_SETUP = (($1 >> 4) & 0x000F),
          .TMRD_SETUP = (($1 >> 8) & 0x0003),
          .SDACC_SETUP = ($1 & 0x0400) ? "32-bits wide (D[31:0])" : "16-bits wide (D[15:0])"
      )
      prop CE0_SCR1_SETUP_update :: (
          .CE0_RDHOLD_SETUP = ($1 & 0x0003),
          .CE0_RDSTROBE_SETUP = (($1 >> 2) & 0x003F),
          .CE0_RDSET_SETUP = (($1 >> 8) & 0x000F),
          .CE0_MTYPE_SETUP = (($a = $1 & 0x7000),
              ($a == 0x0000) ? "8-bit wide Asynchronous" :
              ($a == 0x1000) ? "16-bit wide Asynchronous" :
              ($a == 0x2000) ? "32-bit wide Asynchronous" :
              ($a == 0x3000) ? "32-bit wide SDRAM" :
              "32-bit wide SBSRAM")
      )
      prop CE0_SCR2_SETUP_update :: (
          .CE0_WRHOLD_SETUP = ($1 & 0x0003),
          .CE0_WRSTROBE_SETUP = (($1 >> 2) & 0x003F),
          .CE0_WRSET_SETUP = (($1 >> 8) & 0x000F),
          .CE0_EXWRHOLD_SETUP = (($1 >> 12) & 0x0003),
          .CE0_EXRDHOLD_SETUP = (($1 >> 14) & 0x0003)
      )
      prop CE1_SCR1_SETUP_update :: (
          .CE1_RDHOLD_SETUP = ($1 & 0x0003),
          .CE1_RDSTROBE_SETUP = (($1 >> 2) & 0x003F),
          .CE1_RDSET_SETUP = (($1 >> 8) & 0x000F),
          .CE1_MTYPE_SETUP = (($a = $1 & 0x7000),
              ($a == 0x0000) ? "8-bit wide Asynchronous" :
              ($a == 0x1000) ? "16-bit wide Asynchronous" :
              ($a == 0x2000) ? "32-bit wide Asynchronous" :
              ($a == 0x3000) ? "32-bit wide SDRAM" :
              "32-bit wide SBSRAM")
      )
      prop CE1_SCR2_SETUP_update :: (
          .CE1_WRHOLD_SETUP = ($1 & 0x0003),
          .CE1_WRSTROBE_SETUP = (($1 >> 2) & 0x003F),
          .CE1_WRSET_SETUP = (($1 >> 8) & 0x000F),
          .CE1_EXWRHOLD_SETUP = (($1 >> 12) & 0x0003),
          .CE1_EXRDHOLD_SETUP = (($1 >> 14) & 0x0003)
      )
      prop CE2_SCR1_SETUP_update :: (
          .CE2_RDHOLD_SETUP = ($1 & 0x0003),
          .CE2_RDSTROBE_SETUP = (($1 >> 2) & 0x003F),
          .CE2_RDSET_SETUP = (($1 >> 8) & 0x000F),
          .CE2_MTYPE_SETUP = (($a = $1 & 0x7000),
              ($a == 0x0000) ? "8-bit wide Asynchronous" :
              ($a == 0x1000) ? "16-bit wide Asynchronous" :
              ($a == 0x2000) ? "32-bit wide Asynchronous" :
              ($a == 0x3000) ? "32-bit wide SDRAM" :
              "32-bit wide SBSRAM")
      )
      prop CE2_SCR2_SETUP_update :: (
          .CE2_WRHOLD_SETUP = ($1 & 0x0003),
          .CE2_WRSTROBE_SETUP = (($1 >> 2) & 0x003F),
          .CE2_WRSET_SETUP = (($1 >> 8) & 0x000F),
          .CE2_EXWRHOLD_SETUP = (($1 >> 12) & 0x0003),
          .CE2_EXRDHOLD_SETUP = (($1 >> 14) & 0x0003)
      )
      prop CE3_SCR1_SETUP_update :: (
          .CE3_RDHOLD_SETUP = ($1 & 0x0003),
          .CE3_RDSTROBE_SETUP = (($1 >> 2) & 0x003F),
          .CE3_RDSET_SETUP = (($1 >> 8) & 0x000F),
          .CE3_MTYPE_SETUP = (($a = $1 & 0x7000),
              ($a == 0x0000) ? "8-bit wide Asynchronous" :
              ($a == 0x1000) ? "16-bit wide Asynchronous" :
              ($a == 0x2000) ? "32-bit wide Asynchronous" :
              ($a == 0x3000) ? "32-bit wide SDRAM" :
              "32-bit wide SBSRAM")
      )
      prop CE3_SCR2_SETUP_update :: (
          .CE3_WRHOLD_SETUP = ($1 & 0x0003),
          .CE3_WRSTROBE_SETUP = (($1 >> 2) & 0x003F),
          .CE3_WRSET_SETUP = (($1 >> 8) & 0x000F),
          .CE3_EXWRHOLD_SETUP = (($1 >> 12) & 0x0003),
          .CE3_EXRDHOLD_SETUP = (($1 >> 14) & 0x0003)
      )
      
      inst EMIF_man :: 0 {
          prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
          prop Label :: "Configure Manually "
	    prop JSName :: "emifManualConfigure"
          prop Visible :: 1
          prop Writable :: 1
          prop NoGen :: 1
          prop cGen :: 0
          prop TabName :: "Advanced"
      }
      inst GCR_VALUE :: .GCR_VALUE_update() {
          prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
          prop Format :: "0x%04x"
          prop Label :: "Global Control Register "
	    prop JSName :: "emifGcr"
          prop Visible :: 1
          prop Writable :: .EMIF_man
          prop NoGen :: 1
          prop cGen :: 1
          prop TabName :: "Advanced"
          prop Set :: ( if ((($1 >> 9) && 0x0007) <= 8) {
                            .GCR_VALUE = $1 & 0x0EAF,
                            .GCR_SETUP_update($1 & 0x0EAF)
                        }
                        else {
                            .error("MEMFREQ value is reserved")
                        },
                        "ok"
                      )
      }
      inst GRR_VALUE :: 0x0000 {
          prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
          prop Format :: "0x%04x"
          prop Label :: "Global Reset Register "
	    prop JSName :: "emifGrr"
          prop Visible :: 1
          prop Writable :: .EMIF_man
          prop NoGen :: 1
          prop cGen :: 1
          prop TabName :: "Advanced"
          prop Set :: ( if ($1 != 0x0000) {
                            .GRR_VALUE = 0xFFFF,
                            .RESET_SETUP = 1
                        }
                        else {
                            .GRR_VALUE = 0x0000,
                            .RESET_SETUP = 0
                        },
                        "ok"
                      )
      }
      inst CE0_SCR1_VALUE :: .CE0_SCR1_VALUE_update() {
          prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
          prop Format :: "0x%04x"
          prop Label :: "CE0 Space Control Register 1 "
	    prop JSName :: "emifCe0scr1"
          prop Visible :: 1
          prop Writable :: .EMIF_man
          prop NoGen :: 1
          prop cGen :: 1
          prop TabName :: "Advanced"
          prop Set :: ( if ((($1 >> 12) & 0x0007) <= 0x004) {
                            .CE0_SCR1_VALUE = $1 & 0x7FFF,
                            .CE0_SCR1_SETUP_update($1 & 0x7FFF)
                        }
                        else {
                            .error("MTYPE Value is reserved")
                        },
                        "ok"
                      )
      }
      inst CE0_SCR2_VALUE :: .CE0_SCR2_VALUE_update() {
          prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
          prop Format :: "0x%04x"
          prop Label :: "CE0 Space Control Register 2 "
	    prop JSName :: "emifCe0scr2"
          prop Visible :: 1
          prop Writable :: .EMIF_man
          prop NoGen :: 1
          prop cGen :: 1
          prop TabName :: "Advanced"
          prop Set :: ( .CE0_SCR2_VALUE = $1,
                        .CE0_SCR2_SETUP_update($1),
                        "ok"
                      )
      }
      inst CE0_SCR3_VALUE :: .CE0_SCR3_VALUE_update() {
          prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
          prop Format :: "0x%04x"
          prop Label :: "CE0 Space Control Register 3 "
	    prop JSName :: "emifCe0scr3"
          prop Visible :: 1
          prop Writable :: .EMIF_man
          prop NoGen :: 1
          prop cGen :: 1
          prop TabName :: "Advanced"
          prop Set :: ( .CE0_SCR3_VALUE = $1 & 0x00FF,
                        .CE0_TIMEOUT_SETUP = $1 & 0x00FF,
                        "ok"
                      )
      }
      inst CE1_SCR1_VALUE :: .CE1_SCR1_VALUE_update() {
          prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
          prop Format :: "0x%04x"
          prop Label :: "CE1 Space Control Register 1 "
	    prop JSName :: "emifCe1scr1"
          prop Visible :: 1
          prop Writable :: .EMIF_man
          prop NoGen :: 1
          prop cGen :: 1
          prop TabName :: "Advanced"
          prop Set :: ( if ((($1 >> 12) & 0x0007) <= 0x004) {
                            .CE1_SCR1_VALUE = $1 & 0x7FFF,
                            .CE1_SCR1_SETUP_update($1 & 0x7FFF)
                        }
                        else {
                            .error("MTYPE Value is reserved")
                        },
                        "ok"
                      )
      }
      inst CE1_SCR2_VALUE :: .CE1_SCR2_VALUE_update() {
          prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
          prop Format :: "0x%04x"
          prop Label :: "CE1 Space Control Register 2 "
	    prop JSName :: "emifCe1scr2"
          prop Visible :: 1
          prop Writable :: .EMIF_man
          prop NoGen :: 1
          prop cGen :: 1
          prop TabName :: "Advanced"
          prop Set :: ( .CE1_SCR2_VALUE = $1,
                        .CE1_SCR2_SETUP_update($1),
                        "ok"
                      )
      }
      inst CE1_SCR3_VALUE :: .CE1_SCR3_VALUE_update() {
          prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
          prop Format :: "0x%04x"
          prop Label :: "CE1 Space Control Register 3 "
	    prop JSName :: "emifCe1scr3"
          prop Visible :: 1
          prop Writable :: .EMIF_man
          prop NoGen :: 1
          prop cGen :: 1
          prop TabName :: "Advanced"
          prop Set :: ( .CE1_SCR3_VALUE = $1 & 0x00FF,
                        .CE1_TIMEOUT_SETUP = $1 & 0x00FF,
                        "ok"
                      )
      }
      inst CE2_SCR1_VALUE :: .CE2_SCR1_VALUE_update() {
          prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
          prop Format :: "0x%04x"
          prop Label :: "CE2 Space Control Register 1 "
	    prop JSName :: "emifCe2scr1"
          prop Visible :: 1
          prop Writable :: .EMIF_man
          prop NoGen :: 1
          prop cGen :: 1
          prop TabName :: "Advanced"
          prop Set :: ( if ((($1 >> 12) & 0x0007) <= 0x004) {
                            .CE2_SCR1_VALUE = $1 & 0x7FFF,
                            .CE2_SCR1_SETUP_update($1 & 0x7FFF)
                        }
                        else {
                            .error("MTYPE Value is reserved")
                        },
                        "ok"
                      )
      }
      inst CE2_SCR2_VALUE :: .CE2_SCR2_VALUE_update() {
          prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
          prop Format :: "0x%04x"
          prop Label :: "CE2 Space Control Register 2 "
	    prop JSName :: "emifCe2scr2"
          prop Visible :: 1
          prop Writable :: .EMIF_man
          prop NoGen :: 1
          prop cGen :: 1
          prop TabName :: "Advanced"
          prop Set :: (     .CE2_SCR2_VALUE = $1,
                            .CE2_SCR2_SETUP_update($1),
                            "ok"
                      )
      }
      inst CE2_SCR3_VALUE :: .CE2_SCR3_VALUE_update() {
          prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
          prop Format :: "0x%04x"
          prop Label :: "CE2 Space Control Register 3 "
	    prop JSName :: "emifCe2scr3"
          prop Visible :: 1
          prop Writable :: .EMIF_man
          prop NoGen :: 1
          prop cGen :: 1
          prop TabName :: "Advanced"
          prop Set :: ( .CE2_SCR3_VALUE = $1 & 0x00FF,
                        .CE2_TIMEOUT_SETUP = $1 & 0x00FF,
                        "ok"
                      )
      }
      inst CE3_SCR1_VALUE :: .CE3_SCR1_VALUE_update() {
          prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
          prop Format :: "0x%04x"
          prop Label :: "CE3 Space Control Register 1 "
	    prop JSName :: "emifCe3scr1"
          prop Visible :: 1
          prop Writable :: .EMIF_man
          prop NoGen :: 1
          prop cGen :: 1
          prop TabName :: "Advanced"
          prop Set :: ( if ((($1 >> 12) & 0x0007) <= 0x004) {
                            .CE3_SCR1_VALUE = $1 & 0x7FFF,
                            .CE3_SCR1_SETUP_update($1 & 0x7FFF)
                        }
                        else {
                            .error("MTYPE Value is reserved")
                        },
                        "ok"
                      )
      }
      inst CE3_SCR2_VALUE :: .CE3_SCR2_VALUE_update() {
          prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
          prop Format :: "0x%04x"
          prop Label :: "CE3 Space Control Register 2 "
	    prop JSName :: "emifCe3scr2"
          prop Visible :: 1
          prop Writable :: .EMIF_man
          prop NoGen :: 1
          prop cGen :: 1
          prop TabName :: "Advanced"
          prop Set :: ( .CE3_SCR2_VALUE = $1,
                        .CE3_SCR2_SETUP_update($1),
                        "ok"
                      )
      }
      inst CE3_SCR3_VALUE :: .CE3_SCR3_VALUE_update() {
          prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
          prop Format :: "0x%04x"
          prop Label :: "CE3 Space Control Register 3 "
	    prop JSName :: "emifCe3scr3"
          prop Visible :: 1
          prop Writable :: .EMIF_man
          prop NoGen :: 1
          prop cGen :: 1
          prop TabName :: "Advanced"
          prop Set :: ( .CE3_SCR3_VALUE = $1 & 0x00FF,
                        .CE3_TIMEOUT_SETUP = $1 & 0x00FF,
                        "ok"
                      )
      }
      inst SDCR1_VALUE :: .SDCR1_VALUE_update() {
          prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
          prop Format :: "0x%04x"
          prop Label :: "SDRAM Control Register 1 "
	    prop JSName :: "emifSdcr1"
          prop Visible :: 1
          prop Writable :: .EMIF_man
          prop NoGen :: 1
          prop cGen :: 1
          prop TabName :: "Advanced"
          prop Set :: ( .SDCR1_VALUE = $1,
                        .SDCR1_SETUP_update($1),
                        "ok"
                      )
      }
      inst SDPERIOD_VALUE :: .SDPERIOD_SETUP {
          prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
          prop Format :: "0x%04x"
          prop Label :: "SDRAM Period Register "
	    prop JSName :: "emifSdperiodAdv"
          prop Visible :: 1
          prop Writable :: .EMIF_man
          prop NoGen :: 1
          prop cGen :: 1
          prop TabName :: "Advanced"
          prop Set :: ( .SDPERIOD_VALUE = $1 & 0x0FFF,
                        .SDPERIOD_SETUP = $1 & 0x0FFF,
                        "ok"
                      )
      }
      inst SDINIT_VALUE :: .SDINIT_SETUP {
          prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
          prop Format :: "0x%04x"
          prop Label :: "SDRAM Initialization Register "
	    prop JSName :: "emifSdinitAdv"
          prop Visible :: 1
          prop Writable :: .EMIF_man
          prop NoGen :: 1
          prop cGen :: 1
          prop TabName :: "Advanced"
          prop Set :: ( if ($1 != 0x0000) {
                            .SDINIT_SETUP = 1,
                            .SDINIT_VALUE = 0xFFFF
                        }
                        else {
                            .SDINIT_SETUP = 0,
                            .SDINIT_VALUE = 0
                        },
                        "ok"
                      )
      }
      inst SDCR2_VALUE :: .SDCR2_VALUE_update() {
          prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
          prop Format :: "0x%04x"
          prop Label :: "SDRAM Control Register 2 "
	    prop JSName :: "emifSdcr2"
          prop Visible :: 1
          prop Writable :: .EMIF_man
          prop NoGen :: 1
          prop cGen :: 1
          prop TabName :: "Advanced"
          prop Set :: ( .SDCR2_VALUE = $1 & 0x07FF,
                        .SDCR2_SETUP_update($1 & 0x07FF),
                        "ok"
                      )
      }
}
type hEMIF {
	isa ObjectMgr
	prop name :: "hEMIF"
	prop Label :: "EMIF Resource Manager"
	prop JSName :: "HEMIF"
	prop GlobalHelpTopic :: 1042
	prop InstanceHelpTopic :: 1042
	prop GlobalIcon :: 163
	prop InstanceIcon :: 164
	prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-00105A98CA0B}"
        prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-0000C070F3E9}"
    	prop Vendor :: "vendor1"
    	prop Version :: "1.00.00"
	prop IsContainedIn :: EMIFFOLDER
	
	prop maxObjs :: (
		(GBL.CHIPTYPE == "5510") ? 1 :
		1
	)
	prop NoGen :: 1
	prop cGen :: 1
	prop cHandle :: 0
	prop cHeaderName :: .c55emif == 1 ? "csl_emif.h" : ""
	prop cConfigName :: "EMIF_config"
	global c55emif :: 0 {
          prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Label :: "C55x EMIF opened "
	    prop Visible :: 0
	    prop Writable :: 1
	    prop NoGen :: 1
	    prop cGen :: 0
      }
	global GblEmifReset :: 0 {
          prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Label :: "Global Reset of EMIF"
	    prop Visible :: 0
	    prop Writable :: 1
	    prop NoGen :: 1
	    prop cGen :: 0
      }
    	inst PINIT_ENABLE :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Enable pre-initialization "
	  prop JSName :: "emifEnablePreInit"
	  prop Visible :: 1
	  prop Writable :: 1
	  prop NoGen :: 1
	  prop Set :: (
		$a = 0,
		scan ($b; emifCfg) {
			$a = 1
		},
		if ($a == 0) {
			"You must create a configuration object"
		}
		else {
			.PINIT_ENABLE = $1,
			.cConfigArg0 = EMIF_NOTHING
		},
            if ($1 == 1) {
                .c55emif = 1
            }
            else {
                .c55emif = 0
            },
            "ok"
	  )
    	}
	inst cConfigGen ::= ((.PINIT_ENABLE == 1) && (.cConfigArg0 != EMIF_NOTHING)) {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
      }
     	inst cConfigArg0 :: EMIF_NOTHING {
	  prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	  prop MemberType :: emifCfg
	  prop Label :: "Pre-initialize "
	  prop JSName :: "emifPreInit"
	  prop Visible :: 1
	  prop Writable :: (.PINIT_ENABLE == 1)
	  prop NoGen :: 0
	  prop cPreVal :: "&"
        prop Set :: (
              .cConfigArg0 = $1,
              "ok"
        )
    	}
      prop emifRstFxnName :: ((hEMIF.GblEmifReset) ? "EMIF_RSET(EMIRST,0xFFFFu);":"")
      prop cGenFxnEpilogue :: (
	        "\n\t%1S\n\0,emifRstFxnName"
      )
}
object EMIF_NOTHING :: emifCfg {
    param iIsUsed :: 0
}
object hEMIF0 :: hEMIF {
    param iComment :: .iDelMsg
    param iIsUsed :: 1  
    param iDelUser :: "hEMIF"
    param iDelMsg :: ("EMIF")
}
type GPIOFOLDER {
    	prop Label :: "GPIO - General Purpose Input/Output"
    	prop GlobalIcon :: 171
    	prop GlobalPropertyPage :: "{B976FB91-49A5-11d4-967C-0050048381B7}"
	prop GlobalHelpTopic :: 1050
    	prop IsContainedIn :: CSL
      prop NoGen :: 1
}
type gpioCfg {
	isa ObjectMgr
	prop name :: "gpioCfg"
	prop Label :: "Non-Multiplexed GPIO Configuration "
      prop JSName :: "GPIO"
	prop GlobalHelpTopic :: 1051
	prop InstanceHelpTopic :: 1051
	prop GlobalIcon :: 171
	prop InstanceIcon :: 172
	prop GlobalPropertyPage :: "{C5CB30B4-F115-11d2-84A7-10105A98CA0B}"
      prop InstancePropertyPage :: "{AC0C36D1-840B-11d0-A627-1000C070F3E9}"
    	prop Vendor :: "vendor1"
    	prop Version :: "1.00.00"
	prop IsContainedIn :: GPIOFOLDER
	
	prop NoGen :: 1
	prop cHandle :: 0
	prop cGen :: 1
    	prop cStruct :: 0
	prop cHeaderName :: .c55gpio == 1 ? "csl_gpio.h" : ""
	prop maxObjs :: 0
      prop apgio_Support :: ( (GBL.CHIPTYPE == "5509") ||
                              (GBL.CHIPTYPE == "5509A") ||
                              (GBL.CHIPTYPE == "5509PG1_0") ||
                              (GBL.CHIPTYPE == "5509PG2_0") 
      )
      prop gpioen_Support :: ( (GBL.CHIPTYPE == "5509") ||
                               (GBL.CHIPTYPE == "5509A") ||
                                 (GBL.CHIPTYPE == "5509PG1_0") ||
                                 (GBL.CHIPTYPE == "5509PG2_0")
      )
	global c55gpio :: 0 {
          prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Label :: "C55x GPIO opened "
	    prop Visible :: 0
	    prop Writable :: 1
	    prop NoGen :: 1
	    prop cGen :: 0
      }
      global configGPIO :: 0 {
		prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
		prop Label :: "Enable Pre-initialization "
            prop JSName :: "gpioConfigure"
		prop Visible :: 1
		prop Writable :: 1
		prop NoGen :: 1
		prop cGen :: 0
            prop TabName :: "General"
            prop Set :: (
               .configGPIO = $1,
               if ($1 == 1) {
                   .c55gpio = 1
               }
               else {
                   .c55gpio = 0
               },
               "ok"
          )
	}
	global iodirIOMask :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Label :: "IODIR I/O Mask"
	  prop Format :: "0x%04x"
	  prop Visible :: 0
	  prop Writable :: 1
	  prop NoGen :: 1
	  prop TabName :: "Non-Power Down I/O Pins"
	}
	global iodataIOMask :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Label :: "IODATA I/O Mask"
	  prop Format :: "0x%04x"
	  prop Visible :: 0
	  prop Writable :: 1
	  prop NoGen :: 1
	  prop TabName :: "Non-Power Down I/O Pins"
	}
	global IODIR0_IO :: "Input" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "IO0 "
	  prop Enum  :: "Input,Output Low,Output High"
	  prop JSName :: "gpioIo0dir"
	  prop Visible :: 1
	  prop Writable :: .configGPIO
	  prop NoGen :: 1
	  prop TabName :: "Non-Power Down I/O Pins"
	  prop Set :: (.IODIR0_IO = $1,
                    if (.IODIR0_IO == "Output Low") {
                     	 .iodirIOMask |= (0x0001),
                    	 .iodataIOMask &= (0xFFFE)
                     }
                     else { 
				if (.IODIR0_IO == "Output High") {
               		   .iodirIOMask |= (0x0001),
               	         .iodataIOMask |= (0x0001)
				}
				else {		
                    	   .iodirIOMask &= (0xFFFE),
                    	   .iodataIOMask &= (0xFFFE)
				}
                     },   
                     .IODIRMSK_VALUE = .iodirIOMask,
                     .IODATAMSK_VALUE = .iodataIOMask,
			   "ok"
          )
 
      }
	global IODIR1_IO :: "Input" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "IO1 "
	  prop Enum  :: "Input,Output Low,Output High"
	  prop JSName :: "gpioIo1dir"
	  prop Visible :: 1
	  prop Writable :: .configGPIO
	  prop NoGen :: 1
	  prop TabName :: "Non-Power Down I/O Pins"
	  prop Set :: (.IODIR1_IO = $1,
                    if (.IODIR1_IO == "Output Low") {
                     	 .iodirIOMask |= (0x0002),
                    	 .iodataIOMask &= (0xFFFD)
                     }
                     else { 
				if (.IODIR1_IO == "Output High") {
               		   .iodirIOMask |= (0x0002),
               	         .iodataIOMask |= (0x0002)
				}
				else {		
                    	   .iodirIOMask &= (0xFFFD),
                    	   .iodataIOMask &= (0xFFFD)
				}
                     },   
                     .IODIRMSK_VALUE = .iodirIOMask,
                     .IODATAMSK_VALUE = .iodataIOMask,
			   "ok"
             )
      }
	
	global IODIR2_IO :: "Input" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "IO2 "
	  prop Enum  :: "Input,Output Low,Output High"
	  prop JSName :: "gpioIo2dir"
	  prop Visible :: 1
	  prop Writable :: .configGPIO
	  prop NoGen :: 1
	  prop TabName :: "Non-Power Down I/O Pins"
	  prop Set :: (.IODIR2_IO = $1,
                    if (.IODIR2_IO == "Output Low") {
                     	 .iodirIOMask |= (0x0004),
                    	 .iodataIOMask &= (0xFFFB)
                     }
                     else { 
				if (.IODIR2_IO == "Output High") {
               		   .iodirIOMask |= (0x0004),
               	         .iodataIOMask |= (0x0004)
				}
				else {		
                    	   .iodirIOMask &= (0xFFFB),
                    	   .iodataIOMask &= (0xFFFB)
				}
                     },   
                     .IODIRMSK_VALUE = .iodirIOMask,
                     .IODATAMSK_VALUE = .iodataIOMask,
			   "ok"
             )
      }
	
	global IODIR3_IO :: "Input" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "IO3 "
	  prop Enum  :: "Input,Output Low,Output High"
	  prop JSName :: "gpioIo3dir"
	  prop Visible :: 1
	  prop Writable :: .configGPIO
	  prop NoGen :: 1
	  prop TabName :: "Non-Power Down I/O Pins"
	  prop Set :: (.IODIR3_IO = $1,
                    if (.IODIR3_IO == "Output Low") {
                     	 .iodirIOMask |= (0x0008),
                    	 .iodataIOMask &= (0xFFF7)
                     }
                     else { 
				if (.IODIR3_IO == "Output High") {
               		   .iodirIOMask |= (0x0008),
               	         .iodataIOMask |= (0x0008)
				}
				else {		
                    	   .iodirIOMask &= (0xFFF7),
                    	   .iodataIOMask &= (0xFFF7)
				}
                     },   
                     .IODIRMSK_VALUE = .iodirIOMask,
                     .IODATAMSK_VALUE = .iodataIOMask,
			   "ok"
             )
      }
	global IODIR4_IO :: "Input" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "IO4 "
	  prop Enum  :: "Input,Output Low,Output High"
	  prop JSName :: "gpioIo4dir"
	  prop Visible :: 1
	  prop Writable :: .configGPIO
	  prop NoGen :: 1
	  prop TabName :: "Non-Power Down I/O Pins"
	  prop Set :: (.IODIR4_IO = $1,
                    if (.IODIR4_IO == "Output Low") {
                     	 .iodirIOMask |= (0x0010),
                    	 .iodataIOMask &= (0xFFEF)
                     }
                     else { 
				if (.IODIR4_IO == "Output High") {
               		   .iodirIOMask |= (0x0010),
               	         .iodataIOMask |= (0x0010)
				}
				else {		
                    	   .iodirIOMask &= (0xFFEF),
                    	   .iodataIOMask &= (0xFFEF)
				}
                     },   
                     .IODIRMSK_VALUE = .iodirIOMask,
                     .IODATAMSK_VALUE = .iodataIOMask,
			   "ok"
             )
      }
	global IODIR5_IO :: "Input" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "IO5 "
	  prop Enum  :: "Input,Output Low,Output High"
	  prop JSName :: "gpioIo5dir"
	  prop Visible :: 1
	  prop Writable :: .configGPIO
	  prop NoGen :: 1
	  prop TabName :: "Non-Power Down I/O Pins"
	  prop Set :: (.IODIR5_IO = $1,
                    if (.IODIR5_IO == "Output Low") {
                     	 .iodirIOMask |= (0x0020),
                    	 .iodataIOMask &= (0xFFDF)
                     }
                     else { 
				if (.IODIR5_IO == "Output High") {
               		   .iodirIOMask |= (0x0020),
               	         .iodataIOMask |= (0x0020)
				}
				else {		
                    	   .iodirIOMask &= (0xFFDF),
                    	   .iodataIOMask &= (0xFFDF)
				}
                     },   
                     .IODIRMSK_VALUE = .iodirIOMask,
                     .IODATAMSK_VALUE = .iodataIOMask,
			   "ok"
             )
      }
	
	global IODIR6_IO :: "Input" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "IO6 "
	  prop Enum  :: "Input,Output Low,Output High"
	  prop JSName :: "gpioIo6dir"
	  prop Visible :: 1
	  prop Writable :: .configGPIO
	  prop NoGen :: 1
	  prop TabName :: "Non-Power Down I/O Pins"
	  prop Set :: (.IODIR6_IO = $1,
                    if (.IODIR6_IO == "Output Low") {
                     	 .iodirIOMask |= (0x0040),
                    	 .iodataIOMask &= (0xFFBF)
                     }
                     else { 
				if (.IODIR6_IO == "Output High") {
               		   .iodirIOMask |= (0x0040),
               	         .iodataIOMask |= (0x0040)
				}
				else {		
                    	   .iodirIOMask &= (0xFFBF),
                    	   .iodataIOMask &= (0xFFBF)
				}
                     },   
                     .IODIRMSK_VALUE = .iodirIOMask,
                     .IODATAMSK_VALUE = .iodataIOMask,
			   "ok"
             )
      }
	
	global IODIR7_IO :: "Input" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "IO7 "
	  prop Enum  :: "Input,Output Low,Output High"
	  prop JSName :: "gpioIo7dir"
	  prop Visible :: 1
	  prop Writable :: .configGPIO
	  prop NoGen :: 1
	  prop TabName :: "Non-Power Down I/O Pins"
	  prop Set :: (.IODIR7_IO = $1,
                    if (.IODIR7_IO == "Output Low") {
                     	 .iodirIOMask |= (0x0080),
                    	 .iodataIOMask &= (0xFF7F)
                     }
                     else { 
				if (.IODIR7_IO == "Output High") {
               		   .iodirIOMask |= (0x0080),
               	         .iodataIOMask |= (0x0080)
				}
				else {		
                    	   .iodirIOMask &= (0xFF7F),
                    	   .iodataIOMask &= (0xFF7F)
				}
                     },   
                     .IODIRMSK_VALUE = .iodirIOMask,
                     .IODATAMSK_VALUE = .iodataIOMask,
			   "ok"
             )
      }
	global NOTE :: "These pins cannot be configured, via software, to be held active/inactive at CPU power-down" {
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop TabName :: "Non-Power Down I/O Pins"
        prop NoGen :: 1
	} 
	global aiodirMask :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Label :: "AIODIR I/O Mask"
	  prop Format :: "0x%04x"
	  prop Visible :: 0
	  prop Writable :: ebselCfg.ADDRESS
	  prop NoGen :: 1
	  prop TabName :: "Power Down Address I/O Pins"
	}
	global aiodataMask :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Label :: "AIODATA I/O Mask"
	  prop Format :: "0x%04x"
	  prop Visible :: 0
	  prop Writable :: ebselCfg.ADDRESS
	  prop NoGen :: 1
	  prop TabName :: "Power Down Address I/O Pins"
	}
	global aioenMask :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Label :: "AIOEN I/O Mask"
	  prop Format :: "0x%04x"
	  prop Visible :: 0
	  prop Writable :: ebselCfg.ADDRESS
	  prop NoGen :: 1
	  prop TabName :: "Power Down Address I/O Pins"
	}
	global AGPIODIR0 :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum ::  "Disabled,Input,Output Low,Output High"
	  prop Label :: "AGPIO0 "
	  prop JSName :: "gpioAgpio0dir"
        prop Visible :: 1
	  prop Writable :: (gpioCfg.agpio_Support) && (.configGPIO) && (ebselCfg.ADDRESS)
	  prop NoGen :: 1
	  prop TabName :: "Power Down Address I/O Pins"
	  prop Set :: (.AGPIODIR0 = $1,
			if (.AGPIODIR0 == "Disabled")
			{
			   .aioenMask &= (0xFFFE),
                     .aiodirMask &= (0xFFFE),
                     .aiodataMask &= (0xFFFE)
			}
			else
			{
			  .aioenMask |= (0x0001),
                    if (.AGPIODIR0 == "Output Low") {
                     	 .aiodirMask |= (0x0001),
                    	 .aiodataMask &= (0xFFFE)
                     }
                     else { 
				if (.AGPIODIR0 == "Output High") {
               		   .aiodirMask |= (0x0001),
               	         .aiodataMask |= (0x0001)
				}
				else {		
                    	   .aiodirMask &= (0xFFFE),
                    	   .aiodataMask &= (0xFFFE)
				}
                     }
			},
			   .AIOENMSK_VALUE = .aioenMask,
                     .AIODIRMSK_VALUE = .aiodirMask,
                     .AIODATAMSK_VALUE = .aiodataMask,
			   "ok"
             	  )
	}
	global AGPIODIR1 :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum ::  "Disabled,Input,Output Low,Output High"
	  prop Label :: "AGPIO1 "
	  prop JSName :: "gpioAgpio1dir"
	  prop Visible :: 1
	  prop Writable :: (gpioCfg.agpio_Support) && (.configGPIO) && (ebselCfg.ADDRESS)
	  prop NoGen :: 1
	  prop TabName :: "Power Down Address I/O Pins"
	  prop Set :: (.AGPIODIR1 = $1,
			if (.AGPIODIR1 == "Disabled")
			{
			   .aioenMask &= (0xFFFD),
                     .aiodirMask &= (0xFFFD),
                     .aiodataMask &= (0xFFFD)
			}
			else
			{
			  .aioenMask |= (0x0002),
                    if (.AGPIODIR1 == "Output Low") {
                     	 .aiodirMask |= (0x0002),
                    	 .aiodataMask &= (0xFFFD)
                     }
                     else { 
				if (.AGPIODIR1 == "Output High") {
               		   .aiodirMask |= (0x0002),
               	         .aiodataMask |= (0x0002)
				}
				else {		
                    	   .aiodirMask &= (0xFFFD),
                    	   .aiodataMask &= (0xFFFD)
				}
                     }
			},
			   .AIOENMSK_VALUE = .aioenMask,
                     .AIODIRMSK_VALUE = .aiodirMask,
                     .AIODATAMSK_VALUE = .aiodataMask,
			   "ok"
             	  )
	}
	global AGPIODIR2 :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum ::  "Disabled,Input,Output Low,Output High"
	  prop Label :: "AGPIO2 "
	  prop JSName :: "gpioAgpio2dir"
	  prop Visible :: 1
	  prop Writable :: (gpioCfg.agpio_Support) && (.configGPIO) && (ebselCfg.ADDRESS)
	  prop NoGen :: 1
	  prop TabName :: "Power Down Address I/O Pins"
	  prop Set :: (.AGPIODIR2 = $1,
			if (.AGPIODIR2 == "Disabled")
			{
			   .aioenMask &= (0xFFFB),
                     .aiodirMask &= (0xFFFB),
                     .aiodataMask &= (0xFFFB)
			}
			else
			{
			  .aioenMask |= (0x0004),
                    if (.AGPIODIR2 == "Output Low") {
                     	 .aiodirMask |= (0x0004),
                    	 .aiodataMask &= (0xFFFB)
                     }
                     else { 
				if (.AGPIODIR2 == "Output High") {
               		   .aiodirMask |= (0x0004),
               	         .aiodataMask |= (0x0004)
				}
				else {		
                    	   .aiodirMask &= (0xFFFB),
                    	   .aiodataMask &= (0xFFFB)
				}
                     }
			},
			   .AIOENMSK_VALUE = .aioenMask,
                     .AIODIRMSK_VALUE = .aiodirMask,
                     .AIODATAMSK_VALUE = .aiodataMask,
			   "ok"
             	  )
	}
	global AGPIODIR3 :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum ::  "Disabled,Input,Output Low,Output High"
	  prop Label :: "AGPIO3 "
	  prop JSName :: "gpioAgpio3dir"
	  prop Visible :: 1
	  prop Writable :: (gpioCfg.agpio_Support) && (.configGPIO) && (ebselCfg.ADDRESS)
	  prop NoGen :: 1
	  prop TabName :: "Power Down Address I/O Pins"
	  prop Set :: (.AGPIODIR3 = $1,
			if (.AGPIODIR3 == "Disabled")
			{
			   .aioenMask &= (0xFFF7),
                     .aiodirMask &= (0xFFF7),
                     .aiodataMask &= (0xFFF7)
			}
			else
			{
			  .aioenMask |= (0x0008),
                    if (.AGPIODIR3 == "Output Low") {
                     	 .aiodirMask |= (0x0008),
                    	 .aiodataMask &= (0xFFF7)
                     }
                     else { 
				if (.AGPIODIR3 == "Output High") {
               		   .aiodirMask |= (0x0008),
               	         .aiodataMask |= (0x0008)
				}
				else {		
                    	   .aiodirMask &= (0xFFF7),
                    	   .aiodataMask &= (0xFFF7)
				}
                     }
			},
			   .AIOENMSK_VALUE = .aioenMask,
                     .AIODIRMSK_VALUE = .aiodirMask,
                     .AIODATAMSK_VALUE = .aiodataMask,
			   "ok"
             	  )
	}
	global AGPIODIR4 :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum ::  "Disabled,Input,Output Low,Output High"
	  prop Label :: "AGPIO4 "
	  prop JSName :: "gpioAgpio4dir"
	  prop Visible :: 1
	  prop Writable :: (gpioCfg.agpio_Support) && (.configGPIO) && (ebselCfg.ADDRESS)
	  prop NoGen :: 1
	  prop TabName :: "Power Down Address I/O Pins"
	  prop Set :: (.AGPIODIR4 = $1,
			if (.AGPIODIR4 == "Disabled")
			{
			   .aioenMask &= (0xFFEF),
                     .aiodirMask &= (0xFFEF),
                     .aiodataMask &= (0xFFEF)
			}
			else
			{
			  .aioenMask |= (0x0010),
                    if (.AGPIODIR4 == "Output Low") {
                     	 .aiodirMask |= (0x0010),
                    	 .aiodataMask &= (0xFFEF)
                     }
                     else { 
				if (.AGPIODIR4 == "Output High") {
               		   .aiodirMask |= (0x0010),
               	         .aiodataMask |= (0x0010)
				}
				else {		
                    	   .aiodirMask &= (0xFFEF),
                    	   .aiodataMask &= (0xFFEF)
				}
                     }
			},
			   .AIOENMSK_VALUE = .aioenMask,
                     .AIODIRMSK_VALUE = .aiodirMask,
                     .AIODATAMSK_VALUE = .aiodataMask,
			   "ok"
             	  )
	}
	global AGPIODIR5 :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum ::  "Disabled,Input,Output Low,Output High"
	  prop Label :: "AGPIO5 "
	  prop JSName :: "gpioAgpio5dir"
	  prop Visible :: 1
	  prop Writable :: (gpioCfg.agpio_Support) && (.configGPIO) && (ebselCfg.ADDRESS)
	  prop NoGen :: 1
	  prop TabName :: "Power Down Address I/O Pins"
	  prop Set :: (.AGPIODIR5 = $1,
			if (.AGPIODIR5 == "Disabled")
			{
			   .aioenMask &= (0xFFDF),
                     .aiodirMask &= (0xFFDF),
                     .aiodataMask &= (0xFFDF)
			}
			else
			{
			  .aioenMask |= (0x0020),
                    if (.AGPIODIR5 == "Output Low") {
                     	 .aiodirMask |= (0x0020),
                    	 .aiodataMask &= (0xFFDF)
                     }
                     else { 
				if (.AGPIODIR5 == "Output High") {
               		   .aiodirMask |= (0x0020),
               	         .aiodataMask |= (0x0020)
				}
				else {		
                    	   .aiodirMask &= (0xFFDF),
                    	   .aiodataMask &= (0xFFDF)
				}
                     }
			},
			   .AIOENMSK_VALUE = .aioenMask,
                     .AIODIRMSK_VALUE = .aiodirMask,
                     .AIODATAMSK_VALUE = .aiodataMask,
			   "ok"
             	  )
	}
	global AGPIODIR6 :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum ::  "Disabled,Input,Output Low,Output High"
	  prop Label :: "AGPIO6 "
	  prop JSName :: "gpioAgpio6dir"
	  prop Visible :: 1
	  prop Writable :: (gpioCfg.agpio_Support) && (.configGPIO) && (ebselCfg.ADDRESS)
	  prop NoGen :: 1
	  prop TabName :: "Power Down Address I/O Pins"
	  prop Set :: (.AGPIODIR6 = $1,
			if (.AGPIODIR6 == "Disabled")
			{
			   .aioenMask &= (0xFFBF),
                     .aiodirMask &= (0xFFBF),
                     .aiodataMask &= (0xFFBF)
			}
			else
			{
			  .aioenMask |= (0x0040),
                    if (.AGPIODIR6 == "Output Low") {
                     	 .aiodirMask |= (0x0040),
                    	 .aiodataMask &= (0xFFBF)
                     }
                     else { 
				if (.AGPIODIR6 == "Output High") {
               		   .aiodirMask |= (0x0040),
               	         .aiodataMask |= (0x0040)
				}
				else {		
                    	   .aiodirMask &= (0xFFBF),
                    	   .aiodataMask &= (0xFFBF)
				}
                     }
			},
			   .AIOENMSK_VALUE = .aioenMask,
                     .AIODIRMSK_VALUE = .aiodirMask,
                     .AIODATAMSK_VALUE = .aiodataMask,
			   "ok"
             	  )
	}
	global AGPIODIR7 :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum ::  "Disabled,Input,Output Low,Output High"
	  prop Label :: "AGPIO7 "
	  prop JSName :: "gpioAgpio7dir"
	  prop Visible :: 1
	  prop Writable :: (gpioCfg.agpio_Support) && (.configGPIO) && (ebselCfg.ADDRESS)
	  prop NoGen :: 1
	  prop TabName :: "Power Down Address I/O Pins"
	  prop Set :: (.AGPIODIR7 = $1,
			if (.AGPIODIR7 == "Disabled")
			{
			   .aioenMask &= (0xFF7F),
                     .aiodirMask &= (0xFF7F),
                     .aiodataMask &= (0xFF7F)
			}
			else
			{
			  .aioenMask |= (0x0080),
                    if (.AGPIODIR7 == "Output Low") {
                     	 .aiodirMask |= (0x0080),
                    	 .aiodataMask &= (0xFF7F)
                     }
                     else { 
				if (.AGPIODIR7 == "Output High") {
               		   .aiodirMask |= (0x0080),
               	         .aiodataMask |= (0x0080)
				}
				else {		
                    	   .aiodirMask &= (0xFF7F),
                    	   .aiodataMask &= (0xFF7F)
				}
                     }
			},
			   .AIOENMSK_VALUE = .aioenMask,
                     .AIODIRMSK_VALUE = .aiodirMask,
                     .AIODATAMSK_VALUE = .aiodataMask,
			   "ok"
             	  )
	}
	global AGPIODIR8 :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum ::  "Disabled,Input,Output Low,Output High"
	  prop Label :: "AGPIO8 "
	  prop JSName :: "gpioAgpio8dir"
	  prop Visible :: 1
	  prop Writable :: (gpioCfg.agpio_Support) && (.configGPIO) && (ebselCfg.ADDRESS)
	  prop NoGen :: 1
	  prop TabName :: "Power Down Address I/O Pins"
	  prop Set :: (.AGPIODIR8 = $1,
			if (.AGPIODIR8 == "Disabled")
			{
			   .aioenMask &= (0xFEFF),
                     .aiodirMask &= (0xFEFF),
                     .aiodataMask &= (0xFEFF)
			}
			else
			{
			  .aioenMask |= (0x0100),
                    if (.AGPIODIR8 == "Output Low") {
                     	 .aiodirMask |= (0x0100),
                    	 .aiodataMask &= (0xFEFF)
                     }
                     else { 
				if (.AGPIODIR8 == "Output High") {
               		   .aiodirMask |= (0x0100),
               	         .aiodataMask |= (0x0100)
				}
				else {		
                    	   .aiodirMask &= (0xFEFF),
                    	   .aiodataMask &= (0xFEFF)
				}
                     }
			},
			   .AIOENMSK_VALUE = .aioenMask,
                     .AIODIRMSK_VALUE = .aiodirMask,
                     .AIODATAMSK_VALUE = .aiodataMask,
			   "ok"
             	  )
	}
	global AGPIODIR9 :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum ::  "Disabled,Input,Output Low,Output High"
	  prop Label :: "AGPIO9 "
	  prop JSName :: "gpioAgpio9dir"
	  prop Visible :: 1
	  prop Writable :: (gpioCfg.agpio_Support) && (.configGPIO) && (ebselCfg.ADDRESS)
	  prop NoGen :: 1
	  prop TabName :: "Power Down Address I/O Pins"
	  prop Set :: (.AGPIODIR9 = $1,
			if (.AGPIODIR9 == "Disabled")
			{
			   .aioenMask &= (0xFDFF),
                     .aiodirMask &= (0xFDFF),
                     .aiodataMask &= (0xFDFF)
			}
			else
			{
			  .aioenMask |= (0x0200),
                    if (.AGPIODIR9 == "Output Low") {
                     	 .aiodirMask |= (0x0200),
                    	 .aiodataMask &= (0xFDFF)
                     }
                     else { 
				if (.AGPIODIR9 == "Output High") {
               		   .aiodirMask |= (0x0200),
               	         .aiodataMask |= (0x0200)
				}
				else {		
                    	   .aiodirMask &= (0xFDFF),
                    	   .aiodataMask &= (0xFDFF)
				}
                     }
			},
			   .AIOENMSK_VALUE = .aioenMask,
                     .AIODIRMSK_VALUE = .aiodirMask,
                     .AIODATAMSK_VALUE = .aiodataMask,
			   "ok"
             	  )
	}
	global AGPIODIR10 :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum ::  "Disabled,Input,Output Low,Output High"
	  prop Label :: "AGPIO10 "
	  prop JSName :: "gpioAgpio10dir"
	  prop Visible :: 1
	  prop Writable :: (gpioCfg.agpio_Support) && (.configGPIO) && (ebselCfg.ADDRESS)
	  prop NoGen :: 1
	  prop TabName :: "Power Down Address I/O Pins"
	  prop Set :: (.AGPIODIR10 = $1,
			if (.AGPIODIR10 == "Disabled")
			{
			   .aioenMask &= (0xFBFF),
                     .aiodirMask &= (0xFBFF),
                     .aiodataMask &= (0xFBFF)
			}
			else
			{
			  .aioenMask |= (0x0400),
                    if (.AGPIODIR10 == "Output Low") {
                     	 .aiodirMask |= (0x0400),
                    	 .aiodataMask &= (0xFBFF)
                     }
                     else { 
				if (.AGPIODIR10 == "Output High") {
               		   .aiodirMask |= (0x0400),
               	         .aiodataMask |= (0x0400)
				}
				else {		
                    	   .aiodirMask &= (0xFBFF),
                    	   .aiodataMask &= (0xFBFF)
				}
                     }
			},
			   .AIOENMSK_VALUE = .aioenMask,
                     .AIODIRMSK_VALUE = .aiodirMask,
                     .AIODATAMSK_VALUE = .aiodataMask,
			   "ok"
             	  )
	}
	global AGPIODIR11 :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum ::  "Disabled,Input,Output Low,Output High"
	  prop Label :: "AGPIO11 "
	  prop JSName :: "gpioAgpio11dir"
	  prop Visible :: 1
	  prop Writable :: (gpioCfg.agpio_Support) && (.configGPIO) && (ebselCfg.ADDRESS)
	  prop NoGen :: 1
	  prop TabName :: "Power Down Address I/O Pins"
	  prop Set :: (.AGPIODIR11 = $1,
			if (.AGPIODIR11 == "Disabled")
			{
			   .aioenMask &= (0xF7FF),
                     .aiodirMask &= (0xF7FF),
                     .aiodataMask &= (0xF7FF)
			}
			else
			{
			  .aioenMask |= (0x0800),
                    if (.AGPIODIR11 == "Output Low") {
                     	 .aiodirMask |= (0x0800),
                    	 .aiodataMask &= (0xF7FF)
                     }
                     else { 
				if (.AGPIODIR11 == "Output High") {
               		   .aiodirMask |= (0x0800),
               	         .aiodataMask |= (0x0800)
				}
				else {		
                    	   .aiodirMask &= (0xF7FF),
                    	   .aiodataMask &= (0xF7FF)
				}
                     }
			},
			   .AIOENMSK_VALUE = .aioenMask,
                     .AIODIRMSK_VALUE = .aiodirMask,
                     .AIODATAMSK_VALUE = .aiodataMask,
			   "ok"
             	  )
	}
	global AGPIODIR12 :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum ::  "Disabled,Input,Output Low,Output High"
	  prop Label :: "AGPIO12 "
	  prop JSName :: "gpioAgpio12dir"
	  prop Visible :: 1
	  prop Writable :: (gpioCfg.agpio_Support) && (.configGPIO) && (ebselCfg.ADDRESS)
	  prop NoGen :: 1
	  prop TabName :: "Power Down Address I/O Pins"
	  prop Set :: (.AGPIODIR12 = $1,
			if (.AGPIODIR12 == "Disabled")
			{
			   .aioenMask &= (0xEFFF),
                     .aiodirMask &= (0xEFFF),
                     .aiodataMask &= (0xEFFF)
			}
			else
			{
			  .aioenMask |= (0x1000),
                    if (.AGPIODIR12 == "Output Low") {
                     	 .aiodirMask |= (0x1000),
                    	 .aiodataMask &= (0xEFFF)
                     }
                     else { 
				if (.AGPIODIR12 == "Output High") {
               		   .aiodirMask |= (0x1000),
               	         .aiodataMask |= (0x1000)
				}
				else {		
                    	   .aiodirMask &= (0xEFFF),
                    	   .aiodataMask &= (0xEFFF)
				}
                     }
			},
			   .AIOENMSK_VALUE = .aioenMask,
                     .AIODIRMSK_VALUE = .aiodirMask,
                     .AIODATAMSK_VALUE = .aiodataMask,
			   "ok"
             	  )
	}
	global AGPIODIR13 :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum ::  "Disabled,Input,Output Low,Output High"
	  prop Label :: "AGPIO13 "
	  prop JSName :: "gpioAgpio13dir"
	  prop Visible :: 1
	  prop Writable :: (gpioCfg.agpio_Support) && (.configGPIO) && (ebselCfg.ADDRESS)
	  prop NoGen :: 1
	  prop TabName :: "Power Down Address I/O Pins"
	  prop Set :: (.AGPIODIR13 = $1,
			if (.AGPIODIR13 == "Disabled")
			{
			   .aioenMask &= (0xDFFF),
                     .aiodirMask &= (0xDFFF),
                     .aiodataMask &= (0xDFFF)
			}
			else
			{
			  .aioenMask |= (0x2000),
                    if (.AGPIODIR13 == "Output Low") {
                     	 .aiodirMask |= (0x2000),
                    	 .aiodataMask &= (0xDFFF)
                     }
                     else { 
				if (.AGPIODIR13 == "Output High") {
               		   .aiodirMask |= (0x2000),
               	         .aiodataMask |= (0x2000)
				}
				else {		
                    	   .aiodirMask &= (0xDFFF),
                    	   .aiodataMask &= (0xDFFF)
				}
                     }
			},
			   .AIOENMSK_VALUE = .aioenMask,
                     .AIODIRMSK_VALUE = .aiodirMask,
                     .AIODATAMSK_VALUE = .aiodataMask,
			   "ok"
             	  )
	}
	global AGPIODIR14 :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum ::  "Disabled,Input,Output Low,Output High"
	  prop Label :: "AGPIO14 "
	  prop JSName :: "gpioAgpio14dir"
	  prop Visible :: 1
	  prop Writable :: (gpioCfg.agpio_Support) && (.configGPIO) && (ebselCfg.ADDRESS)
	  prop NoGen :: 1
	  prop TabName :: "Power Down Address I/O Pins"
	  prop Set :: (.AGPIODIR14 = $1,
			if (.AGPIODIR14 == "Disabled")
			{
			   .aioenMask &= (0xBFFF),
                     .aiodirMask &= (0xBFFF),
                     .aiodataMask &= (0xBFFF)
			}
			else
			{
			  .aioenMask |= (0x4000),
                    if (.AGPIODIR14 == "Output Low") {
                     	 .aiodirMask |= (0x4000),
                    	 .aiodataMask &= (0xBFFF)
                     }
                     else { 
				if (.AGPIODIR14 == "Output High") {
               		   .aiodirMask |= (0x4000),
               	         .aiodataMask |= (0x4000)
				}
				else {		
                    	   .aiodirMask &= (0xBFFF),
                    	   .aiodataMask &= (0xBFFF)
				}
                     }
			},
			   .AIOENMSK_VALUE = .aioenMask,
                     .AIODIRMSK_VALUE = .aiodirMask,
                     .AIODATAMSK_VALUE = .aiodataMask,
			   "ok"
             	  )
	}
	global AGPIODIR15 :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum ::  "Disabled,Input,Output Low,Output High"
	  prop Label :: "AGPIO15 "
	  prop JSName :: "gpioAgpio15dir"
	  prop Visible :: 1
	  prop Writable :: (gpioCfg.agpio_Support) && (.configGPIO) && (ebselCfg.ADDRESS)
	  prop NoGen :: 1
	  prop TabName :: "Power Down Address I/O Pins"
	  prop Set :: (.AGPIODIR15 = $1,
			if (.AGPIODIR15 == "Disabled")
			{
			   .aioenMask &= (0x7FFF),
                     .aiodirMask &= (0x7FFF),
                     .aiodataMask &= (0x7FFF)
			}
			else
			{
			  .aioenMask |= (0x8000),
                    if (.AGPIODIR15 == "Output Low") {
                     	 .aiodirMask |= (0x8000),
                    	 .aiodataMask &= (0x7FFF)
                     }
                     else { 
				if (.AGPIODIR15 == "Output High") {
               		   .aiodirMask |= (0x8000),
               	         .aiodataMask |= (0x8000)
				}
				else {		
                    	   .aiodirMask &= (0x7FFF),
                    	   .aiodataMask &= (0x7FFF)
				}
                     }
			},
			   .AIOENMSK_VALUE = .aioenMask,
                     .AIODIRMSK_VALUE = .aiodirMask,
                     .AIODATAMSK_VALUE = .aiodataMask,
			   "ok"
             	  )
	}
	global WARNING :: "Do not write to A14 - A15 for 5509 QFP packages! " {
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop TabName :: "Power Down Address I/O Pins"
        prop NoGen :: 1
	} 
   
	global gpioenMask :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Label :: "GPIOEN Mask"
	  prop Format :: "0x%04x"
	  prop Visible :: 0
	  prop Writable :: (gpioCfg.gpioen_Support) && (.configGPIO)
	  prop NoGen :: 1
	  prop TabName :: "Power Down I/O Pins"
	}
	global gpiodirMask :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Label :: "GPIODIR Mask"
	  prop Format :: "0x%04x"
	  prop Visible :: 0
	  prop Writable :: (gpioCfg.gpioen_Support) && (.configGPIO)
	  prop NoGen :: 1
	  prop TabName :: "Power Down I/O Pins"
	}
	global gpiodataMask :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Label :: "GPIODATA Mask"
	  prop Format :: "0x%04x"
	  prop Visible :: 0
	  prop Writable :: (gpioCfg.gpioen_Support) && (.configGPIO)
	  prop NoGen :: 1
	  prop TabName :: "Power Down I/O Pins"
	}
	global GPIODIR8 :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum ::  "Disabled,Input,Output Low,Output High"
	  prop Label :: "GPIO8 "
	  prop JSName :: "gpioGpio8dir"
	  prop Visible :: 1
	  prop Writable :: (gpioCfg.gpioen_Support) && (.configGPIO)
	  prop NoGen :: 1
	  prop TabName :: "Power Down I/O Pins"
	  prop Set :: (.GPIODIR8 = $1,
			if (.GPIODIR8 == "Disabled")
			{
			   .gpioenMask &= (0xFFFE),
                     .gpiodirMask &= (0xFFFE),
                     .gpiodataMask &= (0xFFFE)
			}
			else
			{
			  .gpioenMask |= (0x0001),
                    if (.GPIODIR8 == "Output Low") {
                     	 .gpiodirMask |= (0x0001),
                    	 .gpiodataMask &= (0xFFFE)
                     }
                     else { 
				if (.GPIODIR8 == "Output High") {
               		   .gpiodirMask |= (0x0001),
               	         .gpiodataMask |= (0x0001)
				}
				else {		
                    	   .gpiodirMask &= (0xFFFE),
                    	   .gpiodataMask &= (0xFFFE)
				}
                     }
			},
			   .GPIOENMSK_VALUE = .gpioenMask,
                     .GPIODIRMSK_VALUE = .gpiodirMask,
                     .GPIODATAMSK_VALUE = .gpiodataMask,
			   "ok"
             	  )
	}
	global GPIODIR9 :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum ::  "Disabled,Input,Output Low,Output High"
	  prop Label :: "GPIO9 "
	  prop JSName :: "gpioGpio9dir"
	  prop Visible :: 1
	  prop Writable :: (gpioCfg.gpioen_Support) && (.configGPIO)
	  prop NoGen :: 1
	  prop TabName :: "Power Down I/O Pins"
	  prop Set :: (.GPIODIR9 = $1,
			if (.GPIODIR9 == "Disabled")
			{
			   .gpioenMask &= (0xFFFD),
                     .gpiodirMask &= (0xFFFD),
                     .gpiodataMask &= (0xFFFD)
			}
			else
			{
			  .gpioenMask |= (0x0002),
                    if (.GPIODIR9 == "Output Low") {
                     	 .gpiodirMask |= (0x0002),
                    	 .gpiodataMask &= (0xFFFD)
                     }
                     else { 
				if (.GPIODIR9 == "Output High") {
               		   .gpiodirMask |= (0x0002),
               	         .gpiodataMask |= (0x0002)
				}
				else {		
                    	   .gpiodirMask &= (0xFFFD),
                    	   .gpiodataMask &= (0xFFFD)
				}
                     }
			},
			   .GPIOENMSK_VALUE = .gpioenMask,
                     .GPIODIRMSK_VALUE = .gpiodirMask,
                     .GPIODATAMSK_VALUE = .gpiodataMask,
			   "ok"
             	  )
	}
	global GPIODIR10 :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum ::  "Disabled,Input,Output Low,Output High"
	  prop Label :: "GPIO10 "
	  prop JSName :: "gpioGpio10dir"
	  prop Visible :: 1
	  prop Writable :: (gpioCfg.gpioen_Support) && (.configGPIO)
	  prop NoGen :: 1
	  prop TabName :: "Power Down I/O Pins"
	  prop Set :: (.GPIODIR10 = $1,
			if (.GPIODIR10 == "Disabled")
			{
			   .gpioenMask &= (0xFFFB),
                     .gpiodirMask &= (0xFFFB),
                     .gpiodataMask &= (0xFFFB)
			}
			else
			{
			  .gpioenMask |= (0x0004),
                    if (.GPIODIR10 == "Output Low") {
                     	 .gpiodirMask |= (0x0004),
                    	 .gpiodataMask &= (0xFFFB)
                     }
                     else { 
				if (.GPIODIR10 == "Output High") {
               		   .gpiodirMask |= (0x0004),
               	         .gpiodataMask |= (0x0004)
				}
				else {		
                    	   .gpiodirMask &= (0xFFFB),
                    	   .gpiodataMask &= (0xFFFB)
				}
                     }
			},
			   .GPIOENMSK_VALUE = .gpioenMask,
                     .GPIODIRMSK_VALUE = .gpiodirMask,
                     .GPIODATAMSK_VALUE = .gpiodataMask,
			   "ok"
             	  )
	}
	global GPIODIR11 :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum ::  "Disabled,Input,Output Low,Output High"
	  prop Label :: "GPIO11 "
	  prop JSName :: "gpioGpio11dir"
	  prop Visible :: 1
	  prop Writable :: (gpioCfg.gpioen_Support) && (.configGPIO)
	  prop NoGen :: 1
	  prop TabName :: "Power Down I/O Pins"
	  prop Set :: (.GPIODIR11 = $1,
			if (.GPIODIR11 == "Disabled")
			{
			   .gpioenMask &= (0xFFF7),
                     .gpiodirMask &= (0xFFF7),
                     .gpiodataMask &= (0xFFF7)
			}
			else
			{
			  .gpioenMask |= (0x0008),
                    if (.GPIODIR11 == "Output Low") {
                     	 .gpiodirMask |= (0x0008),
                    	 .gpiodataMask &= (0xFFF7)
                     }
                     else { 
				if (.GPIODIR11 == "Output High") {
               		   .gpiodirMask |= (0x0008),
               	         .gpiodataMask |= (0x0008)
				}
				else {		
                    	   .gpiodirMask &= (0xFFF7),
                    	   .gpiodataMask &= (0xFFF7)
				}
                     }
			},
			   .GPIOENMSK_VALUE = .gpioenMask,
                     .GPIODIRMSK_VALUE = .gpiodirMask,
                     .GPIODATAMSK_VALUE = .gpiodataMask,
			   "ok"
             	  )
	}
	global GPIODIR12 :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum ::  "Disabled,Input,Output Low,Output High"
	  prop Label :: "GPIO12 "
	  prop JSName :: "gpioGpio12dir"
	  prop Visible :: 1
	  prop Writable :: (gpioCfg.gpioen_Support) && (.configGPIO)
	  prop NoGen :: 1
	  prop TabName :: "Power Down I/O Pins"
	  prop Set :: (.GPIODIR12 = $1,
			if (.GPIODIR12 == "Disabled")
			{
			   .gpioenMask &= (0xFFEF),
                     .gpiodirMask &= (0xFFEF),
                     .gpiodataMask &= (0xFFEF)
			}
			else
			{
			  .gpioenMask |= (0x0010),
                    if (.GPIODIR12 == "Output Low") {
                     	 .gpiodirMask |= (0x0010),
                    	 .gpiodataMask &= (0xFFEF)
                     }
                     else { 
				if (.GPIODIR12 == "Output High") {
               		   .gpiodirMask |= (0x0010),
               	         .gpiodataMask |= (0x0010)
				}
				else {		
                    	   .gpiodirMask &= (0xFFEF),
                    	   .gpiodataMask &= (0xFFEF)
				}
                     }
			},
			   .GPIOENMSK_VALUE = .gpioenMask,
                     .GPIODIRMSK_VALUE = .gpiodirMask,
                     .GPIODATAMSK_VALUE = .gpiodataMask,
			   "ok"
             	  )
	}
	global GPIODIR13 :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum ::  "Disabled,Input,Output Low,Output High"
	  prop Label :: "GPIO13 "
	  prop JSName :: "gpioGpio13dir"
	  prop Visible :: 1
	  prop Writable :: (gpioCfg.gpioen_Support) && (.configGPIO)
	  prop NoGen :: 1
	  prop TabName :: "Power Down I/O Pins"
	  prop Set :: (.GPIODIR13 = $1,
			if (.GPIODIR13 == "Disabled")
			{
			   .gpioenMask &= (0xFFDF),
                     .gpiodirMask &= (0xFFDF),
                     .gpiodataMask &= (0xFFDF)
			}
			else
			{
			  .gpioenMask |= (0x0020),
                    if (.GPIODIR13 == "Output Low") {
                     	 .gpiodirMask |= (0x0020),
                    	 .gpiodataMask &= (0xFFDF)
                     }
                     else { 
				if (.GPIODIR13 == "Output High") {
               		   .gpiodirMask |= (0x0020),
               	         .gpiodataMask |= (0x0020)
				}
				else {		
                    	   .gpiodirMask &= (0xFFDF),
                    	   .gpiodataMask &= (0xFFDF)
				}
                     }
			},
			   .GPIOENMSK_VALUE = .gpioenMask,
                     .GPIODIRMSK_VALUE = .gpiodirMask,
                     .GPIODATAMSK_VALUE = .gpiodataMask,
			   "ok"
             	  )
	}
	global IODIRMSK_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
          prop Label :: "IODIR Mask "
          prop Visible :: 0
          prop Writable :: 1
          prop NoGen :: 1
	  prop cGen :: 1
	  prop cType :: "Uint16"
    	}
	global IODATAMSK_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
          prop Label :: "IODATA Mask "
          prop Visible :: 0
          prop Writable :: 1
          prop NoGen :: 1
	  prop cGen :: 1
	  prop cType :: "Uint16"
    	}
	global AIODIRMSK_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
          prop Label :: "AGPIODIR Mask "
          prop Visible :: 0
          prop Writable :: (gpioCfg.agpio_Support)
          prop NoGen :: 1
	  prop cGen :: 1
	  prop cType :: "Uint16"
    	}
	global AIODATAMSK_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
          prop Label :: "AGPIODATA Mask "
          prop Visible :: 0
          prop Writable :: (gpioCfg.agpio_Support)
          prop NoGen :: 1
	  prop cGen :: 1
	  prop cType :: "Uint16"
    	}
	global AIOENMSK_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
          prop Label :: "AGPIOEN Mask "
          prop Visible :: 0
          prop Writable :: (gpioCfg.agpio_Support)
          prop NoGen :: 1
	  prop cGen :: 1
	  prop cType :: "Uint16"
    	}
	global GPIOENMSK_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
          prop Label :: "GPIOEN Mask "
          prop Visible :: 0
          prop Writable :: (gpioCfg.gpioen_Support)
          prop NoGen :: 1
	  prop cGen :: 1
	  prop cType :: "Uint16"
    	}
	global GPIODIRMSK_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
          prop Label :: "GPIODIR Mask "
          prop Visible :: 0
          prop Writable :: (gpioCfg.gpioen_Support)
          prop NoGen :: 1
	  prop cGen :: 1
	  prop cType :: "Uint16"
    	}
	global GPIODATAMSK_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
          prop Label :: "GPIODATA Mask "
          prop Visible :: 0
          prop Writable :: (gpioCfg.gpioen_Support)
          prop NoGen :: 1
	  prop cGen :: 1
	  prop cType :: "Uint16"
    	}
        prop valueDir :: .IODIRMSK_VALUE
	prop valueDirStr :: "GPIO_RSET(IODIR, 0x%9x);\n"
        prop valueData :: .IODATAMSK_VALUE
	prop valueDataStr :: "GPIO_RSET(IODATA, 0x%10x);\n\n"
        prop valueAEn :: .AIOENMSK_VALUE
	prop valueAEnStr :: (gpioCfg.agpio_Support) ? "GPIO_RSET(AGPIOEN, 0x%11x);\n" : ""
        prop valueADir :: .AIODIRMSK_VALUE
	prop valueADirStr :: (gpioCfg.agpio_Support) ? "GPIO_RSET(AGPIODIR, 0x%12x);\n" : ""
        prop valueAData :: .AIODATAMSK_VALUE
	prop valueADataStr :: (gpioCfg.agpio_Support) ? "GPIO_RSET(AGPIODATA, 0x%13x);\n\n" : ""
        prop valueGpioEn :: .GPIOENMSK_VALUE
	prop valueGpioEnStr :: (gpioCfg.gpioen_Support) ? "GPIO_RSET(GPIOEN, 0x%14x);\n" : ""
        prop valueGpioDir :: .GPIODIRMSK_VALUE
	prop valueGpioDirStr :: (gpioCfg.gpioen_Support) ? "GPIO_RSET(GPIODIR, 0x%15x);\n" : ""
        prop valueGpioData :: .GPIODIRMSK_VALUE
	prop valueGpioDataStr :: (gpioCfg.gpioen_Support) ? "GPIO_RSET(GPIODATA, 0x%16x);" : ""
	prop cGenFxnEpilogue :: (
          if (.c55gpio == 1) { 
	"%5t%1S%2S%3S%4S%5S%6S%7S%8S\n%0t\0,valueDirStr,valueDataStr,
						    valueAEnStr,valueADirStr,valueADataStr,
						    valueGpioEnStr,valueGpioDirStr,valueGpioDataStr,
						    valueDir,valueData,
						    valueAEn,valueADir,valueAData,
						    valueGpioEn,valueGpioDir,valueGpioData"
	    }
	)
	prop ioInclStr :: "#include <_csl_gpiohal.h>\n"
	prop agpioInclStr :: (gpioCfg.agpio_Support) ? "#include <_csl_pgpiohal.h>\n" : ""
	prop cGenCPrologue :: (
	  if (.c55gpio == 1) { 
        "%1S%2S\n\n\0, ioInclStr, agpioInclStr"
	  }
	)
}
type ICACHEFOLDER {
    	prop Label :: "ICACHE - Instruction Cache"
    	prop GlobalIcon :: IDI_ICACHE_GLOBAL
    	prop GlobalPropertyPage :: "{B976FB91-49A5-11d4-967C-0050048381B7}"
	prop GlobalHelpTopic :: 1050
    	prop IsContainedIn :: CSL
      prop NoGen :: 1
}
type icacheCfg {
	isa ObjectMgr
	prop name :: "icacheCfg"
	prop Label :: "ICACHE Configuration "
	prop JSName :: "ICACHE"
	prop GlobalHelpTopic :: 1051
	prop InstanceHelpTopic :: 1051
	prop GlobalIcon :: IDI_ICACHE_GLOBAL
	prop InstanceIcon :: 172
	prop GlobalPropertyPage :: "{C5CB30B4-F115-11d2-84A7-10105A98CA0B}"
      prop InstancePropertyPage :: "{AC0C36D1-840B-11d0-A627-1000C070F3E9}"
    	prop Vendor :: "vendor1"
    	prop Version :: "1.00.00"
	prop IsContainedIn :: ICACHEFOLDER
	
	prop NoGen :: 1
	prop cHandle :: 0
	prop cGen :: 1
    	prop cStruct :: 0
	prop cHeaderName :: .c55icache == 1 ? "csl_icache.h" : ""
	prop maxObjs :: 0
	global c55icache :: 0 {
          prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Label :: "C55x ICACHE opened "
	    prop Visible :: 0
	    prop Writable :: 1
	    prop NoGen :: 1
	    prop cGen :: 0
      }
      prop ICACHE_SUPPORT :: ( (GBL.CHIPTYPE == "5510PG2_0") ||
                               (GBL.CHIPTYPE == "5510PG2_1") ||
                               (GBL.CHIPTYPE == "5510PG2_2")
      )
      global configICACHE :: 0 {
		prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
		prop Label :: "Enable Initialization "
		prop Visible :: 1
		prop Writable :: (icacheCfg.ICACHE_SUPPORT)
		prop NoGen :: 1
		prop cGen :: 0
            prop TabName :: "General"
            prop Set :: (
               .configICACHE = $1,
               if ($1 == 1) {
                   .c55icache = 1
               }
               else {
                   .c55icache = 0
               },
               "ok"
          )
	}
	global RAMSET_SETUP :: "No RAM set" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "RAM Set Mode "
	  prop JSName :: "icacheRamsetMode"
	  prop Enum  :: "No RAM set,1 RAM set,2 RAM sets"
	  prop Visible :: 1
	  prop Writable :: ((icacheCfg.ICACHE_SUPPORT) && (.c55icache == 1))
	  prop NoGen :: 1
	  prop TabName :: "5510 Settings"
	  prop Set ::  (	  .RAMSET_SETUP = $1,
				  "ok"
			   )	
	}
	global RAMSET1ADDR_SETUP :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%06x"
        prop Label :: "RAM Set 1 Address "
	  prop JSName :: "icacheRamset1Addr"
        prop Visible :: 1
        prop Writable :: ((icacheCfg.ICACHE_SUPPORT) && (.c55icache == 1) && (.RAMSET_SETUP != "No RAM set"))
        prop NoGen :: 1
        prop TabName :: "5510 Settings"
	  prop Set ::  (	.RAMSET1ADDR_SETUP = $1,
				"ok"
			   )
    	}
	global RAMSET2ADDR_SETUP :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%06x"
        prop Label :: "RAM Set 2 Address "
	  prop JSName :: "icacheRamset2Addr"
        prop Visible :: 1
        prop Writable :: ((icacheCfg.ICACHE_SUPPORT) && (.c55icache == 1) && (.RAMSET_SETUP == "2 RAM sets"))
        prop NoGen :: 1
        prop TabName :: "5510 Settings"
	  prop Set ::  (	.RAMSET2ADDR_SETUP = $1,
				"ok"
			   )
    	}
	prop RAMSET_VALUE :: ( 
			(.RAMSET_SETUP == "No RAM set") ? "0RAMSET" : 
			(.RAMSET_SETUP == "1 RAM set") ? "1RAMSET" : 
			"2RAMSET"
	)
	prop ramsetValue :: .RAMSET_VALUE
	prop rmodeStr :: "ICACHE_RSET(ICGC, ICACHE_ICGC_RMODE_%5S);\n\n"
	prop icwcStr :: "ICACHE_FSET(ICWC, WINIT, ICACHE_ICWC_WINIT_WINIT);\n"
	prop icrc1Str :: "ICACHE_FSET(ICRC1, R1INIT, ICACHE_ICRC1_R1INIT_INIT);\n"
	prop icrc2Str :: "ICACHE_FSET(ICRC2, R2INIT, ICACHE_ICRC2_R2INIT_INIT);\n"
	
	prop enableStr :: "ICACHE_enable();\n\n"
	prop r1addrVal :: .RAMSET1ADDR_SETUP
	prop r2addrVal :: .RAMSET2ADDR_SETUP
	prop TAGS_VALUE :: (
			(.RAMSET_SETUP == "No RAM set") ? "" : 
			(.RAMSET_SETUP == "1 RAM set") ? "ICACHE_FSET(ICRTAG1, R1TAG, ((Uint16)((0x%8x >> 12) & 0x0FFFu)));\nwhile(!ICACHE_FGET(ICRC1, R1TVALID));\n" : 
			"ICACHE_FSET(ICRTAG1, R1TAG, ((Uint16)((0x%8x >> 12) & 0x0FFFu)));\nwhile(!ICACHE_FGET(ICRC1, R1TVALID));\nICACHE_FSET(ICRTAG2, R2TAG, ((Uint16)((0x%9x >> 12) & 0x0FFFu)));\nwhile(!ICACHE_FGET(ICRC2, R2TVALID));\n\n"
	)
	prop tagsStr :: .TAGS_VALUE
	prop cGenFxnEpilogue :: (
          if ((icacheCfg.ICACHE_SUPPORT) && (.c55icache == 1)) { 
		"%5t%1S%2S%3S%4S%6S%7S\n%0t\0, rmodeStr,icwcStr,icrc1Str,icrc2Str,ramsetValue, 												enableStr,tagsStr,r1addrVal,r2addrVal"
	    }
	)
	prop icacheInclStr :: "#include <csl_icache.h>\n"
	prop cGenCPrologue :: (
	  if (.c55icache == 1) { 
        "%1S\n\n\0, icacheInclStr"
	  }
	)
}
type MCBSPFOLDER {
    
    prop Label :: "MCBSP - Multichannel Buffered Serial Port"
    prop GlobalIcon :: 159
    prop GlobalPropertyPage :: "{B016FB95-52A5-11d4-967C-0750048381B7}"
    prop GlobalHelpTopic :: 1060
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}
type mcbspCfg {
	isa ObjectMgr
	prop name :: "MCBSP"
	prop Label :: "MCBSP Configuration Manager"
	prop JSName :: "MCBSP"
	prop GlobalHelpTopic :: 1061
	prop InstanceHelpTopic :: 1061
	prop GlobalIcon :: 159
	prop InstanceIcon :: 160
	prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-00105A98CA0B}"
      prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-0000C070F3E9}"
    	prop Vendor :: "vendor1"
    	prop Version :: "1.00.00"
	
	prop cGen :: 1
      prop NoGen :: 1
    	prop cStruct :: 1
    	prop cStructType :: "MCBSP_Config"
	prop cHeaderName :: .gNumOf > 0 ? "csl_mcbsp.h" : ""
	prop IsContainedIn :: MCBSPFOLDER
      
	inst IDLE_EN_SETUP :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Stop all clocks in McBSP during Peripheral Idle Mode "
	prop JSName :: "mcbspPcrIdleEn"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man)
        prop NoGen :: 1
        prop TabName :: "General"
	  prop Set ::  (	  .IDLE_EN_SETUP = $1,
				  .PCR_VALUE = .PCR_VALUE_update(),
				  "ok"
			   )
	}
	prop IDLE_EN_PCR :: (
		(.IDLE_EN_SETUP == 1) ? 0x4000 : 0x0000
	)
      
	inst XIOEN_SETUP :: 1 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Configure DX, FSX, and CLKX as Serial Port Pins "
	  prop JSName :: "mcbspPcrXioen"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man)
        prop NoGen :: 1
        prop TabName :: "General"
	  prop Set :: (	.XIOEN_SETUP = $1,
                        .XIOEN2_SETUP = $1,
				.PCR_VALUE = .PCR_VALUE_update(),
                        .PCR_VALUE &= 0xFAFF,
                        .FSX_IO = "Input",
                        .CLKX_IO = "Input",
				"ok"
			  )
	}
	inst XIOEN2_SETUP :: 1 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Configure DX, FSX, and CLKX as Serial Port Pins "
        prop Visible :: 0
        prop Writable :: !(.MCBSP_man)
        prop NoGen :: 1
        prop TabName :: "General"
	  prop Set :: (	.XIOEN2_SETUP = $1,
                        .XIOEN_SETUP = $1,
				.PCR_VALUE = .PCR_VALUE_update(),
				"ok"
			  )
	}
	prop XIOEN_PCR :: (
		(.XIOEN_SETUP == 1) ? 0x0000 : 0x2000
	)
      
      
	inst CLKXM1_SETUP :: "External" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "External,Internal"
        prop Label :: "Clock Mode (CLKXM) "
	prop JSName :: "mcbspPcrClkxm"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.CLKSTP_SETUP == "Disable") && (.XIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Transmit Modes"
	  prop Set ::  (	.CLKXM1_SETUP = $1,
				.PCR_VALUE = .PCR_VALUE_update(),
				"ok"
			   )
	}
	inst CLKXM2_SETUP :: "Slave" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Slave,Master"
        prop Label :: "SPI Clock Mode (CLKXM) "
	prop JSName :: "mcbspPcrClkxmSpi"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.CLKSTP_SETUP != "Disable") && (.XIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Transmit Modes"
	  prop Set ::  (	.CLKXM2_SETUP = $1,
				.PCR_VALUE = .PCR_VALUE_update(),
				"ok"
			    )
	}
	prop CLKXM_PCR :: (
		if (.CLKSTP_SETUP == "Disable") {
		  (.CLKXM1_SETUP == "External") ? (.CLKXM2_SETUP = "Slave", 0x0000) : 
		  (.CLKXM2_SETUP = "Master", 0x0200)
		}
		else {
		  (.CLKXM2_SETUP == "Slave") ? (.CLKXM1_SETUP = "External", 0x0000) :
		  (.CLKXM1_SETUP = "Internal", 0x0200)
		}
	)
      
	inst CLKXP_SETUP :: "Rising Edge" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Rising Edge,Falling Edge"
        prop Label :: "Clock Polarity (CLKXP) "
	prop JSName :: "mcbspPcrClkxp"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.CLKSTP_SETUP == "Disable") && (.XIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Transmit Modes"
	  prop Set ::  (	.CLKXP_SETUP = $1,
				.PCR_VALUE = .PCR_VALUE_update(),
				"ok"
			   )
	}
	
	prop CLKXP_PCR :: (
		(.CLKXP_SETUP == "Rising Edge") ? 0x0000 : 0x0002
	)
      
	inst FSXP_SETUP :: "Active High" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Active High,Active Low"
        prop Label :: "Frame-Sync Polarity (FSXP) "
	  prop JSName :: "mcbspPcrFsxp"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.XIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Transmit Modes"
	  prop Set ::  (	.FSXP_SETUP = $1,
				.PCR_VALUE = .PCR_VALUE_update(),
				"ok"
			   )
	}
	prop FSXP_PCR :: (
		(.FSXP_SETUP == "Active High") ? 0x0000 : 0x0008
	)
      
	inst DXENA_SETUP :: "Disable" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "DX Pin Delay (DXENA) "
	  prop JSName :: "mcbspSpcr1Dxena"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.XIOEN_SETUP == 1) && (mcbspCfg.DXENA_SUPPORT))
        prop NoGen :: 1
        prop TabName :: "Transmit Modes"
	  prop Set ::  (	.DXENA_SETUP = $1,
				.SPCR1_VALUE = .SPCR1_VALUE_update(),
				"ok"
			   )
	}
	prop DXENA_SUPPORT :: (
		1 
	)
	prop DXENA_SPCR1 :: (
		(.DXENA_SETUP == "Enable") ? 0x0080 : 0x0000
	)
      
	inst XDATDLY_SETUP :: "0-bit" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0-bit,1-bit,2-bit"
        prop Label :: "Transmit Delay (XDATDLY) "
	prop JSName :: "mcbspXcr2Xdatdly"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.XIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Transmit Modes"
	  prop Set ::  (	.XDATDLY_SETUP = $1,
				.XCR2_VALUE = .XCR2_VALUE_update(),
				"ok"
			   )
	}
	prop XDATDLY_XCR2 :: (
		(.XDATDLY_SETUP == "0-bit") ? 0x0000 :
		(.XDATDLY_SETUP == "1-bit") ? 0x0001 :
		0x0002
	)
      
	inst XPHASE_SETUP :: "Single-phase" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Single-phase,Dual-phase"
        prop Label :: "Phase (XPHASE) "
	prop JSName :: "mcbspXcr2Xphase"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.XIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Transmit Lengths"
	  prop Set ::  (	.XPHASE_SETUP = $1,
				.XCR2_VALUE = .XCR2_VALUE_update(),
				"ok"
			   )
	}
	prop XPHASE_XCR2 :: (
		(.XPHASE_SETUP == "Single-phase") ? 0x0000: 0x8000
	)
	inst XWDLEN1_SETUP :: "8-bits" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "8-bits,12-bits,16-bits,20-bits,24-bits,32-bits"
        prop Label :: "Word Length Phase1 (XWDLEN1) "
	prop JSName :: "mcbspXcr1Xwdlen1"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.XIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Transmit Lengths"
	  prop Set ::  (	.XWDLEN1_SETUP = $1,
				.XCR1_VALUE = .XCR1_VALUE_update(),
				"ok"
			   )
	}
	prop XWDLEN1_XCR1 :: (
		(.XWDLEN1_SETUP == "12-bits") ? 0x0020 :
		(.XWDLEN1_SETUP == "16-bits") ? 0x0040 :
		(.XWDLEN1_SETUP == "20-bits") ? 0x0060 :
		(.XWDLEN1_SETUP == "24-bits") ? 0x0080 :
		(.XWDLEN1_SETUP == "32-bits") ? 0x00A0 : 
		0x0000
	)
	inst XWDLEN2_SETUP :: "8-bits" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "8-bits,12-bits,16-bits,20-bits,24-bits,32-bits"
        prop Label :: "Word Length Phase2 (XWDLEN2) "
	prop JSName :: "mcbspXcr2Xwdlen2"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.XPHASE_SETUP == "Dual-phase") && (.XIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Transmit Lengths"
	  prop Set ::  (	.XWDLEN2_SETUP = $1,
				.XCR2_VALUE = .XCR2_VALUE_update(),				    
				"ok"			
			   )
	}
	prop XWDLEN2_XCR2 :: (
		(.XWDLEN2_SETUP == "12-bits") ? 0x0020 :
		(.XWDLEN2_SETUP == "16-bits") ? 0x0040 :
		(.XWDLEN2_SETUP == "20-bits") ? 0x0060 :
		(.XWDLEN2_SETUP == "24-bits") ? 0x0080 :
		(.XWDLEN2_SETUP == "32-bits") ? 0x00A0 : 
		0x0000
	)
	inst XFRLEN1_SETUP :: 1 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Words/Frame Phase1 (XFRLEN1) "
	prop JSName :: "mcbspXcr1Xfrlen1"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.XIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Transmit Lengths"
	  prop Set :: (	if (($1 <=128) && ($1 >= 1)) {
				    .XFRLEN1_SETUP = $1,
				    .XCR1_VALUE = .XCR1_VALUE_update(),
				    "ok"}
				else {"Invalid value"})
	}
	prop XFRLEN1_XCR1 :: ((.XFRLEN1_SETUP -1) << 8)
	inst XFRLEN2_SETUP :: 1 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Words/Frame Phase2 (XFRLEN2) "
	prop JSName :: "mcbspXcr2Xfrlen2"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.XPHASE_SETUP == "Dual-phase") && (.XIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Transmit Lengths"
	  prop Set :: (	if (($1 <=128) && ($1 >= 1)) {
				    .XFRLEN2_SETUP = $1,
				    .XCR2_VALUE = .XCR2_VALUE_update(),				    
				    "ok"}
				else {"Invalid value"})
	}
	prop XFRLEN2_XCR2 :: ((.XFRLEN2_SETUP - 1) << 8)
      
	inst XSYNCERR_SETUP :: "Disable" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Detect Sync Error (XSYNCERR) "
	prop JSName :: "mcbspSpcr2Xsyncerr"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.XIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Transmit Modes"
	  prop Set ::  (	.XSYNCERR_SETUP = $1,
				.SPCR2_VALUE = .SPCR2_VALUE_update(),
				"ok"
			   )
	}
	
	prop XSYNCERR_SPCR2 :: (
		(.XSYNCERR_SETUP == "Enable") ? 0x0008 : 0x0000
	)
      
	inst XINTM_SETUP :: "XRDY" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "XRDY,End of block/frame,New Frame Sync.,XSYNCERR"
        prop Label :: "Interrupt Mode (XINTM) "
	prop JSName :: "mcbspSpcr2Xintm"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.XIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Transmit Modes"
	  prop Set ::  (	.XINTM_SETUP = $1,
				.SPCR2_VALUE = .SPCR2_VALUE_update(),
				"ok"
			   )
	}
	prop XINTM_SPCR2 :: (
		(.XINTM_SETUP == "XRDY") ? 0x0000 :
		(.XINTM_SETUP == "End of block/frame") ? 0x0010 :
		(.XINTM_SETUP == "New Frame Sync.") ? 0x0020 :
		0x0030
	)
      
	inst FSXM_SETUP :: "External" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "External,Sample Rate Gen"
        prop Label :: "Frame-Sync Mode (FSXM) "
        prop Visible :: 0
        prop Writable :: !(.MCBSP_man) && (.XIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "Transmit Modes"
	  prop Set ::  (	.FSXM_SETUP = $1,
				.PCR_VALUE = .PCR_VALUE_update(),
				"ok"
			   )
	}
	prop FSXM_PCR :: (
		(.FSXM_SETUP == "External") ? 0x0000 : 0x0800
	)
	inst XFIG_SETUP :: "Restart Transfer" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Restart Transfer,Ignore"
        prop Label :: "Early Frame Sync Response (XFIG) "
	prop JSName :: "mcbspXcr2Xfig"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.XIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Transmit Modes"
	  prop Set ::  (	.XFIG_SETUP = $1,
				.XCR2_VALUE = .XCR2_VALUE_update(),				    
				"ok"
			   )
	}
	prop XFIG_XCR2 :: (
		(.XFIG_SETUP == "Restart Transfer") ? 0x0000 : 0x0004
	)
      
	inst XCOMPAND_SETUP :: "No Companding-MSB First" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "No Companding-MSB First,No Companding-LSB First,u-Law,A-Law"
        prop Label :: "Companding (XCOMPAND) "
	prop JSName :: "mcbspXcr2Xcompand"
        prop Visible :: 1
        prop Writable :: ((!(.MCBSP_man)) && (.XIOEN_SETUP == 1) && (.XWDLEN1_SETUP == "8-bits") && ((.XWDLEN2_SETUP == "8-bits") || !(.XPHASE_SETUP == "Dual-phase")))
        prop NoGen :: 1
        prop TabName :: "Transmit Modes"
	  prop Set ::  (	.XCOMPAND_SETUP = $1,
				.XCR2_VALUE = .XCR2_VALUE_update(),				    
				"ok"
			   )
	}
	prop XCOMPAND_XCR2 :: (
		(.XCOMPAND_SETUP == "No Companding-MSB First") ? 0x0000 :
		(.XCOMPAND_SETUP == "No Companding-LSB First") ? 0x0008 :
		(.XCOMPAND_SETUP == "u-Law") ? 0x0010 :
		0x0018
	)
	inst FSXM_FSGM_SETUP :: "External" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "External,DXR[1/2]-to-XSR[1/2] Copy,FSG Signal"
        prop Label :: "Transmit Frame-Sync Source "
	  prop JSName :: "mcbspPcrFsxm"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.XIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "Transmit Modes"
	  prop Set ::  (	.FSXM_FSGM_SETUP = $1,
                        if ($1 == "External") {
                            .FSXM_SETUP = "External",
                            .FSGM_SETUP = "Disable"
                        }
                        else {
                            if ($1 == "DXR[1/2]-to-XSR[1/2] Copy") {
                                .FSXM_SETUP = "Sample Rate Gen",
                                .FSGM_SETUP = "Disable"
                            }
                            else {
                                .FSXM_SETUP = "Sample Rate Gen",
                                .FSGM_SETUP = "Enable"
                            }
                        },
				.SRGR2_VALUE = .SRGR2_VALUE_update(),
                        .PCR_VALUE = .PCR_VALUE_update,
				"ok"
			   )
	}
      prop FSXM_FSGM_SETUP_update :: (
           ((.FSXM_SETUP == "External") && (.FSGM_SETUP == "Disable")) ? "External" :
             ((.FSXM_SETUP == "Sample Rate Gen") && (.FSGM_SETUP == "Disable")) ?
              "DXR[1/2]-to-XSR[1/2] Copy" :
               "FSG Signal"
      )
      
	inst RIOEN_SETUP :: 1 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Configure DR, FSR, CLKR, and CLKS as Serial Port Pins "
	prop JSName :: "mcbspPcrRioen"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man)
        prop NoGen :: 1
        prop TabName :: "General"
	  prop Set ::  (	.RIOEN_SETUP = $1,
                        .RIOEN2_SETUP = $1,
				.PCR_VALUE = .PCR_VALUE_update(),
                        .PCR_VALUE &= 0xF5FF,
                        .FSR_IO = "Input",
                        .CLKR_IO = "Input",
				"ok"
			   )
	}
	prop RIOEN_PCR :: (
		(.RIOEN_SETUP == 1) ? 0x0000 : 0x1000
	)
	inst RIOEN2_SETUP :: 1 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Configure DR, FSR, CLKR, and CLKS as Serial Port Pins "
        prop Visible :: 0
        prop Writable :: !(.MCBSP_man)
        prop NoGen :: 1
        prop TabName :: "General"
	  prop Set ::  (	.RIOEN_SETUP = $1,
                        .RIOEN2_SETUP = $1,
				.PCR_VALUE = .PCR_VALUE_update(),
				"ok"
			   )
	}
      
	inst CLKRM1_SETUP :: "External" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "External,Internal"
        prop Label :: "Clock Mode (CLKRM) "
	prop JSName :: "mcbspPcrClkrm"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.DLB_SETUP == "Disable") && (.RIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Receive Modes"
	  prop Set ::  (	.CLKRM1_SETUP = $1,
				.PCR_VALUE = .PCR_VALUE_update(),
				"ok"
			   )
	}
	
	inst CLKRM2_SETUP :: "CLKX Driven" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "CLKX Driven,CLKR as Output"
        prop Label :: "SPI Clock Mode (CLKRM) "
	prop JSName :: "mcbspPcrClkrmDlb"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.DLB_SETUP == "Enable"))
        prop NoGen :: 1
        prop TabName :: "Receive Modes"
	  prop Set ::  (	.CLKRM2_SETUP = $1,
				.PCR_VALUE = .PCR_VALUE_update(),
				"ok"
			   )
	}
	prop CLKRM_PCR :: (
		if (.DLB_SETUP == "Disable") {
		  (.CLKRM1_SETUP == "External") ? (.CLKRM2_SETUP = "CLKX Driven", 0x0000) :
		  (.CLKRM2_SETUP = "CLKR as Output", 0x0100)
		}
		else {
		  (.CLKRM2_SETUP == "CLKX Driven") ? (.CLKRM1_SETUP = "External", 0x0000) :
		  (.CLKRM1_SETUP = "Internal", 0x0100)
		}
	)
      
	inst CLKRP_SETUP :: "Falling Edge" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Rising Edge,Falling Edge"
        prop Label :: "Clock Polarity (CLKRP) "
	prop JSName :: "mcbspPcrClkrp"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.RIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Receive Modes"
	  prop Set ::  (	.CLKRP_SETUP = $1,
				.PCR_VALUE = .PCR_VALUE_update(),
				"ok"
			   )
	}
	prop CLKRP_PCR :: (
		(.CLKRP_SETUP == "Rising Edge") ? 0x0001 : 0x0000
	)
      
	inst FSRP_SETUP :: "Active High" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Active High,Active Low"
        prop Label :: "Frame-Sync Polarity (FSRP) "
	prop JSName :: "mcbspPcrFsrp"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.RIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Receive Modes"
	  prop Set ::  (	.FSRP_SETUP = $1,
				.PCR_VALUE = .PCR_VALUE_update(),
				"ok"
			   )
	}
	prop FSRP_PCR :: (
		(.FSRP_SETUP == "Active High") ? 0x0000 : 0x0004
	)
      
	inst RDATDLY_SETUP :: "0-bit" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0-bit,1-bit,2-bit"
        prop Label :: "Receive Delay (RDATDLY) "
	prop JSName :: "mcbspRcr2Rdatdly"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.RIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Receive Modes"
	  prop Set :: (	.RDATDLY_SETUP = $1,
				.RCR2_VALUE = .RCR2_VALUE_update(),
				"ok"
			  )
	}
	prop RDATDLY_RCR2 :: (
		(.RDATDLY_SETUP == "0-bit") ? 0x0000 :
		(.RDATDLY_SETUP == "1-bit") ? 0x0001 :
		0x0002
	)
      
	inst RPHASE_SETUP :: "Single-phase" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Single-phase,Dual-phase"
        prop Label :: "Phases (RPHASE) "
	prop JSName :: "mcbspRcr2Rphase"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.RIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Receive Lengths"
	  prop Set ::  (	.RPHASE_SETUP = $1,
				.RCR2_VALUE = .RCR2_VALUE_update(),
				"ok"
			   )
	}
	prop RPHASE_RCR2 :: (
		(.RPHASE_SETUP == "Single-phase") ? 0x0000 : 0x8000
	)
	inst RWDLEN1_SETUP :: "8-bits" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "8-bits,12-bits,16-bits,20-bits,24-bits,32-bits"
        prop Label :: "Word Length Phase1 (RWDLEN1) "
	prop JSName :: "mcbspRcr1Rwdlen1"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.RIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Receive Lengths"
	  prop Set ::  (	.RWDLEN1_SETUP = $1,
				.RCR1_VALUE = .RCR1_VALUE_update(),
				"ok"
			   )
	}
	prop RWDLEN1_RCR1 :: (
		(.RWDLEN1_SETUP == "8-bits") ? 0x0000 :
		(.RWDLEN1_SETUP == "12-bits") ? 0x0020 :
		(.RWDLEN1_SETUP == "16-bits") ? 0x0040 :
		(.RWDLEN1_SETUP == "20-bits") ? 0x0060 :
		(.RWDLEN1_SETUP == "24-bits") ? 0x0080 :
		0x00A0
	)
	inst RWDLEN2_SETUP :: "8-bits" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "8-bits,12-bits,16-bits,20-bits,24-bits,32-bits"
        prop Label :: "Word Length Phase2 (RWDLEN2) "
	prop JSName :: "mcbspRcr2Rwdlen2"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.RPHASE_SETUP == "Dual-phase") && (.RIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Receive Lengths"
	  prop Set ::  (	.RWDLEN2_SETUP = $1,
				.RCR2_VALUE = .RCR2_VALUE_update(),
				"ok"
			   )
	}
	prop RWDLEN2_RCR2 :: (
		(.RWDLEN2_SETUP == "8-bits") ? 0x0000 :
		(.RWDLEN2_SETUP == "12-bits") ? 0x0020 :
		(.RWDLEN2_SETUP == "16-bits") ? 0x0040 :
		(.RWDLEN2_SETUP == "20-bits") ? 0x0060 :
		(.RWDLEN2_SETUP == "24-bits") ? 0x0080 :
		0x00A0
	)
	inst RFRLEN1_SETUP :: 1 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Words/Frame Phase1 (RFRLEN1) "
	prop JSName :: "mcbspRcr1Rfrlen1"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.RIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Receive Lengths"
	  prop Set :: (	if (($1 <=128) && ($1 >= 1)) {
				  .RFRLEN1_SETUP = $1,
				  .RCR1_VALUE = .RCR1_VALUE_update(),
				  "ok"
				}
				else {"Invalid value"}
			  )
	}
	prop RFRLEN1_RCR1 :: ((.RFRLEN1_SETUP - 1) << 8)
	inst RFRLEN2_SETUP :: 1 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Words/Frame Phase2 (RFRLEN2) "
	prop JSName :: "mcbspRcr2Rfrlen2"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.RPHASE_SETUP == "Dual-phase") && (.RIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Receive Lengths"
	  prop Set :: (	if (($1 <=128) && ($1 >= 1)) {
				    	.RFRLEN2_SETUP = $1,
				    	.RCR2_VALUE = .RCR2_VALUE_update(),
					"ok"}
				else {"Invalid value"})
	}
	prop RFRLEN2_RCR2 :: ((.RFRLEN2_SETUP-1) << 8)
      
	inst RSYNCERR_SETUP :: "Disable" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Detect Sync Error (RSYNCERR) "
	prop JSName :: "mcbspSpcr1Rsyncerr"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.RIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "Receive Modes"
	  prop Set ::  (	.RSYNCERR_SETUP = $1,
				.SPCR1_VALUE = .SPCR1_VALUE_update(),
				"ok"
			   )
	}
	prop RSYNCERR_SPCR1 :: (
		(.RSYNCERR_SETUP == "Enable") ? 0x0008 : 0x0000
	)
      
	inst RINTM_SETUP :: "RRDY" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "RRDY,End of block/frame,New Frame Sync.,RSYNCERR"
        prop Label :: "Interrupt Mode (RINTM) "
	prop JSName :: "mcbspSpcr1Rintm"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.RIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Receive Modes"
	  prop Set ::  (	.RINTM_SETUP = $1,
				.SPCR1_VALUE = .SPCR1_VALUE_update(),
				"ok"
			   )
	}
	prop RINTM_SPCR1 :: (
		(.RINTM_SETUP == "RRDY") ? 0x0000 :
		(.RINTM_SETUP == "End of block/frame") ? 0x0010 :
		(.RINTM_SETUP == "New Frame Sync.") ? 0x0020 :
		0x0030
	)
      
	inst FSRM_SETUP :: "External" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "External,Sample Rate Gen"
        prop Label :: "Frame-Sync Mode (FSRM) "
	prop JSName :: "mcbspPcrFsrm"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.RIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "Receive Modes"
	  prop Set ::  (	.FSRM_SETUP = $1,
				.PCR_VALUE = .PCR_VALUE_update(),
				"ok"
			   )
	}
	prop FSRM_PCR :: (
		(.FSRM_SETUP == "External") ? 0x0000 : 0x0400
	)
	inst RFIG_SETUP :: "Restart Transfer" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Restart Transfer,Ignore"
        prop Label :: "Early Frame Sync Response (RFIG) "
	prop JSName :: "mcbspRcr2Rfig"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.RIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "Receive Modes"
	  prop Set ::  (	.RFIG_SETUP = $1,
				.RCR2_VALUE = .RCR2_VALUE_update(),
				"ok"
			   )
	}
	prop RFIG_RCR2 :: (
		(.RFIG_SETUP == "Restart Transfer") ? 0x0000 : 0x0004
	)
      
	inst RJUST_SETUP :: "Right-justify/zero-fill" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Right-justify/zero-fill,Right-justify/sign-extend,Left-justify/zero-fill"
        prop Label :: "Sign-Ext and Justification (RJUST) "
	prop JSName :: "mcbspSpcr1Rjust"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.RIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "Receive Modes"
	  prop Set ::  (	.RJUST_SETUP = $1,
				.SPCR1_VALUE = .SPCR1_VALUE_update(),
				"ok"
			   )
	}
	prop RJUST_SPCR1 :: (
		(.RJUST_SETUP == "Right-justify/zero-fill") ? 0x0000 :
		(.RJUST_SETUP == "Right-justify/sign-extend") ? 0x2000 :
		0x4000
	)
      
	inst RCOMPAND_SETUP :: "No Companding-MSB First" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "No Companding-MSB First,No Companding-LSB First,u-Law,A-Law"
        prop Label :: "Companding (RCOMPAND) "
	prop JSName :: "mcbspRcr2Rcompand"
        prop Visible :: 1
        prop Writable :: ((!(.MCBSP_man)) && (.RIOEN_SETUP == 1) && (.RWDLEN1_SETUP == "8-bits") && ((.RWDLEN2_SETUP == "8-bits") || !(.RPHASE_SETUP == "Dual-phase")))
        prop NoGen :: 1
        prop TabName :: "Receive Modes"
	  prop Set ::  (	.RCOMPAND_SETUP = $1,
				.RCR2_VALUE = .RCR2_VALUE_update(),
				"ok"
			   )
	}
	
	prop RCOMPAND_RCR2 :: (
		(.RCOMPAND_SETUP == "No Companding-MSB First") ? 0x0000 :
		(.RCOMPAND_SETUP == "No Companding-LSB First") ? 0x0008 :
		(.RCOMPAND_SETUP == "u-Law") ? 0x0010 :
		0x0018
	)
	inst FREE_SOFT_SETUP :: "Stop Immediately" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Stop Immediately,Stop After Current Word,Do Not Stop"
        prop Label :: "Breakpoint Emulation "
	prop JSName :: "mcbspSpcr2Free"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man)
        prop NoGen :: 1
        prop TabName :: "General"
	  prop Set ::  (	.FREE_SOFT_SETUP = $1,
				.SPCR2_VALUE = .SPCR2_VALUE_update(),
				"ok"
			   )
	}
	prop FREE_SOFT_SPCR2 :: (
		(.FREE_SOFT_SETUP == "Stop Immediately") ? 0x0000 :
            (.FREE_SOFT_SETUP == "Stop After Current Word") ? 0x0100 :
            0x0200
	)
	inst CLKSTP_SETUP :: "Disable" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Rising Edge w/o Delay,Falling Edge w/o Delay,Rising Edge w/ Delay,Falling Edge w/ Delay"
        prop Label :: "SPI Mode (CLKSTP) "
	prop JSName :: "mcbspSpcr1Clkstp"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.ABIS_SETUP == "Disable"))
        prop NoGen :: 1
        prop TabName :: "General"
	  prop Set ::  (	.CLKSTP_SETUP = $1,
				.SPCR1_VALUE = .SPCR1_VALUE_update(),
				.PCR_VALUE = .PCR_VALUE_update(),
				"ok"
			   )
	}
	prop CLKSTP_SPCR1 :: (
		(.CLKSTP_SETUP == "Disable") ? 0x0000 :
		(.CLKSTP_SETUP == "Rising Edge w/o Delay") ? (.CLKXP_SETUP = "Rising Edge", 0x1000) :
		(.CLKSTP_SETUP == "Falling Edge w/o Delay") ? (.CLKXP_SETUP = "Falling Edge", 0x1000) :
		(.CLKSTP_SETUP == "Rising Edge w/ Delay") ? (.CLKXP_SETUP = "Rising Edge", 0x1800) :
		(.CLKXP_SETUP = "Falling Edge", 0x1800)
	)
      
	inst DLB_SETUP :: "Disable" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Digital Loop Back (DLB) "
	prop JSName :: "mcbspSpcr1Dlb"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man)
        prop NoGen :: 1
        prop TabName :: "General"
	  prop Set ::  (	.DLB_SETUP = $1,
				.SPCR1_VALUE = .SPCR1_VALUE_update(),
				"ok"
			   )
	}
	prop DLB_SPCR1 :: (
		(.DLB_SETUP == "Enable") ? 0x8000 : 0x0000
	)
      
	inst ABIS_SETUP :: "Disable" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "A-Bis (ABIS) "
	prop JSName :: "mcbspSpcr1Abis"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.CLKSTP_SETUP == "Disable"))
        prop NoGen :: 1
        prop TabName :: "General"
	  prop Set ::  (	.ABIS_SETUP = $1,
				.SPCR1_VALUE = .SPCR1_VALUE_update(),
				"ok"
			   )
	}
	prop ABIS_SPCR1 :: (
		(.ABIS_SETUP == "Enable") ? 0x0040 : 0x0000
	)
	inst GRST_SETUP :: 1 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Sample Rate Generator Enable "
        prop Visible :: 0
        prop Writable :: !(.MCBSP_man)
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Gen"
	  prop Set :: 	(.GRST_SETUP = $1,
				 "ok"
				)
	}
      
	inst CLKSM_SETUP :: "CLKS Pin" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "CLKS Pin,CPU Clock,BCLKR Pin,BCLKX Pin"
        prop Label :: "SRG Clock Source (CLKSM) "
	prop JSName :: "mcbspSrgr2Clksm"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.GRST_SETUP == 1) && ((.XIOEN_SETUP == 1) || (.RIOEN_SETUP == 1)))
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Gen"
	  prop Set ::  (	
      			.CLKSM_SETUP = $1,
                        .SCLKME_SETUP = $1,
				.PCR_VALUE = .PCR_VALUE_update(),
				.SRGR2_VALUE = .SRGR2_VALUE_update(),
				"ok"
			   )
	}
	prop CLKSM_SRGR2 :: (
		((.CLKSM_SETUP == "CPU Clock") || (.CLKSM_SETUP == "BCLKX Pin")) ? 0x2000 : 0x0000
	)
      
	inst SCLKME_SETUP :: "CLKS Pin" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum :: "CLKS Pin,CPU Clock,BCLKR Pin,BCLKX Pin"
        prop Label :: "SCLKME(NOT visible) "
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Gen"
	}
	prop SCLKME_PCR :: (
			(.SCLKME_SETUP == "BCLKX Pin") ? 0x0080 :
			(.SCLKME_SETUP == "BCLKR Pin") ? 0x0080 :
			0x0000
	)
      
	inst GSYNC_SETUP :: "Disable" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Clock Synchronization With CLKS Pin (GSYNC) "
	prop JSName :: "mcbspSrgr2Gsync"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.CLKSM_SETUP == "CLKS Pin") && (.GRST_SETUP == 1) && ((.XIOEN_SETUP == 1) || (.RIOEN_SETUP == 1)))
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Gen"
	  prop Set ::  (	.GSYNC_SETUP = $1,
				.SRGR2_VALUE = .SRGR2_VALUE_update(),
				"ok"
			   )
	}
	prop GSYNC_SRGR2 :: (
		(.GSYNC_SETUP == "Enable") ? 0x8000 : 0x0000
	)
      
	inst CLKSP_SETUP :: "Rising Edge of CLKS" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Rising Edge of CLKS,Falling Edge of CLKS"
        prop Label :: "CLKS Polarity Clock Edge (From CLKS Pin) (CLKSP) "
	prop JSName :: "mcbspSrgr2Clksp"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.CLKSM_SETUP == "CLKS Pin") && (.GRST_SETUP == 1) && ((.XIOEN_SETUP == 1) || (.RIOEN_SETUP == 1)))
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Gen"
	  prop Set ::  (	.CLKSP_SETUP = $1,
				.SRGR2_VALUE = .SRGR2_VALUE_update(),
				"ok"
			   )
	}
      prop CLKSTP_SETUP_update :: (
           ((.SPCR1_VALUE & 0x1800) == (0x1800)) ? 
                      ((.PCR_VALUE & 0x0002) ? "Falling Edge" : "Rising Edge w/ Delay"):
               (.SPCR1_VALUE & 0x1000) ? 
                     ((.PCR_VALUE & 0x0002) ? "Falling Edge w/o Delay" : "Rising Edge w/o Delay") :
                           "Disable"
      )
	prop CLKSP_SRGR2 :: (
		(.CLKSP_SETUP == "Rising Edge of CLKS") ? 0x0000 : 0x4000
	)
      
	inst FSGM_SETUP :: "Disable" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Transmit Frame-Sync Mode (FSXM = 1) (FSGM) "
	prop JSName :: "mcbspSrgr2Fsgm"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.FSXM_SETUP == "Sample Rate Gen") && (.GRST_SETUP == 1) && ((.XIOEN_SETUP == 1) || (.RIOEN_SETUP == 1)))
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Gen"
	  prop Set ::  (	.FSGM_SETUP = $1,
				.SRGR2_VALUE = .SRGR2_VALUE_update(),
				"ok"
			   )
	}
	prop FSGM_SRGR2 :: (
		(.FSGM_SETUP == "Enable") ? 0x1000 : 0x0000
	)
      
	inst FWID_SETUP :: 1 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Frame Width (1-256) (FWID) "
	prop JSName :: "mcbspSrgr1Fwid"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.GRST_SETUP == 1) && ((.XIOEN_SETUP == 1) || (.RIOEN_SETUP == 1)))
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Gen"
	  prop Set :: (	if (($1 <= 256) && ($1 >= 1)) {
				    .FWID_SETUP = $1,
				    .SRGR1_VALUE = .SRGR1_VALUE_update(),
				    "ok"}
				else {"Invalid value"})
	}
	prop FWID_SRGR1 :: ((.FWID_SETUP - 1) << 8)
      
	inst CLKGDV_SETUP :: 1 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Clock Divider (1-256) (CLKGDV) "
	prop JSName :: "mcbspSrgr1Clkgdv"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.GRST_SETUP == 1) && ((.XIOEN_SETUP == 1) || (.RIOEN_SETUP == 1)))
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Gen"
	  prop Set :: (	if (($1 <= 256) && ($1 >= 1)) {
				    .CLKGDV_SETUP = $1,
				    .SRGR1_VALUE = .SRGR1_VALUE_update(),
				    "ok"}
				else {"Invalid value"})
	}
	prop CLKGDV_SRGR1 :: (.CLKGDV_SETUP - 1)
      
	inst FPER_SETUP :: 1 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Frame Period (1-4096) (FPER) "
	prop JSName :: "mcbspSrgr2Fper"
        prop Visible :: 1
        prop Writable :: (!(.MCBSP_man) && (.GRST_SETUP == 1) && ((.XIOEN_SETUP == 1) || (.RIOEN_SETUP == 1)))
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Gen"
	  prop Set :: (	if (($1 <= 4096) && ($1 >= 1)) {
				    .FPER_SETUP = $1,
				    .SRGR2_VALUE = .SRGR2_VALUE_update(),
				    "ok"}
				else {"Invalid value"})
	}
	prop FPER_SRGR2 :: (.FPER_SETUP - 1)
      
	prop CLKS_SUPPORT :: (
		          1 
	)
      
	inst CLKX_IO :: "Input" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Select CLKX Pin as "
	  prop Enum  :: "Input,Output"
	  prop JSName :: "mcbspGpioClkx"
	  prop Visible :: 1
	  prop Writable :: !(.MCBSP_man) && (.XIOEN_SETUP == 0)
	  prop NoGen :: 1
	  prop TabName :: "GPIO"
	  prop Set :: (.CLKX_IO = $1,
                     if (.CLKX_IO == "Output") {
                         .PCR_VALUE |= (0x0200)
                     }
                     else {
                         .PCR_VALUE &= (0xFDFF)
                     },
			   "ok"
             )
      }
	
	inst FSX_IO :: "Input" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Select FSX Pin as "
	  prop Enum  :: "Input,Output"
	  prop JSName :: "mcbspGpioFsx"
	  prop Visible :: 1
	  prop Writable :: !(.MCBSP_man) && (.XIOEN_SETUP == 0)
	  prop NoGen :: 1
	  prop TabName :: "GPIO"
	  prop Set :: (.FSX_IO = $1,
                     if (.FSX_IO == "Output") {
                         .PCR_VALUE |= (0x0800)
                     }
                     else {
                         .PCR_VALUE &= (0xF7FF)
                     },
			   "ok"
             )
      }
	
	inst CLKR_IO :: "Input" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Select CLKR Pin as "
	  prop Enum  :: "Input,Output"
	  prop JSName :: "mcbspGpioClkr"
	  prop Visible :: 1
	  prop Writable :: !(.MCBSP_man) && (.RIOEN_SETUP == 0)
	  prop NoGen :: 1
	  prop TabName :: "GPIO"
	  prop Set :: (.CLKR_IO = $1,
                     if (.CLKR_IO == "Output") {
                         .PCR_VALUE |= (0x0100)
                     }
                     else {
                         .PCR_VALUE &= (0xFEFF)
                     },
			   "ok"
             )
      }
	inst FSR_IO :: "Input" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Select FSR Pin as "
	  prop Enum  :: "Input,Output"
	  prop JSName :: "mcbspGpioFsr"
	  prop Visible :: 1
	  prop Writable :: !(.MCBSP_man) && (.RIOEN_SETUP == 0)
	  prop NoGen :: 1
	  prop TabName :: "GPIO"
	  prop Set :: (.FSR_IO = $1,
                     if (.FSR_IO == "Output") {
                         .PCR_VALUE |= (0x0400)
                     }
                     else {
                         .PCR_VALUE &= (0xFBFF)
                     },
			   "ok"
             )
      }
	inst EN_DX :: "Output" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum  :: "Unused,Output"
	  prop Label :: "Select DX Pin as "
	  prop JSName :: "mcbspGpioDx"
	  prop Visible :: 1
	  prop Writable :: 0
	  prop NoGen :: 1
	  prop TabName :: "GPIO"
      }
	inst EN_DR :: "Input" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum  :: "Unused,Input"
	  prop Label :: "Select DR Pin as "
	  prop JSName :: "mcbspGpioDr"
	  prop Visible :: 1
	  prop Writable :: 0
	  prop NoGen :: 1
	  prop TabName :: "GPIO"
      }
	inst EN_CLKS :: "Input" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum  :: "Unused,Input"
	  prop Label :: "Select CLKS Pin as "
	  prop JSName :: "mcbspGpioClks"
	  prop Visible :: 1
	  prop Writable :: 0
	  prop NoGen :: 1
	  prop TabName :: "GPIO"
      }
      
	
	prop MCR1_VALUE_update :: (
		   .RPBBLK_MCR1()
		|  .RPABLK_MCR1()
		|  .RMCM_MCR1()
            |  .RMCME_MCR1()
	)
	prop MCR2_VALUE_update :: (
               .XPBBLK_MCR2()
		|  .XPABLK_MCR2()
		|  .XMCM_MCR2()
		|  .XMCME_MCR2()
	)
	prop PCR_VALUE_update :: (
		   .XIOEN_PCR()
		|  .RIOEN_PCR()
		|  .FSXM_PCR()
		|  .FSRM_PCR()
		|  .CLKXM_PCR()
		|  .CLKRM_PCR()
		|  .FSXP_PCR()
		|  .FSRP_PCR()
		|  .CLKXP_PCR()
		|  .CLKRP_PCR()
		|  .SCLKME_PCR()
            |  .IDLE_EN_PCR()
	)
	
	prop RCR1_VALUE_update :: (
		   .RFRLEN1_RCR1()
		|  .RWDLEN1_RCR1()
	)
	prop RCR2_VALUE_update :: (
		   .RDATDLY_RCR2()
		|  .RPHASE_RCR2()
		|  .RFRLEN2_RCR2()
		|  .RWDLEN2_RCR2()
		|  .RFIG_RCR2()
		|  .RCOMPAND_RCR2()
	)
	prop SPCR1_VALUE_update :: (
		   .DLB_SPCR1()
		|  .RJUST_SPCR1()
		|  .CLKSTP_SPCR1()
		|  .DXENA_SPCR1()
		|  .ABIS_SPCR1()
		|  .RINTM_SPCR1()
		|  .RSYNCERR_SPCR1()
	)
	prop SPCR2_VALUE_update :: (
		   .FREE_SOFT_SPCR2()
		|  .XSYNCERR_SPCR2()
		|  .XINTM_SPCR2()
	)
	prop SRGR1_VALUE_update :: (
		   .FWID_SRGR1()
		|  .CLKGDV_SRGR1()
	)
	prop SRGR2_VALUE_update :: (
		   .GSYNC_SRGR2()
		|  .CLKSP_SRGR2()
		|  .CLKSM_SRGR2()
		|  .FSGM_SRGR2()
		|  .FPER_SRGR2()
	)
	
	prop XCR1_VALUE_update :: (
		   .XFRLEN1_XCR1()
		|  .XWDLEN1_XCR1()
	)
	prop XCR2_VALUE_update :: (
		   .XPHASE_XCR2()
		|  .XFRLEN2_XCR2()
		|  .XWDLEN2_XCR2()
		|  .XCOMPAND_XCR2()
		|  .XFIG_XCR2()
		|  .XDATDLY_XCR2()
	)
	
	
	prop PCR_SETUP_update ::  (
		.IDLE_EN_SETUP = ($1 & 0x4000) ? 1 : 0,
		.XIOEN_SETUP = ($1 & 0x2000) ? 0 : 1,
		.XIOEN2_SETUP = ($1 & 0x2000) ? 0 : 1,
		.RIOEN_SETUP = ($1 & 0x1000) ? 0 : 1,
		.RIOEN2_SETUP = ($1 & 0x1000) ? 0 : 1,
            if (.XIOEN_SETUP == 0) {
                .CLKX_IO = ($1 & 0x0200) ? "Output" : "Input",
                .FSX_IO = ($1 & 0x0800) ? "Output" : "Input",
                if (.RIOEN_SETUP == 0) {
                    .CLKR_IO = ($1 & 0x0100) ? "Output" : "Input",
                    .FSR_IO = ($1 & 0x0400) ? "Output" : "Input"
                }
            }
            else {
		    .FSXM_SETUP = ($1 & 0x0800) ? "Sample Rate Gen" : "External",
	  	    .FSRM_SETUP = ($1 & 0x0400) ? "Sample Rate Gen" : "External",
                .FSGM_SETUP = (.SRGR2_VALUE & 0x1000) ? "Enable" : "Disable", 
                .FSXM_FSGM_SETUP = .FSXM_FSGM_SETUP_update(), 
		    .CLKXM1_SETUP = ($1 & 0x0200) ? "Internal" : "External",
		    .CLKXM2_SETUP = ($1 & 0x0200) ? "Master" : "Slave",
		    .CLKRM1_SETUP = ($1 & 0x0100) ? "Internal" : "External",
		    .CLKRM2_SETUP = ($1 & 0x0100) ? "CLKR as Output" : "CLKX Driven",
		    .FSXP_SETUP = ($1 & 0x0008) ? "Active Low" : "Active High",
		    .FSRP_SETUP = ($1 & 0x0004) ? "Active Low" : "Active High",
		    .CLKXP_SETUP = ($1 & 0x0002) ? "Falling Edge" : "Rising Edge",
 		    .CLKRP_SETUP = ($1 & 0x0001) ? "Rising Edge" : "Falling Edge",
                .CLKSTP_SETUP = .CLKSTP_SETUP_update(),
                .CLKSM_SETUP = ($a = $1 & 0x0080,
                     (($a == 0x0080) && (!(.SRGR2_VALUE & 0x2000))) ? "BCLKR Pin" :
                     (($a == 0x0080) && (.SRGR2_VALUE & 0x2000)) ? "BCLKX Pin" :
                     (($a == 0x0000) && (!(.SRGR2_VALUE & 0x2000))) ? "CLKS Pin" :
                     "CPU Clock")
            }
	)
	prop RCR1_SETUP_update :: (
		.RFRLEN1_SETUP = ((($1 & 0x7F00) >> 8) + 1),
		.RWDLEN1_SETUP = 	($a = $1 & 0x00E0,
					($a == 0x0000) ? "8-bits" :
					($a == 0x0020) ? "12-bits" :
					($a == 0x0040) ? "16-bits" :
					($a == 0x0060) ? "20-bits" :
					($a == 0x0080) ? "24-bits" :
					"32-bits")
	)
	prop RCR2_SETUP_update :: (
		.RPHASE_SETUP =  ($1 & 0x8000) ? "Dual-phase" : "Single-phase",
		.RFRLEN2_SETUP = ((($1 & 0x7F00) >> 8) + 1),
		.RWDLEN2_SETUP = 	($a = $1 & 0x00E0,
					($a == 0x0000) ? "8-bits"  :
					($a == 0x0020) ? "12-bits" :
					($a == 0x0040) ? "16-bits" :
					($a == 0x0060) ? "20-bits" :
					($a == 0x0080) ? "24-bits" :
					"32-bits"),
		.RFIG_SETUP =	($1 & 0x0004) ? "Ignore" : "Restart Transfer",
		.RDATDLY_SETUP =	($a = $1 & 0x0003,
					($a == 0x0000) ? "0-bit" :
					($a == 0x0001) ? "1-bit" :
					"2-bit"),
		.RCOMPAND_SETUP =	($a = $1 & 0x0018,
					($a == 0x0000) ? "No Companding-MSB First" :
					($a == 0x0008) ? "No Companding-LSB First" :
					($a == 0x0010) ? "u-Law" :
					"A-Law")
	)
	prop SPCR1_SETUP_update :: (
		.DLB_SETUP = ($1 & 0x8000) ? "Enable" : "Disable",
		.RJUST_SETUP =	($a = $1 & 0x6000,
					($a == 0x0000) ? "Right-justify/zero-fill" :
					($a == 0x2000) ? "Right-justify/sign-extend" :
					"Left-justify/zero-fill"),
		.DXENA_SETUP = ($1 & 0x0080) ? "Enable" : "Disable",
		.ABIS_SETUP = ($1 & 0x0040) ? "Enable" : "Disable",
		.RINTM_SETUP = 	($a = $1 & 0x0030,
					($a == 0x0000) ? "RRDY" :
					($a == 0x0010) ? "End of block/frame" :
					($a == 0x0020) ? "New Frame Sync." :
					"RSYNCERR"),						
		.RSYNCERR_SETUP = ($1 & 0x0008) ? "Enable" : "Disable",
		.CLKSTP_SETUP = 	($a = $1 & 0x1800,
					if ($a == 0x0000) {"Disable"}
					else {
					   if (.CLKXP_SETUP == "Rising Edge") {
						($a == 0x1000) ? "Rising Edge w/o Delay" : "Rising Edge w/ Delay"
					   }
					   else {
					   	($a == 0x1000) ? "Falling Edge w/o Delay" : "Falling Edge w/ Delay"
					   }
					})
					
	)
	
	prop SPCR2_SETUP_update :: (
		.FREE_SOFT_SETUP = ($a = $1 & 0x0300, 
                               ($a == 0x0000) ? "Stop Immediately" :
                               ($a == 0x0100) ? "Stop After Current Word" :
                               ($a == 0x0200) ? "Do Not Stop" :
                               "Do Not Stop"),		
            .XINTM_SETUP =	($a = $1 & 0x0030,
					($a == 0x0000) ? "XRDY" :
					($a == 0x0010) ? "End of block/frame" :
					($a == 0x0020) ? "New Frame Sync." :
					"XSYNCERR"),
		.XSYNCERR_SETUP = ($1 & 0x0008) ? "Enable" : "Disable"
	)
	prop SRGR1_SETUP_update :: (
		.FWID_SETUP = ((($1 & 0xFF00) >> 8) + 1),
		.CLKGDV_SETUP = (($1 & 0x00FF) + 1)
	)
	prop SRGR2_SETUP_update :: (
		.GSYNC_SETUP = ($1 & 0x8000) ? "Enable" : "Disable",
		.CLKSP_SETUP = ($1 & 0x4000) ? "Falling Edge of CLKS" : "Rising Edge of CLKS",
		.CLKSM_SETUP = ($a = $1 & 0x2000,
                 (($a == 0x2000) && (!(.PCR_VALUE & 0x0080))) ? "CPU Clock" :
                 (($a == 0x2000) && (.PCR_VALUE & 0x0080)) ? "BCLKX Pin" :
                 (($a == 0x0000) && (!(.PCR_VALUE & 0x0080))) ? "CLKS Pin" :
                 "BCLKR Pin"),
		.FSGM_SETUP = ($1 & 0x1000) ? "Enable" : "Disable",
		.FPER_SETUP = (($1 & 0x0FFF) + 1)
	)
	prop XCR1_SETUP_update :: (
		.XFRLEN1_SETUP =  ((($1 & 0x7F00) >> 8) + 1),
		.XWDLEN1_SETUP =  ($a = $1 & 0x00E0,
					($a == 0x0020) ? "12-bits" :
					($a == 0x0040) ? "16-bits" :
					($a == 0x0060) ? "20-bits" :
					($a == 0x0080) ? "24-bits" :
					($a == 0x00A0) ? "32-bits" :
					"8-bits")
	)
	prop XCR2_SETUP_update :: (
		.XPHASE_SETUP  =	($1 & 0x8000) ? "Dual-phase" : "Single-phase",
		.XFRLEN2_SETUP =  ((($1 & 0x7F00) >> 8) + 1),
		.XWDLEN2_SETUP =  ($a = ($1 & 0x00E0),
					($a == 0x0020) ? "12-bits" :
					($a == 0x0040) ? "16-bits" :
					($a == 0x0060) ? "20-bits" :
					($a == 0x0080) ? "24-bits" :
					($a == 0x00A0) ? "32-bits" :
					"8-bits"),
		.XCOMPAND_SETUP = ($a = $1 & 0x0018,
					($a == 0x0008) ? "No Companding-LSB First" :
					($a == 0x0010) ? "u-Law" :
					($a == 0x0018) ? "A-Law" :
					"No Companding-MSB First"),
		.XFIG_SETUP =	($1 & 0x0004) ? "Ignore" : "Restart Transfer",
		.XDATDLY_SETUP =	($a = $1 & 0x0003,
					($a == 0x0000) ? "0-bit" :
					($a == 0x0001) ? "1-bit" :
					"2-bit")
	)
	prop MCR1_SETUP_update :: (
		.RPBBLK_SETUP =	($a = $1 & 0x0180,
					($a == 0x0000) ? "Block 1. Channel 16-31" :
					($a == 0x0080) ? "Block 3. Channel 48-63" :
					($a == 0x0100) ? "Block 5. Channel 80-95" :
					"Block 7. Channel 112-127"),
		.RPABLK_SETUP =	($a = $1 & 0x0060,
					($a == 0x0000) ? "Block 0. Channel 0-15" :
					($a == 0x0020) ? "Block 2. Channel 32-47" :
					($a == 0x0040) ? "Block 4. Channel 64-79" :
					"Block 6. Channel 96-111"),
		.RMCM_RMCME_SETUP = ($a = $1 & 0x0201,
                              ($a == 0x0000) ? "All 128 Channels" :
                              ($a == 0x0001) ? "2 Blocks(Up to 16Ch./Blk.)" :
                              "Any of 128 Ch.")
	)
	prop MCR2_SETUP_update :: (
		.XPABLK_SETUP =	($a = $1 & 0x0180,
					($a == 0x0000) ? "Block 0. Channel 0-15" :
					($a == 0x0080) ? "Block 2. Channel 32-47" :
					($a == 0x0100) ? "Block 4. Channel 64-79" :
					"Block 6. Channel 96-111"),
		.XPBBLK_SETUP =	($a = $1 & 0x0060,
					($a == 0x0000) ? "Block 1. Channel 16-31" :
					($a == 0x0020) ? "Block 3. Channel 48-63" :
					($a == 0x0040) ? "Block 5. Channel 80-95" :
					"Block 7. Channel 112-127"),
		.XMCM_XMCME_SETUP = ($a = $1 & 0x0203,
					($a == 0x0000) ? "All 128 Channels" :
					($a == 0x0001) ? "2 Blocks(Up to 16Ch./Blk. - XMCM=01)" :
					($a == 0x0002) ? "2 Blocks(Up to 16Ch./Blk. - XMCM=10)" :
					($a == 0x0003) ? "Symmetric Transmit and Receive" :
					"Any of 128 Ch.")
	)
	
	
	inst MCBSP_man :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Set Manually "
	  prop JSName :: "mcbspManualSet"
	  prop Visible :: 1
	  prop Writable :: 1
	  prop NoGen :: 1
	  prop TabName :: "Advanced A"
      }
	inst SPCR1_VALUE :: .SPCR1_VALUE_update() {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Serial Port Control Register 1 "
	prop JSName :: "mcbspSpcr1"
        prop Visible :: 1
        prop Writable :: .MCBSP_man
        prop NoGen :: 1
	  prop TabName :: "Advanced A"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set :: (	(($1 & 0x6000) == 0x6000) ? "Invalid RJUST Value" : (
				.SPCR1_VALUE = ($1 & 0xF8F9),
				.SPCR1_SETUP_update($1),
				"ok")
			  )
    	}
	inst SPCR2_VALUE :: .SPCR2_VALUE_update() {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Serial Port Control Register 2 "
	prop JSName :: "mcbspSpcr2"
        prop Visible :: 1
        prop Writable :: .MCBSP_man
        prop NoGen :: 1
	  prop TabName :: "Advanced A"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set :: (	.SPCR2_VALUE = ($1 & 0x03F9),
				.SPCR2_SETUP_update($1),
				"ok"
			  )
    	}
	inst RCR1_VALUE :: .RCR1_VALUE_update() {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Receive Control Register 1 "
	prop JSName :: "mcbspRcr1"
        prop Visible :: 1
        prop Writable :: .MCBSP_man
        prop NoGen :: 1
	  prop TabName :: "Advanced A"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set :: (	(($1 & 0x00E0) == 0x00E0) ? "Invalid RWDLEN1 Value" :
				(($1 & 0x00E0) == 0x00C0) ? "Invalid RWDLEN1 Value" : (
				.RCR1_VALUE = ($1 & 0x7FE0),
				.RCR1_SETUP_update($1),
				"ok")
			  )
    	}
	inst RCR2_VALUE :: .RCR2_VALUE_update() {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Receive Control Register 2 "
	prop JSName :: "mcbspRcr2"
        prop Visible :: 1
        prop Writable :: .MCBSP_man
        prop NoGen :: 1
	  prop TabName :: "Advanced A"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set :: (	(($1 & 0x00E0) == 0x00E0) ? "Invalid RWDLEN2 Value" :
				(($1 & 0x00E0) == 0x00C0) ? "Invalid RWDLEN2 Value" :
				(($1 & 0x0003) == 0x0003) ? "Invalid RDATDLY Value" : (
				.RCR2_VALUE = $1,
				.RCR2_SETUP_update($1),
				"ok")
			  )
    	}
	inst XCR1_VALUE :: .XCR1_VALUE_update() {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Transmit Control Register 1 "
	prop JSName :: "mcbspXcr1"
        prop Visible :: 1
        prop Writable :: .MCBSP_man
        prop NoGen :: 1
	  prop TabName :: "Advanced A"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set :: (	(($1 & 0x00E0) == 0x00E0) ? "Invalid XWDLEN1 Value" :
				(($1 & 0x00E0) == 0x00C0) ? "Invalid XWDLEN1 Value" : (
				.XCR1_VALUE = ($1 & 0x7FE0),
				.XCR1_SETUP_update($1),
				"ok")
			  )
    	}
	
	inst XCR2_VALUE :: .XCR2_VALUE_update() {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Transmit Control Register 2 "
	prop JSName :: "mcbspXcr2"
        prop Visible :: 1
        prop Writable :: .MCBSP_man
        prop NoGen :: 1
	  prop TabName :: "Advanced A"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set ::  (	(($1 & 0x00E0) == 0x00E0) ? "Invalid XWDLEN2 Value" :
				(($1 & 0x00E0) == 0x00C0) ? "Invalid XWDLEN2 Value" :
				(($1 & 0x0003) == 0x0003) ? "Invalid XDATDLY Value" : (
				.XCR2_VALUE = $1,
				.XCR2_SETUP_update($1),
				"ok")
			   )
    	}
	inst SRGR1_VALUE :: .SRGR1_VALUE_update() {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Sample Rate Generator Register 1 "
	prop JSName :: "mcbspSrgr1"
        prop Visible :: 1
        prop Writable :: .MCBSP_man
        prop NoGen :: 1
	  prop TabName :: "Advanced A"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set :: (	.SRGR1_VALUE = $1,
				.SRGR1_SETUP_update($1),
				"ok"
			  )
    	}
		
	inst SRGR2_VALUE :: .SRGR2_VALUE_update() {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Sample Rate Generator Register 2 "
	  prop JSName :: "mcbspSrgr2"
        prop Visible :: 1
        prop Writable :: .MCBSP_man
        prop NoGen :: 1
	  prop TabName :: "Advanced A"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set :: (	.SRGR2_VALUE = $1,
				.SRGR2_SETUP_update($1),
                        .FSXM_SETUP = (.PCR_VALUE & 0x800) ? "Sample Rate Gen" : "External",
                        .FSGM_SETUP = ($1 & 0x1000) ? "Enable" : "Disable",
                        .FSXM_FSGM_SETUP = .FSXM_FSGM_SETUP_update(),
				"ok"
			  )
    	}
	inst MCR1_VALUE :: .MCR1_VALUE_update() {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Multichannel Control Register 1 "
	  prop JSName :: "mcbspMcr1"
        prop Visible :: 1
        prop Writable :: .MCBSP_man
        prop NoGen :: 1
	  prop TabName :: "Advanced A"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set :: (	.MCR1_VALUE = ($1 & 0x03E1),
				.MCR1_SETUP_update($1),
				"ok"
			  )
    	}
	inst MCR2_VALUE :: .MCR2_VALUE_update() {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Multichannel Control Register 2 "
	prop JSName :: "mcbspMcr2"
        prop Visible :: 1
        prop Writable :: .MCBSP_man
        prop NoGen :: 1
	  prop TabName :: "Advanced A"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set :: (	.MCR2_VALUE = ($1 & 0x03E3),
				.MCR2_SETUP_update($1),
				"ok"
			  )
    	}
	inst PCR_VALUE :: .PCR_VALUE_update() {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Pin Control Register "
	prop JSName :: "mcbspPcr"
        prop Visible :: 1
        prop Writable :: .MCBSP_man
        prop NoGen :: 1
	  prop TabName :: "Advanced A"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set ::  (	.PCR_VALUE = ($1 & 0x7F8F),
				.PCR_SETUP_update($1),
				"ok"
			   )
    	}
	
	inst RMCM_RMCME_SETUP :: "All 128 Channels" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum :: "All 128 Channels,2 Blocks(Up to 16Ch./Blk.),Any of 128 Ch."
        prop Label :: "RX Channel Enable "
	prop JSName :: "mcbspMcr1RmcmRmcme"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.RIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "Receive Multichannel"
	  prop Set ::  (	.RMCM_RMCME_SETUP = $1,
				.MCR1_VALUE = .MCR1_VALUE_update(),
				"ok"
			   )
	}
	prop RMCM_MCR1 :: (
             (.RMCM_RMCME_SETUP == "All 128 Channels") ? 0x0000 :
             (.RMCM_RMCME_SETUP == "2 Blocks(Up to 16Ch./Blk.)") ? 0x0001 :
             0x0000
      )
	prop RMCME_MCR1 :: (
             (.RMCM_RMCME_SETUP == "Any of 128 Ch.") ? 0x0200 : 0x0000
      )
	inst RPABLK_SETUP :: "Block 0. Channel 0-15" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Block 0. Channel 0-15,Block 2. Channel 32-47,Block 4. Channel 64-79,Block 6. Channel 96-111"
        prop Label :: "Receive Partition A (RPABLK) "
	prop JSName :: "mcbspMcr1Rpablk"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.RMCM_RMCME_SETUP == "2 Blocks(Up to 16Ch./Blk.)") && (.RIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "Receive Multichannel"
	  prop Set ::  (	.RPABLK_SETUP = $1,
				.MCR1_VALUE = .MCR1_VALUE_update(),
				"ok"
			   )
	}
	prop RPABLK_MCR1 :: (
		(.RPABLK_SETUP == "Block 0. Channel 0-15") ? 0x0000 :
		(.RPABLK_SETUP == "Block 2. Channel 32-47") ? 0x0020 :
		(.RPABLK_SETUP == "Block 4. Channel 64-79") ? 0x0040 :
		0x0060
	)
	inst RPBBLK_SETUP :: "Block 1. Channel 16-31" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Block 1. Channel 16-31,Block 3. Channel 48-63,Block 5. Channel 80-95,Block 7. Channel 112-127"
        prop Label :: "Receive Partition B (RPBBLK) "
	prop JSName :: "mcbspMcr1Rpbblk"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.RMCM_RMCME_SETUP == "2 Blocks(Up to 16Ch./Blk.)") && (.RIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "Receive Multichannel"
	  prop Set ::  (	.RPBBLK_SETUP = $1,
				.MCR1_VALUE = .MCR1_VALUE_update(),
				"ok"
			   )
	}
	prop RPBBLK_MCR1 :: (
		(.RPBBLK_SETUP == "Block 1. Channel 16-31") ? 0x0000 :
		(.RPBBLK_SETUP == "Block 3. Channel 48-63") ? 0x0080 :
		(.RPBBLK_SETUP == "Block 5. Channel 80-95") ? 0x0100 :
		0x0180
	)
	inst RCERA_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition A "
	prop JSName :: "mcbspRcera"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.RIOEN_SETUP == 1) && ((.RMCM_RMCME_SETUP == "2 Blocks(Up to 16Ch./Blk.)") || (.RMCM_RMCME_SETUP == "Any of 128 Ch.")) && (.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Receive Multichannel"
	  prop cGen :: 1
	  prop cType :: "Uint16"
    	}
	inst RCERB_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition B "
	prop JSName :: "mcbspRcerb"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.RIOEN_SETUP == 1) && ((.RMCM_RMCME_SETUP == "2 Blocks(Up to 16Ch./Blk.)") || (.RMCM_RMCME_SETUP == "Any of 128 Ch.")) && (.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Receive Multichannel"
	  prop cGen :: 1
	  prop cType :: "Uint16"
    	}
	inst RCERC_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition C "
	prop JSName :: "mcbspRcerc"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.RIOEN_SETUP == 1) && (.RMCM_RMCME_SETUP == "Any of 128 Ch.") && (.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Receive Multichannel"
	  prop cGen :: 1
	  prop cType :: "Uint16"
    	}
	inst RCERD_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition D "
	prop JSName :: "mcbspRcerd"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.RIOEN_SETUP == 1) && (.RMCM_RMCME_SETUP == "Any of 128 Ch.") && (.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Receive Multichannel"
	  prop cGen :: 1
	  prop cType :: "Uint16"
    	}
	inst RCERE_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition E "
	prop JSName :: "mcbspRcere"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.RIOEN_SETUP == 1) && (.RMCM_RMCME_SETUP == "Any of 128 Ch.") && (.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Receive Multichannel"
	  prop cGen :: 1
	  prop cType :: "Uint16"
    	}
	inst RCERF_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition F "
	prop JSName :: "mcbspRcerf"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.RIOEN_SETUP == 1) && (.RMCM_RMCME_SETUP == "Any of 128 Ch.") && (.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Receive Multichannel"
	  prop cGen :: 1
	  prop cType :: "Uint16"
    	}
	inst RCERG_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition G "
	prop JSName :: "mcbspRcerg"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.RIOEN_SETUP == 1) && (.RMCM_RMCME_SETUP == "Any of 128 Ch.") && (.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Receive Multichannel"
	  prop cGen :: 1
	  prop cType :: "Uint16"
    	}
	inst RCERH_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition H "
	prop JSName :: "mcbspRcerh"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.RIOEN_SETUP == 1) && (.RMCM_RMCME_SETUP == "Any of 128 Ch.") && (.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Receive Multichannel"
	  prop cGen :: 1
	  prop cType :: "Uint16"
    	}
	inst XMCM_XMCME_SETUP :: "All 128 Channels" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum :: "All 128 Channels,2 Blocks(Up to 16Ch./Blk. - XMCM=01),2 Blocks(Up to 16Ch./Blk. - XMCM=10),Symmetric Transmit and Receive,Any of 128 Ch."
        prop Label :: "TX Channel Enable "
	prop JSName :: "mcbspMcr2XmcmXmcme"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.XIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "Transmit Multichannel"
	  prop Set ::  (	.XMCM_XMCME_SETUP = $1,
				.MCR2_VALUE = .MCR2_VALUE_update(),
				"ok"
			   )
	}
	prop XMCM_MCR2 :: (
             (.XMCM_XMCME_SETUP == "All 128 Channels") ? 0x0000 :
             (.XMCM_XMCME_SETUP == "2 Blocks(Up to 16Ch./Blk. - XMCM=01)") ? 0x0001 :
             (.XMCM_XMCME_SETUP == "2 Blocks(Up to 16Ch./Blk. - XMCM=10)") ? 0x0002 :
             (.XMCM_XMCME_SETUP == "Symmetric Transmit and Receive") ? 0x0003 :
             0x0000
      )
	prop XMCME_MCR2 :: (
             (.XMCM_XMCME_SETUP == "Any of 128 Ch.") ? 0x0200 : 0x0000
      )
	inst XPABLK_SETUP :: "Block 0. Channel 0-15" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Block 0. Channel 0-15,Block 2. Channel 32-47,Block 4. Channel 64-79,Block 6. Channel 96-111"
        prop Label :: "Transmit Partition A (XPABLK) "
	prop JSName :: "mcbspMcr2Xpablk"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.XIOEN_SETUP == 1)  && ((.XMCM_XMCME_SETUP == "2 Blocks(Up to 16Ch./Blk. - XMCM=01)") || (.XMCM_XMCME_SETUP == "2 Blocks(Up to 16Ch./Blk. - XMCM=10)") || (.XMCM_XMCME_SETUP == "Symmetric Transmit and Receive"))
        prop NoGen :: 1
        prop TabName :: "Transmit Multichannel"
	  prop Set ::  (	.XPABLK_SETUP = $1,
				.MCR2_VALUE = .MCR2_VALUE_update(),
				"ok"
			   )
	}
	prop XPABLK_MCR2 :: (
		(.XPABLK_SETUP == "Block 0. Channel 0-15") ? 0x0000 :
		(.XPABLK_SETUP == "Block 2. Channel 32-47") ? 0x0080 :
		(.XPABLK_SETUP == "Block 4. Channel 64-79") ? 0x0100 :
		0x0180
	)
	inst XPBBLK_SETUP :: "Block 1. Channel 16-31" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Block 1. Channel 16-31,Block 3. Channel 48-63,Block 5. Channel 80-95,Block 7. Channel 112-127"
        prop Label :: "Transmit Partition B (XPBBLK) "
	prop JSName :: "mcbspMcr2Xpbblk"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.XIOEN_SETUP == 1) && ((.XMCM_XMCME_SETUP == "2 Blocks(Up to 16Ch./Blk. - XMCM=01)") || (.XMCM_XMCME_SETUP == "2 Blocks(Up to 16Ch./Blk. - XMCM=10)") || (.XMCM_XMCME_SETUP == "Symmetric Transmit and Receive"))
        prop NoGen :: 1
        prop TabName :: "Transmit Multichannel"
	  prop Set ::  (	.XPBBLK_SETUP = $1,
				.MCR2_VALUE = .MCR2_VALUE_update(),
				"ok"
			   )
	}
	prop XPBBLK_MCR2 :: (
		(.XPBBLK_SETUP == "Block 1. Channel 16-31") ? 0x0000 :
		(.XPBBLK_SETUP == "Block 3. Channel 48-63") ? 0x0020 :
		(.XPBBLK_SETUP == "Block 5. Channel 80-95") ? 0x0040 :
		0x0060
	)
	inst XCERA_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition A "
	prop JSName :: "mcbspXcera"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.XIOEN_SETUP == 1) && (.XMCM_XMCME_SETUP != "All 128 Channels") && (.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Transmit Multichannel"
	  prop cGen :: 1
	  prop cType :: "Uint16"
    	}
	inst XCERB_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition B "
	prop JSName :: "mcbspXcerb"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.XIOEN_SETUP == 1) && (.XMCM_XMCME_SETUP != "All 128 Channels") && (.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Transmit Multichannel"
  	  prop cGen :: 1
	  prop cType :: "Uint16"
    	}
	inst XCERC_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition C "
	prop JSName :: "mcbspXcerc"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.XIOEN_SETUP == 1) && (.XMCM_XMCME_SETUP == "Any of 128 Ch.") && (.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Transmit Multichannel"
	  prop cGen :: 1
	  prop cType :: "Uint16"
    	}
	inst XCERD_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition D "
	prop JSName :: "mcbspXcerd"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.XIOEN_SETUP == 1) && (.XMCM_XMCME_SETUP == "Any of 128 Ch.") && (.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Transmit Multichannel"
	  prop cGen :: 1
	  prop cType :: "Uint16"
    	}
	inst XCERE_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition E "
	prop JSName :: "mcbspXcere"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.XIOEN_SETUP == 1) && (.XMCM_XMCME_SETUP == "Any of 128 Ch.") && (.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Transmit Multichannel"
	  prop cGen :: 1
	  prop cType :: "Uint16"
    	}
	inst XCERF_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition F "
	prop JSName :: "mcbspXcerf"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.XIOEN_SETUP == 1) && (.XMCM_XMCME_SETUP == "Any of 128 Ch.") && (.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Transmit Multichannel"
	  prop cGen :: 1
	  prop cType :: "Uint16"
    	}
	inst XCERG_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition G "
	prop JSName :: "mcbspXcerg"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.XIOEN_SETUP == 1) && (.XMCM_XMCME_SETUP == "Any of 128 Ch.") && (.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Transmit Multichannel"
	  prop cGen :: 1
	  prop cType :: "Uint16"
    	}
	inst XCERH_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition H "
	prop JSName :: "mcbspXcerh"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.XIOEN_SETUP == 1) && (.XMCM_XMCME_SETUP == "Any of 128 Ch.") && (.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Transmit Multichannel"
	  prop cGen :: 1
	  prop cType :: "Uint16"
    	}
	inst XMCM_01 :: "DXR written for enabled/unmasked channels,DX driven for enabled/unmasked channels" {
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "Transmit Multichannel"
	}
	inst XMCM_10 :: "DXR written for all channels in block,DX driven for unmasked channels" {
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "Transmit Multichannel"
	}
      
	inst ABIS_RCERA_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "ABIS RX. Bit Enable Register Partition A "
	prop JSName :: "mcbspRceraAbis"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.ABIS_SETUP == "Enable") && (.RIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "ABIS"
	  prop cGen :: 0
	  prop cType :: "Uint16"
	  prop Set ::  (	.ABIS_XCERA_VALUE = $1,
                        .XCERA_VALUE = $1,
				"ok"
			   )
    	}
	inst ABIS_RCERB_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "ABIS RX. Bit Enable Register Partition B "
	prop JSName :: "mcbspRcerbAbis"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.ABIS_SETUP == "Enable") && (.RIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "ABIS"
	  prop cGen :: 0
	  prop cType :: "Uint16"
	  prop Set ::  (	.ABIS_RCERB_VALUE = $1,
                        .RCERB_VALUE = $1,
				"ok"
			   )
    	}
	inst ABIS_XCERA_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "ABIS TX. Bit Enable Register Partition A "
	prop JSName :: "mcbspXceraAbis"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.ABIS_SETUP == "Enable") && (.XIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "ABIS"
	  prop cGen :: 0
	  prop cType :: "Uint16"
	  prop Set ::  (	.ABIS_XCERA_VALUE = $1,
                        .XCERA_VALUE = $1,
				"ok"
			   )
    	}
	inst ABIS_XCERB_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "ABIS TX. Bit Enable Register Partition B "
	prop JSName :: "mcbspXcerbAbis"
        prop Visible :: 1
        prop Writable :: !(.MCBSP_man) && (.ABIS_SETUP == "Enable") && (.XIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "ABIS"
  	  prop cGen :: 0
	  prop cType :: "Uint16"
	  prop Set ::  (	.ABIS_XCERB_VALUE = $1,
                        .XCERB_VALUE = $1,
				"ok"
			   )
    	}
	inst RCERA :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition A "
	prop JSName :: "mcbspRceraAdv"
        prop Visible :: .MCBSP_man
        prop Writable :: .MCBSP_man
        prop NoGen :: 1
	  prop TabName :: "Advanced B"
	  prop cGen :: 0
	  prop cType :: "Uint16"
        prop Set :: (
              .RCERA = $1,
              .RCERA_VALUE = $1,
              "ok"
        )
    	}
	inst RCERB :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition B "
	prop JSName :: "mcbspRcerbAdv"
        prop Visible :: .MCBSP_man
        prop Writable :: .MCBSP_man
        prop NoGen :: 1
	  prop TabName :: "Advanced B"
	  prop cGen :: 0
	  prop cType :: "Uint16"
        prop Set :: (
              .RCERB = $1,
              .RCERB_VALUE = $1,
              "ok"
        )
    	}
	inst RCERC :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition C "
	prop JSName :: "mcbspRcercAdv"
        prop Visible :: .MCBSP_man
        prop Writable :: .MCBSP_man
        prop NoGen :: 1
	  prop TabName :: "Advanced B"
	  prop cGen :: 0
	  prop cType :: "Uint16"
        prop Set :: (
              .RCERC = $1,
              .RCERC_VALUE = $1,
              "ok"
        )
    	}
	inst RCERD :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition D "
	prop JSName :: "mcbspRcerdAdv"
        prop Visible :: .MCBSP_man
        prop Writable :: .MCBSP_man
        prop NoGen :: 1
	  prop TabName :: "Advanced B"
	  prop cGen :: 0
	  prop cType :: "Uint16"
        prop Set :: (
              .RCERD = $1,
              .RCERD_VALUE = $1,
              "ok"
        )
    	}
	inst RCERE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition E "
	prop JSName :: "mcbspRcereAdv"
        prop Visible :: .MCBSP_man
        prop Writable :: .MCBSP_man
        prop NoGen :: 1
	  prop TabName :: "Advanced B"
	  prop cGen :: 0
	  prop cType :: "Uint16"
        prop Set :: (
              .RCERE = $1,
              .RCERE_VALUE = $1,
              "ok"
        )
    	}
	inst RCERF :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition F "
	prop JSName :: "mcbspRcerfAdv"
        prop Visible :: .MCBSP_man
        prop Writable :: .MCBSP_man
        prop NoGen :: 1
	  prop TabName :: "Advanced B"
	  prop cGen :: 0
	  prop cType :: "Uint16"
        prop Set :: (
              .RCERF = $1,
              .RCERF_VALUE = $1,
              "ok"
        )
    	}
	inst RCERG :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition G "
	prop JSName :: "mcbspRcergAdv"
        prop Visible :: .MCBSP_man
        prop Writable :: .MCBSP_man
        prop NoGen :: 1
	  prop TabName :: "Advanced B"
	  prop cGen :: 0
	  prop cType :: "Uint16"
        prop Set :: (
              .RCERG = $1,
              .RCERG_VALUE = $1,
              "ok"
        )
    	}
	inst RCERH :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition H "
	prop JSName :: "mcbspRcerhAdv"
        prop Visible :: .MCBSP_man
        prop Writable :: .MCBSP_man
        prop NoGen :: 1
	  prop TabName :: "Advanced B"
	  prop cGen :: 0
	  prop cType :: "Uint16"
        prop Set :: (
              .RCERH = $1,
              .RCERH_VALUE = $1,
              "ok"
        )
    	}
	inst XCERA :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition A "
	prop JSName :: "mcbspXceraAdv"
        prop Visible :: .MCBSP_man
        prop Writable :: .MCBSP_man
        prop NoGen :: 1
	  prop TabName :: "Advanced B"
	  prop cGen :: 0
	  prop cType :: "Uint16"
        prop Set :: (
              .XCERA = $1,
              .XCERA_VALUE = $1,
              "ok"
        )
    	}
	inst XCERB :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition B "
	prop JSName :: "mcbspXcerbAdv"
        prop Visible :: .MCBSP_man
        prop Writable :: .MCBSP_man
        prop NoGen :: 1
	  prop TabName :: "Advanced B"
  	  prop cGen :: 0
	  prop cType :: "Uint16"
        prop Set :: (
              .XCERB = $1,
              .XCERB_VALUE = $1,
              "ok"
        )
    	}
	inst XCERC :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition C "
	prop JSName :: "mcbspXcercAdv"
        prop Visible :: .MCBSP_man
        prop Writable :: .MCBSP_man
        prop NoGen :: 1
	  prop TabName :: "Advanced B"
	  prop cGen :: 0
	  prop cType :: "Uint16"
        prop Set :: (
              .XCERC = $1,
              .XCERC_VALUE = $1,
              "ok"
        )
    	}
	inst XCERD :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition D "
	prop JSName :: "mcbspXcerdAdv"
        prop Visible :: .MCBSP_man
        prop Writable :: .MCBSP_man
        prop NoGen :: 1
	  prop TabName :: "Advanced B"
	  prop cGen :: 0
	  prop cType :: "Uint16"
        prop Set :: (
              .XCERD = $1,
              .XCERD_VALUE = $1,
              "ok"
        )
    	}
	inst XCERE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition E "
	prop JSName :: "mcbspXcereAdv"
        prop Visible :: .MCBSP_man
        prop Writable :: .MCBSP_man
        prop NoGen :: 1
	  prop TabName :: "Advanced B"
	  prop cGen :: 0
	  prop cType :: "Uint16"
        prop Set :: (
              .XCERE = $1,
              .XCERE_VALUE = $1,
              "ok"
        )
    	}
	inst XCERF :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition F "
	prop JSName :: "mcbspXcerfAdv"
        prop Visible :: .MCBSP_man
        prop Writable :: .MCBSP_man
        prop NoGen :: 1
	  prop TabName :: "Advanced B"
	  prop cGen :: 0
	  prop cType :: "Uint16"
        prop Set :: (
              .XCERF = $1,
              .XCERF_VALUE = $1,
              "ok"
        )
    	}
	inst XCERG :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition G "
	prop JSName :: "mcbspXcergAdv"
        prop Visible :: .MCBSP_man
        prop Writable :: .MCBSP_man
        prop NoGen :: 1
	  prop TabName :: "Advanced B"
	  prop cGen :: 0
	  prop cType :: "Uint16"
        prop Set :: (
              .XCERG = $1,
              .XCERG_VALUE = $1,
              "ok"
        )
    	}
	inst XCERH :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition H "
	prop JSName :: "mcbspXcerhAdv"
        prop Visible :: .MCBSP_man
        prop Writable :: .MCBSP_man
        prop NoGen :: 1
	  prop TabName :: "Advanced B"
	  prop cGen :: 0
	  prop cType :: "Uint16"
        prop Set :: (
              .XCERH = $1,
              .XCERH_VALUE = $1,
              "ok"
        )
    	}
}
type hMCBSP {
	isa ObjectMgr
	prop name :: "hMCBSP"
	prop Label :: "MCBSP Resource Manager"
	prop JSName :: "HMCBSP"
	prop GlobalHelpTopic :: 1062
	prop InstanceHelpTopic :: 1063
	prop GlobalIcon :: 159
	prop InstanceIcon :: 160
	prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-00105A98CA0B}"
      prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-0000C070F3E9}"
    	prop Vendor :: "vendor1"
    	prop Version :: "1.00.00"
	prop IsContainedIn :: MCBSPFOLDER
	
	prop maxObjs :: (
		(GBL.CHIPTYPE == "5510") ? 3 :
		3
	)
	prop NoGen :: 1
	prop cGen :: 1
	prop cHandle :: .cOpenGen
	prop cHeaderName :: hMCBSP.c55mcbsp == 1 ? "csl_mcbsp.h" : ""
	prop cHandleType :: "MCBSP_Handle"
	prop cOpenName :: "MCBSP_open"
	prop cConfigName :: "MCBSP_config"
	prop cHandleName :: .handleName
	global c55mcbsp :: 0 {
          prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Label :: "C55x McBSP opened "
	    prop Visible :: 0
	    prop Writable :: 1
	    prop NoGen :: 1
	    prop cGen :: 0
      }
	inst cOpenGen :: 0 {
	    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Label :: "Open Handle to McBSP "
	    prop JSName :: "mcbspHandleEnable"
	    prop Visible :: 1
	    prop Writable :: 1
	    prop NoGen :: 1
	    prop cGen :: 1
          prop Set :: (
               .cOpenGen = $1,
               if ($1 == 1) {
                   hMCBSP.c55mcbsp = 1
               }
               else {
                   hMCBSP.c55mcbsp = 0
               },
               "ok"
          )
	}
	inst cOpenArg0 :: "MCBSP_DEV0" {
	     prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	     prop Label :: "Open Arg 0"
	     prop Visible :: 0
	     prop Writable :: 1
	     prop NoGen :: 1
	}
	inst cOpenArg1 :: "MCBSP_OPEN_RESET" {
	     prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	     prop Label :: "Open Arg 1"
	     prop Visible :: 0
	     prop Writable :: 0
	     prop NoGen :: 1
	}
    	inst handleName :: self {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Specify Handle Name "
	  prop JSName :: "mcbspHandleName"
	  prop Visible :: 1
	  prop Writable :: (.cOpenGen)
	  prop NoGen :: 1
	  prop Set :: (
             .handleName = $1,
             .cConfigArg0 = $1,
             "ok"
        )
    	}
    	inst PINIT_ENABLE :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Enable pre-initialization"
	  prop JSName :: "mcbspEnablePreInit"
	  prop Visible :: 1
	  prop Writable :: .cOpenGen
	  prop NoGen :: 1
	  prop Set :: (
		$a = 0,
		scan ($b; MCBSP) {
			$a = 1
		},
		if ($a == 0) {
			"You must create a configuration object"
		}
		else {
			.PINIT_ENABLE = $1,
			"ok"
		}
	  )
    	}
	inst cConfigGen ::= ((.cOpenGen == 1) && (.PINIT_ENABLE == 1) && (.cConfigArg1 != MCBSP_NOTHING)) {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
      }
	inst cConfigArg0 :: .handleName {
            prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
            prop Label :: "Config argument 0"
            prop Visible :: 0
            prop Writable :: 1
        }
	
     	inst cConfigArg1 :: MCBSP_NOTHING {
	  prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	  prop MemberType :: mcbspCfg
	  prop Label :: "Pre-initialize "
	  prop JSName :: "mcbspPreInit"
	  prop Visible :: 1
	  prop Writable :: .PINIT_ENABLE == 1
	  prop NoGen :: 0
	  prop cPreVal :: "&"
    	}
	prop comment :: "/* You must use MCBSP_start() in your main code to start the MCBSP. */"
	prop cGenFxnEpilogue :: (       
            "%5t\n%1s\n\n%0t\0,comment"
	)
}
object MCBSP_NOTHING :: mcbspCfg {
    param iIsUsed :: 0
}
object hMCBSP0 :: hMCBSP {
    param iComment :: .iDelMsg
    param iIsUsed :: 1  
    param iDelUser :: "hMCBSP"
    param iDelMsg :: ("MCBSP 0")
    param handleName :: "hMcbsp0"
    param cOpenArg0 :: "MCBSP_PORT0"
}
object hMCBSP1 :: hMCBSP {
    param iComment :: .iDelMsg
    param iIsUsed :: 1  
    param iDelUser :: "hMCBSP"
    param iDelMsg :: ("MCBSP 1")
    param handleName :: "hMcbsp1"
    param cOpenArg0 :: "MCBSP_PORT1"
}
object hMCBSP2 :: hMCBSP {
    param iComment :: .iDelMsg
    param iIsUsed :: 1  
    param iDelUser :: "hMCBSP"
    param iDelMsg :: ("MCBSP 2")
    param handleName :: "hMcbsp2"
    param cOpenArg0 :: "MCBSP_PORT2"
}
type PLLFOLDER {
    
    prop Label :: "PLL - Clock Generator"
    prop GlobalIcon :: 173
    prop GlobalPropertyPage :: "{B916FB95-52A5-11d4-967C-0750048381B7}"
    prop GlobalHelpTopic :: 1070
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}
type pllCfg {
	isa ObjectMgr
	prop name :: "PLL"
	prop Label :: "PLL Configuration Manager"
	prop JSName :: "PLL"
	prop GlobalHelpTopic :: 1071
	prop InstanceHelpTopic :: 1071
	
	prop IsContainedIn :: PLLFOLDER
	prop GlobalIcon :: 173
	prop InstanceIcon :: 174
	prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-10105A98CA0B}"
        prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-1000C070F3E9}"
    	prop Vendor :: "vendor1"
    	prop Version :: "1.00.00"
	
	prop cGen :: 1
    	prop cStruct :: 1
    	prop cStructType :: "PLL_Config"
	prop cHeaderName :: .gNumOf > 0 ? "csl_pll.h" : ""
	prop NoGen :: 1
	inst IAI_SETUP :: "Use Prior-to-Idle Settings" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Use Prior-to-Idle Settings,Start Entire Locking Sequence"
        prop Label :: "PLL Response After Idle (IAI) "
	  prop JSName :: "pllClkmdIai"
        prop Visible :: 1
        prop Writable :: (CLK.USETIMER == 1)
        prop NoGen :: 1
        prop TabName :: "Settings"
        prop Set :: (
                       .IAI_SETUP = $1,
                       if ($1 == "Use Prior-to-Idle Settings") {
                           .IAI_VALUE = 0
                       }
                       else {
                           .IAI_VALUE = 1
                       },
                       "ok"
         )
	}
	inst IOB_SETUP :: "Ignore" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Ignore,Start New Locking Sequence"
        prop Label :: "Response to Loss of PLL Core Lock (IOB)                    "
	prop JSName :: "pllClkmdIob"
        prop Visible :: 1
        prop Writable :: (CLK.USETIMER == 1)
        prop NoGen :: 1
        prop TabName :: "Settings"
        prop Set :: (
                       .IOB_SETUP = $1,
                       if ($1 == "Ignore") {
                           .IOB_VALUE = 0
                       }
                       else {
                           .IOB_VALUE = 1
                       },
                       "ok"
         )
	}
	inst PLL_MULT_SETUP :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "PLL Multiply Value (PLL_MULT) "
	prop JSName :: "pllClkmdPllmult"
        prop Visible :: 1
        prop Writable :: (CLK.USETIMER == 1)
        prop NoGen :: 1
        prop TabName :: "Settings"
	  prop Set ::  (	if (($1 >= 0) && ($1 <= 31)) {
  				    .PLL_MULT_SETUP = $1,
                            .PLL_MULT_VALUE = $1,
                            .CLKOUT_update()
                        }
                        else {
                            .error("PLL_MULT value exceeds limits")
                        },
   				"ok"
			   )
	}
	inst PLL_DIV_SETUP :: "CLKOUT = CLKIN" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "CLKOUT = CLKIN,CLKOUT = CLKIN/2,CLKOUT = CLKIN/3,CLKOUT = CLKIN/4"
        prop Label :: "PLL Divide Value (PLL_DIV) "
	prop JSName :: "pllClkmdPlldiv"
        prop Visible :: 1
        prop Writable :: (CLK.USETIMER == 1)
        prop NoGen :: 1
        prop TabName :: "Settings"
	  prop Set ::  (	
                       .PLL_DIV_SETUP = $1,
                       if ($1 == "CLKOUT = CLKIN") {
                           .PLL_DIV_VALUE = 0
                       }
                       else {
                           if ($1 == "CLKOUT = CLKIN/2") {
                               .PLL_DIV_VALUE = 1
                           }
                           else {
                               if ($1 == "CLKOUT = CLKIN/3") {
                                   .PLL_DIV_VALUE = 2
                               }
                               else {
                                   .PLL_DIV_VALUE = 3
                               }
                           }
                       },
                       .CLKOUT_update(),
                       "ok"
		   )
	}
	inst CLKOUT_SETUP :: 1.000 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.3f"
        prop Label :: "Output Clock Frequency:  CLKOUT = CLKIN x "
	prop JSName :: "pllClkout"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "Settings"
	}
      prop CLKOUT_update :: (
          if ((.PLL_MULT_VALUE == 0) || (.PLL_MULT_VALUE == 1)) {
              .CLKOUT_SETUP = float(1) / float(.PLL_DIV_VALUE + 1)
          }
          else {
              .CLKOUT_SETUP = float(.PLL_MULT_VALUE) / float(.PLL_DIV_VALUE + 1)
          }
      )
      
	inst IAI_VALUE :: 0 {
	  prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "0x%04x"
        prop Label :: "PLL Response After Idle (IAI) "
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Settings"
        prop cGen :: 1
        prop cType :: "Uint16"
	}
	inst IOB_VALUE :: 0 {
	  prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "0x%04x"
        prop Label :: "Response to Loss of PLL Core Lock (IOB) "
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Settings"
        prop cGen :: 1
        prop cType :: "Uint16"
	}
	inst PLL_MULT_VALUE :: 0 {
	  prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "0x%04x"
        prop Label :: "PLL Multiply Value (PLL_MULT) "
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Settings"
        prop cGen :: 1
        prop cType :: "Uint16"
	}
	inst PLL_DIV_VALUE :: 0 {
	  prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "0x%04x"
        prop Label :: "PLL Divide Value (PLL_DIV) "
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Settings"
        prop cGen :: 1
        prop cType :: "Uint16"
	}
}
type hPLL {
	isa ObjectMgr
	prop name :: "hPLL"
	prop Label :: "PLL Resource Manager"
	prop JSName :: "HPLL"
	prop GlobalHelpTopic :: 1072
	prop InstanceHelpTopic :: 1072
	prop GlobalIcon :: 173
	prop InstanceIcon :: 174
	prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-10105A98CA0B}"
        prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-1000C070F3E9}"
    	prop Vendor :: "vendor1"
    	prop Version :: "1.00.00"
	prop IsContainedIn :: PLLFOLDER
	
	prop maxObjs :: (
		1
	)
	prop NoGen :: 1
	prop cGen :: 1
	prop cHeaderName :: .c55pll == 1 ? "csl_pll.h" : ""
	prop cConfigName :: "PLL_config"
	global c55pll :: 0 {
          prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Label :: "C55x PLL configured "
	    prop Visible :: 0
	    prop Writable :: 1
	    prop NoGen :: 1
	    prop cGen :: 0
      }
    	inst PINIT_ENABLE :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Enable Configuration of PLL "
	  prop JSName :: "pllEnablePreInit"
	  prop Visible :: 1
	  prop Writable :: (CLK.USETIMER == 1)
	  prop NoGen :: 1
	  prop Set :: (	.PINIT_ENABLE = $1,
                        if ($1 == 1) {
                            .c55pll = 1
                        }
                        else {
                            .c55pll = 0
                        },
				"ok"
			  )
    	}
	inst cConfigGen ::= ((.PINIT_ENABLE == 1) && (.cConfigArg0 != PLL_NOTHING)) {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
	  prop Writable :: 1
      }
     	inst cConfigArg0 :: PLL_NOTHING {
	  prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	  prop MemberType :: pllCfg
	  prop Label :: "Pre-initialize"
	  prop JSName :: "pllPreInit"
	  prop Visible :: 1
	  prop Writable :: .PINIT_ENABLE
	  prop NoGen :: 0
	  prop cPreVal :: "&"
    	}
}
object PLL_NOTHING :: pllCfg {
    param iIsUsed :: 0
}
object PLL0 :: hPLL {
	param iIsUsed :: 1
	param iDelUser :: "hPLL"
	param iDelMsg :: ("PLL 0")
}
type PWRFOLDER {
    
    prop Label :: "Power"
    prop GlobalIcon :: 185
    prop GlobalPropertyPage :: "{B916FB95-52A5-11d4-967C-0750048381C8}"
    prop GlobalHelpTopic :: 1090
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}
type pwrCfg {
	isa ObjectMgr
	prop name :: "PWR"
	prop Label :: "Power Configuration Manager"
      prop JSName :: "PWR"
	prop GlobalHelpTopic :: 1091
	prop InstanceHelpTopic :: 1091
	
	prop IsContainedIn :: PWRFOLDER
	prop GlobalIcon :: 185
	prop InstanceIcon :: 186
	prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-10105A98CA0B}"
      prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-1000C070F3E9}"
    	prop Vendor :: "vendor1"
    	prop Version :: "1.00.00"
	
	prop cGen :: 1
    	prop cStruct :: 0
	prop cHeaderName :: .c55pwr == 1 ? "csl_pwr.h" : ""
	prop NoGen :: 1
      prop maxObjs :: 0
	global c55pwr :: 0 {
          prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Label :: "C55x PWR opened "
	    prop Visible :: 0
	    prop Writable :: 1
	    prop NoGen :: 1
	    prop cGen :: 0
      }
      global configPwr :: 0 {
		prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
		prop Label :: "Enable Pre-initialization "
            prop JSName :: "pwrConfigPwr"
		prop Visible :: 1
		prop Writable :: 1
		prop NoGen :: 1
		prop cGen :: 0
            prop TabName :: "General"
            prop Set :: (
               .configPwr = $1,
               if ($1 == 1) {
                   .c55pwr = 1
               }
               else {
                   .c55pwr = 0
               },
               "ok"
          )
	}
      
	global CLOCKGEN_SETUP :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Clock Generator Disable "
        prop JSName :: "pwrClockgenPwrDwnMode"
        prop Visible :: 1
        prop Writable :: .configPwr
        prop NoGen :: 1
        prop TabName :: "Power Save During IDLE Instruction"
	  prop Set ::  (	  .CLOCKGEN_SETUP = $1,
				  .ICR_VALUE = .ICR_VALUE_update(),
				  "ok"
			   )	
	  }
        prop cache_Support :: ( ! ((GBL.CHIPTYPE == "5509") ||
                                   (GBL.CHIPTYPE == "5509A") ||
                                   (GBL.CHIPTYPE == "5509PG1_0") ||
                                   (GBL.CHIPTYPE == "5509PG2_0")
                                  ) 
        )
        prop i2c_Support :: ( (GBL.CHIPTYPE == "5509") ||
                              (GBL.CHIPTYPE == "5509A") ||
                              (GBL.CHIPTYPE == "5509PG1_0") ||
                              (GBL.CHIPTYPE == "5509PG2_0")
        )
        prop xbsrReg_Support :: ( (GBL.CHIPTYPE == "5509") ||
                                  (GBL.CHIPTYPE == "5509A") ||
                                  (GBL.CHIPTYPE == "5509PG1_0") ||
                                  (GBL.CHIPTYPE == "5509PG2_0") 
        )
	global CACHE_SETUP :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "CACHE Disable "
        prop JSName :: "pwrCachePwrDwnMode"
        prop Visible :: (pwrCfg.cache_Support)
        prop Writable :: .configPwr	
        prop NoGen :: 1
        prop TabName :: "Power Save During IDLE Instruction"
	  prop Set ::  (	  .CACHE_SETUP = $1,
				  .ICR_VALUE = .ICR_VALUE_update(),
				  "ok"
			   )	
	  }
	global CPU_SETUP :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "CPU Disable "
        prop JSName :: "pwrCpuPwrDwnMode"
        prop Visible :: 1
        prop Writable :: .configPwr	
        prop NoGen :: 1
        prop TabName :: "Power Save During IDLE Instruction"
	  prop Set ::  (	  .CPU_SETUP = $1,
				  .ICR_VALUE = .ICR_VALUE_update(),
				  "ok"
			   )	
	  }
	global DMA_SETUP :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DMA Disable "
        prop JSName :: "pwrDmaPwrDwnMode"
        prop Visible :: 1
        prop Writable :: .configPwr
        prop NoGen :: 1
        prop TabName :: "Power Save During IDLE Instruction"
	  prop Set ::  (	  .DMA_SETUP = $1,
				  .ICR_VALUE = .ICR_VALUE_update(),
				  "ok"
			   )	
	  }
	global EMIF_SETUP :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "EMIF Disable "
        prop JSName :: "pwrEmifPwrDwnMode"
        prop Visible :: 1
        prop Writable :: .configPwr
        prop NoGen :: 1
        prop TabName :: "Power Save During IDLE Instruction"
	  prop Set ::  (	  .EMIF_SETUP = $1,
				  .ICR_VALUE = .ICR_VALUE_update(),
				  "ok"
			   )	
	  }
	global MCBSP0_SETUP :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "McBsp 0 Disable "
        prop JSName :: "pwrMcbsp0PwrDwnMode"
        prop Visible :: 1
        prop Writable :: .configPwr
        prop NoGen :: 1
        prop TabName :: "Power Save During IDLE Instruction"
	  prop Set ::  (	  .MCBSP0_SETUP = $1,
				  .ICR_VALUE = .ICR_VALUE_update(),
				  .MCBSP0_VALUE = .mcBspVal0_update(),
				  "ok"
			   )	
	  }
	global MCBSP1_SETUP :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "McBsp 1 Disable "
        prop JSName :: "pwrMcbsp1PwrDwnMode"
        prop Visible :: 1
        prop Writable :: .configPwr
        prop NoGen :: 1
        prop TabName :: "Power Save During IDLE Instruction"
	  prop Set ::  (	  .MCBSP1_SETUP = $1,
				  .ICR_VALUE = .ICR_VALUE_update(),
				  .MCBSP1_VALUE = .mcBspVal1_update(),
				  "ok"
			   )	
	  }
	global MCBSP2_SETUP :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "McBsp 2 Disable "
        prop JSName :: "pwrMcbsp2PwrDwnMode"
        prop Visible :: 1
        prop Writable :: .configPwr
        prop NoGen :: 1
        prop TabName :: "Power Save During IDLE Instruction"
	  prop Set ::  (	  .MCBSP2_SETUP = $1,
				  .ICR_VALUE = .ICR_VALUE_update(),
				  .MCBSP2_VALUE = .mcBspVal2_update(),
				  "ok"
			   )	
	  }
	global TIMER0_SETUP :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Timer 0 Disable "
        prop JSName :: "pwrTimer0PwrDwnMode"
        prop Visible :: 1
        prop Writable :: .configPwr
        prop NoGen :: 1
        prop TabName :: "Power Save During IDLE Instruction"
	  prop Set ::  (	  .TIMER0_SETUP = $1,
				  .ICR_VALUE = .ICR_VALUE_update(),
				  .TIMER0_VALUE = .timerVal0_update(),
				  "ok"
			   )	
	  }
	global TIMER1_SETUP :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Timer 1 Disable "
        prop JSName :: "pwrTimer1PwrDwnMode"
        prop Visible :: 1
        prop Writable :: .configPwr
        prop NoGen :: 1
        prop TabName :: "Power Save During IDLE Instruction"
	  prop Set ::  (	  .TIMER1_SETUP = $1,
				  .ICR_VALUE = .ICR_VALUE_update(),
				  .TIMER1_VALUE = .timerVal1_update(),
				  "ok"
			   )	
	  }
	global I2C_SETUP :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "I2C Disable "
        prop JSName :: "pwrI2cPwrDwnMode"
        prop Visible :: (pwrCfg.i2c_Support)
        prop Writable :: .configPwr
        prop NoGen :: 1
        prop TabName :: "Power Save During IDLE Instruction"
	  prop Set ::  (	  .I2C_SETUP = $1,
				  .I2C_VALUE = .i2cVal_update(),		
				  "ok"
			   )	
	  }
	global NOTE :: "     See Spru 317 Ch. 8 for IDLE domain combinations that do not make sense" {
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop TabName :: "Power Save During IDLE Instruction"
        prop NoGen :: 1
	} 
	
	
	global CLOCKOUT_SETUP :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Clockout Pin Disable "
        prop JSName :: "pwrClockoutPwrDwnMode"
        prop Visible :: 1
	  prop Writable :: .configPwr
        prop NoGen :: 1
        prop TabName :: "General Power Savings"
	  prop Set ::  (	.CLOCKOUT_SETUP = $1,
				.CLOCKOUT_VALUE = .clockoutVal_update(),
				"ok" 
			   )
      }
	global CLKMEM_SETUP :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Disable CLKMEM "
        prop JSName :: "pwrClkmemPwrDwnMode"
        prop Visible :: 1
	  prop Writable :: (.configPwr) && !(emifCfg.SYNCH)
        prop NoGen :: 1
        prop TabName :: "General Power Savings"
	  prop Set ::  (	.CLKMEM_SETUP = $1,
				.CLKMEM_VALUE = .clkmemVal_update(),
				"ok" 
			   )
      }
	global EBSELOSC_SETUP :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Oscillator Disable "
        prop JSName :: "pwrOscPwrDwnMode"
        prop NoGen :: 1
        prop Visible :: 1
	  prop Writable :: .configPwr	
        prop TabName :: "General Power Savings"
	  prop Set ::  (	.EBSELOSC_SETUP = $1,
				.EBSELOSC_VALUE = .oscVal_update(),
				"ok" 
			   )
      }
	
	
	global INFO :: "Additional Power Saving Tips:" {
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop TabName :: "General"
        prop NoGen :: 1
	} 
	global PLL :: "Set your PLL to minimum MIPS required. " {
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop TabName :: "General"
        prop NoGen :: 1
	} 
	global GPIO :: "If unused, set all GPIO pins as output high. " {
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop TabName :: "General"
        prop NoGen :: 1
	} 
	global EMIF :: "If asynchronous memory is used, disable CLKMEM. " {
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop TabName :: "General"
        prop NoGen :: 1
	} 
	global NOTE_ :: "The unused GPIO pins can be disabled (5509xx only)" {
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop TabName :: "General"
        prop NoGen :: 1
	} 
	
	
	global ICR_VALUE :: 0  {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%02x" 
        prop Label :: "IDLE Configuration Register "
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
	  prop cGen :: 1
	  prop cType :: "Uint16" 
    	}
	prop CLOCKGEN_VALUE :: ( 
			(.CLOCKGEN_SETUP == 1) ? 0x10 : 
			0x00
	)
	prop EMIF_VALUE :: ( 
			(.EMIF_SETUP == 1) ? 0x20 : 
			0x00
	)
	prop CPU_VALUE :: ( 
			(.CPU_SETUP == 1) ? 0x01 : 
			0x00
	)
	prop DMA_VALUE :: ( 
			(.DMA_SETUP == 1) ? 0x02 : 
			0x00
	)
	prop CACHE_VALUE :: ( 
			(.CACHE_SETUP == 1) ? 0x04 : 
			0x00
	)
	prop PERI_VALUE :: ( 
			((.TIMER0_SETUP == 1)||(.TIMER1_SETUP == 1)||(.MCBSP0_SETUP == 1)||(.MCBSP1_SETUP == 1)||(.MCBSP2_SETUP == 1)) ? 0x08 : 
			0x00
	)
	prop ICR_VALUE_update :: (
		 .EMIF_VALUE
		|.CLOCKGEN_VALUE
		|.PERI_VALUE	
		|.CACHE_VALUE
		|.DMA_VALUE
		|.CPU_VALUE
	)
	
	global MCBSP0_VALUE :: "" {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "McBsp Value"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
	  prop cGen :: 1
    	}
	global MCBSP1_VALUE :: "" {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "McBsp Value"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
	  prop cGen :: 1
    	}
	global MCBSP2_VALUE :: "" {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "McBsp Value"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
	  prop cGen :: 1
    	}
	prop mcBspVal0_update :: (.MCBSP0_SETUP == 1) ? "MCBSP_FSET(PCR0,IDLEEN,1);\n" : ""
	prop mcBspVal1_update :: (.MCBSP1_SETUP == 1) ? "MCBSP_FSET(PCR1,IDLEEN,1);\n" : ""
	prop mcBspVal2_update :: (.MCBSP2_SETUP == 1) ? "MCBSP_FSET(PCR2,IDLEEN,1);\n" : ""
	
	global TIMER0_VALUE :: "" {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Timer Value"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
	  prop cGen :: 1
    	}
	global TIMER1_VALUE :: "" {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Timer Value"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
	  prop cGen :: 1
    	}
	prop timerVal0_update :: (.TIMER0_SETUP == 1) ? "TIMER_FSET(TCR0,IDLEEN,1);\n" : ""
	prop timerVal1_update :: (.TIMER1_SETUP == 1) ? "TIMER_FSET(TCR1,IDLEEN,1);\n" : ""
	global I2C_VALUE :: "" {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "I2C Value"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
	  prop cGen :: 1
    	}
	prop i2cVal_update :: (.I2C_SETUP == 1) ? "I2C_FSET(ICMDR,IDLEEN,1);\n" : ""
	
	global CLOCKOUT_VALUE :: "" {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Clockout Value"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
	  prop cGen :: 1
    	}
	prop clockoutVal_update :: 
	( if (pwrCfg.xbsrReg_Support) 
		{
			(.CLOCKOUT_SETUP == 1) ? "CHIP_FSET(ST3_55, CLKOFF, 0x04);\nCHIP_FSET(XBSR,CLKOUT, 1);\n" : ""
		}
	  else
		{
			(.CLOCKOUT_SETUP == 1) ? "CHIP_FSET(ST3_55, CLKOFF, 0x04);\n" : ""
		}
	)
	global EBSELOSC_VALUE :: "" {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Oscillator Disable Value"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
	  prop cGen :: 1
    	}
	prop oscVal_update :: ( 
			(.EBSELOSC_SETUP == 1) ? "CHIP_FSET(XBSR, OSCDIS, 1);\n" : ""
	)
      prop icrValue :: .ICR_VALUE
	prop icrStr :: "CSL_init();\n"
	prop icrStr1 :: "\nPWR_RSET(ICR, 0x%3d);\n"
	prop mcbspVal0 :: .MCBSP0_VALUE
	prop mcbspVal1 :: .MCBSP1_VALUE
	prop mcbspVal2 :: .MCBSP2_VALUE
	prop timerVal0 :: .TIMER0_VALUE
	prop timerVal1 :: .TIMER1_VALUE
	prop i2cVal :: .I2C_VALUE
	prop clockVal :: .CLOCKOUT_VALUE
	prop oscVal :: .EBSELOSC_VALUE
      prop cGenFxnEpilogue :: (
          if (.c55pwr == 1) { 
              "%5t%2S%4S%5S%6S%7S%8S%9S%10S%11S%0t\0, 
			icrStr,icrStr1,icrValue,mcbspVal0,mcbspVal1,mcbspVal2,timerVal0,timerVal1,clockVal,i2cVal,oscVal"
	   }
      )
	prop includeStr :: "#include <csl_pwrhal.h>\n" 
	prop inclStr :: ((.TIMER0_SETUP == 1) || (.TIMER1_SETUP == 1)) ? "#include <csl_timhal.h>\n" : ""
	prop incStr :: ((.MCBSP0_SETUP == 1) || (.MCBSP1_SETUP == 1) || (.MCBSP2_SETUP == 1)) ? "#include <csl_mcbsphal.h>\n" : ""
	prop i2cStr :: (.I2C_SETUP == 1) ? "#include <csl_i2chal.h>\n" : ""
	prop oscStr :: ((.EBSELOSC_SETUP == 1) || (.CLOCKOUT_SETUP == 1)) ? "#include <csl_chiphal.h>\n" : ""
	prop cGenCPrologue :: (
          if (.c55pwr == 1) { 
        "%1S%2S%3S%4S%5S\n\n\0, includeStr, inclStr,incStr,i2cStr,oscStr"
	    }
	)
}
type RTCFOLDER {
    
    prop Label :: "Real Time Clock "
    prop GlobalIcon :: 187
    prop GlobalPropertyPage :: "{B916FB95-52A5-11d4-967C-0750048381C8}"
    prop GlobalHelpTopic :: 1100
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}
type rtcCfg {
	isa ObjectMgr
	prop name :: "RTC"
	prop Label :: "Real Time Clock Configuration Manager"
	prop JSName :: "RTC"
	prop GlobalHelpTopic :: 1101
	prop InstanceHelpTopic :: 1101
	
	prop IsContainedIn :: RTCFOLDER
	prop GlobalIcon :: 187
	prop InstanceIcon :: 188
	prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-10105A98CA0B}"
      prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-1000C070F3E9}"
    	prop Vendor :: "vendor1"
    	prop Version :: "1.00.00"
	
      prop rtc_Support :: ( (GBL.CHIPTYPE == "5509") ||
                            (GBL.CHIPTYPE == "5509A") ||
                            (GBL.CHIPTYPE == "5509PG1_0") ||
                            (GBL.CHIPTYPE == "5509PG2_0")
      )
	prop cGen :: 1
    	prop cStruct :: (rtcCfg.rtc_Support)
    	prop cStructType :: "RTC_Config"
	prop cHeaderName :: ((.gNumOf > 0) && (rtcCfg.rtc_Support)) ? "csl_rtc.h" : ""
	prop NoGen :: 1
	inst RS_SETUP :: "None" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Periodic Interrupt Rate "
	prop JSName :: "rtcRtcpintrRs"
	  prop Enum :: "None,122us,244us,488us,976us,1.95ms,3.9ms,7.8125ms,15.625ms,31.25ms,62.5ms,125ms,250ms,500ms,1 minute"
        prop Visible :: 1
        prop Writable :: (rtcCfg.rtc_Support)
        prop NoGen :: 1
        prop TabName :: "General"
	  prop Set ::  (	  .RS_SETUP = $1,
				  .RTCPINTR_VALUE = .RTCPINTR_VALUE_update(),
				  "ok"
			   )	
	  }
      
	inst MODE_SETUP :: "12 Hour Mode" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Choose Mode "
	prop JSName :: "rtcRtcintenSet"
	  prop Enum :: "12 Hour Mode,24 Hour Mode"
        prop Visible :: 1
        prop Writable :: (rtcCfg.rtc_Support)
        prop NoGen :: 1
        prop TabName :: "Set Date/Time"
	  prop Set ::  (	  .MODE_SETUP = $1,
				  .RTCHOUR_VALUE = .RTCHOUR_VALUE_update(),
				  "ok"
			   )	
	  }
	inst YEAR_SETUP :: 1 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "20%02d" 
        prop Label :: "Year      "
	prop JSName :: "rtcRtcyearYear"
        prop Visible :: 1
        prop Writable :: (rtcCfg.rtc_Support)
        prop NoGen :: 1
        prop TabName :: "Set Date/Time"
	  prop Set ::  (  if (($1 >= 1) && ($1 <= 99)) {
				  .YEAR_SETUP = $1,
				  .RTCYEAR_VALUE = .DEC_to_BCD($1),
				  "ok" }
				else { if (($1 >= 2001) && ($1 <= 2099)) {
					 	.YEAR_SETUP = $1 - 2000,
				  		.RTCYEAR_VALUE = .DEC_to_BCD($1 - 2000),
				  		"ok" }
					 else { .error("Year entered not supported. Valid range: 2001 - 2099") }
				}
			   )	
	  }
	inst MONTH_SETUP :: "January" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Month "
	prop JSName :: "rtcRtcmonthMonth"
	  prop Enum :: "January,February,March,April,May,June,July,August,September,October,November,December"
        prop Visible :: 1
        prop Writable :: (rtcCfg.rtc_Support)
        prop NoGen :: 1
        prop TabName :: "Set Date/Time"
	  prop Set ::  (	  .MONTH_SETUP = $1,
				  .RTCMONTH_VALUE = .RTCMONTH_VALUE_update(),
				  "ok"
			   )	
	  }
	inst DAYM_SETUP :: 1 {
	  prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Date "
	prop JSName :: "rtcRtcdaymDate"
	  prop Enum :: "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31" 
        prop Visible :: 1
        prop Writable :: (rtcCfg.rtc_Support)
        prop NoGen :: 1
        prop TabName :: "Set Date/Time"
	  prop Set ::  (	  .DAYM_SETUP = $1,
				  .RTCDAYM_VALUE = .RTCDAYM_VALUE_update(),
				  "ok"
			   )	
	  }
	inst DAYW_SETUP :: "Sunday" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Day of the Week"
	prop JSName :: "rtcRtcdaywDay"
	  prop Enum :: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday"
        prop Visible :: 1
        prop Writable :: (rtcCfg.rtc_Support)
        prop NoGen :: 1
        prop TabName :: "Set Date/Time"
	  prop Set ::  (	  .DAYW_SETUP = $1,
				  .RTCDAYW_VALUE = .RTCDAYW_VALUE_update(), 
				  "ok"
			   )	
	  }
	inst ____________________ :: "" {
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop TabName :: "Set Date/Time"
        prop NoGen :: 1
	} 
	inst HOUR24_SETUP :: 0 {
	  prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Hour (24-hour mode) "
	prop JSName :: "rtcRtchourHr24"
	  prop Enum :: "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23"
        prop Visible :: 1
        prop Writable :: (rtcCfg.rtc_Support) && (.MODE_SETUP == "24 Hour Mode")
        prop NoGen :: 1
        prop TabName :: "Set Date/Time"
	  prop Set ::  (	  .HOUR24_SETUP = $1,
				  if ($1 > 12) {  .HOUR12_SETUP = $1 - 12,
							.AMPM_SETUP = "PM" }
				  else { if ($1 == 0) { .HOUR12_SETUP = 12, .AMPM_SETUP = "PM" }
					    else { .HOUR12_SETUP = $1, .AMPM_SETUP = "AM" } 
				  }, 
				  .RTCHOUR_VALUE = .RTCHOUR_VALUE_update(), 
				  "ok"
			   )	
	  } 
	inst HOUR12_SETUP :: 1 {
	  prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Hour (12-hour mode) "
	prop JSName :: "rtcRtchourHr12"
	  prop Enum :: "1,2,3,4,5,6,7,8,9,10,11,12"
        prop Visible :: 1
        prop Writable :: ((rtcCfg.rtc_Support) && (.MODE_SETUP == "12 Hour Mode"))
        prop NoGen :: 1
        prop TabName :: "Set Date/Time"
	  prop Set ::  (	  .HOUR12_SETUP = $1,
				  if (.AMPM_SETUP == "AM") {
				         .HOUR24_SETUP = $1 }
				  else { if ($1 == 12) { .HOUR24_SETUP = 0  }
					   else { .HOUR24_SETUP = $1 + 12 } 
				  },
				  .RTCHOUR_VALUE = .RTCHOUR_VALUE_update(), 
				  "ok"
			   )	
	  } 
	inst AMPM_SETUP :: "AM" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "AM/PM "
	prop JSName :: "rtcRtchourAmpm"
	  prop Enum :: "AM,PM"
        prop Visible :: 1
        prop Writable :: ((rtcCfg.rtc_Support) && (.MODE_SETUP == "12 Hour Mode"))
        prop NoGen :: 1
        prop TabName :: "Set Date/Time"
	  prop Set ::  (	  .AMPM_SETUP = $1,
				  if ($1 == "AM") { .HOUR24_SETUP = .HOUR12_SETUP
				  			} 
				  else { if (.HOUR12_SETUP == 12) { .HOUR24_SETUP = 0	   }
					   else { .HOUR24_SETUP = .HOUR12_SETUP + 12
					        },
				  .RTCHOUR_VALUE = .RTCHOUR_VALUE_update(), 
				  "ok"
				  }
			   )	
	  } 
	prop AMPM_RTHOUR :: (
	  (.AMPM_SETUP == "PM") ? 0x80 : 0x00
	)
	inst MINUTE_SETUP :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Minute "
	prop JSName :: "rtcRtcminMin"
        prop Visible :: 1
        prop Writable :: (rtcCfg.rtc_Support)
        prop NoGen :: 1
        prop TabName :: "Set Date/Time"
	  prop Set ::  (	 if (($1 < 60)&&($1 > 0)) { 
				  .MINUTE_SETUP = $1,
				  .RTCMIN_VALUE = .DEC_to_BCD($1), 
				  "ok" }
				 else { .error("Wrong minute. Valid range: 0 - 59") } 
			   )	
	  }
	inst SECOND_SETUP :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Second "
	prop JSName :: "rtcRtcsecSec"
        prop Visible :: 1
        prop Writable :: (rtcCfg.rtc_Support)
        prop NoGen :: 1
        prop TabName :: "Set Date/Time"
	  prop Set ::  (	if (($1 < 60)&&($1 >= 0)) {  
				  .SECOND_SETUP = $1,
				  .RTCSEC_VALUE = .DEC_to_BCD($1), 
				  "ok" }
				else { .error("Wrong second. Valid range: 0 - 59") }
			   )	
	  } 
      
      
	inst HOURAL24_SETUP :: 0 {
	  prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Alarm Hour (24-hour mode) "
	prop JSName :: "rtcRtchouraHar24"
	  prop Enum :: "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23"
        prop Visible :: 1
        prop Writable :: (rtcCfg.rtc_Support) && (.MODE_SETUP == "24 Hour Mode")&&!(.PERHOURALARM_SETUP)
        prop NoGen :: 1
        prop TabName :: "Set Alarm"
	  prop Set ::  (	  .HOURAL24_SETUP = $1,
				  if ($1 > 12) {  .HOURAL12_SETUP = $1 - 12,
							.AMPMAL_SETUP = "PM" }
				  else { if ($1 == 0) { .HOURAL12_SETUP = 12, 
								.AMPMAL_SETUP = "PM"
							    }
					    else { .HOURAL12_SETUP = $1, 
						     .AMPMAL_SETUP = "AM"
						   } 
				  },
				  .RTCHOURA_VALUE = .RTCHOURA_VALUE_update(), 
				  "ok"
			   )	
	  }
	inst HOURAL12_SETUP :: 1 {
	  prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Alarm Hour (12-hour mode) "
	prop JSName :: "rtcRtchouraHar12"
	  prop Enum :: "1,2,3,4,5,6,7,8,9,10,11,12"
        prop Visible :: 1
        prop Writable :: (rtcCfg.rtc_Support) &&(.MODE_SETUP == "12 Hour Mode")&&!(.PERHOURALARM_SETUP)
        prop NoGen :: 1
        prop TabName :: "Set Alarm"
	  prop Set ::  (	 .HOURAL12_SETUP = $1,
				  if (.AMPMAL_SETUP == "AM") {
				    .HOURAL24_SETUP = $1  }
				  else { if ($1 == 12) { .HOURAL24_SETUP = 0 }
					   else { .HOURAL24_SETUP = $1 + 12   } 
				  },
			       .RTCHOURA_VALUE = .RTCHOURA_VALUE_update(), 
				 "ok"
			   )	
	  }
	inst AMPMAL_SETUP :: "AM" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "AM/PM "
	prop JSName :: "rtcRtchouraAmpm"
	  prop Enum :: "AM,PM"
        prop Visible :: 1
        prop Writable :: ((rtcCfg.rtc_Support) &&(.MODE_SETUP == "12 Hour Mode")&&!(.PERHOURALARM_SETUP))
        prop NoGen :: 1
        prop TabName :: "Set Alarm"
	  prop Set ::  (	  .AMPMAL_SETUP = $1,
				  if ($1 == "AM") {
					.HOURAL24_SETUP = .HOURAL12_SETUP  }
				  else { if (.HOURAL12_SETUP == 12) { .HOURAL24_SETUP = 0 }
					   else { .HOURAL24_SETUP = .HOURAL12_SETUP + 12  }
				  }, 
				  .RTCHOURA_VALUE = .RTCHOURA_VALUE_update(), 
				  "ok"
			   )	
	  } 
	inst MINUTEAL_SETUP :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Minute "
	prop JSName :: "rtcRtcminaMar"
        prop Visible :: 1
        prop Writable :: ((rtcCfg.rtc_Support) &&!(.PERMINUTEALARM_SETUP))
        prop NoGen :: 1
        prop TabName :: "Set Alarm"
	  prop Set ::  (	 if (($1 < 60)&&($1 >= 0)) { 
				  .MINUTEAL_SETUP = $1,
				  .RTCMINA_VALUE = .RTCMINA_VALUE_update(),
				  "ok" }
				 else { .error("Wrong minute. Valid range: 0 - 59") } 
			   )	
	  }
	inst SECONDAL_SETUP :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Second "
	prop JSName :: "rtcRtcsecaSar"
        prop Visible :: 1
        prop Writable :: ((rtcCfg.rtc_Support) && !(.PERSECONDALARM_SETUP))
        prop NoGen :: 1
        prop TabName :: "Set Alarm"
	  prop Set ::  (	 if (($1 < 60)&&($1 >= 0)) {   
				  .SECONDAL_SETUP = $1,
				  .RTCSECA_VALUE = .RTCSECA_VALUE_update(),
				  "ok" }
				 else { .error("Wrong second. Valid range: 0 - 59") } 
			   )	
	  }
	prop DAEN_RTDAYW :: (
	  (.PERDAYALARM_SETUP == 1) ? 0x08 : 0x00
	)
	inst DAYWAL_SETUP :: "Sunday" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Day of the Week"
	prop JSName :: "rtcRtcdaywDar"
	  prop Enum :: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday"
        prop Visible :: 1
        prop Writable :: (rtcCfg.rtc_Support) &&!(.PERDAYALARM_SETUP)
        prop NoGen :: 1
        prop TabName :: "Set Alarm"
	  prop Set ::  (	  .DAYWAL_SETUP = $1,
				  .RTCDAYW_VALUE = .RTCDAYW_VALUE_update(),
				  "ok"
			   )	
	  }
	prop DAR_RTDAYW :: (
		       (.DAYWAL_SETUP == "Sunday") ? 0x18 :
                   (.DAYWAL_SETUP == "Monday") ? 0x28 :
                   (.DAYWAL_SETUP == "Tuesday") ? 0x38 :
		       (.DAYWAL_SETUP == "Wednesday") ? 0x48 :
		       (.DAYWAL_SETUP == "Thursday") ? 0x58 :
		       (.DAYWAL_SETUP == "Friday") ? 0x68 :
		       0x70
    )
	inst ___________________ :: "" {
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop TabName :: "Set Alarm"
        prop NoGen :: 1
	} 
	inst PERMINUTEALARM_SETUP :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Periodic Alarm Every Minute "
	prop JSName :: "rtcPerminutealarm"
        prop Visible :: 1
        prop Writable :: (rtcCfg.rtc_Support)
        prop NoGen :: 1
        prop TabName :: "Set Alarm"
	  prop Set :: (  .PERMINUTEALARM_SETUP = $1,
			     .RTCMINA_VALUE = .RTCMINA_VALUE_update(),
			     "ok" 	
			  )
	  }
	prop MINALARM_RTMINA :: (
	  (.PERMINUTEALARM_SETUP == 1) ? 0xC0 : 0x00
	)
	inst PERSECONDALARM_SETUP :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Periodic Alarm Every Second "
	prop JSName :: "rtcPersecondalarm"
        prop Visible :: 0
        prop Writable :: (rtcCfg.rtc_Support)
        prop NoGen :: 1
        prop TabName :: "Set Alarm"
	  prop Set :: (  .PERSECONDALARM_SETUP = $1,
			     .RTCSECA_VALUE = .RTCSECA_VALUE_update(),
			     "ok" 	
			  )
	  }
	prop SECALARM_RTSECA :: (
	  (.PERSECONDALARM_SETUP == 1) ? 0xC0 : 0x00
	)
	inst PERHOURALARM_SETUP :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Periodic Alarm Every Hour "
	prop JSName :: "rtcPerhouralarm"
        prop Visible :: 1
        prop Writable :: (rtcCfg.rtc_Support)
        prop NoGen :: 1
        prop TabName :: "Set Alarm"
	  prop Set :: (  .PERHOURALARM_SETUP = $1,
			     .RTCHOURA_VALUE = .RTCHOURA_VALUE_update(),
			     "ok" 	
			  )
	  }
	prop HRALARM_RTHOURA :: (
	  (.PERHOURALARM_SETUP == 1) ? 0xC0 : 0x00
	)
	inst PERDAYALARM_SETUP :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Periodic Alarm Every Day "
	prop JSName :: "rtcPerweekalarm"
        prop Visible :: 1
        prop Writable :: (rtcCfg.rtc_Support)
        prop NoGen :: 1
        prop TabName :: "Set Alarm"
	  prop Set :: (  .PERDAYALARM_SETUP = $1,
			     .RTCDAYW_VALUE = .RTCDAYW_VALUE_update(),
			     "ok" 	
			  )
	  }
	prop DAYALARM_RTDAYW :: (
	  (.PERDAYALARM_SETUP == 1) ? 0x80 : 0x00
	)
      
      
	inst RTC_man :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Set Manually "
	prop JSName :: "rtcSetManually"
	  prop Visible :: 1
	  prop Writable :: (rtcCfg.rtc_Support)
	  prop NoGen :: 1
	  prop TabName :: "Advanced"
      }
	inst RTCSEC_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%02x"
        prop Label :: "Seconds Register (RTCSEC) "
	prop JSName :: "rtcRtcsecAdv"
        prop Visible :: 1
        prop Writable :: .RTC_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set ::  ( 	if (($1 <= 0x59)&&($1 >= 0x00)) { 
				   .RTCSEC_VALUE = $1,
				   .SECOND_SETUP = .BCD_to_DEC(.RTCSEC_VALUE),
				   "ok" }
			      else { .error("Wrong value for second. Valid range: 0 - 59") } 
			   )
    	}
	inst RTCSECA_VALUE :: .RTCSECA_VALUE_update($1) {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%02x"
        prop Label :: "Seconds Alarm Register (RTCSECA) "
	prop JSName :: "rtcRtcsecaAdv"
        prop Visible :: 1
        prop Writable :: .RTC_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set ::  (	  .RTCSECA_VALUE = $1,
				  .RTSECA_SETUP_update($1),
				  "ok" 
			   )
    	}
	inst RTCMIN_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%02x"
        prop Label :: "Minutes Register (RTCMIN) "
	prop JSName :: "rtcRtcminAdv"
        prop Visible :: 1
        prop Writable :: .RTC_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set ::  (	if (($1 <= 0x59)&&($1 >= 0x00)) { 
				  .RTCMIN_VALUE = $1,
				  .MINUTE_SETUP = .BCD_to_DEC(.RTCMIN_VALUE),
				  "ok" }
			      else { .error("Wrong value for minute. Valid range: 0 - 59") } 
			   )
    	}
	inst RTCMINA_VALUE :: .RTCMINA_VALUE_update($1) {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%02x"
        prop Label :: "Minutes Alarm Register (RTCMINA) "
	prop JSName :: "rtcRtcminaAdv"
        prop Visible :: 1
        prop Writable :: .RTC_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set ::  (	.RTCMINA_VALUE = $1,
				.RTMINA_SETUP_update($1),
				"ok" 
			   )
    	}
	inst RTCHOUR_VALUE :: .RTCHOUR_VALUE_update($1) {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%02x"
        prop Label :: "Hour Register (RTCHOUR) "
	prop JSName :: "rtcRtchourAdv"
        prop Visible :: 1
        prop Writable :: .RTC_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set ::  ( .RTCHOUR_VALUE = $1,
			     .RTHOUR_SETUP_update($1),
			     "ok"
			   ) 
    	}
	inst RTCHOURA_VALUE :: .RTCHOURA_VALUE_update($1) {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%02x"
        prop Label :: "Hour Alarm Register (RTCHOURA) "
	prop JSName :: "rtcRtchouraAdv"
        prop Visible :: 1
        prop Writable :: .RTC_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set ::  (   .RTCHOURA_VALUE = $1,
				 .RTHOURA_SETUP_update($1),
				 "ok"
			   )
    	} 
	inst RTCDAYW_VALUE :: .RTCDAYW_VALUE_update($1) {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%02x"
        prop Label :: "Day of the Week Register (RTCDAYW) "
	prop JSName :: "rtcRtcdaywAdv"
        prop Visible :: 1
        prop Writable :: .RTC_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set ::  (	.RTCDAYW_VALUE = $1,
				.RTDAYW_SETUP_update($1),
				"ok" 
			   )
    	}
	inst RTCDAYM_VALUE :: 1 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%02x"
        prop Label :: "Day of the Month Register (RTCDAYM) "
	prop JSName :: "rtcRtcdaymAdv"
        prop Visible :: 1
        prop Writable :: .RTC_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set ::  (	.RTCDAYM_VALUE = $1 & 0xbf,
				.RTDAYM_SETUP_update($1 & 0xbf),
				"ok" 
			   )
    	}
	inst RTCMONTH_VALUE :: 1 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%02x"
        prop Label :: "Month Register (RTCMONTH) "
	prop JSName :: "rtcRtcmonthAdv"
        prop Visible :: 1
        prop Writable :: .RTC_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set ::  (	.RTCMONTH_VALUE = $1 & 0x9f,
				.RTMONTH_SETUP_update($1),
				"ok"
			   )
    	}
	inst RTCYEAR_VALUE :: 1 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%02x"
        prop Label :: "Year Register (RTCYEAR) "
	prop JSName :: "rtcRtcyearAdv"
        prop Visible :: 1
        prop Writable :: .RTC_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set ::  (	.RTCYEAR_VALUE = $1,
				.YEAR_SETUP = .BCD_to_DEC(.RTCYEAR_VALUE),
				"ok"
			   )
    	}
	inst RTCPINTR_VALUE :: .RTCPINTR_VALUE_update($1) {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%02x"
        prop Label :: "Periodic Interrupt Selection Register (RTCPINTR) "
	prop JSName :: "rtcRtcpintrAdv"
        prop Visible :: 1
        prop Writable :: .RTC_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set ::  (	.RTCPINTR_VALUE = ($1 & 0x1F),
				.RTPINTR_SETUP_update($1),
				"ok"
			   )
    	}
	inst RTCINTEN_VALUE :: 2 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%02x"
        prop Label :: "Interrupt Enable Register (RTCINTEN) "
	prop JSName :: "rtcRtcintenAdv"
        prop Visible :: 1
        prop Writable :: .RTC_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set ::  (	.RTCINTEN_VALUE = ($1 & 0x82),
				.MODE_SETUP = ($1 & 0x02) ? "24 Hour Mode" : "12 Hour Mode",
				"ok"
			   )
    	}
      
	
	prop RTCSECA_VALUE_update :: (
	     .SECALARM_RTSECA
	   | .DEC_to_BCD(.SECONDAL_SETUP)
	)
	prop RTCMINA_VALUE_update :: (
	     .MINALARM_RTMINA
	   | .DEC_to_BCD(.MINUTEAL_SETUP)
	)
	prop RTCHOUR_VALUE_update :: (
		.DEC_to_BCD(.HOUR24_SETUP)  
	)
	prop RTCHOURA_VALUE_update :: (
	  	     .DEC_to_BCD(.HOURAL24_SETUP) 
		  |  .HRALARM_RTHOURA
	) 
	prop RTCDAYW_VALUE_update :: (
	     .DAYALARM_RTDAYW
	  |  .DAR_RTDAYW 
	  |  .DAEN_RTDAYW
	  |  .DAYW_VALUE_update()
	)   
	prop RTCDAYM_VALUE_update :: (
	     .DEC_to_BCD(.DAYM_SETUP)
	)
	prop RTCMONTH_VALUE_update :: (
	    .DEC_to_BCD(.MONTH_VALUE_update())
	)
	prop RTCPINTR_VALUE_update :: (
                   (.RS_SETUP == "None") ? 0x00 :
                   (.RS_SETUP == "122us") ? 0x03 :
		       (.RS_SETUP == "244us") ? 0x04 :
		       (.RS_SETUP == "488us") ? 0x05 :
		       (.RS_SETUP == "976us") ? 0x06 :
		       (.RS_SETUP == "1.95ms") ? 0x07 :
		       (.RS_SETUP == "3.9ms") ? 0x08 :
		       (.RS_SETUP == "7.8125ms") ? 0x09 :
		       (.RS_SETUP == "15.625ms") ? 0x0A :
		       (.RS_SETUP == "31.25ms") ? 0x0B :
		       (.RS_SETUP == "62.5ms") ? 0x0C :
                   (.RS_SETUP == "125ms") ? 0x0D :
		       (.RS_SETUP == "250ms") ? 0x0E :
		       (.RS_SETUP == "500ms") ? 0x0F :
		       0x1F
    ) 
	
	prop RTSECA_SETUP_update :: (
		.PERSECONDALARM_SETUP = (.RTCSECA_VALUE & 0xC0) ? 1 : 0,
		.SECONDAL_SETUP = .BCD_to_DEC($1 & 0x7F)
	)
	prop RTMINA_SETUP_update :: (
		.PERMINUTEALARM_SETUP = (.RTCMINA_VALUE & 0xC0) ? 1 : 0,
		.MINUTEAL_SETUP = .BCD_to_DEC(.RTCMINA_VALUE & 0x7F)
	)
	prop RTDAYW_SETUP_update :: (
		.PERDAYALARM_SETUP = (.RTCDAYW_VALUE & 0x80) ? 1 : 0,
		.DAYWAL_SETUP = ($a = ($1 & 0x70),
   		                ($a == 0x10 ) ? "Sunday" :
  		                ($a == 0x20 ) ? "Monday" :
   		                ($a == 0x30 ) ? "Tuesday" :
				    ($a == 0x40 ) ? "Wednesday" :
				    ($a == 0x50 ) ? "Thursday" :
				    ($a == 0x60 ) ? "Friday" :
				    "Saturday" ),
		.DAYW_SETUP = ($a = ($1 & 0x07),
	                    ($a == 0x01 ) ? "Sunday" :
      	              ($a == 0x02 ) ? "Monday" :
            	        ($a == 0x03 ) ? "Tuesday" :
			        ($a == 0x04 ) ? "Wednesday" :
			        ($a == 0x05 ) ? "Thursday" :
			        ($a == 0x06 ) ? "Friday" :
		      	  "Saturday" )
	)
	prop RTDAYM_SETUP_update :: (
		.DAYM_SETUP = .BCD_to_DEC($1 & 0x3F)
	)
	prop RTMONTH_SETUP_update :: (
		.MONTH_SETUP = ($a = (.RTCMONTH_VALUE & 0x1f),
	                     ($a == 0x01 ) ? "January" :
      	               ($a == 0x02 ) ? "February" :
			         ($a == 0x03 ) ? "March" :
		      	   ($a == 0x04 ) ? "April" :
			         ($a == 0x05 ) ? "May" :
			         ($a == 0x06 ) ? "June" :
			         ($a == 0x07 ) ? "July" :
		      	   ($a == 0x08 ) ? "August" :
			         ($a == 0x09 ) ? "September" :
			         ($a == 0x10 ) ? "October" :
			         ($a == 0x11 ) ? "November" :
			         "December" )
	)
	prop RTPINTR_SETUP_update :: (
            .RS_SETUP = ($a = ($1 & 0x1f),
			 (($a == 0x00)||($a == 0x01)||($a == 0x02)) ? "None" :
                   ($a == 0x03) ? "122us" :
		       ($a == 0x04) ? "244us" :
		       ($a == 0x05) ? "488us" :
		       ($a == 0x06) ? "976us" :
		       ($a == 0x07) ? "1.95ms" :
		       ($a == 0x08) ? "3.9ms" :
		       ($a == 0x09) ? "7.8125ms" :
		       ($a == 0x0A) ? "15.625ms" :
		       ($a == 0x0B) ? "31.25ms" :
		       ($a == 0x0C) ? "62.5ms" :
                   ($a == 0x0D) ? "125ms" :
		       ($a == 0x0E) ? "250ms" :
		       ($a == 0x0F) ? "500ms" :
		       "1 minute" )
    ) 
	prop RTHOUR_SETUP_update :: (
		  .HOUR24_SETUP = .BCD_to_DEC($1 & 0x3F),
		  if (.HOUR24_SETUP > 12) 
		  {  
			.HOUR12_SETUP = .HOUR24_SETUP - 12,
			.AMPM_SETUP = "PM" 
		  }
		  else 
		  { 
			if (.HOUR24_SETUP == 0) 
			{ 
			  .HOUR12_SETUP = 12, 
			  .AMPM_SETUP = "PM" 
			}
			else 
			{ 
				.HOUR12_SETUP = .HOUR24_SETUP, 
				.AMPM_SETUP = "AM" 
			} 
		}
	)
	prop RTHOURA_SETUP_update :: (
	    .HOURAL24_SETUP = .BCD_to_DEC($1 & 0x3F),
	    if (.HOURAL24_SETUP > 12) 
		{  
			.HOURAL12_SETUP = .HOURAL24_SETUP - 12,
			.AMPMAL_SETUP = "PM" 
		}
	    else 
		{ 
			if (.HOURAL24_SETUP == 0) 
			{ 
				.HOURAL12_SETUP = 12, 
				.AMPMAL_SETUP = "PM" 
			}
			else 
			{ 
				.HOURAL12_SETUP = .HOURAL24_SETUP, 
				.AMPMAL_SETUP = "AM" 
			} 
		},
	    .PERHOURALARM_SETUP = ((.RTCHOURA_VALUE & 0xC0)&&(.PERMINUTEALARM_SETUP == 0)&&(.PERSECONDALARM_SETUP == 0)) ? 1 : 0 
	) 
	
	prop BCD_to_DEC :: (
		((($1 >> 4) & 0x000F) * 10) + ($1 & 0x000F)
	)
	prop DEC_to_BCD :: (
            $a = $1,
            $b = 0,
            $c = 0,
            while ($a > 0) {
                $a -= 10,
                $b++
            },
            if ($a != 0) {
                $a += 10,
                $b--
            },
            $b*16 + $a
	)
	prop DAYW_VALUE_update :: (
		       (.DAYW_SETUP == "Sunday") ? 0x01 :
                   (.DAYW_SETUP == "Monday") ? 0x02 :
                   (.DAYW_SETUP == "Tuesday") ? 0x03 :
		       (.DAYW_SETUP == "Wednesday") ? 0x04 :
		       (.DAYW_SETUP == "Thursday") ? 0x05 :
		       (.DAYW_SETUP == "Friday") ? 0x06 :
		       0x07
    )
	prop MONTH_VALUE_update :: (
                   (.MONTH_SETUP == "January") ? 1 :
                   (.MONTH_SETUP == "February") ? 2 :
		       (.MONTH_SETUP == "March") ? 3 :
		       (.MONTH_SETUP == "April") ? 4 :
		       (.MONTH_SETUP == "May") ? 5 :
		       (.MONTH_SETUP == "June") ? 6 :
		       (.MONTH_SETUP == "July") ? 7 :
		       (.MONTH_SETUP == "August") ? 8 :
		       (.MONTH_SETUP == "September") ? 9 :
		       (.MONTH_SETUP == "October") ? 10 :
		       (.MONTH_SETUP == "November") ? 11 :
		       12
    ) 
}
type rtcRes {
	isa ObjectMgr
	prop name :: "RTCRes"
	prop Label :: "Real Time Clock Resource Manager"
	prop JSName :: "RTCRES"
	prop GlobalHelpTopic :: 1102
	prop InstanceHelpTopic :: 1103
	prop GlobalIcon :: 187
	prop InstanceIcon :: 188
	prop GlobalPropertyPage :: "{1C8F8861-E550-11d4-9745-00B0D0524DFE}"
      prop InstancePropertyPage :: "{1C8F8862-E550-11d4-9745-00B0D0524DFE}"
    	prop Vendor :: "vendor1"
    	prop Version :: "1.00.00"
	prop IsContainedIn :: RTCFOLDER
	prop maxObjs :: ( 1 )
	prop cHeaderName :: (rtcCfg.rtc_Support) ? "csl_rtc.h" : ""
	prop NoGen :: 1
	prop cGen :: 1
	prop cConfigName :: "RTC_config"
	inst configRtc :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable RTC Configuration "
	prop JSName :: "rtcCfgEnable"
        prop NoGen :: 1
        prop Visible :: (rtcCfg.rtc_Support)
	  prop Writable :: 1
	}
	inst cConfigGen ::= ((.configRtc) && (.cConfigArg0 != RTC_NOTHING)) {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable RTC Configuration "
        prop NoGen :: 1
        prop Visible :: 0
	  prop Writable :: 1
	}
	inst cConfigArg0 :: RTC_NOTHING {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	  prop MemberType :: rtcCfg
	  prop Label :: "Pre-initialize"
	prop JSName :: "rtcPreInit"
	  prop cPreVal :: "&"
        prop Visible :: 1
	  prop Writable :: ((rtcCfg.rtc_Support) && (.configRtc))
      }
	prop comment :: (rtcCfg.rtc_Support) ? "/* You must use RTC_start() in your main code to start the RTC. */"
 						: ""
	prop cGenFxnEpilogue :: (       
            "%5t\n%1s\n\n%0t\0,comment"
	)
}
object RTC_NOTHING :: rtcCfg {
	param iIsUsed :: 0
}
object RTC0 :: rtcRes {
    param iComment :: .iDelMsg
    param iIsUsed :: 1
    param iDelUser :: "rtcRes"
    param iDelMsg :: ("RTC ")
}
type TIMERFOLDER {
    
    prop Label :: "TIMER - Timer Device"
    prop GlobalIcon :: 161
    prop GlobalPropertyPage :: "{B916FB95-52A5-11d4-967C-0750048381B7}"
    prop GlobalHelpTopic :: 1080
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}
type timerCfg {
	isa ObjectMgr
	prop name :: "TIMER"
	prop Label :: "Timer Configuration Manager"
	prop JSName :: "TIMER"
	
	prop IsContainedIn :: TIMERFOLDER
	prop GlobalHelpTopic :: 1081
	prop InstanceHelpTopic :: 1081
	prop GlobalIcon :: 161
	prop InstanceIcon :: 162
	prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-10105A98CA0B}"
      prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-1000C070F3E9}"
    	prop Vendor :: "vendor1"
    	prop Version :: "1.00.00"
	
	prop cGen :: 1
    	prop cStruct :: 1
    	prop cStructType :: "TIMER_Config"
	prop cHeaderName :: .gNumOf > 0 ? "csl_timer.h" : ""
	prop NoGen :: 1
      
      
      
      
	inst FUNC_SETUP :: "Internal(TOUT is Input)" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum :: "Internal(TOUT is Input),Internal(TOUT is Output),External"
        prop Label :: "Clock Source "
	  prop JSName :: "timerTcrFunc"
        prop Visible :: 1
        prop Writable :: !(.TIMER_man)
        prop NoGen :: 1
        prop TabName :: "Clock Control"
	  prop Set ::  (	  .FUNC_SETUP = $1,
				  .TCR_VALUE = .TCR_VALUE_update(),
				  "ok"
			   )
	}
	prop FUNC_TCR :: (
		(.FUNC_SETUP == "Internal(TOUT is Input)") ? 0x0000 :
		(.FUNC_SETUP == "Internal(TOUT is Output)") ? 0x0800 :
            0x1000
	)
      prop FUNC_SETUP_update :: (
             (.TCR_VALUE & 0x1000) ? "External" :
                   (.TCR_VALUE & 0x0800) ? "Internal(TOUT is Output)" :
                      "Internal(TOUT is Input)"
      )
      
      
	inst POLAR_SETUP :: "TIN/TOUT starts low" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum :: "TIN/TOUT starts low,TIN/TOUT starts high"
        prop Label :: "Polarity (POLAR) "
	  prop JSName :: "timerTcrPolar"
        prop Visible :: 1
        prop Writable :: !(.TIMER_man) && (.FUNC_SETUP == "Internal(TOUT is Output)")
        prop NoGen :: 1
        prop TabName :: "Clock Control"
	  prop Set ::  (	  .POLAR_SETUP = $1,
				  .TCR_VALUE = .TCR_VALUE_update(),
				  "ok"
			   )
	}
	prop POLAR_TCR :: (
		(.POLAR_SETUP == "TIN/TOUT starts high") ? 0x0004 : 0x0000
	)
      
	inst PWID_SETUP :: "1 CLKOUT Period" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum :: "1 CLKOUT Period,2 CLKOUT Periods,4 CLKOUT Periods,8 CLKOUT Periods"
        prop Label :: "Pulse Width (PWID) "
	  prop JSName :: "timerTcrPwid"
        prop Visible :: 1
        prop Writable :: !(.TIMER_man) && (.FUNC_SETUP == "Internal(TOUT is Output)") && (.CP_SETUP == "Pulse Mode")
        prop NoGen :: 1
        prop TabName :: "Clock Control"
	  prop Set ::  (	  .PWID_SETUP = $1,
				  .TCR_VALUE = .TCR_VALUE_update(),
				  "ok"
			   )
	}
	prop PWID_TCR :: (
		(.PWID_SETUP == "1 CLKOUT Period") ? 0x0000 :
		(.PWID_SETUP == "2 CLKOUT Periods") ? 0x0040 :
		(.PWID_SETUP == "4 CLKOUT Periods") ? 0x0080 :
            0x00C0
	)
      prop PWID_SETUP_update :: (
           ((.TCR_VALUE & 0x00C0) == 0x00C0) ? "8 CLKOUT Periods" :
              (.TCR_VALUE & 0x0080) ? "4 CLKOUT Periods" :
                (.TCR_VALUE & 0x0040) ? "2 CLKOUT Periods" :
                   "1 CLKOUT Period"
      )
      
	inst CP_SETUP :: "Pulse Mode" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum :: "Pulse Mode,Clock Mode"
        prop Label :: "Clock/Pulse Mode (C/P) "
	  prop JSName :: "timerTcrCp"
        prop Visible :: 1
        prop Writable :: !(.TIMER_man) && (.FUNC_SETUP == "Internal(TOUT is Output)")
        prop NoGen :: 1
        prop TabName :: "Clock Control"
	  prop Set ::  (	  .CP_SETUP = $1,
				  .TCR_VALUE = .TCR_VALUE_update(),
				  "ok"
			   )
	}
	prop CP_TCR :: (
		(.CP_SETUP == "Clock Mode") ? 0x0008 : 0x0000
	)
      
      
      
	inst TDDR_SETUP :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Timer Divide Down Ratio(TDDR) [0 - 15] "
	prop JSName :: "timerPrscTddr"
        prop Visible :: 1
        prop Writable :: !(.TIMER_man)
        prop NoGen :: 1
        prop TabName :: "Counter Control"
	  prop Set ::  (	  .TDDR_SETUP = $1,
				  .PRSC_VALUE = .PRSC_VALUE_update(),
				  "ok"
			   )
	}
      
      
      
	inst PRD_SETUP :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Timer Period (PRD) "
	prop JSName :: "timerPrd"
        prop Visible :: 1
        prop Writable :: !(.TIMER_man)
        prop NoGen :: 1
        prop TabName :: "Counter Control"
	  prop Set ::  (	  .PRD_SETUP = $1,
				  .PRD_VALUE = $1,
				  "ok"
			   )
	}
      
	inst FREE_SOFT_SETUP :: "Stop Immediately"{
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum :: "Stop Immediately,Stop when counter = 0,Do Not Stop"
        prop Label :: "Breakpoint Emulation Behavior "
	  prop JSName :: "timerTcrFreeSoft"
        prop Visible :: 1
        prop Writable :: !(.TIMER_man)
        prop NoGen :: 1
        prop TabName :: "General"
	  prop Set ::  (	  .FREE_SOFT_SETUP = $1,
				  .TCR_VALUE = .TCR_VALUE_update(),
				  "ok"
			   )
	}
	prop FREE_SOFT_TCR :: (
		(.FREE_SOFT_SETUP == "Stop when counter = 0") ? 0x0200 :
            (.FREE_SOFT_SETUP == "Stop Immediately") ? 0x0000 :
            0x0100
	)
     prop FREE_SOFT_SETUP_update :: (
            (.TCR_VALUE & 0x0200) ? "Stop when counter = 0" :
            (.TCR_VALUE & 0x0100) ? "Do Not Stop" : "Stop Immediately"
     )
      
	inst IDLE_EN_SETUP :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Stop all clocks in Timer during Peripheral Idle Mode "
	  prop JSName :: "timerTcrIdleen"
        prop Visible :: 1
        prop Writable :: !(.TIMER_man)
        prop NoGen :: 1
        prop TabName :: "General"
	  prop Set ::  (	  .IDLE_EN_SETUP = $1,
				  .TCR_VALUE = .TCR_VALUE_update(),
				  "ok"
			   )
	}
	prop IDLE_EN_TCR :: (
		(.IDLE_EN_SETUP == 1) ? 0x8000 : 0x0000
	)
      
	inst ARB_SETUP :: "Disabled" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum :: "Disabled,Enabled"
        prop Label :: "Auto Reload (ARB) "
	  prop JSName :: "timerTcrArb"
        prop Visible :: 1
        prop Writable :: !(.TIMER_man)
        prop NoGen :: 1
        prop TabName :: "Counter Control"
	  prop Set ::  (	  .ARB_SETUP = $1,
				  .TCR_VALUE = .TCR_VALUE_update(),
				  "ok"
			   )
	}
	prop ARB_TCR :: (
		(.ARB_SETUP == "Enabled") ? 0x0020 : 0x0000
	)
      
      
      
	inst TIMER_man :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Set Manually "
	  prop JSName :: "timerSetManually"
	  prop Visible :: 1
	  prop Writable :: 1
	  prop NoGen :: 1
	  prop TabName :: "Advanced"
      }
      
	inst TCR_VALUE :: .TCR_VALUE_update() {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Timer Control Register (TCR) "
	  prop JSName :: "timerTcr"
        prop Visible :: 1
        prop Writable :: .TIMER_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set :: (	.TCR_VALUE = $1,
				.TCR_SETUP_update($1),
				"ok"
			  )
    	}
      
	inst PRD_VALUE :: .PRD_SETUP {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Timer Period Register (PRD) "
	prop JSName :: "timerPrdAdv"
        prop Visible :: 1
        prop Writable :: .TIMER_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set :: (	.PRD_VALUE = $1,
				.PRD_SETUP = $1,
				"ok"
			  )
    	}
      
      
	inst PRSC_VALUE :: .PRSC_VALUE_update() {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Timer Prescalar Register (PRSC) "
	prop JSName :: "timerPrsc"
        prop Visible :: 1
        prop Writable :: .TIMER_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: 1
	  prop cType :: "Uint16"
	  prop Set :: (	.PRSC_VALUE = $1,
				.PRSC_SETUP_update($1),
				"ok"
			  )
    	}
      
      
      
      
	prop TSS_TCR :: ( 0x0010 )
      prop TCR_VALUE_update :: (
		   .POLAR_TCR()
		|  .CP_TCR()
		|  .ARB_TCR()
		|  .PWID_TCR()
		|  .FREE_SOFT_TCR()
		|  .FUNC_TCR()
            |  .TSS_TCR()
            |  .IDLE_EN_TCR()
	)
      
	prop PRSC_VALUE_update :: (
		   (.TDDR_SETUP & 0x000F)
	)
      
      
      
      
	prop TCR_SETUP_update :: (
		.POLAR_SETUP = ($1 & 0x0004) ? "TIN/TOUT starts high" : "TIN/TOUT starts low",
		.CP_SETUP = ($1 & 0x0008) ? "Clock Mode" : "Pulse Mode",
		.ARB_SETUP = ($1 & 0x0020) ? "Enabled" : "Disabled",
		.PWID_SETUP = .PWID_SETUP_update(),
		.FREE_SOFT_SETUP = .FREE_SOFT_SETUP_update(),
		.FUNC_SETUP = .FUNC_SETUP_update(),
            .IDLE_EN_SETUP = ($1 & 0x8000) ? 1 : 0
	)
      
	prop PRSC_SETUP_update :: (
		.TDDR_SETUP = ($1 & 0x000F)
	)
}
type hTIMER {
	isa ObjectMgr
	prop name :: "hTIMER"
	prop Label :: "Timer Resource Manager"
	prop JSName :: "HTIMER"
	prop GlobalHelpTopic :: 1082
	prop InstanceHelpTopic :: 1083
	prop GlobalIcon :: 161
	prop InstanceIcon :: 162
	prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-10105A98CA0B}"
      prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-1000C070F3E9}"
    	prop Vendor :: "vendor1"
    	prop Version :: "1.00.00"
	prop IsContainedIn :: TIMERFOLDER
	
	prop maxObjs :: (
		(GBL.CHIPTYPE == "5510") ? 2 :
		2
	)
	prop NoGen :: 1
	prop cGen :: 1
	prop cHandle :: .cOpenGen
	prop cHeaderName :: .c55timer == 1 ? "csl_timer.h" : ""
	prop cHandleType :: "TIMER_Handle"
	prop cOpenName :: "TIMER_open"
	prop cConfigName :: "TIMER_config"
	prop cHandleName :: .handleName
	global c55timer :: 0 {
          prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Label :: "C55x Timer opened "
	    prop Visible :: 0
	    prop Writable :: 1
	    prop NoGen :: 1
	    prop cGen :: 0
      }
      inst cOpenGen :: 0 {
	    prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Label :: "Open Handle to Timer "
	    prop JSName :: "timerHandleEnable"
	    prop Visible :: 1
	    prop Writable :: 1
	    prop NoGen :: 1
	    prop cGen :: 1
          prop Set :: (
                        if ((.cOpenArg0 == "TIMER_DEV0") && (CLK.USETIMER == 1) && (CLK.TIMERNUM == 0)) {
                            .cOpenGen = 0,
                            .error("TIMER0 already used by the CLK module")
                        }
                        else {
                            if ((.cOpenArg0 == "TIMER_DEV1") && (CLK.USETIMER == 1) && (CLK.TIMERNUM == 1)) {
                                .cOpenGen = 0,
                                .error("TIMER1 already used by the CLK module")
                            }
                            else {
                                .cOpenGen = $1,
                                if ($1 == 1) {
                                    .c55timer = 1,
                                    if (.cOpenArg0 == "TIMER_DEV0") {
                                        HWI_INT4.client = "CSL"
                                    }
                                    else {
                                        if (.cOpenArg0 == "TIMER_DEV1") {
                                            HWI_INT22.client = "CSL"
                                        }
                                    },
                                    "ok"
                                }
                                else {
                                    .c55timer = 0,
                                    if (.cOpenArg0 == "TIMER_DEV0") {
                                        HWI_INT4.client = "USER"
                                    }
                                    else {
                                        if (.cOpenArg0 == "TIMER_DEV1") {
                                            HWI_INT22.client = "USER"
                                        }
                                    },
                                    "ok"
                                }
                            }
                        }
                    )
	}
	inst cOpenArg0 :: "TIMER_DEV0" {
	     prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	     prop Label :: "Open Arg 0"
	     prop Visible :: 0
	     prop Writable :: 1
	     prop NoGen :: 1
	}
	inst cOpenArg1 :: "TIMER_OPEN_RESET" {
	     prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	     prop Label :: "Open Arg 1"
	     prop Visible :: 0
	     prop Writable :: 0
	     prop NoGen :: 1
	}
	
    	inst handleName :: self {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Specify Handle Name "
	  prop JSName :: "timerHandleName"
	  prop Visible :: 1
	  prop Writable :: (.cOpenGen)
	  prop NoGen :: 1
        prop Set :: ( .handleName = $1,
                      .cConfigArg0 = $1,
                      "ok"
                   )
    	}
    	inst PINIT_ENABLE :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Enable pre-initialization "
	  prop JSName :: "timerEnablePreInit"
	  prop Visible :: 1
	  prop Writable :: .cOpenGen
	  prop NoGen :: 1
	  prop Set :: (
		$a = 0,
		scan ($b; timerCfg) {
			$a = 1
		},
		if ($a == 0) {
			"You must create a configuration object"
		}
		else {
			.PINIT_ENABLE = $1,
			"ok"
		}
	  )
    	}
	
	inst cConfigGen ::= ((.cOpenGen == 1) && (.PINIT_ENABLE == 1) && (.cConfigArg1 != TIMER_NOTHING)) {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
      }
	inst cConfigArg0 :: .handleName {
            prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
            prop Label :: "Config argument 0"
            prop Visible :: 0
        }
	
     	inst cConfigArg1 :: TIMER_NOTHING {
	  prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	  prop MemberType :: timerCfg
	  prop Label :: "Pre-initialize "
	  prop JSName :: "timerPreInit"
	  prop Visible :: 1
	  prop Writable :: .PINIT_ENABLE == 1
	  prop NoGen :: 0
	  prop cPreVal :: "&"
    	}
}
object TIMER_NOTHING :: timerCfg {
    param iIsUsed :: 0
}
object TIMER0 :: hTIMER {
      param iComment :: .iDelMsg
	param iIsUsed :: 1
      param iDelUser :: "hTIMER"
	param iDelMsg :: ("Timer 0")
	param handleName :: "hTimer0"
	param cOpenArg0 :: "TIMER_DEV0"
}
object TIMER1 :: hTIMER {
      param iComment :: .iDelMsg
	param iIsUsed :: 1
      param iDelUser :: "hTIMER"
	param iDelMsg :: ("Timer 1")
	param handleName :: "hTimer1"
	param cOpenArg0 :: "TIMER_DEV1"
}
type USBFOLDER {
    
    prop Label :: "USB"
    prop GlobalIcon :: 191
    prop GlobalPropertyPage :: "{B916FB95-52A5-11d4-967C-0750048381C8}"
    prop GlobalHelpTopic :: 1200
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}
type endptObj {
	isa ObjectMgr
	prop name :: "USB"
	prop Label :: "USB Endpoint Configuration Manager"
      prop JSName :: "USB"
	prop GlobalHelpTopic :: 1201
	prop InstanceHelpTopic :: 1201
	
	prop IsContainedIn :: USBFOLDER
	prop GlobalIcon :: 191
	prop InstanceIcon :: 192
	prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-10105A98CA0B}"
      prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-1000C070F3E9}"
    	prop Vendor :: "vendor1"
    	prop Version :: "1.00.00"
	
      prop usb_Support :: ( (GBL.CHIPTYPE == "5509") ||
                            (GBL.CHIPTYPE == "5509A") ||
                            (GBL.CHIPTYPE == "5509PG1_0") ||
                            (GBL.CHIPTYPE == "5509PG2_0")
      )
	prop cGen :: 1
    	prop cStruct :: (endptObj.usb_Support)
    	prop cStructType :: "USB_EpObj"
	prop cHeaderName ::  ((.gNumOf > 0) && (endptObj.usb_Support)) ? "csl_usb.h" : ""
	prop NoGen :: 1
      prop localCreate :: ( .MAX_PKTSIZE = .MAX_PKTSIZE + 8,
                            .gPKTSIZE_LEFT = .gPKTSIZE_LEFT - 64,
                            .PKTSIZE_LEFT = .gPKTSIZE_LEFT,
				    "ok"
	)
      prop localDelete :: (  .MAX_PKTSIZE = .MAX_PKTSIZE - .PKTSIZE_VALUE,
                             .gPKTSIZE_LEFT = .gPKTSIZE_LEFT + .PKTSIZE_VALUE,
				    "ok"
	)
	prop maxObjs :: ( if (.gPKTSIZE_LEFT >= 8) { 1000 }
				else { .gNumOf }
 )
      
	inst NUM_SETUP :: "Endpoint 0 - OUT" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum :: "Endpoint 0 - OUT,Endpoint 1 - OUT,Endpoint 2 - OUT,Endpoint 3 - OUT,Endpoint 4 - OUT,Endpoint 5 - OUT,Endpoint 6 - OUT,Endpoint 7 - OUT,Endpoint 0 - IN,Endpoint 1 - IN,Endpoint 2 - IN,Endpoint 3 - IN,Endpoint 4 - IN,Endpoint 5 - IN,Endpoint 6 - IN,Endpoint 7 - IN"
        prop Label :: "Endpoint Number"
        prop JSName :: "usbEndpointNumber"
        prop Visible :: 1
        prop Writable :: (endptObj.usb_Support)
        prop NoGen :: 1
        prop TabName :: "Endpoints Setting"
	  prop Set ::  (	  .NUM_SETUP = $1,
				  .NUM_VALUE = .NUM_VALUE_update(), 
				  .DMAADDR_VALUE = .DMAADDR_VALUE_update(),
				  .ENDPTADDR_VALUE = .ENDPTADDR_VALUE_update(),
				  .TRANSFER_VALUE = .TRANSFER_VALUE_update(), 
				  if (($1 == "Endpoint 0 - OUT") || ($1 == "Endpoint 0 - IN"))
				  {	 .PKTSIZE_COMBO_SETUP = 64,
				       .PKTSIZE_VALUE = .PKTSIZE_COMBO_SETUP,
				       .MAX_PKTSIZE = .MAX_PKTSIZE + .PKTSIZE_COMBO_SETUP - .LAST_PKTSIZE,
				       .gPKTSIZE_LEFT = 3595 - .MAX_PKTSIZE,
				       .PKTSIZE_LEFT = .gPKTSIZE_LEFT,
				       .LAST_PKTSIZE = .PKTSIZE_VALUE
				  },
				 if ((.TRANSFER_SETUP == "Interrupt") && ((.NUM_SETUP == "Endpoint 1 - OUT") || 
										    (.NUM_SETUP == "Endpoint 2 - OUT") ||
										    (.NUM_SETUP == "Endpoint 3 - OUT") ||
										    (.NUM_SETUP == "Endpoint 4 - OUT") ||
										    (.NUM_SETUP == "Endpoint 5 - OUT") ||
										    (.NUM_SETUP == "Endpoint 6 - OUT") ||
										    (.NUM_SETUP == "Endpoint 7 - OUT"))
				   ) {
					.TRANSFER_SETUP = "Bulk" },
				  "ok"
			   )	
	  }
	inst TRANSFER_SETUP :: "Bulk" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum :: "Bulk,Interrupt,Isochronous,Host Port"
        prop Label :: "Transfer Type "
        prop JSName :: "usbTransferType"
        prop Visible :: 1
        prop Writable :: ((endptObj.usb_Support) && (.NUM_SETUP != "Endpoint 0 - OUT") && (.NUM_SETUP != "Endpoint 0 - IN"))
        prop NoGen :: 1
        prop TabName :: "Endpoints Setting"
	  prop Set ::  (	  .TRANSFER_SETUP = $1,
				  if ($1 == "Host Port")
				  {	 .PKTSIZE_COMBO_SETUP = 64,
				       .PKTSIZE_VALUE = .PKTSIZE_COMBO_SETUP,
				       .MAX_PKTSIZE = .MAX_PKTSIZE + .PKTSIZE_COMBO_SETUP - .LAST_PKTSIZE,
				       .gPKTSIZE_LEFT = 3595 - .MAX_PKTSIZE,
				       .PKTSIZE_LEFT = .gPKTSIZE_LEFT,
				       .LAST_PKTSIZE = .PKTSIZE_VALUE
				  },
				  if (($1 == "Interrupt") && ((.NUM_SETUP == "Endpoint 1 - OUT") || 
								    (.NUM_SETUP == "Endpoint 2 - OUT") ||
								    (.NUM_SETUP == "Endpoint 3 - OUT") ||
								    (.NUM_SETUP == "Endpoint 4 - OUT") ||
								    (.NUM_SETUP == "Endpoint 5 - OUT") ||
								    (.NUM_SETUP == "Endpoint 6 - OUT") ||
								    (.NUM_SETUP == "Endpoint 7 - OUT"))
				   ) {
					.TRANSFER_SETUP = "Bulk",
					.error("Endpoints 1-7 OUT cannot have Interrupt transfer type")
				     }
				else {
				  .TRANSFER_VALUE = .TRANSFER_VALUE_update(), 
				  "ok"
				}
			   )
	}
	inst PKTSIZE_LEFT :: .gPKTSIZE_LEFT  {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Packet size available at instance level "
        prop Visible :: 0
        prop Writable :: (endptObj.usb_Support)
        prop NoGen :: 1
        prop TabName :: "Endpoints Setting"
	}
	global gPKTSIZE_LEFT :: 3595 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Memory Available for Endpoint Packets "
        prop JSName :: "usbPktsizeLeft"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
	}
	global genPsof :: 0 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Generate PreSOF Timer Value "
        prop NoGen :: 1
        prop Visible :: 0
	  prop Writable :: (endptObj.usb_Support)
      }
	global psofTimer :: 0 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "PreSOF Interrupt Timer Value [0 - 255]: Time ~ 1.33usecs x "
        prop JSName :: "usbPsofTimer"
        prop NoGen :: 1
        prop Visible :: 1
	  prop Writable :: (endptObj.usb_Support) && (.genPsof != 0)
        prop Set :: (
                    if (($1 <= 255) && ($1 >= 0)) {
                        .psofTimer = $1,
                        USB.cConfigArg2 = $1,
                        "ok"
                    }
                    else {
                        .error("Value exceeds Limits")
                    }
        )
      }
	global pllInit :: "3 MHz" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "3 MHz,6 MHz,12 MHz,24 MHz,48 MHz"
        prop Label :: "USB PLL Input Clock Frequency "
        prop JSName :: "usbPllInit"
        prop NoGen :: 1
        prop Visible :: 1
	  prop Writable :: (endptObj.usb_Support)
	  prop Set ::  (	  .pllInit = $1,
				  .pllInit_VAL = .pllInit_update(), 
				  "ok"
			   )
      }
	prop pllInit_update :: (
                   (.pllInit == "3 MHz") ? "3" :
                   (.pllInit == "6 MHz") ? "6" :
		       (.pllInit == "12 MHz") ? "12" :
		       (.pllInit == "24 MHz") ? "24" :
		       "48"
    )
	global pllInit_VAL :: .pllInit_update() {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "USB PLL Input Clock Frequency "
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
	  prop cGen :: 0
	  prop cStruct :: 0
	  prop cType :: "Uint16" 
	  prop Set ::  (	.pllInit_VAL = $1,
				"ok"
			   )
	}
	global INFO :: "USB requires 48 MHz. " {
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
	} 
	inst PKTSIZE_COMBO_SETUP :: 64 {
	  prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum :: "8,16,32,64"
        prop Label :: "Maximum Packet Size "
        prop JSName :: "usbPktsize"
        prop Visible :: 1
        prop Writable :: ((.TRANSFER_SETUP != "Isochronous") && (endptObj.usb_Support) && 
				  (.NUM_SETUP != "Endpoint 0 - OUT") && 
				  (.NUM_SETUP != "Endpoint 0 - IN") && 
				  (.TRANSFER_SETUP != "Host Port"))
        prop NoGen :: 1
        prop TabName :: "Endpoints Setting"
	  prop Set ::  ( 	if ($1 <= (.gPKTSIZE_LEFT + .LAST_PKTSIZE) ) {
				  .PKTSIZE_COMBO_SETUP = $1,
				  .PKTSIZE_VALUE = .PKTSIZE_COMBO_SETUP,
				  .MAX_PKTSIZE = .MAX_PKTSIZE + .PKTSIZE_COMBO_SETUP - .LAST_PKTSIZE,
				  .gPKTSIZE_LEFT = 3595 - .MAX_PKTSIZE,
				  .PKTSIZE_LEFT = .gPKTSIZE_LEFT,
				  .LAST_PKTSIZE = .PKTSIZE_VALUE,
				    "ok" 
				}
				else { .error("Total packet size supported by USB exceeded") } 
			   )
	}
	inst PKTSIZE_SETUP :: 1 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Maximum Packet Size for Isochronous transfer "
        prop JSName :: "usbPktsizeIso"
        prop Visible :: 1
        prop Writable :: (.TRANSFER_SETUP == "Isochronous") && (endptObj.usb_Support)
        prop NoGen :: 1
        prop TabName :: "Endpoints Setting"
	  prop Set ::  ( if (($1 >= 1) && ($1 <= 1023)) {
				  if ($1 <= (.gPKTSIZE_LEFT + .LAST_PKTSIZE) ) {
				    .PKTSIZE_SETUP = $1,
				    .PKTSIZE_VALUE = .PKTSIZE_SETUP,
				    .MAX_PKTSIZE = .MAX_PKTSIZE + .PKTSIZE_SETUP - .LAST_PKTSIZE,
				    .gPKTSIZE_LEFT = 3595 - .MAX_PKTSIZE,
				    .PKTSIZE_LEFT = .gPKTSIZE_LEFT,
				    .LAST_PKTSIZE = .PKTSIZE_VALUE, 
				    "ok" 
				  }
				  else { .error("Total packet size supported by USB exceeded ") }
			     }
				else { .error("Invalid packet size. (Valid Range: 1 - 1023) ") }
			   )
	}
	inst FXN_SETUP :: "USB_EvISR_NONE" {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "User Interrupt Handle Function "
        prop JSName :: "usbInterruptFxn"
        prop Visible :: 1
        prop Writable :: (endptObj.usb_Support)
        prop NoGen :: 1
        prop TabName :: "Endpoints Setting"
	  prop Set ::  (	  .FXN_SETUP = $1,
				  .FXN_VALUE = .FXN_SETUP, 
				  "ok"
			   )
	}
	inst NOTE :: "The User Interrupt Handle Function is called only if one or more USB events are selected from USB Events tab. " {
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop TabName :: "Endpoints Setting"
        prop NoGen :: 1
	} 
	inst NOTE1 :: "For ENDPOINT 0, Transfer type is always Control, and Maximum Packet Size is always 64. " {
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop TabName :: "Endpoints Setting"
        prop NoGen :: 1
	} 
	
	inst MASK :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Mask Value "
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "USB Events"
	}
	inst RESET_SETUP :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Reset Request (RSTR) "
        prop JSName :: "usbEventReset"
        prop Visible :: 1
	  prop Writable :: (endptObj.usb_Support)
        prop NoGen :: 1
        prop TabName :: "USB Events"
	  prop Set ::  (	.RESET_SETUP = $1,
				if ($1 == 1) {
					.EVENTMASK_VALUE |= 0x0001,
					.MASK = .EVENTMASK_VALUE,
					"ok" }
				else {
					.EVENTMASK_VALUE &= 0xFFFE,
					.MASK = .EVENTMASK_VALUE,
					"ok" }
			   )
      }
	inst SUSPEND_SETUP :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Suspend Request (SUSR) "
        prop JSName :: "usbEventSuspend"
        prop NoGen :: 1
        prop Visible :: 1
	  prop Writable :: (endptObj.usb_Support)
        prop TabName :: "USB Events"
	  prop Set ::  (	.SUSPEND_SETUP = $1,
				if ($1 == 1) {
					.EVENTMASK_VALUE |= 0x0004,
					.MASK = .EVENTMASK_VALUE,
					"ok" }
				else {
					.EVENTMASK_VALUE &= 0xFFFB,
					.MASK = .EVENTMASK_VALUE,
					"ok" }
			   )
      }
	inst RESUME_SETUP :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Resume Request (RESR) "
        prop JSName :: "usbEventResume"
        prop NoGen :: 1
        prop Visible :: 1
	  prop Writable :: (endptObj.usb_Support)
        prop TabName :: "USB Events"
	  prop Set ::  (	.RESUME_SETUP = $1,
				if ($1 == 1) {
					.EVENTMASK_VALUE |= 0x0008,
					.MASK = .EVENTMASK_VALUE,
					"ok" }
				else {
					.EVENTMASK_VALUE &= 0xFFF7,
					.MASK = .EVENTMASK_VALUE,
					"ok" }
			   )
      }
	inst SOF_SETUP :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Start Of Frame (SOF) "
        prop JSName :: "usbEventSof"
        prop NoGen :: 1
        prop Visible :: 1
	  prop Writable :: (endptObj.usb_Support)
        prop TabName :: "USB Events"
	  prop Set ::  (	.SOF_SETUP = $1,
				if ($1 == 1) {
					.EVENTMASK_VALUE |= 0x0002,
					.MASK = .EVENTMASK_VALUE,
					"ok" }
				else {
					.EVENTMASK_VALUE &= 0xFFFD,
					.MASK = .EVENTMASK_VALUE,
					"ok" }
			   )
      }
	inst SETUP_SETUP :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Setup Packet Receive (SETUP) "
        prop JSName :: "usbEventSetup"
        prop NoGen :: 1
        prop Visible :: 1
	  prop Writable :: (endptObj.usb_Support)
        prop TabName :: "USB Events"
	  prop Set ::  (	.SETUP_SETUP = $1,
				if ($1 == 1) {
					.EVENTMASK_VALUE |= 0x00010,
					.MASK = .EVENTMASK_VALUE,
					"ok" }
				else {
					.EVENTMASK_VALUE &= 0xFFEF,
					.MASK = .EVENTMASK_VALUE,
					"ok" }
			   )
      }
	inst EOT_SETUP :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "End of Posted Transfer (EOT) "
        prop JSName :: "usbEventEot"
        prop NoGen :: 1
        prop Visible :: 1
	  prop Writable :: (endptObj.usb_Support)
        prop TabName :: "USB Events"
	  prop Set ::  (	.EOT_SETUP = $1,
				if ($1 == 1) {
					.EVENTMASK_VALUE |= 0x00020,
					.MASK = .EVENTMASK_VALUE,
					"ok" }
				else {
					.EVENTMASK_VALUE &= 0xFFDF,
					.MASK = .EVENTMASK_VALUE,
					"ok" }
			   )
      }
	inst STPOW_SETUP :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Setup Packet Overwrite (STPOW) "
        prop JSName :: "usbEventStpow"
        prop NoGen :: 1
        prop Visible :: 1
	  prop Writable :: (endptObj.usb_Support)
        prop TabName :: "USB Events"
	  prop Set ::  (	.STPOW_SETUP = $1,
				if ($1 == 1) {
					.EVENTMASK_VALUE |= 0x00040,
					.MASK = .EVENTMASK_VALUE,
					"ok" }
				else {
					.EVENTMASK_VALUE &= 0xFFBF,
					.MASK = .EVENTMASK_VALUE,
					"ok" }
			   )
      }
	inst PSOF_SETUP :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Pre-Start Of Frame (PSOF) "
        prop JSName :: "usbEventPsof"
        prop NoGen :: 1
        prop Visible :: 1
	  prop Writable :: (endptObj.usb_Support)
        prop TabName :: "USB Events"
	  prop Set ::  (	.PSOF_SETUP = $1,
				if ($1 == 1) {
					.EVENTMASK_VALUE |= 0x00080,
					.MASK = .EVENTMASK_VALUE,
                              .genPsof += 1,
					"ok" }
				else {
					.EVENTMASK_VALUE &= 0xFF7F,
					.MASK = .EVENTMASK_VALUE,
                              .genPsof -= 1,
                              if (.genPsof == 0) {
                                  .psofTimer = 0
                              },
					"ok" }
			   )
      }
	inst HINT_SETUP :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Host Interrupt (HINT) "
        prop JSName :: "usbEventHint"
        prop NoGen :: 1
        prop Visible :: 1
	  prop Writable :: (endptObj.usb_Support)
        prop TabName :: "USB Events"
	  prop Set ::  (	.HINT_SETUP = $1,
				if ($1 == 1) {
					.EVENTMASK_VALUE |= 0x00100,
					.MASK = .EVENTMASK_VALUE,
					"ok" }
				else {
					.EVENTMASK_VALUE &= 0xFEFF,
					.MASK = .EVENTMASK_VALUE,
					"ok" }
			   )
      }
	inst HERR_SETUP :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Host Error (HERR) "
        prop JSName :: "usbEventHerr"
        prop NoGen :: 1
        prop Visible :: 1
	  prop Writable :: (endptObj.usb_Support)
        prop TabName :: "USB Events"
	  prop Set ::  (	.HERR_SETUP = $1,
				if ($1 == 1) {
					.EVENTMASK_VALUE |= 0x00200,
					.MASK = .EVENTMASK_VALUE,
					"ok" }
				else {
					.EVENTMASK_VALUE &= 0xFDFF,
					.MASK = .EVENTMASK_VALUE,
					"ok" }
			   )
      }
	
	
	inst NUM_VALUE :: .NUM_VALUE_update() {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Endpoint Number "
        prop Visible :: 0
        prop Writable :: (endptObj.usb_Support)
        prop NoGen :: 1
        prop TabName :: "Endpoints Setting"
	  prop cGen :: 1
	  prop cStruct :: 1
	  prop cType :: "Uint16"
	  prop Set ::  (	.NUM_VALUE = $1,
				"ok"
			   )
    	}
	prop NUM_VALUE_update :: (
                   (.NUM_SETUP == "Endpoint 0 - OUT") ? "USB_OUT_EP0" :
                   (.NUM_SETUP == "Endpoint 1 - OUT") ? "USB_OUT_EP1" :
		       (.NUM_SETUP == "Endpoint 2 - OUT") ? "USB_OUT_EP2" :
		       (.NUM_SETUP == "Endpoint 3 - OUT") ? "USB_OUT_EP3" :
		       (.NUM_SETUP == "Endpoint 4 - OUT") ? "USB_OUT_EP4" :
		       (.NUM_SETUP == "Endpoint 5 - OUT") ? "USB_OUT_EP5" :
		       (.NUM_SETUP == "Endpoint 6 - OUT") ? "USB_OUT_EP6" :
		       (.NUM_SETUP == "Endpoint 7 - OUT") ? "USB_OUT_EP7" :
		       (.NUM_SETUP == "Endpoint 0 - IN") ? "USB_IN_EP0" :
		       (.NUM_SETUP == "Endpoint 1 - IN") ? "USB_IN_EP1" :
		       (.NUM_SETUP == "Endpoint 2 - IN") ? "USB_IN_EP2" :
		       (.NUM_SETUP == "Endpoint 3 - IN") ? "USB_IN_EP3" :
		       (.NUM_SETUP == "Endpoint 4 - IN") ? "USB_IN_EP4" :
		       (.NUM_SETUP == "Endpoint 5 - IN") ? "USB_IN_EP5" :
		       (.NUM_SETUP == "Endpoint 6 - IN") ? "USB_IN_EP6" :
		       "USB_IN_EP7"
    )
	inst TRANSFER_VALUE :: .TRANSFER_VALUE_update() {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Transfer type value "
        prop Visible :: 0
        prop Writable :: (endptObj.usb_Support)
        prop NoGen :: 1
        prop TabName :: "Endpoints Setting"
	  prop cGen :: 1
	  prop cStruct :: 1
	  prop cType :: "Uint16"
	  prop Set ::  (	.TRANSFER_VALUE = $1,
				"ok"
			   )
    	}
	prop TRANSFER_VALUE_update :: (
			 ((.NUM_SETUP == "Endpoint 0 - OUT") || (.NUM_SETUP == "Endpoint 0 - IN")) ? "USB_CTRL" :
                   (.TRANSFER_SETUP == "Bulk") ? "USB_BULK" :
		       (.TRANSFER_SETUP == "Interrupt") ? "USB_INTR" :
		       (.TRANSFER_SETUP == "Isochronous") ? "USB_ISO" :
		       "USB_HPORT"
    )
	inst PKTSIZE_VALUE :: 64 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Maximum Packet Size Supported by EP "
        prop Visible :: 0
        prop Writable :: (endptObj.usb_Support)
        prop NoGen :: 1
        prop TabName :: "Endpoints Setting"
	  prop cGen :: 1
	  prop cStruct :: 1
	  prop cType :: "Uint16"
	  prop Set ::  (	.PKTSIZE_VALUE = $1,
				"ok" 
			   )
    	}
	global MAX_PKTSIZE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Total Packet Size supported by USB "
        prop Visible :: 0
        prop Writable :: (endptObj.usb_Support)
        prop NoGen :: 1
	  prop cGen :: 0
	  prop cType :: "Uint16"
    	}
	inst LAST_PKTSIZE :: 8  {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Last Packet Size value selected by user "
        prop Visible :: 0
        prop Writable :: (endptObj.usb_Support)
        prop NoGen :: 1
        prop TabName :: "Endpoints Setting"
	  prop cGen :: 0
	  prop cType :: "Uint16"
    	}
	inst EVENTMASK_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Event Mask "
        prop Visible :: 0
        prop Writable :: (endptObj.usb_Support)
        prop NoGen :: 1
	  prop cGen :: 1
	  prop cStruct :: 1
	  prop cType :: "Uint16"
	} 
	inst FXN_VALUE :: .FXN_SETUP {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Pointer to USB event ISR "
        prop Visible :: 0
        prop Writable :: (endptObj.usb_Support)
        prop NoGen :: 1
        prop TabName :: "Endpoints Setting"
	  prop cGen :: 1
	  prop cStruct :: 1
	  prop cType :: "Uint16"
	  prop Set ::  (	.FXN_VALUE = $1,
				"ok"
			   )
    	}
	inst FLAGS_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Data Flags "
        prop Visible :: 0
        prop Writable :: (endptObj.usb_Support)
        prop NoGen :: 1
	  prop cGen :: 1
	  prop cStruct :: 1
	  prop cType :: "Uint16"
    	}
	inst STATUS_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Status "
        prop Visible :: 0
        prop Writable :: (endptObj.usb_Support)
        prop NoGen :: 1
	  prop cGen :: 1
	  prop cStruct :: 1
	  prop cType :: "Uint16"
    	}
	inst ENDPTADDR_VALUE :: .ENDPTADDR_VALUE_update() {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Endpoint descriptor reg block start addr "
        prop Visible :: 0
        prop Writable :: (endptObj.usb_Support)
        prop NoGen :: 1
	  prop cGen :: 1
	  prop cStruct :: 1
	  prop cType :: "Uint16"
    	}
	prop ENDPTADDR_VALUE_update :: (
                   (.NUM_SETUP == "Endpoint 0 - OUT") ? 0x6782 :
                   (.NUM_SETUP == "Endpoint 1 - OUT") ? 0x6708 :
		       (.NUM_SETUP == "Endpoint 2 - OUT") ? 0x6710 :
		       (.NUM_SETUP == "Endpoint 3 - OUT") ? 0x6718 :
		       (.NUM_SETUP == "Endpoint 4 - OUT") ? 0x6720 :
		       (.NUM_SETUP == "Endpoint 5 - OUT") ? 0x6728 :
		       (.NUM_SETUP == "Endpoint 6 - OUT") ? 0x6730 :
		       (.NUM_SETUP == "Endpoint 7 - OUT") ? 0x6738 :
		       (.NUM_SETUP == "Endpoint 0 - IN") ? 0x6780 :
		       (.NUM_SETUP == "Endpoint 1 - IN") ? 0x6748 :
		       (.NUM_SETUP == "Endpoint 2 - IN") ? 0x6750 :
		       (.NUM_SETUP == "Endpoint 3 - IN") ? 0x6758 :
		       (.NUM_SETUP == "Endpoint 4 - IN") ? 0x6760 :
		       (.NUM_SETUP == "Endpoint 5 - IN") ? 0x6768 :
		       (.NUM_SETUP == "Endpoint 6 - IN") ? 0x6770 :
		       0x6778
    )
	inst DMAADDR_VALUE :: .DMAADDR_VALUE_update() {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "DMA reg block start addr "
        prop Visible :: 0
        prop Writable :: (endptObj.usb_Support)
        prop NoGen :: 1
	  prop cGen :: 1
	  prop cStruct :: 1
	  prop cType :: "Uint16"
    	}
	prop DMAADDR_VALUE_update :: (
                   (.NUM_SETUP == "Endpoint 0 - OUT") ? 0x6680 :
                   (.NUM_SETUP == "Endpoint 1 - OUT") ? 0x5808 :
		       (.NUM_SETUP == "Endpoint 2 - OUT") ? 0x5810 :
		       (.NUM_SETUP == "Endpoint 3 - OUT") ? 0x5818 :
		       (.NUM_SETUP == "Endpoint 4 - OUT") ? 0x5820 :
		       (.NUM_SETUP == "Endpoint 5 - OUT") ? 0x5828 :
		       (.NUM_SETUP == "Endpoint 6 - OUT") ? 0x5830 :
		       (.NUM_SETUP == "Endpoint 7 - OUT") ? 0x5838 :
		       (.NUM_SETUP == "Endpoint 0 - IN") ? 0x66C0 :
		       (.NUM_SETUP == "Endpoint 1 - IN") ? 0x5848 :
		       (.NUM_SETUP == "Endpoint 2 - IN") ? 0x5850 :
		       (.NUM_SETUP == "Endpoint 3 - IN") ? 0x5858 :
		       (.NUM_SETUP == "Endpoint 4 - IN") ? 0x5860 :
		       (.NUM_SETUP == "Endpoint 5 - IN") ? 0x5868 :
		       (.NUM_SETUP == "Endpoint 6 - IN") ? 0x5870 :
		       0x5878
    )
	inst TOTBYTCNT_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Total byte count "
        prop Visible :: 0
        prop Writable :: (endptObj.usb_Support)
        prop NoGen :: 1
	  prop cGen :: 1
	  prop cStruct :: 1
	  prop cType :: "Uint16"
    	}
	inst BYTINTHISSEG_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Number of bytes in the active node of the linked list "
        prop Visible :: 0
        prop Writable :: (endptObj.usb_Support)
        prop NoGen :: 1
	  prop cGen :: 1
	  prop cStruct :: 1
	  prop cType :: "Uint16"
    	}
	inst XFERBYTCNT_VALUE :: "NULL" {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Pointer to store the number of bytes moved in (out) "
        prop Visible :: 0
        prop Writable :: (endptObj.usb_Support)
        prop NoGen :: 1
	  prop cGen :: 1
	  prop cStruct :: 1
	  prop cType :: "Uint16"
    	}
	inst PBUFFER_VALUE :: "NULL" {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Active data buffer pointer "
        prop Visible :: 0
        prop Writable :: (endptObj.usb_Support)
        prop NoGen :: 1
	  prop cGen :: 1
	  prop cStruct :: 1
	  prop cType :: "Uint16"
    	}
	inst PNEXTBUFFER_VALUE :: "NULL" {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Pointer to NEXT Buffer "
        prop Visible :: 0
        prop Writable :: (endptObj.usb_Support)
        prop NoGen :: 1
	  prop cGen :: 1
	  prop cStruct :: 1
	  prop cType :: "Uint16"
    	}
	inst EVENTFLAG_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "Event Flag "
        prop Visible :: 0
        prop Writable :: (endptObj.usb_Support)
        prop NoGen :: 1
	  prop cGen :: 1
	  prop cStruct :: 1
	  prop cType :: "Uint16"
	}
	
	prop externStr :: (.FXN_VALUE != "USB_EvISR_NONE") ? "extern void " : ""
	prop fxnStr :: (.FXN_VALUE != "USB_EvISR_NONE") ? .FXN_VALUE : ""
	prop termStr :: (.FXN_VALUE != "USB_EvISR_NONE") ? "();\n" : ""
	prop cGenCInst :: (
        "%1S%2S%3S\0, externStr,fxnStr,termStr"
	)
	prop nameArray :: (endptObj.usb_Support) ? usbRes.CFGARRAY_NAME_VALUE : ""
	prop index :: (endptObj.usb_Support) ? "[_cslUsbIndex_++] = &" : ""
	prop array :: (endptObj.usb_Support) ? self : ""
	prop term :: (endptObj.usb_Support) ? ";" : ""
	prop cGenFxnPreInst :: (       
            	"%5t%1s%2s%3s%4s\n%0t\0,nameArray,index,array,term"
    )
}
type usbRes {
	isa ObjectMgr
	prop name :: "USBRes"
	prop Label :: "USB Resource Manager"
	prop JSName :: "USBRES"
	prop GlobalHelpTopic :: 1202
	prop InstanceHelpTopic :: 1203
	prop GlobalIcon :: 191
	prop InstanceIcon :: 192
	prop GlobalPropertyPage :: "{1C8F8861-E550-11d4-9745-00B0D0524DFE}"
      prop InstancePropertyPage :: "{1C8F8862-E550-11d4-9745-00B0D0524DFE}"
    	prop Vendor :: "vendor1"
    	prop Version :: "1.00.00"
	prop IsContainedIn :: USBFOLDER
	prop maxObjs :: ( 1 )
	prop cHeaderName ::  ((usbRes.c55usb == 1) && (endptObj.usb_Support)) ? "csl_usb.h" : ""
	prop NoGen :: 1
	prop cGen :: 1
	prop cConfigName :: "USB_init"
	global c55usb :: 0 {
          prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Label :: "C55x USB configured "
	    prop Visible :: 0
	    prop Writable :: 1
	    prop NoGen :: 1
	    prop cGen :: 0
      }
	inst USB_ENABLE :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable USB Configuration "
	  prop JSName :: "usbCfgEnable"
	  prop Visible :: 1
	  prop Writable :: (endptObj.usb_Support)
	  prop NoGen :: 1
	  prop Set :: (	.USB_ENABLE = $1,
                        if ($1 == 1) {
                            .c55usb = 1
                        }
                        else {
                            .c55usb = 0
                        },
				"ok"
			  )
    	}
	inst cConfigGen ::= (.USB_ENABLE == 1) {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
	  prop Writable :: 1
      }
	inst CFGARRAY_SETUP :: "cfgArray" {
	  prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Name of configuration array "
	  prop JSName :: "usbCfgName"
        prop Visible :: 1
        prop Writable :: (endptObj.usb_Support)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "General"
	  prop Set ::  (	  .CFGARRAY_SETUP = $1,
                          .cConfigArg1 = $1,
                          usbRes.CFGARRAY_NAME_VALUE = $1,
				  "ok"
			   )
	}
      global CFGARRAY_NAME_VALUE :: "cfgArray"{
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
        prop cGen :: 0
      }
	prop epStr :: ((endptObj.gNumOf > 0) && (endptObj.usb_Support)) ? "\nUSB_EpObj* " : ""
	prop cfgArrayStr :: ((endptObj.gNumOf > 0) && (endptObj.usb_Support)) ? usbRes.CFGARRAY_NAME_VALUE : ""
	prop range :: ((endptObj.gNumOf > 0) && (endptObj.usb_Support)) ? "[N+1]" : ""
	prop trmStr :: ((endptObj.gNumOf > 0) && (endptObj.usb_Support)) ? ";\n" : ""
	prop decl :: ((endptObj.gNumOf > 0) && (endptObj.usb_Support)) ? "\nstatic int _cslUsbIndex_ = 0;\n" : ""
	prop cGenCInst :: (
		   "%1S%2S%3S%4S%5S\0, epStr,cfgArrayStr,range,trmStr,decl"
	)
	prop defStr :: (endptObj.usb_Support) ? "#define N     %2d" : ""
	prop nrCfg :: (endptObj.usb_Support) ? endptObj.gNumOf : ""
	prop cGenCPrologue :: (
        ((endptObj.usb_Support)&&(endptObj.gNumOf > 0)) ? "%1S\n\n\0, defStr,nrCfg" : ""
	)
	inst cConfigArg0 :: "USB0" {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Config argument 0 "
        prop Visible :: 0
	  prop Writable :: (endptObj.usb_Support)
      }
	inst cConfigArg1 :: .CFGARRAY_SETUP {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Config argument 1 "
        prop Visible :: 0
	  prop Writable :: (endptObj.usb_Support)
      }
	inst cConfigArg2 :: endptObj.psofTimer {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Config argument 3 "
        prop Visible :: 0
	  prop Writable :: (endptObj.usb_Support)
      }
	prop arr :: ((usbRes.c55usb) && (endptObj.usb_Support)) ? usbRes.CFGARRAY_NAME_VALUE : " "
	prop idx :: ((usbRes.c55usb) && (endptObj.usb_Support)) ? "[_cslUsbIndex_] = NULL; " : " "
	prop funcStr :: ((usbRes.c55usb) && (endptObj.usb_Support)) ? "\n\nUSB_setAPIVectorAddress();\n" : " "
	prop pllStr :: ((usbRes.c55usb) && (endptObj.usb_Support)) ? "USB_initPLL(%5S, 48, 0);\n" : " "
	prop pllInitStr :: ((usbRes.c55usb) && (endptObj.usb_Support)) ? endptObj.pllInit_VAL : " "
	prop cGenFxnPreInst :: (  
            "%5t%1s%2s%3S%4S\n%0t\0,arr,idx,funcStr,pllStr,pllInitStr"
    )
}
object USB0 :: usbRes {
    param iComment :: .iDelMsg
    param iIsUsed :: 1
    param iDelUser :: "usbRes"
    param iDelMsg :: ("USB ")
}
type WDTIMERFOLDER {
    
    prop Label :: "WDTIMER - Watchdog Timer Device"
    prop GlobalIcon :: 193
    prop GlobalPropertyPage :: "{B916FB95-52A5-11d4-967C-0750048381B7}"
    prop GlobalHelpTopic :: 1300
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}
type wdtimCfg {
	isa ObjectMgr
	prop name :: "WDTIM"
	prop Label :: "Watchdog Timer Configuration Manager"
        prop JSName :: "WDTIM"
	prop GlobalHelpTopic :: 1301
	prop InstanceHelpTopic :: 1301
	
	prop IsContainedIn :: WDTIMERFOLDER
	prop GlobalIcon :: 193
	prop InstanceIcon :: 194
	prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-10105A98CA0B}"
        prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-1000C070F3E9}"
    	prop Vendor :: "vendor1"
    	prop Version :: "1.00.00"
	
      prop wdtim_Support :: (  (GBL.CHIPTYPE == "5509") ||
                               (GBL.CHIPTYPE == "5509A") ||
                               (GBL.CHIPTYPE == "5509PG1_0") ||
                               (GBL.CHIPTYPE == "5509PG2_0")
      )
	prop cGen :: 1
    	prop cStruct :: (_wdtim_Support)
    	prop cStructType :: "WDTIM_Config"
	prop cHeaderName :: .gNumOf > 0 ? "csl_wdtim.h" : ""
	prop NoGen :: 1
	inst TDDR_SETUP :: 0 {
	  prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Timer Divide-Down Ratio (TDDR) "
        prop Visible :: 1
        prop JSName :: "wdtimTcrTddrSetup"
        prop Writable :: ((wdtimCfg.wdtim_Support) && (.PREMD_SETUP == "Direct Mode"))
        prop NoGen :: 1
        prop TabName :: "Counter Control"
	  prop Set ::  (	if (($1 >= 0) && ($1 < 16)) {
				  .TDDR_SETUP = $1,
				  .TCR_VALUE = .TCR_VALUE_update(),
				  "ok"
				}
				else {"Number Out of Bounds"}
			   )
	}
	prop TDDR_TCR :: (.TDDR_SETUP)
      
	inst FREE_SOFT_SETUP :: "Stop Immediately" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum :: "Stop Immediately,Stop when counter = 0,Do Not Stop"
        prop Label :: "Breakpt. Emulation Behavior "
        prop JSName :: "wdtimTcrFreeSoftSetup"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "General"
	  prop Set ::  (	  .FREE_SOFT_SETUP = $1,
				  .TCR_VALUE = .TCR_VALUE_update(),
				  "ok"
			   )
	}
	prop FREE_SOFT_TCR :: (
		(.FREE_SOFT_SETUP == "Stop when counter = 0") ? 0x0800 :
            (.FREE_SOFT_SETUP == "Stop Immediately") ? 0x0000 :
            0x0400
	)
	prop TCR_VALUE_update :: (
		   .TDDR_TCR
		|  .FREE_SOFT_TCR
	)
	prop TCR_SETUP_update :: (
		.FREE_SOFT_SETUP = ($a = ($1 & 0x0C00),
                               ($a == 0x0000) ? "Stop Immediately" :
                               ($a == 0x0800) ? "Stop when counter = 0" :
                               "Do Not Stop"),
		.TDDR_SETUP = ($1 & 0x000f)
	)
	inst PRD_SETUP :: 0 {
	  prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Period Value "
        prop JSName :: "wdtimPrdSetup"
        prop Visible :: 1
        prop Writable :: (wdtimCfg.wdtim_Support)
        prop NoGen :: 1
        prop TabName :: "Counter Control"
	  prop Set ::  (	if (($1 >= 0) && ($1 < 65536)) {
				  .PRD_SETUP = $1,
				  .PRD_VALUE = .PRD_VALUE_update(),
				  "ok"
				}
				else {"Value out of Bounds"}
			   )
	}
	prop PRD_VALUE_update :: (.PRD_SETUP)
	
	prop PRD_SETUP_update :: (
		.PRD_SETUP = .PRD_VALUE
	)
	inst PREMD_SETUP :: "Direct Mode" {
	  prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum :: "Direct Mode,Indirect Mode"
        prop Label :: "Prescalar Mode "
        prop JSName :: "wdtimTcr2PremdSetup"
        prop Visible :: 1
        prop Writable :: (wdtimCfg.wdtim_Support)
        prop NoGen :: 1
        prop TabName :: "Counter Control"
	  prop Set ::  (
                          .PREMD_SETUP = $1,
				  .TCR2_VALUE = .TCR2_VALUE_update(),
				  "ok"
                     )
	}
	prop PREMD_TCR2 :: (
            (.PREMD_SETUP == "Indirect Mode") ? 0x1000 : 0x0000	
      )
	prop TCR2_VALUE_update :: (.PREMD_TCR2)
	inst PRESC_SETUP :: 0x0001 {
	  prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	  prop Enum :: "0x0001,0x0003,0x0007,0x000F,0x001F,0x003F,0x007F,0x00FF,0x01FF,0x03FF,0x07FF,0x0FFF,0x1FFF,0x3FFF,0x7FFF,0xFFFF"
        prop JSName :: "wdtimTcrPrescSetup"
        prop Label :: "Prescalar Value "
        prop Visible :: 1
        prop Writable :: ((wdtimCfg.wdtim_Support) && (.PREMD_SETUP == "Indirect Mode"))
        prop NoGen :: 1
        prop TabName :: "Counter Control"
	  prop Set ::  (
                          .PRESC_SETUP = $1,
                          .TDDR_SETUP_update($1),
				  .TCR_VALUE = .TCR_VALUE_update(),
				  "ok"
                     )
	}
	prop PRESC_SETUP_update :: (
                .PRESC_SETUP = (
                   ($1 == 0x0000) ? 0x0001 :
                   ($1 == 0x0001) ? 0x0003 :
		       ($1 == 0x0002) ? 0x0007 :
		       ($1 == 0x0003) ? 0x000F :
		       ($1 == 0x0004) ? 0x001F :
		       ($1 == 0x0005) ? 0x003F :
		       ($1 == 0x0006) ? 0x007F :
		       ($1 == 0x0007) ? 0x00FF :
		       ($1 == 0x0008) ? 0x01FF :
		       ($1 == 0x0009) ? 0x03FF :
		       ($1 == 0x000A) ? 0x07FF :
		       ($1 == 0x000B) ? 0x0FFF :
		       ($1 == 0x000C) ? 0x1FFF :
		       ($1 == 0x000D) ? 0x3FFF :
		       ($1 == 0x000E) ? 0x7FFF :
		       0xFFFF)
    )
	prop TDDR_SETUP_update :: (
               .TDDR_SETUP = (
                   ($1 == 0x0001) ? 0x0000 :
                   ($1 == 0x0003) ? 0x0001 :
		       ($1 == 0x0007) ? 0x0002 :
		       ($1 == 0x000F) ? 0x0003 :
		       ($1 == 0x001F) ? 0x0004 :
		       ($1 == 0x003F) ? 0x0005 :
		       ($1 == 0x007F) ? 0x0006 :
		       ($1 == 0x00FF) ? 0x0007 :
		       ($1 == 0x01FF) ? 0x0008 :
		       ($1 == 0x03FF) ? 0x0009 :
		       ($1 == 0x07FF) ? 0x000A :
		       ($1 == 0x0FFF) ? 0x000B :
		       ($1 == 0x1FFF) ? 0x000C :
		       ($1 == 0x3FFF) ? 0x000D :
		       ($1 == 0x7FFF) ? 0x000E :
		       0x000F)
      )
	
	inst TIMER_man :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Set Manually "
	  prop Visible :: 0
	  prop Writable :: (wdtimCfg.wdtim_Support)
	  prop NoGen :: 1
	  prop TabName :: "Advanced"
      }
	inst PRD_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "WD Timer Period Register (WDPRD)"
        prop JSName :: "wdtimWdprdAdv"
        prop Visible :: 1
        prop Writable :: (wdtimCfg.wdtim_Support)
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: (wdtimCfg.wdtim_Support) 
	  prop cType :: "Uint16"
	  prop Set ::  (	.PRD_VALUE = $1,
				.PRD_SETUP_update($1),
				"ok"
			   )
    	}
	inst TCR_VALUE :: .TCR_VALUE_update() {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "WD Timer Control Register (WDTCR)"
        prop JSName :: "wdtimWdtcrAdv"
        prop Visible :: 1
        prop Writable :: (wdtimCfg.wdtim_Support)
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: (wdtimCfg.wdtim_Support)
	  prop cType :: "Uint16"
	  prop Set ::  (	.TCR_VALUE = ($1 & 0x0FFF),
				.TCR_SETUP_update($1),
				"ok"
			   )
    	}
	
	inst TCR2_VALUE :: 0 {
	  prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	  prop Format :: "0x%04x"
        prop Label :: "WD Timer Secondary Control Register (WDTCR2) "
        prop JSName :: "wdtimWdtcr2Adv"
        prop Visible :: 1
        prop Writable :: (wdtimCfg.wdtim_Support)
        prop NoGen :: 1
        prop TabName :: "Advanced"
	  prop cGen :: (wdtimCfg.wdtim_Support)
	  prop cType :: "Uint16"
	  prop Set ::  (	.TCR2_VALUE = ($1 & 0x1000),
                        .TCR2_SETUP_update($1),
				"ok"
			   )
    	}
	prop TCR2_SETUP_update :: (
		.PREMD_SETUP = ($1 & 0x1000) ? "Indirect Mode" : "Direct Mode"
	)
	
}
type hWDTIM {
	isa ObjectMgr
	prop name :: "hWDTIM"
	prop Label :: "Watchdog Timer Resource Manager"
        prop JSName :: "HWDTIM"
	prop GlobalHelpTopic :: 1302
	prop InstanceHelpTopic :: 1303
	prop GlobalIcon :: 193
	prop InstanceIcon :: 194
	prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-10105A98CA0B}"
      prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-1000C070F3E9}"
    	prop Vendor :: "vendor1"
    	prop Version :: "1.00.00"
	prop IsContainedIn :: WDTIMERFOLDER
	
	prop maxObjs :: (
		(wdtimCfg.wdtim_Support) ? 1 :
		0
	)
	prop NoGen :: 1
	prop cGen :: (wdtimCfg.wdtim_Support)
	prop cHeaderName :: .c55wdtimer == 1 ? "csl_wdtim.h" : ""
	prop cConfigName :: "WDTIM_config"
	global c55wdtimer :: 0 {
          prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	    prop Label :: "C55x Watchdog Timer opened "
	    prop Visible :: 0
	    prop Writable :: 1
	    prop NoGen :: 1
	    prop cGen :: 0
      }
    	inst PINIT_ENABLE :: 0 {
	  prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	  prop Label :: "Enable Configuration of Watchdog Timer "
          prop JSName :: "wdtimEnablePreInit"
	  prop Visible :: 1
	  prop Writable :: (wdtimCfg.wdtim_Support) 
	  prop NoGen :: 1
	  prop Set :: (	
                         .PINIT_ENABLE = $1,
                         if ($1 == 1) {
                             .c55wdtimer = 1
                         }
                         else {
                             .c55wdtimer = 0
                         },
                         "ok"
			  )
      }
	inst cConfigGen ::= ((.PINIT_ENABLE == 1) && (.cConfigArg0 != WDTIM_NOTHING)) {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
	  prop Writable :: 1
      }
     	inst cConfigArg0 :: WDTIM_NOTHING {
	  prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	  prop MemberType :: wdtimCfg
	  prop Label :: "Pre-initialize"
          prop JSName :: "wdtimPreInit"
	  prop Visible :: 1
	  prop Writable :: (.PINIT_ENABLE) && (wdtimCfg.wdtim_Support)
	  prop NoGen :: 0
	  prop cPreVal :: "&"
    	}
	prop comment :: (wdtimCfg.wdtim_Support) ? "/* You must use WDTIM_start() in your main code to start the WDTIM. */"
 						: ""
	prop cGenFxnEpilogue :: (       
            "%5t\n%1s\n\n%0t\0,comment"
	)
}
object WDTIM_NOTHING :: wdtimCfg {
    param iIsUsed :: 0
}
object WDTim0 :: hWDTIM {
	param iIsUsed :: 1
	param iDelUser :: "hWDTIM"
	param iDelMsg :: ("Watchdog Timer")
}
