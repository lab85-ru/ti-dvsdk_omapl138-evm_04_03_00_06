C6000 C/C++ CODE GENERATION TOOLS
6.1.14 March 2010
Defect History

------------------------------------------------------------------------------
Table of Contents
------------------------------------------------------------------------------
1.  6.1.14 Fixed Defects
2.  6.1.13 Fixed Defects
3.  6.1.12 Fixed Defects
4.  6.1.11 Fixed Defects
5.  6.1.10 Fixed Defects
6.  6.1.9 Fixed Defects
7.  6.1.8 Fixed Defects
8.  6.1.7 Fixed Defects
9.  6.1.6 Fixed Defects
10. 6.1.5 Fixed Defects
11. 6.1.4 Fixed Defects
12. 6.1.3 Fixed Defects
13. 6.1.2 Fixed Defects
14. 6.1.1 Fixed Defects
15. 6.1.0 Fixed Defects
16. 6.1.0B2 Fixed Defects
17. 6.1.0B1 Fixed Defects
18. Current Known Issues


------------------------------------------------------------------------------
1. 6.1.14 Fixed Defects
------------------------------------------------------------------------------

------------------------------------------------------------------------------
FIXED  SDSCM00008363
------------------------------------------------------------------------------

Summary            : Link-time errors with assert pragma

Fixed in           : 6.1.14
Severity           : S3 - Minor
Affected Component : Linker

Description: 
The issue is how the compiler handles the assert pragma. The pragma is 
considered an intrinsic by the compiler. It uses the assertion
expression to obtain information in order to perform optimization. Before 
the intrinsic was turned into a call to _abort_msg, the optimizer consider
the function "dead" and removed the definition of it. This also caused
the fflush() function to be removed as well. When the linker tried to
bring fflush() back into the link, it also had to bring _doflush() 
because they are defined in the same file. This caused the redefinition
error.	The compiler now will not delete the _abort_msg function.

------------------------------------------------------------------------------
FIXED  SDSCM00031285
------------------------------------------------------------------------------

Summary            : Change in COFF linker handling of subsections in partial
		     link

Fixed in           : 6.1.14
Severity           : S2 - Major
Affected Component : COFF Linker

Description: 
The bug here is that, with the current	linker, when doing a partial
link if subsection matches a non-identical output section name (that is
.textfoo matches .text), the subsection is included in that output
section. A subsection, during a partial link should be passed through
into it's own section, and that is not happening.

------------------------------------------------------------------------------
FIXED  SDSCM00033960
------------------------------------------------------------------------------

Summary            : The linker is generating an extra $fill000 section

Fixed in           : 6.1.14
Severity           : S2 - Major
Affected Component : COFF Linker

Description: 
Linker fill sections were being created to fill holes in a group, even
though the filling was not explicitly requested. The linker should only
fill between sections in a group when explicitly directed/requested.
This is now fixed.

------------------------------------------------------------------------------
FIXED  SDSCM00034180
------------------------------------------------------------------------------

Summary            : The compiler generated incorrect code with a MPY32 and SHR2
		     instruction

Fixed in           : 6.1.14
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
The compiler generated incorrect code with a MPY32 and SHR2
instruction.  In the related ASM code below, we can find that B6 will
be written twice.  One instruction is MPY32, and another instruction is
SHR.


	|| [ B0]   MPY32   .M2X    A20,B20,B6 

	   [ B0]   SUB	   .L2	   B31,B16,B4	     ; |140| 

	   [ B2]   ADD	   .L1X    8,B5,A9 
	|| [ B0]   SUB	   .L2	   B4,1,B0	     ; |140| 
	|| [ B1]   MPYLI   .M2	   B11,B25,B5B4 

	   [!A0]   SHR	   .S2	   B26,2,B6	     ; |167|

------------------------------------------------------------------------------
FIXED  SDSCM00034181
------------------------------------------------------------------------------

Summary            : The optimizer crashes when compiling with -o2 or higher in
		     combination with -mf3 or higher

Fixed in           : 6.1.14
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
A loop structured something like

  for (x = 0;  x < N;  x++)
  {
    y = f();
    if (x == 1) y = g();
    else if (P) ... y ...;
    else	...;
  }

may, if the loop unrolls, cause the optimiser to abort.  The key detail
is that a section of the code only applies to a single iteration of the
loop, and some uses of a variable are within that section and some 
aren't.  When the loop is unrolled, some instances of that section will
be deleted, and the optimiser can fail to properly track the variable's
uses.

------------------------------------------------------------------------------
FIXED  SDSCM00034204
------------------------------------------------------------------------------

Summary            : Codegen register-allocation-failure abort

Fixed in           : 6.1.14
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
This bug causes the compiler to quit with an error message.  This
compiler abort may be seen in a 2 level nested loop.

------------------------------------------------------------------------------
FIXED  SDSCM00034568
------------------------------------------------------------------------------

Summary            : Compiler issues errors with linear asm file

Fixed in           : 6.1.14
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
The linear assembler had an issue passing correct instruction modeling 
information to the code generator for SADD instructions having a
constant operand.  It would model the SADD instruction as having only 
register operands.  This could lead to the code generator to resource 
schedule the instruction using the S unit. SADD with constant operand 
can only be scheduled on L unit.  This would manifest as an assembler error. 

------------------------------------------------------------------------------
FIXED  SDSCM00034576
------------------------------------------------------------------------------

Summary            : _amem2 internal error

Fixed in           : 6.1.14
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
Use of _amem2 intrinsic causes a codegen crash

>> sourcefile.c, line 65 INTERNAL ERROR no match for ASG

------------------------------------------------------------------------------
FIXED  SDSCM00034702
------------------------------------------------------------------------------

Summary            : "Optimizer terminated abnormally" error with Incomplete
		     array type

Fixed in           : 6.1.14
Severity           : S3 - Minor
Affected Component : C/C++ Compiler (cl)

Description: 
The optimiser may abort when presented with a variable with an
incomplete array type (ie, an array with no dimensions, "extern int x[]"), 
if it is able to vectorise an access involving that variable but some internal 
bookkeeping messes up.

------------------------------------------------------------------------------
FIXED  SDSCM00034747
------------------------------------------------------------------------------

Summary            : 6 hour compile time with optimization, only 20 minute
		     project build without optimization

Fixed in           : 6.1.14
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
A small simple loop with a recurrence on an intrinsic, such as

  for (k ...) { x = 31 - _lmbd(1, y);  y = _clr(y, x, x); }

may lead to excessive compilation time if the loop has a known trip
count that is small enough to allow it to unroll completely, and the loop 
occurs more than once within otherwise straight-line code (as when 
inlined as the body of a function).  The key aspects are the recurrence, 
which means that the unrolled loop will be one very long assignment;
the intrinsic, which means the assignment won't simplify;  the 
multiple occurrences, which triggers the optimiser's attempt to pair up
intrinsic calls in separate statements;  and a trip count small enough
to allow complete unrolling but large enough that there are a lot of pairs
to check.

------------------------------------------------------------------------------
FIXED  SDSCM00034921
------------------------------------------------------------------------------

Summary            : Malformed template member name in stdvector template class
		     - extra '>' character

Fixed in           : 6.1.14
Severity           : S2 - Major
Affected Component : COFF Linker

Description: 
In the debugger, both the DW_AT_name and DW_AT_TI_symbol_name
attributes are used to provide the user with the mangled and demangled
name of a symbol.The problem here is that the DW_AT_name DWARF
attribute associated with the allocator member's DW_TAG_member tag has
the wrong name.  The name is specified as "allocator<int>>" which is
incorrect.

------------------------------------------------------------------------------
FIXED  SDSCM00034926
------------------------------------------------------------------------------

Summary            : CGT performance degradation seen in 6.1.11 over 6.0.8

Fixed in           : 6.1.14
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
For-loops with an unsigned index variable, a less-than termination
test, and an increment of 1 can be optimised more efficiently than we had
been doing.	This patch allows the greater efficiency.

------------------------------------------------------------------------------
FIXED  SDSCM00035153
------------------------------------------------------------------------------

Summary            : CGT Optimizer terminated abnormally

Fixed in           : 6.1.14
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
The compiler may abort if given a function call with an argument that
is a struct passed by value, if the struct is small enough to fit into an 
int.

------------------------------------------------------------------------------
FIXED  SDSCM00035155
------------------------------------------------------------------------------

Summary            : Linker fails to fill trampoline fetch packets with zeros,
		     which may cause fetch exceptions

Fixed in           : 6.1.14
Severity           : S2 - Major
Affected Component : COFF Linker

Description: 
There is a trampoline which is the last item placed in a section. The
trampoline is placed on a 16-byte boundary, so it occupies 2 fetch
packets. The last 16 bytes of the second fetch packet are not filled by
zeros by the linker. When running such an executable on a C64x+ target
with exceptions enabled, fetching this trampoline can cause a fetch
packet exception if the last 16 bytes of the second fetch packet are
left with random data. 

This bugs is caused because of	a misaligned trampoline. Trampolines
should be aligned to a 32 byte boundary, failing which problems can
occur with a fetch packet read (if a trampoline is split across 2 FPs).
Also when code and data sections are placed next to each other, a
misaligned trampoline could lead to errors.

------------------------------------------------------------------------------
FIXED  SDSCM00035234
------------------------------------------------------------------------------

Summary            : Auto-RTS selection does not work in some cases

Fixed in           : 6.1.14
Severity           : S2 - Major
Affected Component : Linker

Description: 
The <automatic> RTS Library selection, in the New CCS Project wizard,
fails to select the RTS library during linking for some C64x+ RTSC
project templates (the "RTA Example" template is one such case).

------------------------------------------------------------------------------
FIXED  SDSCM00035306
------------------------------------------------------------------------------

Summary            : The compiler may produce incorrect code when a static local
		     variable appears as part of an argument to a function call

Fixed in           : 6.1.14
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
The compiler may produce incorrect code when a static local variable 
appears as part of an argument to a function call, when the same 
expression is used for that argument in all calls to that function, and
compilation uses -o3 optimisation.  There is a conflict between local 
statics and an aspect of -o3.

------------------------------------------------------------------------------
FIXED  SDSCM00035330
------------------------------------------------------------------------------

Summary            : Add compiler and assembler workaround to prevent 2 LDx
		     instruction in a single cycle

Fixed in           : 6.1.14
Severity           : S1 - Critical / PS
Affected Component : C/C++ Compiler (cl)

Description: 
Add option --c64p_dma_l1d_workaround to workaround a cache corruption 
issue. This is to provide a software solution for the FAE Alert titled 
"DMA Corruption of L1D Allocation" 

- This option will prevent the code generator from scheduling any loads 
in parallel (this includes the linear assembler). 

- This option will also be used to have the assembler issue non-fatal 
 remarks when processing input assembly files. The assembler remark will 
 read:           
	"REMARK at line xxx:[R5003] DMA/L1D bug may be triggered by           
	this execute packet." 
 
  This is similar to what is emitted for the --c64p_l1d_workaround 
   option that is used to work around a Himalaya L1D issue.  

- The option will be hidden, it will not appear on the help screen  

- The option will be ignored if compiling for non-Joule targets.  

There are no plans to deliver a runtime support library built with this 
option. We have identified 3 runtime library routines that have been 
implemented in assembly and contain parallel loads (setjmp.asm,    
memcpy64.asm, tdeh_uwentry_c6000.asm)

It is expected that the use of this option may have a large negative 
impact on performance. 

------------------------------------------------------------------------------
FIXED  SDSCM00035399
------------------------------------------------------------------------------

Summary            : Under certain conditions, the compiler may unroll a loop
		     more times than the loop will actually iterate

Fixed in           : 6.1.14
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
Under certain conditions, the compiler may unroll a loop more times
than the loop will actually iterate, causing incorrect results.


------------------------------------------------------------------------------
2. 6.1.13 Fixed Defects
------------------------------------------------------------------------------

------------------------------------------------------------------------------
FIXED  SDSCM00033394
------------------------------------------------------------------------------

Summary            : Executables created on different PCs have different
		     ordering of sections

Fixed in           : 6.1.13
Severity           : S2 - Major
Affected Component : COFF Linker

Description: 
There are some instances in the linker where a there is a hash table 
comparison done on keys that are pointers to objects that are basically
output sections.  This can result in inconsistent behavior since the 
pointer values used as keys can vary from host to host, or even from
run to run.  The contents of the sections are correct and invariant; its is
only the order that may change. 

------------------------------------------------------------------------------
FIXED  SDSCM00033552
------------------------------------------------------------------------------

Summary            : Loop carry dependence bound increases

Fixed in           : 6.1.13
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
Code which uses small arrays of pointers that are declared in disjoint 
inner scopes within a single function may slow when compiled with
recent compilers that try to reduce stack usage by sharing space for these 
arrays.  The speed loss comes from having to re-read the pointers each 
time through a loop rather than reading it once outside the loop;  the 
sharing optimisation interferes with moving it outside.

------------------------------------------------------------------------------
FIXED  SDSCM00033677
------------------------------------------------------------------------------

Summary            : The 'run' address from the linker uses a different 'load'
		     address if 'load' not specified

Fixed in           : 6.1.13
Severity           : S2 - Major
Affected Component : Linker

Description: 
If a RUN allocation is specified for an initialized section and a LOAD 
allocation is not specified for that section the linker will use a 
default LOAD allocation which will result different run and load 
addresses. This differs from the previous, documented linker behavior 
where a single specified RUN or LOAD allocation will cause the section
to only be allocated once.  As a workaround use a LOAD only specification 
instead of a RUN only.

------------------------------------------------------------------------------
FIXED  SDSCM00033691
------------------------------------------------------------------------------

Summary            : Use of a gcc statement expression crashes the parser

Fixed in           : 6.1.13
Severity           : S2 - Major
Affected Component : Parser

Description: 
This bug happens only in gcc mode. It reports an assertion failure in 
case of statement expressions with simple block statement. 

------------------------------------------------------------------------------
FIXED  SDSCM00033770
------------------------------------------------------------------------------

Summary            : The compiler generates incorrect code with a conditional
		     function call

Fixed in           : 6.1.13
Severity           : S2 - Major
Affected Component : Code Generator

Description: 
A read and write involving the same struct field may occur in the wrong
order in situations involving link-time recompilation and a file that
uses pointer-to-struct without defining the struct type.

------------------------------------------------------------------------------
FIXED  SDSCM00033811
------------------------------------------------------------------------------

Summary            : Error message "INTERNAL ERROR Decomposition error" is
		     displayed when compiling with the
		     --gen_profile_in flag

Fixed in           : 6.1.13
Severity           : S1 - Critical / PS
Affected Component : C/C++ Compiler (cl)

Description: 
When generating profile information using the --gen_profile_info 
option a conditional statement of the form

   bool ? a  b will be 

instrumented by rewriting the statement into

 bool ? true_counter++,a  b

If 'a' is a function that returns a structure the code generator may
not 
correctly handle this expression and report an error.  As a workaround 
rewrite the conditional expression using if/else.

------------------------------------------------------------------------------
FIXED  SDSCM00033846
------------------------------------------------------------------------------

Summary            : The linker is overwriting sections while merging sections

Fixed in           : 6.1.13
Severity           : S2 - Major
Affected Component : Linker

Description: 
This bug is caused by a wrong section merge done by the linker. The
linker, because of alignment considerations, aligns down a few bytes and
overwrites spaces previous allocated to other sections.

In the test case, it overwrote the space previous allocated to a
constant string, thus the last byte of this string is overwritten.

------------------------------------------------------------------------------
FIXED  SDSCM00033854
------------------------------------------------------------------------------

Summary            : The compiler ignores all but the last --preinclude option

Fixed in           : 6.1.13
Severity           : S3 - Minor
Affected Component : C/C++ Compiler (cl)

Description: 
Instead of processing multiple --preinclude options as documented, the
compiler shell will only process the last --preinclude option that appears on
the command line if more than one is specified.

------------------------------------------------------------------------------
FIXED  SDSCM00034078
------------------------------------------------------------------------------

Summary            : Compiler ignores restrict qualifier on a C++ reference type
		     struct argument

Fixed in           : 6.1.13
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
The compiler is ignoring a restrict qualifier on a reference type
struct argument.  

------------------------------------------------------------------------------
FIXED  SDSCM00034194
------------------------------------------------------------------------------

Summary            : The optimizer aborts abnormally

Fixed in           : 6.1.13
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
A loop nest whose inner loop has a known trip count may be a candidate 
for complete unrolling by the compiler.  If the size of the loop body, 
times the number of iterations, is too large, the optimiser may run out
of memory while analysing the completely-unrolled loop.  Such a loop 
would have been too large to unroll completely anyway, so the compiler 
should check for too-large loops before beginning the analysis.
Defect occurs in

------------------------------------------------------------------------------
FIXED  SDSCM00034224
------------------------------------------------------------------------------

Summary            : The optimizer is generating incorrect code

Fixed in           : 6.1.13
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
The statement

  if (P) x = (1<<y) - x;

will be compiled incorrectly.  The compiler converts such statements to

  x = (P<<y) - x

which would be okay if the operator were +, |, or ^, but which is 
incorrect when the operator is -.

------------------------------------------------------------------------------
FIXED  SDSCM00034228
------------------------------------------------------------------------------

Summary            : Codegen seg fault

Fixed in           : 6.1.13
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
This bug can occur when performing optimization and compiling with -mf2
or below. 

------------------------------------------------------------------------------
FIXED  SDSCM00034230
------------------------------------------------------------------------------

Summary            : Codegen assertion failure

Fixed in           : 6.1.13
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
This bug will most likely affect customers using the -pm option. It is 
caused by an overflow of a counter. 

------------------------------------------------------------------------------
FIXED  SDSCM00034426
------------------------------------------------------------------------------

Summary            : Assembly instruction not executed after software pipelined
		     loop (duplicate of SDSCM00029360)

Fixed in           : 6.1.13
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
An indirect reference, such as "(*t).a" in the sequence

  e = (*t).a;
  ...
  ++t;
  ...
  e = (*t).a;

may be incorrectly loaded into a temporary variable at the first use
and reused without reloading at the second use.

------------------------------------------------------------------------------
FIXED  SDSCM00034488
------------------------------------------------------------------------------

Summary            : Error with indirect reference in loop with -o2/-o3, pass
		     with -o1

Fixed in           : 6.1.13
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
An indirect reference, such as "t->a" in the sequence

  e = t->a;
  ...
  ++t;
  ...
  e = t->a;

may be incorrectly loaded into a temporary variable at the first use
and reused without reloading at the second use.

This sequence may also occur when "t->a" and "++t" appear within a
loop, in which case "t->a" may be loaded outside the loop and never reloaded
inside the loop.

------------------------------------------------------------------------------
FIXED  SDSCM00034533
------------------------------------------------------------------------------

Summary            : A const pointer inside a loop is incorrectly handled by
                     the optimizer

Fixed in           : 6.1.13
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: A loop which declares and initialises a const variable may cause
the compiler to mistakenly propagate the variable into its uses.  Const within
a loop means constant for a single iteration, but the compiler may sometimes
interpret it as constant throughout the function.

------------------------------------------------------------------------------
FIXED  SDSCM00034557
------------------------------------------------------------------------------

Summary            : The optimizer generates incorrect code for a plus-assign
                     with mixed integer types

Fixed in           : 6.1.13
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: An expression like "x->us += l", where "us" is an unsigned field
shorter than int and "l" is a variable longer than int that may contain a
negative value, may compile incorrectly when it occurs in a loop or other
control structure that has multiple uses of "x->us".  The compiler will try to
copy "x->us" to a temporary variable to avoid repeating the memory reference,
but it may lose the narrowing cast that comes with an assignment to a
shorter-than-int type.


------------------------------------------------------------------------------
3. 6.1.12 Fixed Defects
------------------------------------------------------------------------------

------------------------------------------------------------------------------
FIXED  SDSCM00024050
------------------------------------------------------------------------------

Summary            : Code size increase in some 6.1.0 RTS library functions

Fixed in           : 6.1.12
Severity           : S3 - Minor
Affected Component : Runtime Support Libraries (RTS)

Description: 
This bug cause code size increase in time related function in RTS 
library, specifically, in asctime() and strftime(). After this fix,
there is no excessive inline of string functions used in these two time
related functions.

------------------------------------------------------------------------------
FIXED  SDSCM00029163
------------------------------------------------------------------------------

Summary            : Optimizer generates different results for a if / if else
		     construct which is logically the same

Fixed in           : 6.1.12
Severity           : S3 - Minor
Affected Component : Optimizer

Description: 
A sequence like

  *(x+i) = k1;
  if (p) *(x+i) = k2;

when x is a pointer and i is a loop variable that is counted down, may 
compile incorrectly and generate the two write instructions in the
wrong order.

------------------------------------------------------------------------------
FIXED  SDSCM00029328
------------------------------------------------------------------------------

Summary            : Missing warning when place an initialized symbol in an
		     un-initialized section using the DATA_SECTION pragma 
		     under C++

Fixed in           : 6.1.12
Severity           : S3 - Minor
Affected Component : C/C++ Compiler (cl)

------------------------------------------------------------------------------
FIXED  SDSCM00029984
------------------------------------------------------------------------------

Summary            : Difference in output due to various optimization levels

Fixed in           : 6.1.12
Severity           : S3 - Minor
Affected Component : C/C++ Compiler (cl)

Description: 
Code of approximately the form

  a->b = a->b + k;
  if (...) ... = a->b;

may compile incorrectly, such that the last a->b isn't re-read but 
instead reuses the value from before the assignment.  

------------------------------------------------------------------------------
FIXED  SDSCM00031732
------------------------------------------------------------------------------

Summary            : Compiler generates incorrect code for Telsa

Fixed in           : 6.1.12
Severity           : S3 - Minor
Affected Component : C/C++ Compiler (cl)

------------------------------------------------------------------------------
FIXED  SDSCM00032540
------------------------------------------------------------------------------

Summary            : Optimizer moves code from 2nd inner loop before a 1st inner
		     loop

Fixed in           : 6.1.12
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
A loop nest that refers to the same array p using *p++, p[i], and 
_memd8((void*)&p[i]) all together may be compiled erroneously. 

------------------------------------------------------------------------------
FIXED  SDSCM00032746
------------------------------------------------------------------------------

Summary            : Using designated initializers on unions causes the parser
		     to crash

Fixed in           : 6.1.12
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
The compiler does not support this GCC extension, but instead of
issuing an error, the compiler accepted the syntax and crashed in a later
phase.  The compiler will now issue an error if designated initializers are
used for unions

------------------------------------------------------------------------------
FIXED  SDSCM00032861
------------------------------------------------------------------------------

Summary            : 64x+ Compiler performance degradation (about 5x) from 6.0.8
		     to 6.1.10

Fixed in           : 6.1.12
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

------------------------------------------------------------------------------
FIXED  SDSCM00032917
------------------------------------------------------------------------------

Summary            : Performance degradation on 6.1.10 comparing with 6.0.8

Fixed in           : 6.1.12
Severity           : S1 - Critical / PS
Affected Component : C/C++ Compiler (cl)

Description: 
In very limited instances, the 6.1.x C6000 compiler (up to 6.1.11) may
not pipeline a loop that 6.0.x compilers did, due to a defect in an
if-conversion transformation introduced in 6.1.0.  The software
pipeline loop information (-mw) will say "Disqualified loop Loop contains
control code".	The generated code is still correct, but the inner loop won't
be software pipelined.

------------------------------------------------------------------------------
FIXED  SDSCM00032969
------------------------------------------------------------------------------

Summary            : compiler fails when using floats as indexes inside for
		     loops

Fixed in           : 6.1.12
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
A loop whose variable is integral but whose increment is floating-point, such 
as "for (i = 0;  i < NumGrey/2.0; i += 1.0)", may cause the optimiser to abort.

------------------------------------------------------------------------------
FIXED  SDSCM00033023
------------------------------------------------------------------------------

Summary            : Loop performance degrades from version 6.1.8 to 6.1.10

Fixed in           : 6.1.12
Severity           : S1 - Critical / PS
Affected Component : Optimizer

------------------------------------------------------------------------------
FIXED  SDSCM00033062
------------------------------------------------------------------------------

Summary            : CGT 6.1.x linker includes all CSL functions from a module
		     in the final executable

Fixed in           : 6.1.12
Severity           : S2 - Major
Affected Component : Linker

------------------------------------------------------------------------------
FIXED  SDSCM00033129
------------------------------------------------------------------------------

Summary            : Compiler generates illegal mnemonic (MVKS)

Fixed in           : 6.1.12
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
In some cases an internal pseudo instruction will not be rewritten to
the final proper mnemonic, resulting in an assembler error.  The frequency
of occurance is quite small and is sensitive to code layout and option set
used. The pseudo instruction is used to generate an index register that
will hold a scaled offset value.

------------------------------------------------------------------------------
FIXED  SDSCM00033171
------------------------------------------------------------------------------

Summary            : Local volatile variables are optimized away by the
		     optimizer

Fixed in           : 6.1.12
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
A memory reference may be optimised away when it is a non-volatile 
variable accessed through a pointer-to-volatile, and when the reference
is not used.

------------------------------------------------------------------------------
FIXED  SDSCM00033302
------------------------------------------------------------------------------

Summary            : compiler does not issue error when a variable length array
		     is seen with --gcc and --c99 options
		     are used

Fixed in           : 6.1.12
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
Variable length arrays have always been unsupported by our tools. Even 
though we do not support this and no claim has been made that we do,
the parser should issue an error if detected. Instead the parser silently 
accepted VLA's and in some cases the compiler would generate invalid 
code. With this release, the compiler will start emitting errors when 
VLA's are detected.

------------------------------------------------------------------------------
FIXED  SDSCM00033320
------------------------------------------------------------------------------

Summary            : Abnormal termination - very large switch case list

Fixed in           : 6.1.12
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
Under certain conditions, constructing an internal representation in
the optimiser may leave erased nodes within the graph, which can cause the 
optimiser to crash.

------------------------------------------------------------------------------
FIXED  SDSCM00033363
------------------------------------------------------------------------------

Summary            : Software pipelining fails completely because of illegal
		     partition causes reg alloc failure

Fixed in           : 6.1.12
Severity           : S2 - Major
Affected Component : Code Generator

Description: 
In rare instances, the compiler may not generate a software pipelined 
loop due to a partition that would prevent successful register 
allocation.  The compiler then would use a straightline loop instead. 
This is a performance issue only and not a correctness issue. 

------------------------------------------------------------------------------
FIXED  SDSCM00033383
------------------------------------------------------------------------------

Summary            : Compiler incorrectly folds shift intrinsic with negative
		     constant

Fixed in           : 6.1.12
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
_shr2(K1, K2), where both K1 and K2 are literal integers, will compile 
incorrectly if the low 16 bits of K1 represent a negative number.  
Instead of truncating at 16 bits, the compiler will let the sign bits 
overwrite the high 16 bits of the result.

------------------------------------------------------------------------------
FIXED  SDSCM00033398
------------------------------------------------------------------------------

Summary            : GCC Extension Support C6x parser does not accept a
while()
                     do as the last statement in a statement expression

Fixed in           : 6.1.12
Severity           : S2 - Major
Affected Component : Parser

Description:
This bug only happens in --gcc mode. It is caused by compound statement
as the last statement with a statement expression.

------------------------------------------------------------------------------
FIXED  SDSCM00033441
------------------------------------------------------------------------------

Summary            : __inline quailifier on the __isnan() function in math.h
		     causes a remark to be issued by the parser

Fixed in           : 6.1.12
Severity           : S3 - Minor
Affected Component : Runtime Support Libraries (RTS)

Description: 
The remark was not noticed during implementation of this feature. It
has been suppressed using diagnostic pragmas.

------------------------------------------------------------------------------
FIXED  SDSCM00033490
------------------------------------------------------------------------------

Summary            : store and load to same structure member getting swapped

Fixed in           : 6.1.12
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
A read and a write to the same struct field, accessed through a 
restricted pointer that is derived from another restricted pointer, may
occur in the wrong order.

------------------------------------------------------------------------------
FIXED  SDSCM00033532
------------------------------------------------------------------------------

Summary            : LDW and STW occur in incorrect order causing wrong result

Fixed in           : 6.1.12
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
A read and write to the same struct field may occur in the wrong order
in certain obscure circumstances involving link-time recompilation.

------------------------------------------------------------------------------
FIXED  SDSCM00033636
------------------------------------------------------------------------------

Summary            : for loop unrolling causes if statements for structure
		     compare to be wrong

Fixed in           : 6.1.12
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
A loop containing a sequence (possibly not contiguous) like

  a[i] = k;
  x    = a[i];

may compile incorrectly if the loop unrolls and the compiler attempts
to combine the stores to a[i] and a[i+1] into a single wider store.

------------------------------------------------------------------------------
FIXED  SDSCM00033671
------------------------------------------------------------------------------

Summary            : Test failure in 6.1.11 

Fixed in           : 6.1.12
Severity           : S1 - Critical / PS
Affected Component : C/C++ Compiler (cl)

Description: 
Under certain very specific circumstances, a loop that reads from x[0] 
(or other fixed index) and writes to x[i] on each iteration may do the 
write before the read.


------------------------------------------------------------------------------
4. 6.1.11 Fixed Defects
------------------------------------------------------------------------------

------------------------------------------------------------------------------
FIXED  SDSCM00031799
------------------------------------------------------------------------------

Summary            : Compiler defect with _mem8 intrinsic

Fixed in           : 6.1.11
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
Some non-aligned accesses, written as _mem8(p->a) for example, may be 
erroneously converted into aligned accesses.  When the pointer is
itself read from memory, it may be assumed to have larger alignment than it 
really does.

------------------------------------------------------------------------------
FIXED  SDSCM00031874
------------------------------------------------------------------------------

Summary            : Compiler can speculatively exec instructions with side
		     effects

Fixed in           : 6.1.11
Severity           : S2 - Major
Affected Component : Code Generator

Description: 
There were no reported errors from this problem.  However, some C6000 
instructions set status bits in the floating point control registers 
FADCR, FAUCR, and FMCR.  If those control registers are read by a 
function, then instructions that set them should not be speculatively 
executed in that function.  Prior to this fix, that restriction was not
enforced, which could potentially result in an incorrect value being
read from one of these registers.  There is a potential execution speed
impact because of this change; if a function reads one of these registers,
then a performance degradation may result due to the new scheduling 
restrictions.

------------------------------------------------------------------------------
FIXED  SDSCM00032019
------------------------------------------------------------------------------

Summary            : optimizer abort

Fixed in           : 6.1.11
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

------------------------------------------------------------------------------
FIXED  SDSCM00032023
------------------------------------------------------------------------------

Summary            : Substantial cycle increase when using compiler 6.1.9
		     compared to 6.0.18

Fixed in           : 6.1.11
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
A loop containing array references and internal control flow may 
experience poorer performance because certain independent array
accesses aren't recognised to be independent.  Specifically, a loop that reads 
x[i] at the top and writes x[i] in the middle, and follows that write 
with a simple one-armed IF or a simple "diamond" two-armed IF that 
doesn't refer to x, may show the problem.  Declaring x "restrict," when
that is safe, can compensate.

------------------------------------------------------------------------------
FIXED  SDSCM00032116
------------------------------------------------------------------------------

Summary            : Compiler incorrectly reorders subsequent accesses to global
		     variable

Fixed in           : 6.1.11
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
References to external array variables declared with no size, ie,
"extern int x[]," may not be properly checked for aliases and their accesses
may be made in the wrong order.

------------------------------------------------------------------------------
FIXED  SDSCM00032131
------------------------------------------------------------------------------

Summary            : parser array bounds read with template code

Fixed in           : 6.1.11
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
Parser could crash with C++ template code.

------------------------------------------------------------------------------
FIXED  SDSCM00032290
------------------------------------------------------------------------------

Summary            : Optimizer hangs 

Fixed in           : 6.1.11
Severity           : S2 - Major
Affected Component : Optimizer

------------------------------------------------------------------------------
FIXED  SDSCM00032293
------------------------------------------------------------------------------

Summary            : Application failure on c64+

Fixed in           : 6.1.11
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
Complicated code involving multiple loops and arrays of structs may 
compile incorrectly when adjacent fields with the same type, in an
array reference with a constant index, are read, written, and read again.

In this case, complex numbers were represented as a struct with two int
fields.  An array of structs was used in the program.  Some early loops
were small and unrolled completely, making x[3].real and x[3].imag 
visible with constant indices.	A later loop wrote to x[i].real and 
x[i].imag, and a still later reference to x[3].real and x[3].imag
reused the last read instead of re-reading after the write.

------------------------------------------------------------------------------
FIXED  SDSCM00032304
------------------------------------------------------------------------------

Summary            : severe performance degradation in CGT 6.1.10 
Fixed in           : 6.1.11
Severity           : S2 - Major
Affected Component : Optimizer

------------------------------------------------------------------------------
FIXED  SDSCM00032325
------------------------------------------------------------------------------

Summary            : Free mismatched memory bug in shell

Fixed in           : 6.1.11
Severity           : S2 - Major
Affected Component : Shell

Description: 
Shell could crash with hand-coded assembly source.

------------------------------------------------------------------------------
FIXED  SDSCM00032458
------------------------------------------------------------------------------

Summary            : Optimizer generates incorrect code for a quest colon
		     construct that performs an absolute value operation

Fixed in           : 6.1.11
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
A quest/colon expression that takes the absolute difference of two 
unsigned variables will be incorrectly replaced with a simple
difference.

------------------------------------------------------------------------------
FIXED  SDSCM00032470
------------------------------------------------------------------------------

Summary            : PC optimizer segmentation 

Fixed in           : 6.1.11
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
On Windows only, compiling a very large function with many references
to global, aliased, or union variables may cause an optimiser crash due to
a stack overflow.

------------------------------------------------------------------------------
FIXED  SDSCM00032672
------------------------------------------------------------------------------

Summary            : Highly inefficient use of stack space

Fixed in           : 6.1.11
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
The compiler may waste stack space in two ways.  If a struct variable
is defined locally, the optimiser may attempt to break it into separate 
temporary variables, one per field, because that often allows for
better results.  However, if the struct's address is taken, it can't be 
broken up that way.  The problem is that the compiler has already created 
the new temporary symbols, though they won't be used, and they will take up
space on the stack.

The other way is that if separate scopes that define aggregate
variables are ultimately defined within only one scope within the function 
scope, the variables won't be shared on the stack even though they could be.  
There was a mistake in the test for whether sharing was worthwhile;  it
insisted that there be at least two scopes immediately within the function 
scope.

------------------------------------------------------------------------------
FIXED  SDSCM00032732
------------------------------------------------------------------------------

Summary            : Compilation hangs with o2 and o3 

Fixed in           : 6.1.11
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
A relatively long sequence that involves assignments to a scalar
variable followed by two or more uses of that variable, repeated 
several times as from unrolling a loop, may lead to exponential 
behavior in the optimiser as the early assignments are substituted 
in the later uses, and then those assignments are substituted, and 
so on, multiplying by two or more each time.

------------------------------------------------------------------------------
FIXED  SDSCM00032744
------------------------------------------------------------------------------

Summary            : optimizer crash 

Fixed in           : 6.1.11
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
A loop in which two pairs of two adjacent array elements each are all 
written may cause an optimiser abort if it can combine the pairs into a
larger single write.  Combining the first pair leaves an inconsistent 
state that combining the second pair trips over.

------------------------------------------------------------------------------
FIXED  SDSCM00032749
------------------------------------------------------------------------------

Summary            : optimizer terminated abnormally

Fixed in           : 6.1.11
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
Certain rare situations may lead to more than one internal definition 
being applicable to an operator, at a point when only one is allowed, 
causing an optimiser abort.  It's hard to be more specific, because
this report has no source code for its test case;  it appears to involve 
an expression like "0x1234u - _mpyu(x,y)" for C64+, and two subtract 
instructions might apply.

------------------------------------------------------------------------------
FIXED  SDSCM00032761
------------------------------------------------------------------------------

Summary            : codegen segfault 

Fixed in           : 6.1.11
Severity           : S2 - Major
Affected Component : Code Generator

Description: 
The error condition is caused by calls to memcpy with the following
form

memcpy((void *)(unsigned int)&func, (const void *)(unsigned 
int)&func2,constval)

Where func or func2 is an externally defined function (eg. c_int00),
the size parameter to memcpy is a constant value, and there is an an 
intermediate type case of '&func' or '&func2'. 

The problem is specific to memcpy where the arguments are externally 
defined symbols.

------------------------------------------------------------------------------
FIXED  SDSCM00032800
------------------------------------------------------------------------------

Summary            : Joule call stub is generated for simple functions
		     increasing code size w/o any performance benefits

Fixed in           : 6.1.11
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

------------------------------------------------------------------------------
FIXED  SDSCM00032923
------------------------------------------------------------------------------

Summary            : Volatile keyword does not prevent the compiler from
		     deleting read accesses

Fixed in           : 6.1.11
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
In certain instances, the C6000 compiler may remove an increment to a 
volatile pointer.  This only occurs if the pointer is volatile, the 
load's value is unused, the increment to the pointer is unused beyond
the loop, and the pointer is unused beyond the loop.


------------------------------------------------------------------------------
5. 6.1.10 Fixed Defects
------------------------------------------------------------------------------


------------------------------------------------------------------------------
FIXED  SDSCM00028948
------------------------------------------------------------------------------

Summary            : Missing <cmath> entries

Fixed in           : 6.1.10
Severity           : S2 - Major
Affected Component : Runtime Support Libraries (RTS)

Description:
Missing overloaded float and long double functions in C++.

------------------------------------------------------------------------------
FIXED  SDSCM00030215
------------------------------------------------------------------------------

Summary            : C I/O cannot support ftell/fseek for DOS format files
		     opened in text mode

Fixed in           : 6.1.10
Severity           : S2 - Major
Affected Component : Runtime Support Libraries (RTS)

Description: 
Use of ftell and fseek on DOS formatted files is not supported in text 
mode, with buffered I/O.  The avoid this error the run-time libraries
can be rebuilt with unbuffered I/O by defining the following macro 
_TI_FORCE_UNBUFFERED_TEXT_IO.  This is defined by adding this switch

-D_TI_FORCE_UNBUFFERED_TEXT_IO

to the shell. 

Workaround: 
1. Open the DOS file in binary mode.
2. Use one of many DOS-to-Unix file converters to strip
carriage-returns from the input file.

------------------------------------------------------------------------------
FIXED  SDSCM00030349
------------------------------------------------------------------------------

Summary            : Symbol details of enumerated variable are lost in COFF file
		     when optimization is enabled

Fixed in           : 6.1.10
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
A variable of an enumerated type will not be noted as such after 
optimisation;  instead, it will have an integral type.

------------------------------------------------------------------------------
FIXED  SDSCM00030519
------------------------------------------------------------------------------

Summary            : Compiler is generating a resource conflict on the .L2 unit.

Fixed in           : 6.1.10
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
In a very rare situation on C6700, a certain loop compiled with -ms3 
could produce code that results in a write port conflict on the
hardware, leading to incorrect results.

------------------------------------------------------------------------------
FIXED  SDSCM00031032
------------------------------------------------------------------------------

Summary            : null pointers are dereferenced when using optimizer with
		     -mf

Fixed in           : 6.1.10
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
A loop like

  for ...
    if (e != NULL)
      *e += ...

may compile incorrectly in such a way as to allow *e to happen outside 
the test for NULL.

------------------------------------------------------------------------------
FIXED  SDSCM00031080
------------------------------------------------------------------------------

Summary            : Bad relocation of expression referencing symbol in same
		     code section and in an object file resulting from partial 
		     link

Fixed in           : 6.1.10
Severity           : S2 - Major
Affected Component : ELF Linker

Description: 
When the linker creates a COFF format file using an input file 
that was the result of previous partial link (-r), a reference to a 
symbol from within the file resulting from the partial link may be 
calculated incorrectly.

------------------------------------------------------------------------------
FIXED  SDSCM00031090
------------------------------------------------------------------------------

Summary            : Compiler mistakenly ignores volatile when applied to a
		     structure

Fixed in           : 6.1.10
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
A write to a field in a volatile struct from within a loop may be 
improperly optimised to only write the final value.

------------------------------------------------------------------------------
FIXED  SDSCM00031194
------------------------------------------------------------------------------

Summary            : Unroll optimizer bug

Fixed in           : 6.1.10
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
A loop nest may unroll-and-jam by an amount that doesn't evenly divide 
the known loop trip count.  When there is exactly one leftover
iteration, the loop iteration variable may not be incremented correctly to 
account for that iteration.  The iteration will still happen, but the loop 
variable may not reflect it.

------------------------------------------------------------------------------
FIXED  SDSCM00031215
------------------------------------------------------------------------------

Summary            : Compiler generates incorrect call to wrong library divide
		     routine

Fixed in           : 6.1.10
Severity           : S1 - Critical / PS
Affected Component : C/C++ Compiler (cl)

Description: 
The compiler could generate an incorrect divide routine call in some 
expressions that mix signed and unsigned types.

------------------------------------------------------------------------------
FIXED  SDSCM00031303
------------------------------------------------------------------------------

Summary            : codegen does not save B12 to stack before use it

Fixed in           : 6.1.10
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
A bug happens for stack save/restore in a function entry/exit. It usually
happens in debug mode where we have a certain order for registers' layout 
on the stack.

------------------------------------------------------------------------------
FIXED  SDSCM00031310
------------------------------------------------------------------------------

Summary            : Missing Call Branch DIE in C64x/C64x+ RTS library function
		     _pproc_diouxp

Fixed in           : 6.1.10
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
Optimization may create duplicate function calls for a single call
occurs instruction.  The codegen may not generate a debug tag for each of
these calls.

------------------------------------------------------------------------------
FIXED  SDSCM00031335
------------------------------------------------------------------------------

Summary            : Compiler incorrectly schedules instructions in SPLOOP

Fixed in           : 6.1.10
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
An inner loop with restricted pointers defined entirely within it may 
produce incorrect results, because "restrict" will be used to 
disambiguate the pointers in all cases, when it should only be used to 
disambiguate within a single iteration and not across iterations.

Note: SDSCM00031335 is not fixed in version 6.1.11.  This fix in
6.1.10 has been shown to negatively impact performance in some
cases.  

------------------------------------------------------------------------------
FIXED  SDSCM00031337
------------------------------------------------------------------------------

Summary            : Level 3 optimization causes compiler to be overly
		     aggressive reorganizing assignments.

Fixed in           : 6.1.10
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
A function with restricted parameters and restricted arguments, when 
inlined, may compile incorrectly.

------------------------------------------------------------------------------
FIXED  SDSCM00031374
------------------------------------------------------------------------------

Summary            : C6x 6.1.6 performance degradation compared with 6.0.14

Fixed in           : 6.1.10
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
Certain loops involving "restrict" will have a longer dependence cycle 
than necessary, in the 6.1.x series of C6x compilers.  This particular 
case involves a reference to a "T *restrict *restrict" variable X, 
approximately X[i][k] where i is the loop index variable.

------------------------------------------------------------------------------
FIXED  SDSCM00031471
------------------------------------------------------------------------------

Summary            : optimizer crashes on PC only

Fixed in           : 6.1.10
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
A string literal less than 64 characters but with more than half 
non-printable characters (as determined by isprint()) may overflow an 
internal buffer and cause an optimiser crash.  It is also possible that
non-printable characters may cause out-of-range accesses in isprint() 
itself, similarly causing an optimiser crash.

------------------------------------------------------------------------------
FIXED  SDSCM00031482
------------------------------------------------------------------------------

Summary            : Optimizer terminates abnormally (C64x)

Fixed in           : 6.1.10
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
A loop containing a statement like "x[i] = _dotp2(y[i],z[i])" can cause
an optimiser abort.  A faulty attempt to vectorise the statement leads
to an internal inconsistency.

------------------------------------------------------------------------------
FIXED  SDSCM00031491
------------------------------------------------------------------------------

Summary            : Linker does not error on user attempt to split .stack
		     section but allocation silently fails

Fixed in           : 6.1.10
Severity           : S2 - Major
Affected Component : Linker

Description: 
Split operator constraints not enforced for .stack, .sysmem, .esysmem 
sections.  They are enforced for .cinit,.pinit sections.  Using split 
operator for these C runtime sections will likely result in runtime
errors.

------------------------------------------------------------------------------
FIXED  SDSCM00031569
------------------------------------------------------------------------------

Summary            : memd8 does not function properly with cgtools 6.1.9

Fixed in           : 6.1.10
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
A non-aligned access, explicitly written with _memd8 or the like or 
generated implicitly, which accesses its data using a different width 
than the native size for the type of the object, may not be recognised
as aliasing the normal access.  As a result, the order of the two may be 
changed, causing incorrect results.
accesses to the same data.

------------------------------------------------------------------------------
FIXED  SDSCM00031626
------------------------------------------------------------------------------

Summary            : Optimizer (O2 or O3) generates Internal Error

Fixed in           : 6.1.10
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
Deeply-nested loops that contain _nasserts, most typically implicitly 
generated by _amem intrinsics, may cause the optimiser to crash.

------------------------------------------------------------------------------
FIXED  SDSCM00031651
------------------------------------------------------------------------------

Summary            : Array elements get swapped when compiling with -o3

Fixed in           : 6.1.10
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
A loop containing a multiply of two unsigned-short array elements, when
compiled in big-endian mode, may vectorise with the vector results in
the wrong order.

------------------------------------------------------------------------------
FIXED  SDSCM00031766
------------------------------------------------------------------------------

Summary            : optimizer (-o1, -o2, -o3) does not make use of the _SUB4
		     intrinsic

Fixed in           : 6.1.10
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
A use of the _sub4 intrinsic may be incorrectly converted to MINUS if
the compiler can determine that the second operand is zero in the 24 lower 
bits or if both operands combined are zero in the 8th, 16th, and 24th
bit (ie, if (opd1|opd2)&0x808080 is zero).


------------------------------------------------------------------------------
6. 6.1.9 Fixed Defects
------------------------------------------------------------------------------

------------------------------------------------------------------------------
FIXED  SDSCM00025230
------------------------------------------------------------------------------

Summary            : Internal error SCONV occurs with CG Toolsv6.1.1

Fixed in           : 6.1.9
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

------------------------------------------------------------------------------
FIXED  SDSCM00030182
------------------------------------------------------------------------------

Summary            : CGT v6.1.7  issues in using -o2 option

Fixed in           : 6.1.9
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
A loop containing an IF or other control flow may compile incorrectly
if it is unrolled, it defines a vector expression (which may be implicit),
and the IF predicate is such that it is always false on the first 
unrolled iteration.  (For example, a sum-of-products for C6x may be 
converted to a _dotp2 intrinsic, which has vector operands.  An IF
which tests for an odd index will always be false if the loop starts at
zero.)

------------------------------------------------------------------------------
FIXED  SDSCM00030206
------------------------------------------------------------------------------

Summary            : MVD instruction has incorrect resource modelling in
		     compiler

Fixed in           : 6.1.9
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

------------------------------------------------------------------------------
FIXED  SDSCM00030247
------------------------------------------------------------------------------

Summary            : Wrong assembly command used in _mem4 intrinsic

Fixed in           : 6.1.9
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
An unaligned access -- _mem4, for example -- whose address contains a 
volatile variable or side-effecting expression may be incorrectly 
manipulated in such a way as to lose the "unaligned" feature.

------------------------------------------------------------------------------
FIXED  SDSCM00030259
------------------------------------------------------------------------------

Summary            : cg6x crashes while compiling a file

Fixed in           : 6.1.9
Severity           : S3 - Minor
Affected Component : C/C++ Compiler (cl)

Description: 
In rare circumstances, the C6000 compiler may crash while performing 
software pipelining.

------------------------------------------------------------------------------
FIXED  SDSCM00030292
------------------------------------------------------------------------------

Summary            : Disassmbly of label/address for BDEC and BPOS in compressed
		     FP is incorrect

Fixed in           : 6.1.9
Severity           : S3 - Minor
Affected Component : Disassembler (dis)

Description: 
The disassembler will incorrectly calculate the displacement for a BDEC
and BPOS instruction in a fetch packet that has a header (i.e. the
fetch packet has compressed/16-bit instructions).  The displacement is half
of what it should be.

------------------------------------------------------------------------------
FIXED  SDSCM00030352
------------------------------------------------------------------------------

Summary            : code coverage fails when processing files with more than
		     100 functions or with huge switch statements

Fixed in           : 6.1.9
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
When generating path profiling instrumentation for a C/C++ source file,
the path profiling utility, pprof6x, may terminate abnormally if the 
source file contains a large switch statement with 100 or more cases.

------------------------------------------------------------------------------
FIXED  SDSCM00030362
------------------------------------------------------------------------------

Summary            : Optimizer generates segmentation fault with -o2 and higher

Fixed in           : 6.1.9
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
A loop nest which may be unrolled-and-jammed -- which requires a
specific set of conditions, but is essentially simple loops which can legally
have the outer loop unrolled -- whose outer loop's initial value is not 
explicitly set in the loop may cause the optimiser to crash.

------------------------------------------------------------------------------
FIXED  SDSCM00030572
------------------------------------------------------------------------------

Summary            : Optimizer terminates abnormally

Fixed in           : 6.1.9
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
The optimiser may abort when it encounters a short simple IF statement 
that sets a value which is used two or more times in subsequent 
statements, if that value is cast to a narrower type (even implicitly)
in the later uses.

------------------------------------------------------------------------------
FIXED  SDSCM00030635
------------------------------------------------------------------------------

Summary            : Incorrect optimization of constant performed with -o2 and
		     higher

Fixed in           : 6.1.9
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
A reference to a field of a union, optionally included in some other 
structure type, may be replaced with an incorrect value if the variable
is auto-initialised and const.	Ie, given "T const x = {1, 2};" where T
is a union, a later "x.a" may be replaced by 2 even though that doesn't
correspond to the proper field.

------------------------------------------------------------------------------
FIXED  SDSCM00030700
------------------------------------------------------------------------------

Summary            : Symbol specified with .label directive within assembly
		     source file gets linked to run address instead of load 
		     address

Fixed in           : 6.1.9
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
Symbol specified with .label directive within assembly source file gets
linked to run address instead of load address

------------------------------------------------------------------------------
FIXED  SDSCM00030799
------------------------------------------------------------------------------

Summary            : --use_profile_info not working on Windows version of
		     compiler

Fixed in           : 6.1.9
Severity           : S2 - Major
Affected Component : Path Profiler (pprof)

------------------------------------------------------------------------------
FIXED  SDSCM00030934
------------------------------------------------------------------------------

Summary            : 6.1.x C6000 compiler generates interrupt unsafe code

Fixed in           : 6.1.9
Severity           : S2 - Major
Affected Component : Code Generator

Description: 
In rare situations, the C6000 compiler may generate code where a
portion of the code is "interrupt-unsafe".

------------------------------------------------------------------------------
FIXED  SDSCM00031037
------------------------------------------------------------------------------

Summary            : Too many relocation overflow error messages when placement
		     fails
Fixed in           : 6.1.9
Severity           : S2 - Major
Affected Component : Linker

Description: 
When the linker is unable to fit .text into the memory segment
requested in the cmd file, we see a lot of relocation error messages
instead of simple "could not fit" error messages. 


------------------------------------------------------------------------------
7. 6.1.8 Fixed Defects
------------------------------------------------------------------------------

------------------------------------------------------------------------------
FIXED  SDSCM00028799
------------------------------------------------------------------------------

Summary            : The new linker should provide the same detailed information
		     as the old linker when the placement fails.

Fixed in           : 6.1.8
Severity           : S2 - Major
Affected Component : Linker

Description: 
This bug did not result in any incorrect behavior.  The error messages 
issued in some cases have been expanded to include the appropriate 
details.

------------------------------------------------------------------------------
FIXED  SDSCM00029155
------------------------------------------------------------------------------

Summary            : Code coverage information missing for inlined functions

Fixed in           : 6.1.8
Severity           : S3 - Minor
Affected Component : C/C++ Compiler (cl)

------------------------------------------------------------------------------
FIXED  SDSCM00029192
------------------------------------------------------------------------------

Summary            : Parser truncates large float value

Fixed in           : 6.1.8
Severity           : S2 - Major
Affected Component : Parser

Description: 
This bug happens when we convert a floating point number that larger
than 32 bit integer. Without this fix, we will convert them all to INT_MAX. 

------------------------------------------------------------------------------
FIXED  SDSCM00029399
------------------------------------------------------------------------------

Summary            : Compiler does not compute floating point value correctly in
		     loop

Fixed in           : 6.1.8
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
This bug happens when the compiler does vectorization and the subscript
in array index is an unsigned char, also this unsigned char got warpped
around at its range boundary.

------------------------------------------------------------------------------
FIXED  SDSCM00029461
------------------------------------------------------------------------------

Summary            : compiler and optimizer segmentation faults

Fixed in           : 6.1.8
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
Storing to a vector of pointers, when two stores to adjacent locations
in that vector can be combined into a single wider store, may cause the 
optimiser to abort.  Generally the situation arises when a loop is 
unrolled.

------------------------------------------------------------------------------
FIXED  SDSCM00029778
------------------------------------------------------------------------------

Summary            : In C++ header file <limits> the members
		     numeric_limits<[unsigned] long>digits are wrong

Fixed in           : 6.1.8
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

------------------------------------------------------------------------------
FIXED  SDSCM00029885
------------------------------------------------------------------------------

Summary            : Linker incorrectly fills .pinit with invalid value

Fixed in           : 6.1.8
Severity           : S2 - Major
Affected Component : Linker

Description: 
This bug happens when there are function calls in pinit section. This
is usually true for some C++ function with global class initialization. 
Pinit holds all the pointers to functions that need to be called before
main(), and this bug causes some garbage pointer be placed in that 
section and leads to failure.

------------------------------------------------------------------------------
FIXED  SDSCM00029964
------------------------------------------------------------------------------

Summary            : cos() gives inaccurate results only on 6747 HW

Fixed in           : 6.1.8
Severity           : S2 - Major
Affected Component : Compressor (cmp)

Description: 
In very rare instances on C674x parts, the compiler tools may generate
a sequence of instructions that leads to a write port conflict, which
means a write to the register file may not occur as necessary.  A write port 
conflict is a problem that can only be seen on the hardware -- it does 
not manifest itself on a simulator.  During a write port conflict, two 
differing latency instructions on the same unit write to the register 
file at the same time.	However, only one of the writes will actually 
occur.	This defect can only manifest itself on C674x parts (e.g. 
TMS320C6747).

------------------------------------------------------------------------------
FIXED  SDSCM00030168
------------------------------------------------------------------------------

Summary            : DWARF line number entry encoding error

Fixed in           : 6.1.8
Severity           : S2 - Major
Affected Component : Assembler

Description: 
The DWARF line number information for the last line number entry, 
representing the last line of the function, can be encoded incorrectly 
depending on the values of the other line number entries.  This is more
likely for functions with very few line number entries.

------------------------------------------------------------------------------
FIXED  SDSCM00030206
------------------------------------------------------------------------------

Summary            : MVD instruction has incorrect resource modelling in
		     compiler

Fixed in           : 6.1.8
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
The C6000 compiler incorrecly models the resource usage of the MVD,
which could lead to write port conflicts on the M unit when the MVD
instruction is used.  The compiler is modelling the instruction writing
its register on the 2nd cycle instead of the 4th.  This could lead to
write port conflicts, especially on the 674x parts, where there are
more lengthy multicycle M unit instructions.

Note that the write port conflict will only manifest itself on the HW
in that the HW will drop one of the writes.  The simulator will write
both values to the register file.


------------------------------------------------------------------------------
8. 6.1.7 Fixed Defects
------------------------------------------------------------------------------

------------------------------------------------------------------------------
FIXED  SDSCM00028850
------------------------------------------------------------------------------

Summary            : cgtools 6.1.3  Incorrect loop code generation

Fixed in           : 6.1.7
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
A "for" or "while" loop that exits early (eg, with a "break") may
compute the wrong value for a variable that is incremented and also modified 
a second way within the loop.

------------------------------------------------------------------------------
FIXED  SDSCM00028855
------------------------------------------------------------------------------

Summary            : Optimizer abort
		     definition

Fixed in           : 6.1.7
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
The optimiser may abort when compiling C++ code.  

------------------------------------------------------------------------------
FIXED  SDSCM00029355
------------------------------------------------------------------------------

Summary            : Incorrect code with -o3 or -o2

Fixed in           : 6.1.7
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
A codegen optimization involving an XOR-XOR-AND/OR instruction sequence
generates incorrect code.

------------------------------------------------------------------------------
FIXED  SDSCM00029427
------------------------------------------------------------------------------

Summary            : Codegen aborts with 'INTERNAL ERROR no match for UMULT'

Fixed in           : 6.1.7
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
A volatile memory access -- a dereference of pointer-to-volatile -- may
be incorrectly vectorised in a way that causes a codegen abort.

------------------------------------------------------------------------------
FIXED  SDSCM00029525
------------------------------------------------------------------------------

Summary            : The linker in late template instantiation opens a file 
                     for READ and then for READ-WRITE without first closing 
		     the file

Fixed in           : 6.1.7
Severity           : S1 - Critical / PS
Affected Component : Linker

Description: 
It is possible that a read of an object file can occur while that same 
object file has already been opened by the linker for a read.  This
could cause errors in parallel build systems.  This can only occur with C++ 
code requiring template instantiations.

------------------------------------------------------------------------------
FIXED  SDSCM00029550
------------------------------------------------------------------------------

Summary            : CPU generation mismatch on the COFF header when linker
		     performs automatic library selection

Fixed in           : 6.1.7
Severity           : S2 - Major
Affected Component : Linker

Description: 
When building a project without explicitly including a RTS library, 
linker correctly includes the library but incorrectly fills the CPU 
generation field on the COFF header, defaulting to C6740. The map files
show the correct library is included, however running the ofd6x on both
the .obj and the .out files show the mismatch. This prevents loading
the .out file to the target. 


------------------------------------------------------------------------------
9. 6.1.6 Fixed Defects
------------------------------------------------------------------------------

------------------------------------------------------------------------------
FIXED  SDSCM00020345
------------------------------------------------------------------------------

Summary            : Switch -mn (--optimize_with_debug) was hidden

Fixed in           : 6.1.6
Severity           : S2 - Major
Affected Component : Code Generator

------------------------------------------------------------------------------
FIXED  SDSCM00024307
------------------------------------------------------------------------------

Summary            : C6x CG coredump with Boost library

Fixed in           : 6.1.6
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
This bug happens when a Boost header file is used.  

------------------------------------------------------------------------------
FIXED  SDSCM00025374
------------------------------------------------------------------------------

Summary            : isfinite function does not work for float

Fixed in           : 6.1.6
Severity           : S3 - Minor
Affected Component : C/C++ Compiler (cl)

Description: 
On C6000 and C5500, compilation would fail when using C++ and the C99
classification macros isnormal, isinf, isnan, isfinite, and fpclassify,
or the C99 nearest integer functions round* and trunc*.

------------------------------------------------------------------------------
FIXED  SDSCM00027014
------------------------------------------------------------------------------

Summary            : Compiler needs to predefine __EDG_VERSION__

Fixed in           : 6.1.6
Severity           : S2 - Major
Affected Component : Parser

------------------------------------------------------------------------------
FIXED  SDSCM00027550
------------------------------------------------------------------------------

Summary            : Dwart type encoding incorrect for C++ class that inherits
		     from template class

Fixed in           : 6.1.6
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
This bug puts a wrong source name for a mangled C++ variable in the 
object file which could lead to difficulties in debugging. 

------------------------------------------------------------------------------
FIXED  SDSCM00027552
------------------------------------------------------------------------------

Summary            : Compiler crashes when compiling code that does exception
		     handling in a destructor

Fixed in           : 6.1.6
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
If you have a try statement in a destructor with a ellipsis in the
catch cluase, this bug will show up. 

------------------------------------------------------------------------------
FIXED  SDSCM00027572
------------------------------------------------------------------------------

Summary            : 674 compiler generates bad comparison code (bad use of A0
		     in back-to-back MVK/MVKL)

Fixed in           : 6.1.6
Severity           : S2 - Major
Affected Component : Code Generator

------------------------------------------------------------------------------
FIXED  SDSCM00027986
------------------------------------------------------------------------------

Summary            : internal optimizer error with segmentation fault

Fixed in           : 6.1.6
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
Certain large functions can lead to excessive allocation in the 
optimiser.  

------------------------------------------------------------------------------
FIXED  SDSCM00028044
------------------------------------------------------------------------------

Summary            : Optimizer terminates abnormally in example code when -mf0
		     switch used

Fixed in           : 6.1.6
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
A vectorised pair of stores and a vectorised pair of loads, both pairs 
referring to the same address within the same function, may be
mishandled in such a way that the optimiser aborts.  

------------------------------------------------------------------------------
FIXED  SDSCM00028050
------------------------------------------------------------------------------

Summary            : C6000 linker seg faults

Fixed in           : 6.1.6
Severity           : S2 - Major
Affected Component : ELF Linker

------------------------------------------------------------------------------
FIXED  SDSCM00028072
------------------------------------------------------------------------------

Summary            : Bit-field modification corrupts neighboring bits

Fixed in           : 6.1.6
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
Given

- a loop which can be safely unrolled
- a store of an integer constant
- the store is indexed
- the access is char or short (signed or unsigned)
- compiling with -o2 or -o3

the compiler may mishandle the combination of stores to adjacent 
iterations in a way that uses zero instead of the correct constant in 
alternating stored expressions.

In this particular case, a mask used when writing a bitfield element
was zero in every other store, effectively clearing bitfields near the one 
that was directly stored.

------------------------------------------------------------------------------
FIXED  SDSCM00028442
------------------------------------------------------------------------------

Summary            : Error - Out of Memory - Optimizer Aborted

Fixed in           : 6.1.6
Severity           : S1 - Critical / PS
Affected Component : C/C++ Compiler (cl)

Description: 
A simple loop, with a known constant trip count, that makes many 
references to its loop variables, may be unrolled a lot, and those 
references may all propagate forward to create new expressions, and the
combination may overwhelm the optimiser and cause it to run out of
memory.

------------------------------------------------------------------------------
FIXED  SDSCM00028522
------------------------------------------------------------------------------

Summary            : INTERNAL ERROR by opt6x.exe when cpp code is compiled

Fixed in           : 6.1.6
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
A conditional loop inside an infinite loop -- in this case a do-while 
inside a while(1) -- may cause the optimiser to crash at -o1 or higher.

------------------------------------------------------------------------------
FIXED  SDSCM00028528
------------------------------------------------------------------------------

Summary            : Linker crash when split operator >> fails to allocate

Fixed in           : 6.1.6
Severity           : S2 - Major
Affected Component : Linker

Description: 
The linker could crash in certain instances when the split operator is 
used in a linker command file.


------------------------------------------------------------------------------
10. 6.1.5 Fixed Defects
------------------------------------------------------------------------------

------------------------------------------------------------------------------
FIXED  SDSCM00014762
------------------------------------------------------------------------------

Summary            : Main routine return not associated with closing brace

Fixed in           : 6.1.5
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
This bug causes wrong code coverage or profiling information. It
happens only around main routine's closing }. Coverage or execution count 
could be wrong because of the wrong source position information.

------------------------------------------------------------------------------
FIXED  SDSCM00025827
------------------------------------------------------------------------------

Summary            : out of memory error during full opt compile

Fixed in           : 6.1.5
Severity           : S3 - Minor
Affected Component : Optimizer

Description: 
A pathological loop may cause the optimiser to repeat internally until
it runs out of memory.  

------------------------------------------------------------------------------
FIXED  SDSCM00026786
------------------------------------------------------------------------------

Summary            : In CG Toolsv6.1.2, the hex6x.exe -fill option will not
		     accept a 0xFFFFFFFF

Fixed in           : 6.1.5
Severity           : S3 - Minor
Affected Component : Hex Converter (hex)

Description: 
The hex utility -fill option will only accept unsigned values from 0x0
to 0x7FFFFFFF.  A value of 0xFFFFFFFF will be not be accepted and will
cause an 'out of range' error.
 
------------------------------------------------------------------------------
FIXED  SDSCM00026798
------------------------------------------------------------------------------

Summary            : Linker mishandles forward references to symbols defined in
		     the command file

Fixed in           : 6.1.5
Severity           : S2 - Major
Affected Component : Linker

Description: 
We changed to the behavior to interpret the linker command file as
shown below. This is specifically to meet the requirement of the BIOS team.

In linker command file, if X=Y and Y has not been assigned a value:

1) replace Y with zero, Y could be a expression tree and Y could appear
multiple times in this tree, so we need to walk through the tree and do
the replacement.

2) issue a warning

------------------------------------------------------------------------------
FIXED  SDSCM00026937
------------------------------------------------------------------------------

Summary            : INTERNAL ERROR lnk6x.exe aborted

Fixed in           : 6.1.5
Severity           : S2 - Major
Affected Component : Linker

------------------------------------------------------------------------------
FIXED  SDSCM00027055
------------------------------------------------------------------------------

Summary            : C6x compiler miscalculates memory address

Fixed in           : 6.1.5
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
An array subscript that uses an unsigned subtraction may cause a 
reference to the wrong memory location.  The unsigned subtraction will
be rendered as an addition of the negated subtrahend, and negating an 
unsigned integer produces a large value because of the wraparound 
behavior of unsigned types in C.  An integer close to the maximum value
for its type could be incorrectly truncated when appearing in a
subscript.

------------------------------------------------------------------------------
FIXED  SDSCM00027452
------------------------------------------------------------------------------

Summary            : Update assembler to work around hardware defect - double
		     precision unary instructions
		     incorrectly load src1 field

Fixed in           : 6.1.5
Severity           : S2 - Major
Affected Component : Assembler

------------------------------------------------------------------------------
FIXED  SDSCM00027485
------------------------------------------------------------------------------

Summary            : Change warning to remark for load_size() operator

Fixed in           : 6.1.5
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)


------------------------------------------------------------------------------
11. 6.1.4 Fixed Defects
------------------------------------------------------------------------------

------------------------------------------------------------------------------
FIXED  SDSCM00024784
------------------------------------------------------------------------------

Summary            : C++ file level variables inside a namespace mistakenly
		     disallowed from using DATA_SECTION pragma

Fixed in           : 6.1.4
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
File level pragmas have been updated to operate on symbols declared 
within namespaces.

------------------------------------------------------------------------------
FIXED  SDSCM00025285
------------------------------------------------------------------------------

Summary            : Linker does not honor allocation based on memory attribute
		     of a region

Fixed in           : 6.1.4
Severity           : S3 - Minor
Affected Component : Linker

Description: 
Linker does not honor allocation based on memory attribute of a region.

For example,
MEMORY
{
    ROM (RW)  org = 0x00000020	 len = 0x00005000  /* ROM */
    RAM (RX)  org = 0x00006000	 len = 0x0007FFE0  /* SYSTEM RAM    */
}

SECTIONS
{
    .text     {} > (RX) 
}

This should allocate the .text section to any memory range that has the 
attribute RX. However, the linker does not honor this allocation. 

If a memory attribute is specified for allocation the linker will match 
any memory region that has the 'R' attribute specified.

------------------------------------------------------------------------------
FIXED  SDSCM00025300
------------------------------------------------------------------------------

Summary            : Optimizer optimizes out destructor code

Fixed in           : 6.1.4
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
An optimisation intended to improve code size may mishandle destructors 
that inline other destructors, causing writes within the destructor to be 
lost.

------------------------------------------------------------------------------
FIXED  SDSCM00026310
------------------------------------------------------------------------------

Summary            : Linker mishandles ROM addresses by emitting false error
		     messages and unnecessary trampolines

Fixed in           : 6.1.4
Severity           : S2 - Major
Affected Component : Linker

Description: 
When the user hard-coded a symbol to an absolute address using the .set
directive (in assembly source), the linker was incorrectly emitting a 
warning and an unnecessary trampoline.	The warning stated that a 
trampoline was conservatively generated.

------------------------------------------------------------------------------
FIXED  SDSCM00026314
------------------------------------------------------------------------------

Summary            : opt6x.exe fails with segmentation fault

Fixed in           : 6.1.4
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
Use of certain intrinsics -- _gmpy and the _efi ops for C6x -- in a 
non-trivial function (including through inlining) can read an uninitialised 
memory location in the optimiser, potentially causing a crash.

------------------------------------------------------------------------------
FIXED  SDSCM00026319
------------------------------------------------------------------------------

Summary            : Linker crashes on large build

Fixed in           : 6.1.4
Severity           : S1 - Critical / PS
Affected Component : Linker

Description: 
Customer reported an INTERNAL ERROR during linking.

------------------------------------------------------------------------------
FIXED  SDSCM00026414
------------------------------------------------------------------------------

Summary            : Optimizer generates incorrect code for bitwise AND operator

Fixed in           : 6.1.4
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
The optimiser will erroneously transform "((1 << x) & y) == 1" into
"((y >> x) & 1) == 1" which is not equivalent.

------------------------------------------------------------------------------
FIXED  SDSCM00026466
------------------------------------------------------------------------------

Summary            : Different results are generated when -o3 used

Fixed in           : 6.1.4
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
If a single function calls memcpy() twice with the same destination, and 
that destination is a scalar variable or scalar-typed memory reference, 
the compiler may erroneously consider the destination to hold the same 
value after the second memcpy() as after the first.  In other words, it 
will lose the effect of the second memcpy().

------------------------------------------------------------------------------
FIXED  SDSCM00026799
------------------------------------------------------------------------------

Summary            : optimizer produces unexpected result for code involving
		     shift and multiplication

Fixed in           : 6.1.4
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
An expression like "(X >> k1) * i2", where i2 is a constant power of two 
less than 2^k1 and of an unsigned type narrower than X's type, may be 
converted into an expression that loses the upper bits of "X >> k1".  
"Constant" in this case means a literal integer or a globally const 
variable whose value is a literal integer.

------------------------------------------------------------------------------
FIXED  SDSCM00027012
------------------------------------------------------------------------------

Summary            : pdd6x on Windows/OS fatal error Invalid dataset
		     magic-version id combination TIPPRD-33554432

Fixed in           : 6.1.4
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
When using pdd6x under Windows/OS a fatal error is generated "invalid 
dataset magic-version id."

------------------------------------------------------------------------------
FIXED  SDSCM00027013
------------------------------------------------------------------------------

Summary            : cl6x --use_profile_info --onlycodecov not producing a .csv
		     file

Fixed in           : 6.1.4
Severity           : S2 - Major
Affected Component : Path Profiler (pprof)

Description: 
If the --gen_profile_info option is used when compiling source 
files specified with relative pathnames (i.e. cl6x ../t.c), the profile 
info for these files is ignored when the --use_profile_option is used for 
feedback based optimization or code coverage analysis.

------------------------------------------------------------------------------
FIXED  SDSCM00027036
------------------------------------------------------------------------------

Summary            : cl6x shell help places profiling options under "Internal
		     Support Options"

Fixed in           : 6.1.4
Severity           : S3 - Minor
Affected Component : Shell

Description: 
The compiler feedback based optimizations and code coverage options were 
grouped under "Internal Options" when using the cl6x --help option.  They 
are now grouped under "Feedback Options".

------------------------------------------------------------------------------
FIXED  SDSCM00027037
------------------------------------------------------------------------------

Summary            : pdd6x help incorrectly says "This tool is designed to be
		     invoked by the compiler."

Fixed in           : 6.1.4
Severity           : S3 - Minor
Affected Component : Profile Based Compilation

Description: 
The pdd6x help screen is not displaying its options and is incorrectly 
saying that it should not be invoked as a standalone tool.

------------------------------------------------------------------------------
12. 6.1.3 Fixed Defects
------------------------------------------------------------------------------

------------------------------------------------------------------------------
FIXED  SDSCM00021997
------------------------------------------------------------------------------

Summary            : Optimizer abnormally terminates for C6400/C64+/C6470 

Fixed in           : 6.1.3
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
An expression that sums four variables, all short or narrower, whose 
result is cast to char, may be internally converted to an idiom that 
triggers an optimiser abort.


Workaround: 
The specific failure involved a sum of four variables with a result
cast to short or char, where one of the variables was short, for C6x.  
Avoiding that situation would avoid the bug, for example by using wider
types for the variables or breaking up the larger addition with 
intervening global or volatile variables.  Or more simply, compile with

-o1 or less, or use --vectorize=off.

------------------------------------------------------------------------------
FIXED  SDSCM00023555
------------------------------------------------------------------------------

Summary            : strtol() and stroll() don't convert LONG_MIN/LLONG_MIN

Fixed in           : 6.1.3
Severity           : S2 - Major
Affected Component : Runtime Support Libraries (RTS)

Description: 
strtol() and strtoll() set errno to ERANGE if called to convert the string 
representation of LONG_MIN or LLONG_MIN, respectively.

------------------------------------------------------------------------------
FIXED  SDSCM00024989
------------------------------------------------------------------------------

Summary            : 64-bit expression constant-folded to incorrect value.

Fixed in           : 6.1.3
Severity           : S3 - Minor
Affected Component : Optimizer

Description: 
Division of a 64-bit long-long dividend can be incorrectly folded into
a constant.

Workaround: 
The problem seems specific to division of a 64-bit long-long dividend. 
Shorter types and different operations don't exhibit the same issue.

------------------------------------------------------------------------------
FIXED  SDSCM00025030
------------------------------------------------------------------------------

Summary            : Parser does not generate error for declaration after
		     executable statement when compiling in
		     relaxed ANSI mode

Fixed in           : 6.1.3
Severity           : S2 - Major
Affected Component : Parser

Description: 
The parser will not generate an error in relaxed mode for a declaration
made after a statement.  For example

a = b + c;
int i = 0;

will not generate an error with the -pr switch.  The fix for the bug is
that the parser diagnostic switches can be used to enable this error.

-pr -pdse=270 will generate an error
-pr -pdsw=270 will generate a warning
-pr -pdsr=270 will generate a remark

------------------------------------------------------------------------------
FIXED  SDSCM00025281
------------------------------------------------------------------------------

Summary            : 64 bit addition needlessly complicated

Fixed in           : 6.1.3
Severity           : S3 - Minor
Affected Component : C/C++ Compiler (cl)

Description: 
Additions involving signed/unsigned ints were being needlessly 
complicated when the result was assigned to a long long. In other
words, when the compiler encountered assignments of the form

long long = int + int
long long = unsigned int + unsigned int

it converted the int/unsigned int variables into long long and
performed 64-bit additions. This is inefficient, as C6000 has a single
instruction to add two 32-bit entities and assign the result to a 
40-bit entity (that takes a 64-bit register pair).

------------------------------------------------------------------------------
FIXED  SDSCM00025368
------------------------------------------------------------------------------

Summary            : compiler generates incorrect code for expression (a-b)%4
		     when a and b are both unsigned short int.

Fixed in           : 6.1.3
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
The optimiser may generate incorrect code for the expression (a-b)%c. 
It changes it to (a%c-b%c)%c in hopes of eliminating the outer %c and 
producing a simpler version of a%c-b%c.  However, that will not work
for cases such as
 (8-7)%4 = 1, 8%4 - 7%4 = -3.

Workaround: 
The compiler is looking for the exact pattern (a-b)%c, so avoiding the 
pattern will work around the problem.  The problem arises when the 
difference is negative, so avoiding cases where b>a will also work
around the problem.

------------------------------------------------------------------------------
FIXED  SDSCM00025372
------------------------------------------------------------------------------

Summary            : The -h linker option hides undefined references

Fixed in           : 6.1.3
Severity           : S2 - Major
Affected Component : Linker

Description: 
The linker hides unresolved symbols with the -h switch during a partial
link.

------------------------------------------------------------------------------
FIXED  SDSCM00025652
------------------------------------------------------------------------------

Summary            : Using --beginopts --endopts on function not in source file
		     unexpectedly affects how code is generated

Fixed in           : 6.1.3
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
The -mf and -ms options when used as override options for a function
not in source file, should make no difference to the code generated. The
code generated should be the same as when there are no override options.
But the override options seemed to influence the options the shell passed
to the parser, optimizer and code generator.

Workaround: 
In the generic case, put the function with overrides into a special
file, and compile separately with the special options. Then, link everything 
together. In this specific case, workaround is to not use the override options 
as the function for which these are used does not exist.

------------------------------------------------------------------------------
FIXED  SDSCM00025712
------------------------------------------------------------------------------

Summary            : Compiler crashes on zero-length array GCC extension

Fixed in           : 6.1.3
Severity           : S2 - Major
Affected Component : Code Generator

Workaround: 
Do not compile with --gcc.

------------------------------------------------------------------------------
FIXED  SDSCM00025935
------------------------------------------------------------------------------

Summary            : Optimizer terminated abnormally with "-o3" option

Fixed in           : 6.1.3
Severity           : S3 - Minor
Affected Component : C/C++ Compiler (cl)

Description: 
Under certain obscure circumstances, an expression used as an argument
to memcpy() can be mishandled in such a way that it fails a 
memcpy()-specific sanity check and causes an optimiser abort.  The 
circumstances involve memcpy() and a literal constant that appears in
the argument and also elsewhere in the function.

Workaround: 
No easy workaround.  The problem involves faulty handling of arguments
to memcpy() when the same literal constant appears in an argument and also
in other places within the function.  Restructuring the code can avoid 
the problem, but there's no simple formula.

------------------------------------------------------------------------------
FIXED  SDSCM00026083
------------------------------------------------------------------------------

Summary            : Optimizer crash on inline function with CSR cregister

Fixed in           : 6.1.3
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
The optimiser may abort at -o2 or -o3 if an operation on a volatile 
variable (such as a control register) is specified incorrectly within
one of the cases of an IF statement with a simple condition.

The bug is harmless unless a statement intended to modify a volatile 
variable doesn't actually modify it;  then, by the rules of "volatile"
in C/C++, the reference to the variable may remain although the rest of
the statement is optimised away.  This disembodied variable reference is a
pre-condition for the optimiser abort.

For example, in this case the statement

  _clr(CSR,9,9);

was used, intending to modify CSR (which is a volatile 
control-register variable).  However, the meaning of _clr() is that it 
clears a field in its first argument and returns that new value;  _clr 
does not itself write to its first argument.  The correct statement is

  CSR = _clr(CSR,9,9);

which writes the modified value back to CSR.  Using this statement 
instead of the incorrect one will avoid the bug even when using an 
unpatched optimiser.


Workaround: 
One of the requirements for this problem to occur is that an operation
on a volatile variable be specified incorrectly;  the workaround therefore
is to specify the operation correctly.	


------------------------------------------------------------------------------
13. 6.1.2 Fixed Defects
------------------------------------------------------------------------------

------------------------------------------------------------------------------
FIXED  SDSCM00023135
------------------------------------------------------------------------------

Summary            : Symbol substitution fails if more than one symbol in
		     expression

Fixed in           : 6.1.2
Severity           : S3 - Minor
Affected Component : Assembler

------------------------------------------------------------------------------
FIXED  SDSCM00024893
------------------------------------------------------------------------------

Summary            : RTS snprintf() copies one additional character to the
		     output array

Fixed in           : 6.1.2
Severity           : S2 - Major
Affected Component : Runtime Support Libraries (RTS)

Description: 
When a user tries to copy n characters to a buffer by snprintf, or
vsnprintf, it copies n characters plus a NULL terminating character to 
the buffer.  According to the standard, it should copy n-1 plus a NULL 
terminating character to the buffer.

------------------------------------------------------------------------------
FIXED  SDSCM00025119
------------------------------------------------------------------------------

Summary            : Linker is overwriting uninitialized allocated sections

Fixed in           : 6.1.2
Severity           : S1 - Critical / PS
Affected Component : Linker


------------------------------------------------------------------------------
14. 6.1.1 Fixed Defects
------------------------------------------------------------------------------

------------------------------------------------------------------------------
FIXED  SDSCM00021840
------------------------------------------------------------------------------

Summary            : Failure to propagate increments in unrolled loop causes
		     large loop-carried dependence

Fixed in           : 6.1.1
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
A loop unrolled with "#pragma UNROLL" may fail to propagate the
increments of the loop variables through the unrolled iterations, leading 
to an artificially-increased loop-carried dependence bound and a consequent 
loss in performance.

------------------------------------------------------------------------------
FIXED  SDSCM00023045
------------------------------------------------------------------------------

Summary            : rts library for 6x/6.1.0B1 still has some .bss (some 
                     static data still missing _DATA_ACCESS keyword)

Fixed in           : 6.1.1
Severity           : S2 - Major
Affected Component : Runtime Support Libraries (RTS)

------------------------------------------------------------------------------
FIXED  SDSCM00023086
------------------------------------------------------------------------------

Summary            : Test case hangs forever in 'for' loop when optimization 
                     is enabled

Fixed in           : 6.1.1
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
A loop may be improperly converted into an infinite loop if its trip
count is larger than will fit in the type of the loop index variable.  
For example, a for-loop from CHAR_MIN to CHAR_MAX when the loop variable is 
of type "signed char" -- the trip count is larger than CHAR_MAX.

------------------------------------------------------------------------------
FIXED  SDSCM00023269
------------------------------------------------------------------------------

Summary            : Testcase with -1L mutiplication is incorrect

Fixed in           : 6.1.1
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
Multiplying an int by -1L or its unsigned equivalent may produce the 
wrong answer when compiled with optimisation.

------------------------------------------------------------------------------
FIXED  SDSCM00023429
------------------------------------------------------------------------------

Summary            : Test cases fail with -o0 or no optimization

Fixed in           : 6.1.1
Severity           : S3 - Minor
Affected Component : C/C++ Compiler (cl)

Description: 
The compiler may incorrectly delete conditional instructions. This can 
happen in cases where non-integer constants are extensively used. 

------------------------------------------------------------------------------
FIXED  SDSCM00023568
------------------------------------------------------------------------------

Summary            : Test case of lhs ++ and += side effects fails when built 
                     with code size optimization (-ms) flag

Fixed in           : 6.1.1
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
An expression like "*(f()) += 2;", where f() has side effects, may be 
incorrectly expanded into "*(f()) = *(f()) + 2;" while attempting to 
vectorise a loop.  The likelihood is influenced by the amount of
inlining nearby;  if f() itself inlines, there is no problem.

------------------------------------------------------------------------------
FIXED  SDSCM00023650
------------------------------------------------------------------------------

Summary            : cg6x abnormally terminates with "OUT OF MEMORY" message 

Fixed in           : 6.1.1
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

------------------------------------------------------------------------------
FIXED  SDSCM00023946
------------------------------------------------------------------------------

Summary            : A pipeline optimized loop is missing a memory read
		     operation in the loop kernel.

Fixed in           : 6.1.1
Severity           : S3 - Minor
Affected Component : Assembler

Description: 
A structure field that is read one way but written another can be 
incorrectly transformed in a way that gives incorrect results,
especially in a pipelined loop but also other ways.  One example is a 
field in a base class that is accessed through an inlined derived-class
member function -- one reference starts at the derived class and does
two field references (one to reach the base class, the other to reach the 
field), while the other uses a pointer cast to the base class and does 
only one field reference.  Another example is an object with a pointer 
field that is set to point to another field in another object;	then
that common field can be reached through either object.

------------------------------------------------------------------------------
FIXED  SDSCM00024008
------------------------------------------------------------------------------

Summary            : Incorrect code generated for quest operator 

Fixed in           : 6.1.1
Severity           : S2 - Major
Affected Component : Optimizer

------------------------------------------------------------------------------
FIXED  SDSCM00024103
------------------------------------------------------------------------------

Summary            : Test cases cause optimizer to hang 

Fixed in           : 6.1.1
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
The expression "(&x-&y)&1" can cause the optimiser to hang.  

------------------------------------------------------------------------------
FIXED  SDSCM00024161
------------------------------------------------------------------------------

Summary            : Compiler generates STW instead of STNW for _mem4 intrinsic
		     on LHS of assignment and a long long expression on RHS.

Fixed in           : 6.1.1
Severity           : S2 - Major
Affected Component : Code Generator

Description: 
The C6000 compiler was generating incorrect code for a very uncommon
construct where the lower 32 bits of a long long are being stored to an
unaligned memory address via the _mem4 intrinsic.  Furthermore, this
only occurred if the lower 32-bits of the long long were not obtained with
the _loll intrinsic but rather an implicit conversion.

------------------------------------------------------------------------------
FIXED  SDSCM00024162
------------------------------------------------------------------------------

Summary            : Optimiser aborts with C source code

Fixed in           : 6.1.1
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
The optimiser may abort while trying to vectorise a loop containing an 
expression for which an operand is a recurrence variable and the 
operation does not have a native instruction at the vectorisation
level.
  
------------------------------------------------------------------------------
FIXED  SDSCM00024278
------------------------------------------------------------------------------

Summary            : Compiler rewrites address register used for store with a
		     load to that address register in SPLOOP

Fixed in           : 6.1.1
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
On C6400+, the compiler can generate incorrect code when

(1) a load from a volatile-qualified pointer occurs late in the loop,

(2) the result of the load is not used (i.e., not in the loop, not in
the function, not returned),

(3) and the compiler decides to use the software pipelined loop buffer 
(SPLOOP).


------------------------------------------------------------------------------
15. 6.1.0 Fixed Defects
------------------------------------------------------------------------------

------------------------------------------------------------------------------
FIXED  SDSCM00020501
------------------------------------------------------------------------------

Summary            : compiler is scheduling use of A8 too early causing
		     incorrect branch

Fixed in           : 6.1.0
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
The compiler does not model multi-cycle reads in the scheduler. It 
therefore could incorrectly schedule code with too many register reads 
happening at the most aggressive optimization levels.  A detection mechanism
has been added to detect when this problem occurs.  An Error Message is 
generated to allow the user to tone down the optimization level. This only 
happens with the C67x target.

Workaround: 
Reduce the speed optimization Level.
Use the -ms0, -ms1 switches.

------------------------------------------------------------------------------
FIXED  SDSCM00022489
------------------------------------------------------------------------------

Summary            : C6x _mem4 intrinsic crashes compiler when used on the lhs
		     of an assignment

Fixed in           : 6.1.0
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
The problem only happens when the user tries to write 64bit result to
32 bit unaligned memory. 

------------------------------------------------------------------------------
FIXED  SDSCM00023266
------------------------------------------------------------------------------

Summary            : End pointer incorrect for strtol, strtoll

Fixed in           : 6.1.0
Severity           : S2 - Major
Affected Component : Runtime Support Libraries (RTS)

Description: 
The functions strtol() and strtoll() have a parameter, char **endptr,
which should point to the first invalid character found in the input string
on return from the call.  In other words, endptr should inform the caller
of the point at which the conversion of the input string stopped.  In 
the case of a hex string conversion, the input string may be preceded
with "0x", but this is not required.  Therefore, an input string of the form
"0xz" converted to base 16 should return zero as the long (or long
long) value, and endptr should point to the 'x' character.  The error in the
code caused endptr to point to the '0' character on return.	

------------------------------------------------------------------------------
FIXED  SDSCM00023321
------------------------------------------------------------------------------

Summary            : Optimizer terminated abnormally with CG Tools v6.1.0B2

Fixed in           : 6.1.0
Severity           : S3 - Minor
Affected Component : Code Generator

Description: 
A program fragment like

  x += e1; x += e2; x += e3; x += e4;

where x and all the ei are char (signed or unsigned) can cause an 
optimiser abort.  The key elements are the summing of four elements
into a single accumulator and that all values are eight bits.

------------------------------------------------------------------------------
FIXED  SDSCM00023402
------------------------------------------------------------------------------

Summary            : Compiler generates code without correct conditional value

Fixed in           : 6.1.0
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
In rare circumstances when using a specific class of large constants in
a statement located within a conditional block (e.g., an if-then or 
if-then-else statement block), the compiler tools may erroneously omit
a necessary predicate/condition register on certain instructions related
to the constant.

------------------------------------------------------------------------------
FIXED  SDSCM00023482
------------------------------------------------------------------------------

Summary            : Matrix, disable c64+ L1D cache bug workaround in compiler &
		     warning in assembler

Fixed in           : 6.1.0
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
The C64+ L1D Cache hardware defect workaround is not required for
C674x. This workaround has been disabled.

------------------------------------------------------------------------------
FIXED  SDSCM00023502
------------------------------------------------------------------------------

Summary            : pdd6x generates fatal error Invalid endianness for dataset
		     TIPPRD

Fixed in           : 6.1.0
Severity           : S2 - Major
Affected Component : Path Profiler (pprof)

Description: 
The profile data file (.pdat) was not opened in binary mode resulting
in a corrupt file on Windows based hosts.


------------------------------------------------------------------------------
16. 6.1.0B2 Fixed Defects
------------------------------------------------------------------------------

------------------------------------------------------------------------------
FIXED  SDSCM00014134
------------------------------------------------------------------------------

Summary            : OFD DW_AT_name wrong on linear asm files

Fixed in           : 6.1.0B2
Severity           : S3 - Minor
Affected Component : OFD Utility

------------------------------------------------------------------------------
FIXED  SDSCM00017011
------------------------------------------------------------------------------

Summary            : Spurious redeclaration warning with -pm when mixing C and
		     C++ and BIOS header

Fixed in           : 6.1.0B2
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
Compiler emits spurious incompatible type warnings with -pm. Fixed.

------------------------------------------------------------------------------
FIXED  SDSCM00017122
------------------------------------------------------------------------------

Summary            : pragma PACK is not supported, but is not rejected

Fixed in           : 6.1.0B2
Severity           : S2 - Major
Affected Component : Parser

Description: 
pragma PACK is accepted and acted upon even though the result is likely
to be incorrect code.

------------------------------------------------------------------------------
FIXED  SDSCM00017388
------------------------------------------------------------------------------

Summary            : SUBSP.S2X  A5, B12, B17 disassembles incorrectly

Fixed in           : 6.1.0B2
Severity           : S3 - Minor
Affected Component : Disassembler (dis)

------------------------------------------------------------------------------
FIXED  SDSCM00019940
------------------------------------------------------------------------------

Summary            : C6000 Floating point divide routine does not handle
		     overflow or underflow correctly.

Fixed in           : 6.1.0B2
Severity           : S2 - Major
Affected Component : Runtime Support Libraries (RTS)

------------------------------------------------------------------------------
FIXED  SDSCM00020090
------------------------------------------------------------------------------

Summary            : All RTS static variables should be declared with the
		     _DATA_ACCESS modifier

Fixed in           : 6.1.0B2
Severity           : S2 - Major
Affected Component : Runtime Support Libraries (RTS)

Description: 
This fix updates the atexit mechanism to add the missing _DATA_ACCESS 
qualifier to the globals introduced as part of the atexit handler. 

------------------------------------------------------------------------------
FIXED  SDSCM00020444
------------------------------------------------------------------------------

Summary            : Structure contents are not corectly displayed in watch
		     window

Fixed in           : 6.1.0B2
Severity           : S2 - Major
Affected Component : Linker

Description: 
The bug is caused by wrong type merging.  It only affects stab debugging.

------------------------------------------------------------------------------
FIXED  SDSCM00020600
------------------------------------------------------------------------------

Summary            : Evaluate if the call to "malloc" can be completely removed
		     from atexit

Fixed in           : 6.1.0B2
Severity           : S3 - Minor
Affected Component : C/C++ Compiler (cl)

Description: 
The RTS function atexit references malloc. Therefore any application 
registering atexit functions has the malloc source linked in.  This change 
updates the RTS to remove any reference to malloc from atexit. When 
registering atexit functions the users will no longer have the penalty of 
having the malloc source linked in. However, the maximum number of atexit 
functions that can be registered going forth is 32 which is the minimum 
required by the C standard. Users requiring more than that have to update 
atexit.c in the RTS source and rebuild the RTS.

------------------------------------------------------------------------------
FIXED  SDSCM00020930
------------------------------------------------------------------------------

Summary            : linker does not always check for bad usage of memory range
		     in placement instruction

Fixed in           : 6.1.0B2
Severity           : S2 - Major
Affected Component : Linker

------------------------------------------------------------------------------
FIXED  SDSCM00020993
------------------------------------------------------------------------------

Summary            : Linker hangs

Fixed in           : 6.1.0B2
Severity           : S2 - Major
Affected Component : Linker

------------------------------------------------------------------------------
FIXED  SDSCM00021046
------------------------------------------------------------------------------

Summary            : New Linker crashes on C++ test cases compiled with
		     optimization and COFF debug

Fixed in           : 6.1.0B2
Severity           : S2 - Major
Affected Component : Linker

------------------------------------------------------------------------------
FIXED  SDSCM00021142
------------------------------------------------------------------------------

Summary            : Optimiser may improperly truncate assignment to bitfield if
		     implicit widening cast

Fixed in           : 6.1.0B2
Severity           : S3 - Minor
Affected Component : C/C++ Compiler (cl)

------------------------------------------------------------------------------
FIXED  SDSCM00021143
------------------------------------------------------------------------------

Summary            : Compiler performs incorrect calculation if a temp variable
		     was used to hold the result of a subtraction

Fixed in           : 6.1.0B2
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
A pair of statements like "tmp = B - A;  A = A - tmp;" may compile 
incorrectly.  The two combine to form "A - (B - A)";  internally, both 
A's are flagged with the same number, and when the expression is 
simplified to "2*A - B" that internal number is mistakenly applied to
2*A which is erroneously replaced with A.

------------------------------------------------------------------------------
FIXED  SDSCM00021231
------------------------------------------------------------------------------

Summary            : WCHAR_MAX macro has inconsistent definitions

Fixed in           : 6.1.0B2
Severity           : S3 - Minor
Affected Component : Runtime Support Libraries (RTS)

------------------------------------------------------------------------------
FIXED  SDSCM00021234
------------------------------------------------------------------------------

Summary            : String constant argument uses absolute addressing even with
		     --dprel

Fixed in           : 6.1.0B2
Severity           : S2 - Major
Affected Component : Code Generator

Description: 
String literal constants are addressed absolutely, even when using
--dprel.

------------------------------------------------------------------------------
FIXED  SDSCM00021271
------------------------------------------------------------------------------

Summary            : linker generates INTERNAL ERROR when split placement
		     specified on a UNION containing uninitialized members

Fixed in           : 6.1.0B2
Severity           : S2 - Major
Affected Component : Linker

------------------------------------------------------------------------------
FIXED  SDSCM00021394
------------------------------------------------------------------------------

Summary            : Definitions for limits of integer types in stdint.h does
		     not conform to standard

Fixed in           : 6.1.0B2
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
According to C99 standard (7.18.2 paragraph 2) each macro that defines
the min/max values for the types declared in <stdint.h> must be

'suitable for use in #if preprocessing directives, and ... shall have
the same type as would an expression that is an object of the
corresponding type converted according to the integer promotion.'

The  implementation of these macros did not meet the C99 requirements
because they use casts (generating errors if used in #if directives)
and the casts were not to appropriate types for the values represented
when promoted.

Rewrote these macros to remove the casts and choose appropriately
formed constant values that will have the type as required when
evaluated in an expression.

------------------------------------------------------------------------------
FIXED  SDSCM00021830
------------------------------------------------------------------------------

Summary            : asm6x allows erroneous crosspath on register pair for some
		     C6x instructions

Fixed in           : 6.1.0B2
Severity           : S2 - Major
Affected Component : Assembler

Description: 
The assembler was not appropriately checking for the inappropriate use
of a cross path for long operand regpairs for three c6x instructions ssub,
ddotpl2r, and ddotph2r.  

------------------------------------------------------------------------------
FIXED  SDSCM00021837
------------------------------------------------------------------------------

Summary            : C++ library output using streams may overrun the underlying
		     buffer

Fixed in           : 6.1.0B2
Severity           : S2 - Major
Affected Component : Runtime Support Libraries (RTS)

Description: 
When using C++ I/O streams for output, a buffer overrun condition may
occur, causing memory corruption or a program crash. This occurs when more
than BUFSIZ (usually 256) characters are written into the stream without
being flushed.  (Generally, for line buffered streams such as stdcout,
writing stdendl into the stream causes it to be flushed, so this condition
would only occur when more than 256 characters are written without any
intervening stdendl's).

For example

#include <iostream>

int main()
{
   for (int i = 0; i < 300; ++i)
      cout << 'x';   // overruns after 256 characters written
}

------------------------------------------------------------------------------
FIXED  SDSCM00021846
------------------------------------------------------------------------------

Summary            : Comparison between bitfield and unsigned char fails when
		     optimization enabled

Fixed in           : 6.1.0B2
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
Arithmetic comparisons of a very specific form -- "x > k" and "x <= k",
where k is an unsigned constant of a type smaller than int whose value
is the maximum for that type -- can be miscompiled.  The specific value
and test are important because the bug is in the transformation of "x > k" 
into "x >= k+1" and "x <= k" into "x < k+1".

------------------------------------------------------------------------------
FIXED  SDSCM00021849
------------------------------------------------------------------------------

Summary            : Structure test cases fail when optimization is enabled

Fixed in           : 6.1.0B2
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
A whole-struct assignment -- "x = y" when both x and y are struct-typed
variables -- may be incorrectly compiled if the structs are small 
(typically 2*sizeof(int) or less) and contain embedded arrays.

------------------------------------------------------------------------------
FIXED  SDSCM00021934
------------------------------------------------------------------------------

Summary            : Linker generates runtime error R6025

Fixed in           : 6.1.0B2
Severity           : S2 - Major
Affected Component : Linker

------------------------------------------------------------------------------
FIXED  SDSCM00021939
------------------------------------------------------------------------------

Summary            : Use of _mem4 intrinsic leads to incorrect usage of aligned
		     load instructions

Fixed in           : 6.1.0B2
Severity           : S2 - Major
Affected Component : C/C++ Compiler (cl)

Description: 
A _mem4 intrinsic operating on a pointer-to-int may be erroneously 
removed and replaced with a normal aligned access.

------------------------------------------------------------------------------
FIXED  SDSCM00021965
------------------------------------------------------------------------------

Summary            : C6x RTS returns incorrect value when executing log10(0.0)
		     and log2(0.0)

Fixed in           : 6.1.0B2
Severity           : S3 - Minor
Affected Component : Runtime Support Libraries (RTS)

------------------------------------------------------------------------------
FIXED  SDSCM00022232
------------------------------------------------------------------------------

Summary            : Compiler fails to reload DP-relative address constant

Fixed in           : 6.1.0B2
Severity           : S2 - Major
Affected Component : Code Generator

Description: 
Under the --dprel switch, the compiler may fail to reload a DP-relative
address offset when there are multiple nearby references to the  same 
symbol. Instead the compiler will try to re-use the recently loaded 
offset rather than re-generate it. However if the second load requires 
different scaling than the first, this is incorrect.

------------------------------------------------------------------------------
FIXED  SDSCM00022300
------------------------------------------------------------------------------

Summary            : No code generated for assignment under --dprel

Fixed in           : 6.1.0B2
Severity           : S2 - Major
Affected Component : Code Generator

Description: 
When using the --dprel option, the compiler may sometimes fail to
generate any code for a simple assignment between two global or static 'far' 
variables.  For example

main()
{
   static far int a,b;
   a = b;     /* may not generate code under --dprel */
}

------------------------------------------------------------------------------
FIXED  SDSCM00022556
------------------------------------------------------------------------------

Summary            : Optimizer generates INTERNAL ERROR and a sementation fault

Fixed in           : 6.1.0B2
Severity           : S2 - Major
Affected Component : Optimizer

Description: 
Expressions mixing _hill or _loll and _itoll, or potentially other 
long-long and unsigned-long-long intrinsics, as predicate and
consequents of a ? expression could cause a divide-by-zero crash in the 
optimiser. 


------------------------------------------------------------------------------
17. 6.1.0B1 Fixed Defects
------------------------------------------------------------------------------

------------------------------------------------------------------------------
FIXED  SDSCM00000149
------------------------------------------------------------------------------

Summary            : Incorrect placement of DWARF debug info.

Fixed in           : 6.1.0B1
Severity           : 1 Production Stop
Affected Component : C/C++ Compiler

------------------------------------------------------------------------------
FIXED  SDSCM00000696
------------------------------------------------------------------------------

Summary            : compiler computes wrong value for the overflow case of
		     DOTPRSU2 under -o2

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : Optimizer

------------------------------------------------------------------------------
FIXED  SDSCM00001262
------------------------------------------------------------------------------

Summary            : optimizer produces wrong code for mem4

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Optimizer

------------------------------------------------------------------------------
FIXED  SDSCM00001274
------------------------------------------------------------------------------

Summary            : Infinite recursion and SIGSEGV for C6700

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Code Generator

Description: 
In very rare situations, floating-point code compiled for C67x can
cause the compiler to go into an infinite loop.

------------------------------------------------------------------------------
FIXED  SDSCM00002641
------------------------------------------------------------------------------

Summary            : "Linker (lnk6x.exe) crashes while linking large number of
		     object files"

Fixed in           : 6.1.0B1
Severity           : 1 Production Stop
Affected Component : Linker

------------------------------------------------------------------------------
FIXED  SDSCM00005280
------------------------------------------------------------------------------

Summary            : Error in disassembly of C672x Instruction

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : C/C++ Compiler

------------------------------------------------------------------------------
FIXED  SDSCM00008018
------------------------------------------------------------------------------

Summary            : codegen crashes when building library

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Code Generator

------------------------------------------------------------------------------
FIXED  SDSCM00008178
------------------------------------------------------------------------------

Summary            : Incorrect handling of static initialization of const
		     variables

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Optimizer

Description: 
Static initialization of const variables of an enum type are not done 
correctly if optimizer is used. 

------------------------------------------------------------------------------
FIXED  SDSCM00008183
------------------------------------------------------------------------------

Summary            : Speculation on SPLOOPW leads to wrong result if loop is
		     interrupted

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Optimizer

Description: 
Speculation on SPLOOPW leads to wrong result if loop is interrupted.

------------------------------------------------------------------------------
FIXED  SDSCM00008187
------------------------------------------------------------------------------

Summary            : Long long arithmetic computes incorrect result

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : C/C++ Compiler

Description: 
An expression involving a long value cast to long long is somehow sign-
extended when it should not have been. 

------------------------------------------------------------------------------
FIXED  SDSCM00008197
------------------------------------------------------------------------------

Summary            : Optimizer generates invalid results when unrolling a loop

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Assembly Optimizer

------------------------------------------------------------------------------
FIXED  SDSCM00008200
------------------------------------------------------------------------------

Summary            : Optimizer hangs when using inline functions in nested loops

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Optimizer

Description: 
A loop involving 16- and 32-bit data may take excessively long to
optimise if an expression within the loop uses labs(), which for C6x 
is defined for 40-bit integers and thus requires extra casts.

------------------------------------------------------------------------------
FIXED  SDSCM00008206
------------------------------------------------------------------------------

Summary            : Missing cast during SIMD corrupts bit fields in structure
		     at -o2/-o3

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Optimizer

Description: 
An assignment like "a.b = x" may produce incorrect results when a.b is
a bitfield (ie, "int b16") narrower than int and x is an expression with 
a type narrower than int.  If x contains a negative value, the assignment
to a.b can overwrite fields adjacent to a.b with the extended sign bits.

------------------------------------------------------------------------------
FIXED  SDSCM00008220
------------------------------------------------------------------------------

Summary            : Linker gen copy tables - copy_in does not handle copies
		     with 0 records

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Linker

------------------------------------------------------------------------------
FIXED  SDSCM00008284
------------------------------------------------------------------------------

Summary            : The compiler fails to choose B14 for long offset indexing

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Assembly Optimizer

------------------------------------------------------------------------------
FIXED  SDSCM00008296
------------------------------------------------------------------------------

Summary            : format changed for DW_OP_plus_uconst from hex to dec 
		     affects scripts

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : OFD Utility

Description: 
Changed format in OFD XML from hex to dec breaks scripts.

------------------------------------------------------------------------------
FIXED  SDSCM00008310
------------------------------------------------------------------------------

Summary            : linear assember file produces errors 

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Assembly Optimizer

Description: 
Assembly optimizer inputs using an ".end" directive to terminate the
file can cause the compiler to generate an assembly file the assembler
would reject.

------------------------------------------------------------------------------
FIXED  SDSCM00008332
------------------------------------------------------------------------------

Summary            : Output loop performance estimates in assembly file under
		     -mw

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Code Generator

------------------------------------------------------------------------------
FIXED  SDSCM00008344
------------------------------------------------------------------------------

Summary            : Wrong use of -b linker switch can cause linker crash.

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : Linker

Description: 
If the -b linker switch is used after listing the object files the 
linker will try to generate a warning.	However, the call to the 
linker warning routine can cause a linker crash.

------------------------------------------------------------------------------
FIXED  SDSCM00008350
------------------------------------------------------------------------------

Summary            : ilk6x.exe and acp6x.exe cannot handle long command lines on
		     XP

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : C/C++ Compiler

Description: 
FATAL ERROR failed while attemping to run ilk6x using the -pm option.

------------------------------------------------------------------------------
FIXED  SDSCM00008383
------------------------------------------------------------------------------

Summary            : Optimizer takes > 60 mins

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Code Generator

------------------------------------------------------------------------------
FIXED  SDSCM00008407
------------------------------------------------------------------------------

Summary            : Performance improvement around sploops

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Code Generator

------------------------------------------------------------------------------
FIXED  SDSCM00008428
------------------------------------------------------------------------------

Summary            : ASM code behavior difference between DA6xx and DA7xx

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Assembler

Description: 
Hand assembly code written for the C67x/DA6xx which did not have 
functional unit designations for ADDSP, SUBSP, ADDDP, and SUBDP 
instructions may be assigned to the S-unit by the assembler when 
assembling for the C67x+/DA7xx.  This may result in a S-unit resource 
conflict with other sebsequent S-unit instructions that the assembler 
does not detect, resulting in code that runs incorrectly.

------------------------------------------------------------------------------
FIXED  SDSCM00008446
------------------------------------------------------------------------------

Summary            : Optimizer incorrectly optimizes away loop at -o3

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Optimizer

Description: 
A function with two pointer parameters, which tests a condition based
on the difference of those two pointers, may incorrectly fold the test 
if caller and callee are in the same compilation unit and one of the
arguments points beyond the pointed-to data object.  (Ie, given "int
x[4]" the argument is x+4.)

------------------------------------------------------------------------------
FIXED  SDSCM00008448
------------------------------------------------------------------------------

Summary            : Cannot transform saturation intrinsics when the SAT bit is
		     read

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : Optimizer

Description: 
The optimizer may sometimes transform saturated intrinsic operations 
in such a way that the SAT bit in the CSR register is no longer set 
when saturation occurs.  If the original code is reading the sat bit 
in the CSR, the sat bit may not have been set correctly.

------------------------------------------------------------------------------
FIXED  SDSCM00008450
------------------------------------------------------------------------------

Summary            : Optimizer incorrectly transforms loop

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Optimizer

------------------------------------------------------------------------------
FIXED  SDSCM00008451
------------------------------------------------------------------------------

Summary            : Optimizer uses same results of unsigned / and % for signed
		     / and %

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Optimizer

Description: 
Compiler may generate incorrect code when using optimization on code 
that computes an unsigned divide (or modulus) followed by a signed 
divide (or modulus) when using the same inputs.

------------------------------------------------------------------------------
FIXED  SDSCM00008643
------------------------------------------------------------------------------

Summary            : Linker complains about compiler generated '.template'
		     section

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : Linker

Description: 
Fixed the linker to not emit missing SECTIONS specification warning for
sections that do not get assigned to memory. E.g. .template sections

------------------------------------------------------------------------------
FIXED  SDSCM00008673
------------------------------------------------------------------------------

Summary            : Very long error message crashes assembler

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : Assembler

------------------------------------------------------------------------------
FIXED  SDSCM00008800
------------------------------------------------------------------------------

Summary            : Linker symbols at the same address should be alphabetical
		     in map file

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : Linker

------------------------------------------------------------------------------
FIXED  SDSCM00009796
------------------------------------------------------------------------------

Summary            : Codegen fails to schedule loop with code that accesses the
		     IER

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Code Generator

Description: 
The C6x compiler fails to schedule loop with predicated barrier
instructions (e.g. MVC instructions that access the IER). This is now
fixed.

------------------------------------------------------------------------------
FIXED  SDSCM00009799
------------------------------------------------------------------------------

Summary            : IF statement gives unexpected results

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : C/C++ Compiler

------------------------------------------------------------------------------
FIXED  SDSCM00009814
------------------------------------------------------------------------------

Summary            : ltoa function can not convert the long minimum val
		     -2147483648 to ascii

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Runtime Support Libraries (RTS)

Description: 
This bug is caused by incorrect handling of LONG_MIN by the ltoa
function in the compiler RTS, and is now fixed.

------------------------------------------------------------------------------
FIXED  SDSCM00009857
------------------------------------------------------------------------------

Summary            : XML options dump not showing LINKER options

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Shell

Description: 
XML option description produced by the compiler has two <TOOL tag="COMPILER"> 
entities while the second should read <TOOL tag="LINKER">.

------------------------------------------------------------------------------
FIXED  SDSCM00010051
------------------------------------------------------------------------------

Summary            : Empty inner loop is incorrectly removed by the optimizer

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Optimizer

Description: 
A loop nest for which the inner loop is empty -- containing only an
increment of its index variable -- may be transformed incorrectly when 
the index variable is initialised outside the outer loop.  In other words, 
the problem arises when the inner loop's index variable is live on entry 
to the inner loop;  its value persists across iterations of the outer loop.  
Simple "for" loops with an initialisation clause do not qualify, but "while"
and "goto" loops often do.

------------------------------------------------------------------------------
FIXED  SDSCM00010103
------------------------------------------------------------------------------

Summary            : interrupts are disabled and not restored back 

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Optimizer

Description: 
In certain cases, the c6x compiler disables interrupts before a
software-pipelined loop, and does not enable them after the loop. If
the block in which the MVC instruction is inserted to enable interrupts
contains an instructions that DEFs the CSR after the MVC instruction
without an intervening USE of the CSR, the MVC instruction is
considered dead and removed.

------------------------------------------------------------------------------
FIXED  SDSCM00010194
------------------------------------------------------------------------------

Summary            : Speculation of circular loads not kicking in

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Code Generator

Description: 
The C6x compiler will speculate circular loads under certain
conditions. This bug prevented the speculation of such loads.

------------------------------------------------------------------------------
FIXED  SDSCM00010352
------------------------------------------------------------------------------

Summary            : Optimization issue for loops using intrinsics that may be
		     related to loop unrolling

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : C/C++ Compiler

Description: 
A loop nest, with loop index variables i and j for the outer and inner
loops, respectively, and array reads like x[K-j] in the inner loop and 
writes like x[K-i] in the outer loop (where K is the same constant value) 
may improperly unroll though there is a bad dependence between inner and 
outer loops.  The problem is the negative factor on the two index variables.

------------------------------------------------------------------------------
FIXED  SDSCM00010458
------------------------------------------------------------------------------

Summary            : trampolines don't work with linker .cmd file function
		     aliases

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Linker

------------------------------------------------------------------------------
FIXED  SDSCM00010512
------------------------------------------------------------------------------

Summary            : Deeply derived template function causes SIGSEGV

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Code Generator

Description: 
Compiler segfaults when compiling a file with a very long mangled name
(greater than 32K chars in length)

------------------------------------------------------------------------------
FIXED  SDSCM00010518
------------------------------------------------------------------------------

Summary            : Parser error occurs in the initialization of a global
		     variable.

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Parser

Description: 
The parser can generate unexpected errors in the initialization of a
global variable when the initialization contains a '?' operator.

------------------------------------------------------------------------------
FIXED  SDSCM00010610
------------------------------------------------------------------------------

Summary            : Loop unrolling problem related to if statement incorrectly
		     being executed in loop

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Optimizer

Description: 
An IF whose predicate is of the form "A & k", where k is a literal
integer and A is an expression whose values range from 0 to k, may be 
improperly removed by the optimiser.  Note that "x & (k >> y)" may be 
converted into "(x << y) & k";  the internal form is more important 
than the original source.

------------------------------------------------------------------------------
FIXED  SDSCM00010815
------------------------------------------------------------------------------

Summary            : #pragma DATA_MEM_BANK does not align to correct memory
		     banks

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Parser

Description: 
For c67+ targets, using the DATA_MEM_BANK pragma does not align
variables to appropriate memory banks

------------------------------------------------------------------------------
FIXED  SDSCM00011035
------------------------------------------------------------------------------

Summary            : Bug in combining conditional code triggers incorrect
		     results

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Parser

------------------------------------------------------------------------------
FIXED  SDSCM00011094
------------------------------------------------------------------------------

Summary            : Internal error from parser for function redeclaration with
		     incompatible name linkage

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : Parser

Description: 
The compiler (parser) previously aborted on some error cases involving
the redeclaration of a function with internal linkage first declared with
extern "C" name linkage.  
 
------------------------------------------------------------------------------
FIXED  SDSCM00011132
------------------------------------------------------------------------------

Summary            : "internal error can't convert ins to IR" with assembly
		     optimzer using DINT/RINT instructions

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Assembly Optimizer

Description: 
DINT/RINT instructions in linear assembly produces error
"internal error can't convert ins to IR"

------------------------------------------------------------------------------
FIXED  SDSCM00011174
------------------------------------------------------------------------------

Summary            : setjmp/longjmp hangs with "-mv6400+ -o2 -ms2 -D_FAR_RTS"

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : C/C++ Compiler

Description: 
A program with far calls to setjmp can fail when compiled for Joule
(-mv6400+) with the  -ms2 option. This is now fixed.

------------------------------------------------------------------------------
FIXED  SDSCM00011275
------------------------------------------------------------------------------

Summary            : Linker throws an error when using -rtti option and
		     recursive template classes with virtual members.

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Linker

Description: 
Linker does not detect and handle RTTI typeinfo identifier symbols when
the mangled names of these symbols are compressed, resulting in an
undefined symbol error. This is now fixed.

------------------------------------------------------------------------------
FIXED  SDSCM00011731
------------------------------------------------------------------------------

Summary            : Near keyword ignored in class static variable when the
		     compiler is used with -ml3 or --mem_modeldata=far switch

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : C/C++ Compiler

Description: 
This is a parser bug with static data members of a C++ class.  If a
static data member has a near or far storage modifier, this modifier is
overrided when a memory model switch is used.  In other words, a near
static data member will end up with a far storage modifier if the
--mem_modeldata=far switch is used.  

------------------------------------------------------------------------------
FIXED  SDSCM00012006
------------------------------------------------------------------------------

Summary            : Packing attribute for interrupts_off incorrect for Joule

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Code Generator

------------------------------------------------------------------------------
FIXED  SDSCM00012205
------------------------------------------------------------------------------

Summary            : Array size of 64k causes INTERNAL ERROR in c++ source file

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : C/C++ Compiler

Description: 
The compiler will generate a constructor function for a C++ "static
scoped" (think global) object initialized with a floating point
expression, rather than a float constant (keep in mind that -0.0 is not
a constant).  If the object has too many initializers, the function
will get too big for the compiler to handle. 

------------------------------------------------------------------------------
FIXED  SDSCM00012208
------------------------------------------------------------------------------

Summary            : Compiler generated .switch sections are not candidates for
		     dead code removal in the linker.

Fixed in           : 6.1.0B1
Severity           : 1 Production Stop
Affected Component : Linker

Description: 
The compiler generates a .switch section which is now marked as a
candidate for link-time dead code removal.

In previous versions of the compiler, the .switch section was not
marked with an STYP_CLINK flag, so any function that was reachable 
from the switch section would always be included in the linker output 
file, whether the function was live in the application or not.

------------------------------------------------------------------------------
FIXED  SDSCM00012231
------------------------------------------------------------------------------

Summary            : lnk6x gives internal error when callee function symbol is
		     left undefined

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Linker

------------------------------------------------------------------------------
FIXED  SDSCM00012367
------------------------------------------------------------------------------

Summary            : Back to back sploops with interrupts can cause incorrect
		     operation on 64x+

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : C/C++ Compiler

Description: 
This bug occurs when the first sploop is interrupted and there are less
 than 2 execute packets between the SPKERNEL of the first sploop and
the  SPLOOP instruction of the second. The first sploop terminates
abruptly i.e. without completing the loop, even though the termination
condition is false. The failure mechanism can be seen as a hang or by
the first sploop draining for the interrupt and starting the second
sploop without taking the interrupt or returning to complete the first
sploop.

------------------------------------------------------------------------------
FIXED  SDSCM00012369
------------------------------------------------------------------------------

Summary            : 40-bit right shift with 32-bit source and destination can
		     produce incorrect results

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : C/C++ Compiler

------------------------------------------------------------------------------
FIXED  SDSCM00012545
------------------------------------------------------------------------------

Summary            : "warning missing DW_AT_name attribute" message generated
		     when using -mv6400+ switch

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : Code Generator

Description: 
For C64+ code, under certain circumstances  the compiler may not be
able to update DWARF debug information that has member functions
defined in the class declaration. 

------------------------------------------------------------------------------
FIXED  SDSCM00012581
------------------------------------------------------------------------------

Summary            : Allow user to specify duplicate labels in separate
		     .cproc/.endproc functions

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : Assembler

Description: 
If a linear assembly file contains more than one C callable procedure
(ie, uses the.cproc/.endproc directives) and duplicate label names are
used within different .cproc/.endproc directives, the assembler may not
generate an error indicating a duplicate label has been defined.

------------------------------------------------------------------------------
FIXED  SDSCM00012629
------------------------------------------------------------------------------

Summary            : Prolog/Epilog scheduler places DINT in || with 8 other
		     instructions, leading to a codegen crash on PC

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Code Generator

Description: 
Prolog/Epilog scheduling could potentially place DINT/RINT in parallel
with 8 other instructions, leading to an instruction with 9 parallel
instructions. This could lead to a code generator crash on Windows
platforms, and assembler errors on Unix platforms. Another
manifestation of this defect is to cause an RINT added during software
pipelining to be scheduled after a CALLP corresponding to a call
following the pipelined loop.  This is now fixed.

------------------------------------------------------------------------------
FIXED  SDSCM00012873
------------------------------------------------------------------------------

Summary            : type conversion in return dropped leading to incorrect
		     results

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Optimizer

Description: 
Return statements that mask an integral value to a size the same as a 
primitive type and narrower than the function's return type -- eg, 
"return x&0xffff" with return type int -- may lose the mask, especially
when compiling with -o2 or -o3.  (The mask will be converted to a cast 
inside the optimiser, and manipulations around the return statement may
erroneously drop the cast.)

------------------------------------------------------------------------------
FIXED  SDSCM00013069
------------------------------------------------------------------------------

Summary            : Using -ar to generate relocatable executables results in
		     relocation overflow linker error

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Linker

Description: 
The linker did not handle veneers or trampolines correctly in an
absolute relocatable executable.  These are generated with the -ar linker
switch.  This would occur when the executable is re-linked.  Relocation
information for trampolines or veneers would not be available in the relinking 
of the executable.

------------------------------------------------------------------------------
FIXED  SDSCM00013094
------------------------------------------------------------------------------

Summary            : Setting optimization level to -o2 and higher causes loop
		     variable to be incorrect

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : Optimizer

Description: 
A loop-based increment of a pointer variable may erroneously disappear
if there is an _nassert inside the loop whose asserted expression uses 
the pointer variable.

------------------------------------------------------------------------------
FIXED  SDSCM00013142
------------------------------------------------------------------------------

Summary            : asm6x crashes on simple testcase involving .map directives

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : Assembler

Description: 
The assembler tries to map an unknown operand, and not finding it
defined earlier crashes. Now the assembler will such a case and report
the problem, and error out gracefully.

------------------------------------------------------------------------------
FIXED  SDSCM00013175
------------------------------------------------------------------------------

Summary            : Optimizer crashes with C++ test case

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Optimizer

Description: 
Casting a pointer to int and back to pointer, which is undefined
behavior according to the language, may cause an optimiser abort.

------------------------------------------------------------------------------
FIXED  SDSCM00013338
------------------------------------------------------------------------------

Summary            : Modulo expression with negative values transformed
		     incorrectly

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Optimizer

Description: 
A particular combination of MOD and PLUS -- ((I+1)%10+5)%10 -- may be
simplified to (I%10+6)%10 even though that is incorrect when I+1 is
negative (because our % operator can return negative values when the
numerator is negative).

------------------------------------------------------------------------------
FIXED  SDSCM00013375
------------------------------------------------------------------------------

Summary            : Software pipelined loop followed by extra DINT instruction,
		     disabling interrupts

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Code Generator

Description: 
The defect introduced in v6.0.6 resulted in DINT/RINT instructions
being incorrectly categorized by the compiler. Consequently, a pass
that optimizes nested loops incorrectly decided that it could speculate
the DINT instruction, resulting in the extra DINT.

------------------------------------------------------------------------------
FIXED  SDSCM00013472
------------------------------------------------------------------------------

Summary            : cpy_tbl.h should guard against multiple inclusions and C++
		     name mangling

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Linker

------------------------------------------------------------------------------
FIXED  SDSCM00013528
------------------------------------------------------------------------------

Summary            : Optimizer generates U$DIV instead of I$DIV for division by
		     signed int

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Optimizer

Description: 
Optimizer generates U$DIV instead of I$DIV for division by structure
member when the access is a bitfield of size less than int and it is
typecast from unsigned int to signed int. 

------------------------------------------------------------------------------
FIXED  SDSCM00013588
------------------------------------------------------------------------------

Summary            : software pipelining illegally overlaps iterations with
		     inlined memcpy of overlapping objects

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : C/C++ Compiler

Description: 
This bug can occur when the compiler software pipelines a loop
containing a block copy (call to memcpy or struct copy).  If a single
call to memcpy accesses overlapping objects on different iterations of
the loop, the compiler can reorder the loads and stores illegally.

------------------------------------------------------------------------------
FIXED  SDSCM00013675
------------------------------------------------------------------------------

Summary            : swap2 pseudo op in machine description could cause too many
		     register reads of one register

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : Code Generator

------------------------------------------------------------------------------
FIXED  SDSCM00013751
------------------------------------------------------------------------------

Summary            : When compiling with -o3 stack deallocation happens before
		     stack access instruction, alllowing interrupt to corrupt 
		     stack

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Optimizer

Description: 
In some cases, the compiler can generate code that places the
deallocation of the frame before loading objects from the frame.  When
an interrupt occurs between these events, the interrupt function can
corrupt objects on the stack.  That bug has been fixed in stages.  This
facet can only occur when the function prolog and function epilog are
the same block.

------------------------------------------------------------------------------
FIXED  SDSCM00013798
------------------------------------------------------------------------------

Summary            : The use of.cdecls does not remove temporary files on PC

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Assembler

Description: 
In some use of .cdecls in assembly files the temporary files created by
the assembler are not removed.

------------------------------------------------------------------------------
FIXED  SDSCM00014001
------------------------------------------------------------------------------

Summary            : Optimizer terminates abnormally when -pm switch used

Fixed in           : 6.1.0B1
Severity           : 1 Production Stop
Affected Component : ILinker (File Merge)

Description: 
In program mode, the compiler can sometimes abnormally terminate when
faced with a typedef involving an incomplete type. 

------------------------------------------------------------------------------
FIXED  SDSCM00014006
------------------------------------------------------------------------------

Summary            : Compiler emits incorect Dwarf type name for C++ "string"
		     variables

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : C/C++ Compiler

------------------------------------------------------------------------------
FIXED  SDSCM00014045
------------------------------------------------------------------------------

Summary            : Optimizer allocating variable at offset on stack that does
		     not satisfy alignment requirements

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : C/C++ Compiler

Description: 
When arranging to share stack space among aggregate (array or struct)
objects that are defined in disjoint scopes, the optimiser may fail to 
properly align one that comes from an inner scope.  The problem arises when 
both outer and inner scopes define aggregates, a sub-object in an inner-scope 
aggregate requires 64-bit alignment, and the overall alignment of the 
outer-scope objects is only aligned to 32 bits.

------------------------------------------------------------------------------
FIXED  SDSCM00014049
------------------------------------------------------------------------------

Summary            : The unaligned memory intrinsics can give wrong results when
		     used in any op-assign statement.

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : C/C++ Compiler

Description: 
The use of the any unaligned memory intrinsic in any op-assign
statement can generate incorrect code.	Here is the list of op-assign
operators

+=, -=, *=, ++, --, /=, %=, &=, |=, ^=, <<=, >>=

The list of unaligned memory intrinsics

_mem2, _mem2_const, _mem4, _mem4_const, _mem8, _mem8_const, _memd8,
_memd8_const

The compiler will generate aligned memory access instructions for these
intrinsics in these types of statements.  If any intrinsic operand is
unaligned in these statements, the bug will cause an incorrect memory
access.  For example, in the following statement

_mem4(dst) += _mem4(src);

The compiler will generate LDW and STW instructions.   A wrong memory
access occurs if either operand is unaligned.

NOTE

The bug does not occur with the use of unaligned memory intrinsics in
assign statements.  For example

_mem4(dst) = _mem4(dst) + _mem4(src);

The compiler will generate unaligned memory access instructions for all
operands.

------------------------------------------------------------------------------
FIXED  SDSCM00014149
------------------------------------------------------------------------------

Summary            : Demangler formats DOS line endings incorrectly

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Demangler

------------------------------------------------------------------------------
FIXED  SDSCM00014225
------------------------------------------------------------------------------

Summary            : If-conversion incorrectly assumes optimal removal of
		     branches

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : C/C++ Compiler

------------------------------------------------------------------------------
FIXED  SDSCM00014228
------------------------------------------------------------------------------

Summary            : Enhancement request add block cycle count under -mw

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Code Generator

------------------------------------------------------------------------------
FIXED  SDSCM00014323
------------------------------------------------------------------------------

Summary            : fn_tmpnam doesn't check return value of tempnam

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Shell

Description: 
The compiler creates temporary files in the system temporary directory.
 If this directory has write permission disabled, the shell will crash
with an internal error.  This sort of crash can also occur if the
system is very low on memory.

------------------------------------------------------------------------------
FIXED  SDSCM00014340
------------------------------------------------------------------------------

Summary            : Inconsistent Dwarf representation of static variables that
		     are declared inside a function

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : C/C++ Compiler

------------------------------------------------------------------------------
FIXED  SDSCM00014467
------------------------------------------------------------------------------

Summary            : Joule Compiler prints out incorrect reason for software
		     pipelining failure.  

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Code Generator

------------------------------------------------------------------------------
FIXED  SDSCM00014525
------------------------------------------------------------------------------

Summary            : Precompiled headers do not work

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : C/C++ Compiler

------------------------------------------------------------------------------
FIXED  SDSCM00014589
------------------------------------------------------------------------------

Summary            : Compile errors when including Dinkumware typeinfo file

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : C/C++ Compiler

------------------------------------------------------------------------------
FIXED  SDSCM00014654
------------------------------------------------------------------------------

Summary            : Compiling code with nested structures with -o2 and higher
		     results in incorrect code.

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Optimizer

Description: 
Given a union containing an integer and a struct with bitfields,
accesses using the bitfields and using the covering integer may not be
recognised as touching the same data, which may lead to incorrect results.

------------------------------------------------------------------------------
FIXED  SDSCM00014662
------------------------------------------------------------------------------

Summary            : The -datawidth option should be deprecated.

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Hex Converter

Description: 
The -datawidth switch is deprecated and no longer listed.

------------------------------------------------------------------------------
FIXED  SDSCM00014798
------------------------------------------------------------------------------

Summary            : ofd markes linker-generated section as regular instead of
		     bss

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : OFD Utility

Description: 
Fixed tools to correctly interpret uninitialized c6x linker generated
sections as BSS sections.

------------------------------------------------------------------------------
FIXED  SDSCM00014877
------------------------------------------------------------------------------

Summary            : Advice in compiler generated .nfo file does not give file
		     name; important when used in combination with -pm

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : Optimizer

------------------------------------------------------------------------------
FIXED  SDSCM00014955
------------------------------------------------------------------------------

Summary            : Compressor sometimes does not update section symbol's
		     auxiliary entry containing the section size

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : Compressor

Description: 
The compiler was sometimes incorrectly setting the section length
located in the section symbol's auxiliary entry (in the symbol table). 
This situation occurs only when the source code is compiled for C6400+
(-mv6400+).  This use of this value is extremely uncommon, and no known
TI-produced C6400+ tools use this value.

------------------------------------------------------------------------------
FIXED  SDSCM00014959
------------------------------------------------------------------------------

Summary            : Compressor sometimes does not correctly update a label that
		     is after the last instruction in a section

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : Compressor

Description: 
The compiler was sometimes incorrectly setting the address in the
symbol table of a label that is located after the last instruction in a
section.  This situation is extremely uncommon and the situation is
never produced by the C/C++ compiler.  The situation only occurs if the
assembly language programmer places a label after the last instruction
in the associated section and the source code is compiled for C6400+
(-mv6400+).

------------------------------------------------------------------------------
FIXED  SDSCM00014993
------------------------------------------------------------------------------

Summary            : The _sshl intrinsic does not account for possible CSR side
		     effects.

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : C/C++ Compiler

Description: 
The saturate intrinsics do not account for a possible setting of the
saturate bit in the CSR register.  This can conflict with the use of
the CSR cregister as demonstrated in the test case.  Our current
analysis is that a fix could be difficult without hurting performance
in uses of saturate intrinsics that are not in conflict with a CSR
cregister.   We are evaluating different possible solutions but there
is unlikely a short-term fix at this point. 

In fact, any saturate intrinsic could be affected if preceded by a use
of the CSR register, or a use of the SSR register on 64+.  The list of
intrinsics that could be affected

For all C6000 devices
_sadd
_lsadd
_sat
_smpy
_smpyh
_smpyhl
_smpylh
_sshl
_ssub
_lssub

For C6400 devices
_sadd2
_saddus2
_smpy2
_smpy2ll
_spack2
_spacku4
_sshvl
_sshvr

For C6400+ devices
_cmpy
_cmpyr
_cmpyr1
_ddotph2
_ddotpl2
_ddotph2r
_ddotpl2r
_mpy2ir
_rpack2
_saddsub
_saddsub2
_smpy32
_ssub2

------------------------------------------------------------------------------
FIXED  SDSCM00015090
------------------------------------------------------------------------------

Summary            : The use of a right shift with a sign int type can produce
		     inconsistent results.

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : Optimizer

Description: 
The use of a right shift with a signed int type is 'implementation
defined' according to the C standard.  Inconsistent results are
possible since the optimizer will fill in the left bits with the signed
bit value.  With no optimization, the code generator will fill with 0. 
Both results are acceptable, however the toolset should be consistent
for both with and without optimization.  

------------------------------------------------------------------------------
FIXED  SDSCM00015103
------------------------------------------------------------------------------

Summary            : cg6x crash

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Code Generator

------------------------------------------------------------------------------
FIXED  SDSCM00015180
------------------------------------------------------------------------------

Summary            : Linker generates "bad long file name table" error

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Linker

Description: 
Library members with names longer than 16 characters are stored in a 
special "long filename" table.	When the total number of characters in 
member file names exceeds 100,000 characters, the linker will have 
problems processing the library.

------------------------------------------------------------------------------
FIXED  SDSCM00015292
------------------------------------------------------------------------------

Summary            : Compiler generates internal error 
                     'Bad kind TYPEtype_pointed_to ' when optimizer used

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Optimizer

Description: 
A call to strcpy() whose source argument is a string literal and whose 
destination argument is not a pointer can cause the optimiser to crash.
 
Normally one wouldn't pass a non-pointer to strcpy(), but in this case 
the argument was a call to strchr() and <string.h> wasn't included, 
causing strchr() to be interpreted as function-returning-int.  A
similar problem can occur with memmove() and a string-literal source argument.

------------------------------------------------------------------------------
FIXED  SDSCM00015302
------------------------------------------------------------------------------

Summary            : Incorrect resolution of relative branch across sections

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : Compressor

Description: 
The c6x compressor did not correctly resolve relative branches under
the following conditions - The branch and the destination are in different 
sections in the same file - The section containing the branch or the 
destination is not compressed (or)  both sections are not compressed.

------------------------------------------------------------------------------
FIXED  SDSCM00015423
------------------------------------------------------------------------------

Summary            : Stack pointer could be corrupted if interrupt occurs
		     between two instructions generated by compiler

Fixed in           : 6.1.0B1
Severity           : 1 Production Stop
Affected Component : C/C++ Compiler

Description: 
The function epilog generated by the C6x compiler is not interrupt safe
if the DATA_MEM_BANK pragma is applied to a local variable in the
function and the architecture targeted is one of 6400, 6400plus, 6700
or 6700plus. The compiler generates a pair of instructions to
deallocate the frame. E.g.
     ADDK	 4136,SP
     LDW	*SP,SP
If an interrupt occurs between these two instructions, and the
interrupt function modifies the stack, the value of SP loaded from *SP
has been corrupted. This is now fixed - the compiler generates a single
instruction to deallocate the frame. E.g.
     LDW       *+SP(4136),SP

------------------------------------------------------------------------------
FIXED  SDSCM00015435
------------------------------------------------------------------------------

Summary            : need func info reported directly from OFD executable

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : OFD Utility

------------------------------------------------------------------------------
FIXED  SDSCM00015804
------------------------------------------------------------------------------

Summary            : cl6x generates message "[E0300] Can't use relocation
		     expression here"

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : C/C++ Compiler

Description: 
When the assembler runs in absolute listing mode, we do not need to 
convert a "out of range" target to a relocation entry which is designed
for trampoline generation in linker. This avoids the error exit in the 
assembler.

The end result LST is OK as the "out of range" target in call or branch
remains as a global symbol.

------------------------------------------------------------------------------
FIXED  SDSCM00016064
------------------------------------------------------------------------------

Summary            : Compiler is generating an illegal instruction for the C672x
		     when optimization is turned on, Illegal mnemonic specified.

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : Code Generator

------------------------------------------------------------------------------
FIXED  SDSCM00016709
------------------------------------------------------------------------------

Summary            : C6000 assembler incorrectly produces error about MVC to ILC
		     being too close to SPLOOP

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : Assembler

------------------------------------------------------------------------------
FIXED  SDSCM00016922
------------------------------------------------------------------------------

Summary            : Having two function names foo and _foo that differ in their
		     name by the leading underscore crashes the optimizer

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Optimizer

Description: 
The artificial situation of having two functions whose names differ by 
only an initial underscore (ie, foo and _foo) in the same file may
cause the optimiser to crash.

------------------------------------------------------------------------------
FIXED  SDSCM00017027
------------------------------------------------------------------------------

Summary            : bad trampolines and failed relocations with partial link

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Linker

------------------------------------------------------------------------------
FIXED  SDSCM00017034
------------------------------------------------------------------------------

Summary            : codegen segmentation fault error when using -o3

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Code Generator

------------------------------------------------------------------------------
FIXED  SDSCM00017080
------------------------------------------------------------------------------

Summary            : Some static variables are not defined when optimization is
		     enabled

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Optimizer

Description: 
A non-static local aggregate variable whose initialisation contains the
address of a static local variable may cause a compilation failure.

------------------------------------------------------------------------------
FIXED  SDSCM00017105
------------------------------------------------------------------------------

Summary            : The SDSCM00014380 update can affect projects that use
		     unreferenced .const sections

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : C/C++ Compiler

Description: 
A change was made in the 3.3.5 compiler that generated const global 
arrays into .const subsections and these arrays are marked with a
.clink assembly directive.  This allows the linker to remove any unreference 
global arrays.	This behavior is default starting with the 3.3.5 
version.  To prevent these arrays from being placed in subsections and 
marked with a .clink directive, the following shell switch has been
added

--no_const_clink

and this is used as follows

cl6x --no_const_clink ...

------------------------------------------------------------------------------
FIXED  SDSCM00017106
------------------------------------------------------------------------------

Summary            : Bit shifting failing when optimization is enabled.

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Optimizer

Description: 
The optimiser will remove a cast under an AND operation when the other 
operand is a literal integer between 0 and 255 and the cast is from 
integer to integer.  That's okay when the cast quantity is int or 
narrower, because the cast is redundant, but is not correct when
casting to or from a wider type.

------------------------------------------------------------------------------
FIXED  SDSCM00017107
------------------------------------------------------------------------------

Summary            : Parser generates internal error when processing certain C++
		     files

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : C/C++ Compiler

------------------------------------------------------------------------------
FIXED  SDSCM00017400
------------------------------------------------------------------------------

Summary            : get --beginopts/--endopts to work with linear assembly

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Assembly Optimizer

Description: 
The function level options override mechanism for LINEAR assembly had 
stopped working. This happened because we updated the tools to use a 
slightly varying mechanism to embed option sets in the intermediate
file and updated the "C" files override mechanism to handle this. We failed
to do this for linear assembly files.

This update fixes this issue and sync's up the 2 mechanisms to use a 
single common interface so as to ensure they will never again be out of
sync.

------------------------------------------------------------------------------
FIXED  SDSCM00017426
------------------------------------------------------------------------------

Summary            : register assignment for if statement incorrect with
		     optimization enabled

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : C/C++ Compiler

Description: 
In programs compiled for C6x with multiple branches, if several
branches get converted to conditional instructions, a certain rare 
optimization can operate incorrectly, causing a predicate register to 
only be initialized on some paths.  This can happen with or without
optimization enabled.

------------------------------------------------------------------------------
FIXED  SDSCM00017469
------------------------------------------------------------------------------

Summary            : Missing cross-iteration dependence information Software
		     pipeliner generates wrong result

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Code Generator

Description: 
Loops containing code like "*o++ = *i;	*i = *i<<1;  ++n;  if 
(!(n%8))i++;", where i and o are pointers of the same type, may
pipeline incorrectly because a dependence is missed.  The key is the repeated
use of "n" in both increment and test;  the bug involves internal C$ temporary 
variables used for common sub-expressions.

------------------------------------------------------------------------------
FIXED  SDSCM00017573
------------------------------------------------------------------------------

Summary            : Codegen fails to detect C6400+ L1D bug which results in
		     ERROR remark in assembler

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : C/C++ Compiler

Description: 
L1D bug is was fixed before. This problem is caused by splitting long 
life time in software pipelining. Add an extra check right after this 
splitting to avoid new instances of L1D bug.

------------------------------------------------------------------------------
FIXED  SDSCM00017665
------------------------------------------------------------------------------

Summary            : Linker throws out user allocation/ordering in output
		     sections

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Linker

------------------------------------------------------------------------------
FIXED  SDSCM00017668
------------------------------------------------------------------------------

Summary            : The compiler generates a U-DIV library call instead of a
		     correct I-DIV call

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : C/C++ Compiler

Description: 
The code generator is changing an expression of the form (A * (B * C))
into ((A * B) * C).	In some cases, the codegen uses the type of (B * C) 
for the type of the new expression.  This can cause a bug if this
expression is part of a larger divide or shift-right expression.  It could 
result in the wrong DIV run-time library call being generated.

------------------------------------------------------------------------------
FIXED  SDSCM00017872
------------------------------------------------------------------------------

Summary            : A portion of "true" section of an IF statement is always
		     executed

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Code Generator

------------------------------------------------------------------------------
FIXED  SDSCM00017883
------------------------------------------------------------------------------

Summary            : optimizer causes precalculation error

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Optimizer

Description: 
The expression _sadd(x*k1,k2), where k1 and k2 are literal integers and
k2 is divisible by 65536 and k1 is not, will be simplified incorrectly
at optimisation levels -o1 and above.

------------------------------------------------------------------------------
FIXED  SDSCM00018059
------------------------------------------------------------------------------

Summary            : The c6x linker does not make use of the silicon version
		     flag (-mv) when determining object compatibility

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Linker

------------------------------------------------------------------------------
FIXED  SDSCM00018089
------------------------------------------------------------------------------

Summary            : Linker should collect unmentioned subsections under base
		     name output scn when linking with '-ar'

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Linker

------------------------------------------------------------------------------
FIXED  SDSCM00018392
------------------------------------------------------------------------------

Summary            : dis6x -o option crashes upon use

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : Disassembler

Description: 
Use of the -o switch with the C6000 disassembler, dis6x, causes the
tool to crash.

------------------------------------------------------------------------------
FIXED  SDSCM00018393
------------------------------------------------------------------------------

Summary            : ! operator applied to arguments being passed on the stack
		     corrupts other arguments

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : C/C++ Compiler

------------------------------------------------------------------------------
FIXED  SDSCM00018425
------------------------------------------------------------------------------

Summary            : Undefined symbol "const" error in cpp file using 6.1.0B1

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Assembler

------------------------------------------------------------------------------
FIXED  SDSCM00018504
------------------------------------------------------------------------------

Summary            : Disassembler does not extract symbolic information from
		     .out file when load and run address of section are 
		     different

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Disassembler

Description: 
Symbol names are now properly displayed by the disassembler when load
and runtime addresses differ.

------------------------------------------------------------------------------
FIXED  SDSCM00018544
------------------------------------------------------------------------------

Summary            : Turning on -o2 causes error " Reload must be initiated by
		     SPMASKR before outer loop branch has completed"

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Code Generator

------------------------------------------------------------------------------
FIXED  SDSCM00018593
------------------------------------------------------------------------------

Summary            : Incorrect generation of unsigned comparison for certain
		     integer comparisons

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : Code Generator

Description: 
The limits.h defines for UCHAR_MAX and USHRT_MAX incorrectly set these
as unsigned types.  The standard specifies that these should be signed
ints.

------------------------------------------------------------------------------
FIXED  SDSCM00018609
------------------------------------------------------------------------------

Summary            : Program generates incorrect output when optimizer used

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Optimizer

Description: 
A loop containing stores that might be SIMDed could optimise incorrectly 
when those accesses are within a conditional statement inside the loop.  

------------------------------------------------------------------------------
FIXED  SDSCM00018655
------------------------------------------------------------------------------

Summary            : Linker gets internal error (out of memory)  if user
		     specifies .debug_info output section in LCF

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Linker

------------------------------------------------------------------------------
FIXED  SDSCM00018760
------------------------------------------------------------------------------

Summary            : Static local variable of inline function should
		     be promoted to file level static instead of global

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Parser

------------------------------------------------------------------------------
FIXED  SDSCM00018861
------------------------------------------------------------------------------

Summary            : Optimizer generates incorrect code for -o3 

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : C/C++ Compiler

Description: 
The optimiser may incorrectly place a use of a variable ahead of its 
assignment if that variable is a parameter of an inlined function and
it is declared "const."  This problem is most likely to occur when the 
parameter is an integer, is used as an index into an array, and the use
occurs within a loop and is repeated.

------------------------------------------------------------------------------
FIXED  SDSCM00018915
------------------------------------------------------------------------------

Summary            : Compiler generates error when cmath and math.h are included
		     in same file

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : C/C++ Compiler

------------------------------------------------------------------------------
FIXED  SDSCM00019051
------------------------------------------------------------------------------

Summary            : MD5 module generates bad checksum

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Code Generator

Description: 
The compiler uses checksums for certain internal bookkeeping functions.
In some circumstances, the checksum would be computed incorrectly for 
long strings, such as might occur in deeply-nested pathnames.  It is 
possible, although astronomically unlikely, that this will cause lost 
opportunities for certain optimizations.  Released versions of the 
compiler use the checksum in only a very few places.

------------------------------------------------------------------------------
FIXED  SDSCM00019156
------------------------------------------------------------------------------

Summary            : optimizer swapping args to _pack2() at -o2

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Optimizer

Description: 
Statements like "x = _pack2(y, x)" which occur within a loop may be 
incorrectly rewritten to be "x = _pack2(x, y)".  The optimiser is 
recognising the assignment as a reduction, like "x = y + x", and
swapping the operands to make a canonical form.

The problem could affect any of the _pack* and _spack* intrinsics for 
C6000.	

------------------------------------------------------------------------------
FIXED  SDSCM00019162
------------------------------------------------------------------------------

Summary            : CG reports "BITVEC WARNING Index beyond size"

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Code Generator

------------------------------------------------------------------------------
FIXED  SDSCM00019258
------------------------------------------------------------------------------

Summary            : Diagnostic report prints garbage at the end of certain
		     messages

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Code Generator

Description: 
This bug manifests as garbage  printed at the end of an error or 
warning message, in cases where the last line of the printed message
has only one valid character

------------------------------------------------------------------------------
FIXED  SDSCM00019520
------------------------------------------------------------------------------

Summary            : C67p, file fails to assemble with the -mpic option

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Code Generator

------------------------------------------------------------------------------
FIXED  SDSCM00019554
------------------------------------------------------------------------------

Summary            : Compiler mishandles conditional execution of mark
		     instruction, resulting in incorrect code

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Code Generator

Description: 
Bug fix to the _mark intrinsic enhancement update.

------------------------------------------------------------------------------
FIXED  SDSCM00019700
------------------------------------------------------------------------------

Summary            : Buffer overflow after using setvbuf

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Runtime Support Libraries (RTS)

Description: 
Note that this modification changes the size of the buffer allocated by
a call to setvbuf(some_fp, NULL, some_mode, BUFSIZ).  Previously,
BUFSIZ bytes would be allocated by this call from the heap.  Now
BUFSIZ+4 bytes are allocated.  This is the method that printf() uses to
allocate a buffer for stdout if one does not already exist, and it is
likely that other standard I/O routines use it as well for stdout,
stderr, and stdin.  This may cause problems in codes that have tight
constraints on heap size.  Note that if the buffer allocation in
printf() fails, then nothing is printed to stdout - the call simply
fails.	If this is a problem, then these buffers can be allocated prior
to use with a call like setvbuf(stdout, NULL, _IOFBF, REQUIRED_SIZE).

------------------------------------------------------------------------------
FIXED  SDSCM00019729
------------------------------------------------------------------------------

Summary            : error in %g formatting for printf

Fixed in           : 6.1.0B1
Severity           : 3 Non-Critical
Affected Component : Runtime Support Libraries (RTS)

------------------------------------------------------------------------------
FIXED  SDSCM00019871
------------------------------------------------------------------------------

Summary            : Library header files cause parser error with -pdse 195
		     switch

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Runtime Support Libraries (RTS)

------------------------------------------------------------------------------
FIXED  SDSCM00019891
------------------------------------------------------------------------------

Summary            : Assembler generates internal error when assembling code
		     with optimizer

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Assembly Optimizer

Description: 
Compiler crashes trying to print a symbol which does not exist.

------------------------------------------------------------------------------
FIXED  SDSCM00019900
------------------------------------------------------------------------------

Summary            : Assembler may incorrectly emit error message, "Write to ILC
		     must precede SPLOOP instruction by at least 4 cycles"

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Assembler

Description: 
Under very rare circumstances, the assembler may incorrectly emit an
error message about a write to the ILC control register being too close to an
SPLOOP instruction.  As a result, the object file will not be created.

------------------------------------------------------------------------------
FIXED  SDSCM00019953
------------------------------------------------------------------------------

Summary            : _mpy32ll intrinsic can cause codegen no-match-for-COMMA
		     abort

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Optimizer

Description: 
Using the _mpy32ll intrinsic can cause a no-match-for-COMMA abort if
the operands, through inlining or other transformations, are no longer the 
expected signed-int type.

------------------------------------------------------------------------------
FIXED  SDSCM00020012
------------------------------------------------------------------------------

Summary            : atexit() calls malloc()

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : Runtime Support Libraries (RTS)

Description: 
The function atexit was changed to allow any arbitrary number of 
functions to be registered. However, that fix added the requirement 
that users allocate a heap when atexit was used. This could cause 
issues for small sized programs where the heap was never used.

This change fixes the issue by using a hybrid approach whereby we use a
statically allocated global datastructure until we need more than the 
minimum governed by the C standard. Thereafter, we switch to using the 
heap.

------------------------------------------------------------------------------
FIXED  SDSCM00020190
------------------------------------------------------------------------------

Summary            : Codegen internal error on C++ file

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : C/C++ Compiler

------------------------------------------------------------------------------
FIXED  SDSCM00020191
------------------------------------------------------------------------------

Summary            : The compiler is not generating expected results with
		     optimization

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : C/C++ Compiler

Description: 
The optimiser may deduce an incorrect result for a division when the 
types are unsigned, the numerator is a large known constant, and the 
denominator is unknown.  In attempting to estimate the division result
as ranging from numerator to -numerator, it'll end up believing the result
is the original numerator.  Depending on how that result is used within
the function, subsequent statements may be transformed incorrectly.

------------------------------------------------------------------------------
FIXED  SDSCM00020368
------------------------------------------------------------------------------

Summary            : Nightly Validation Plumhall fails random options

Fixed in           : 6.1.0B1
Severity           : 2 Critical
Affected Component : C/C++ Compiler

Description: 
An expression like "*(f()) += 2;", where f() has side effects, may be 
incorrectly expanded into "*(f()) = *(f()) + 2;" while attempting to 
vectorise a loop.  The likelihood is influenced by the amount of
inlining nearby;  if f() itself inlines, there is no problem.


------------------------------------------------------------------------------
18. Current Known Issues
------------------------------------------------------------------------------

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00001070
------------------------------------------------------------------------------

Summary            : "Compiler consultant leaves column blank for estimated
		     cycles per iteration".
Affected Component : Compiler Consultant

Description: 
"Compiler consultant leaves column blank for estimated cycles per
iteration".

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00002733
------------------------------------------------------------------------------

Summary            : Problem with bitfield debug info
Affected Component : C/C++ Compiler

Description: 
There is a problem with bitfields on the c6x. The debug info is
incorrect.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00004361
------------------------------------------------------------------------------

Summary            : Cryptic Himalaya error message in log when building large
		     project
Affected Component : Linker

Description: 
TCI6482 the output log says "1 Error" without specifying what the error
is. I have attached the output log file (assuming that you have all the
other files) , would you please let us know what exactly the error is,
so that we can proceed further.

error message from lnk6x when executed at the comand line

>>   error relocation overflow occurred at address 0x00000298 in
section
	    '.text' of input file
	    'C\\CCStudio_v3.2\\MyProjects\\44912\\Debug\\k2138.obj'. 
The
	    21-bit PC-relative displacement 1048576 at this location is
too
	    large to fit into the 21-bit PC-Relative field; the
destination
	    address is too far away from the instruction.
>>   error relocation overflow occurred at address 0x00000040 in
section
	    '.text' of input file
	    'C\\CCStudio_v3.2\\MyProjects\\44912\\Debug\\k2282.obj'. 
The
	    21-bit PC-relative displacement 1048576 at this location is
too
	    large to fit into the 21-bit PC-Relative field; the
destination
	    address is too far away from the instruction.

Don't know why trampolines are not generated, or do not work in this
case.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008210
------------------------------------------------------------------------------

Summary            : Unreferenced globals not being removed with --opt
		     recompilation switch.
Affected Component : Code Generator

Description: 

this one seems specific to alchemy; that is, i can't reproduce a 
similar failure using the compiler in the 'normal' way.  though the 
example is 64x based, the problem occurs on other ISA (e.g., 28x) as 
well.
 
the source file main.c annotates the declaration of an (unreferenced) 
const MAX as follows
 
#pragma DATA_SECTION(MAX, '.constMAX');
asm(' .sect \'.constMAX\'');
asm('  .clink');
const int MAX = 100;
 
int main()
{
    return 0;
}
 
when compiled in the normal fashion -- even without optimization 
enabled -- the linker effectively removes MAX from the final image.
 
when built using alchemy (see the makefile in the .tar file), MAX 
remains in the program.
 
looking at the generatied .asm file corresponding to <whole-program> 
(main.asm in the .tar file), you will see that the actual section in 
which MAX is placed is named somewhat differently....
 
   .global _MAX
   .sect '[0].constMAX'
   .align 4
_MAX
   .field   100,32   ; _MAX @ 0

if i actually use *this* section name in the original source file, the 
const MAX is removed from the image.
 
the problem, however, is the following	occassionally, the section 
name will be prefixed with a '[1]' instead.  since we are generating 
these declarations mechanically, we would like to 'know' the algorithm 
for assigning these names.  we have had similar issues placing .clink 
directives around functions implemented in assembler -- that is, we 
don't know the actual '[n]' prefix that is used by alchemy during 
optimization.  for functions, we've seen cases where 'n' is (say) 14!!!
 
given that we are generating many (unreferenced) extern consts, we 
depend heavily on this technique for reducing memory footprint in BIOS 
6.00.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008248
------------------------------------------------------------------------------

Summary            : Compilers on PC will not work without TMP set
Affected Component : C/C++ Compiler

Description: 
When compiling on the PC, the code generator cannot find the icode 
file produced by the parser if the environment variable TMP is no 
set.  If TMP is set, then all appears well.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008251
------------------------------------------------------------------------------

Summary            : Printf format '%#04x' fills zeros into wrong location
Affected Component : Code Generator

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008270
------------------------------------------------------------------------------

Summary            : hex6x -h is not complete
Affected Component : Hex Converter

Description: 
The information returned by  hex6x -h	is not complete and is not 
sufficient to understand how to use the tool.

#1    -order	    Specify data ordering (endianness)	The 
description should say that this needs to be followed by L or M (i.e. -
order L for little endian, -order M for big [which I''d never 
guess]).  

#2    The options from the .hlp file	-exclude <section_name>   
-byte do not get listed in the output of  hex6x -h 

#3   These options are listed in the output of hex6x but are not 
documented in the  CCS help file 

-bootorg<adr> Specify origin address or symbol of boot table ROM 
-@<file>      Read commands from ''file''  
-e<addr>      Specify entrypoint address or symbol name  
-linkerfill   Include linker fill sections in images 
--ti_txt      Output TI-TXT hex format	 

#4   -image	   Select image mode  What does the above mean?  All 
of these file types are images of one sort or another.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008275
------------------------------------------------------------------------------

Summary            : SPLOOP should not be generated with -mu -ms2/-ms3
		     (-mv6400+)
Affected Component : Code Generator

Description: 
SPLOOP should not be generated with -mu -ms2/-ms3

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008276
------------------------------------------------------------------------------

Summary            : Linker accepts illegal address ranges and truncates to a
		     valid address
Affected Component : Linker

Description: 
Linker accepts illegal address ranges and truncates to a valid address 
without any warnings.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008282
------------------------------------------------------------------------------

Summary            : The .sa file is not handling .if inside structure
		     definition correctly
Affected Component : Assembler

Description: 
The .sa(linear asembly) file is not handling the .if directive inside
a structure definition correctly.

struct_def.inc contains the definition of struct example_str as below
(Refer	struct_def.inc) 
example_str	.struct
elememt1     .word
element2     .word
 .if  0
element3     .word
 .endif
element4     .word

example_str_len    .endstruct

Note 

Here the element3 in the above struct should not be defined, as the .if

directive's condition is set to 0

This implies that the offset of element4 should be 1+1 = 2 words (i.e. 
8bytes)

This is handled properly in .asm

However, the .sa file is wrongly including element3 because of which 
the offset of element 4 will be 1+1+1 = 3 words (i.e. 12 bytes)

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008283
------------------------------------------------------------------------------

Summary            : Linear assembler does not recognise constant defined in .sa
		     file for .if
Affected Component : Assembly Optimizer

Description: 
Linear assembler does not recognise constants defined in .sa file 
for .if directives.

A label set inside a .sa file cannot be used as a condition for .if
LABEL is set to 1. LABEL is used as a condition to the .if directive.
The .if fails to recognise LABEL

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008336
------------------------------------------------------------------------------

Summary            : blank ln in SA file prevents software pipelining
Affected Component : Assembly Optimizer

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008380
------------------------------------------------------------------------------

Summary            : Linker corrupts DWARF information when c-linking partially
		     linked files
Affected Component : Linker

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008525
------------------------------------------------------------------------------

Summary            : Float literal conversion to integers incorrectly saturates
		     at 32 bits
Affected Component : Parser

Description: 
The parser floating-point folding routines always use native 'long' as 
the integer type to fold a float constant to.  For a constant like 
5e11, the constant will be folded to host LONG_MAX, or about 2e9, even though
5e11 is under C6x LONG_MAX.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008534
------------------------------------------------------------------------------

Summary            : Linker -xml_link_info option doesn't work when in a command
		     file
Affected Component : Linker

Description: 
The option --xml_link_info=file.xml does not work when it is
placed inside a linker command file.  

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008537
------------------------------------------------------------------------------

Summary            : assembler expression ~(0x80000000) evaulates as 0x80000000
Affected Component : Code Generator

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008541
------------------------------------------------------------------------------

Summary            : Assembly Parser Mapped regs not subject to same constraints
		     as mrs
Affected Component : Assembly Optimizer

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008543
------------------------------------------------------------------------------

Summary            : Forward reference in .space generates an internal error
Affected Component : Assembler

Description: 
If you attempt to assemble

 .space 0+a
b
a .set 1

the assembler will generate an internal error.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008545
------------------------------------------------------------------------------

Summary            : Using unsupported instr in lin asm file causes internal
		     compiler error
Affected Component : Assembly Optimizer

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008546
------------------------------------------------------------------------------

Summary            : .align 32 between branch and dest confuses prevention of ep
		     spanning fp
Affected Component : Assembler

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008553
------------------------------------------------------------------------------

Summary            : Hex6x -image emits 'overlaps unconfigured memory at 071ah'
		     and hangs
Affected Component : Hex Converter

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008556
------------------------------------------------------------------------------

Summary            : Trampolines not included in XML map file
Affected Component : Linker

Description: 
The XML map file does not include trampolines info, even when
the standard text map file does.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008592
------------------------------------------------------------------------------

Summary            : Data align pragma does not work correctly if constant value
		     is 0x10000
Affected Component : C/C++ Compiler

Description: 
Data alignment is not working properly if value of constant is passed
as 0x10000 (64k) . However it was observed that till 32k(0x8000) it 
works fine.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008632
------------------------------------------------------------------------------

Summary            : Consultant does not properly mark do-while loops
Affected Component : Compiler Consultant

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008670
------------------------------------------------------------------------------

Summary            : Optimizer assumes any floating pt value, also NaN ,is equal
		     to itself
Affected Component : Optimizer

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008680
------------------------------------------------------------------------------

Summary            : Dividing zero by zero results in INF rather than NaN
Affected Component : C/C++ Compiler

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008693
------------------------------------------------------------------------------

Summary            : C6x compiler may emit alias advice for cases where there
		     are no aliases
Affected Component : Optimizer

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00008702
------------------------------------------------------------------------------

Summary            : -o timeout option for load6x doesn't work if there are no
		     CIO functions.
Affected Component : Loader

Description: 
The timeout feature(-o xxx option) in load6x (TMS320C6x Standalone 
Simulator Version 4.20 and also 4.3)doesn't work if there are no CIO 
functions. 

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00013456
------------------------------------------------------------------------------

Summary            : fgets in _IONBF mode does not respect size limit
Affected Component : Runtime Support Libraries (RTS)

Description: 
The second argument to fgets() is the maximum number of chars to read. 
In _IONBF mode, fgets() reads until end-of-line, potentially
overrunning the input buffer.  

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00014408
------------------------------------------------------------------------------

Summary            : asm6x generates bogus EP alignment warning on labeled EP
		     that is only ref'd from debug directive
Affected Component : Assembler

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00014430
------------------------------------------------------------------------------

Summary            : calloc doesn't check arguments to make sure the requested
		     size is reasonable
Affected Component : Runtime Support Libraries (RTS)

Description: 
The function calloc() is required to return a pointer to memory
representing "nelem" copies of "size" bytes, or NULL if the request
cannot be satisfied.  However, for some values of "nelem" and "size"
(specifically when the result of nelem*size wraps around), calloc can
return a pointer to an object that is not large enough, rather than
NULL.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00017559
------------------------------------------------------------------------------

Summary            : instructions generate error on constant offset
Affected Component : Assembler

Description: 
The C6000  assembler reports an error on the below syntax
LDB	*A4++(A5),  A6
LDBU	*A4++(A5),  A6
STB	A6, *A5++(A4)

The error for each of these instructions is
"bug.asm", ERROR!   at line 2 [E0800] Nonscaled offset mode not
supported with
				       this instruction

Scaled and unscaled offset modes are identical for LDB, LDBU and STB,
because the scale factor is 1.	Therefore, this code
should be legal.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00018298
------------------------------------------------------------------------------

Summary            : Some 6700 unary double precision instructions encode
		     incorrectly
Affected Component : Assembler

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00019274
------------------------------------------------------------------------------

Summary            : Left shifting of a 64 bit bitfield produces incorrect
		     result
Affected Component : Parser

Description: 
When performing a left shift on a 64 bit bit field, the compiler
produces an incorrect result.  0x000E000000000000 << 11 produces 0 
instead of 0x7000000000000000.  

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00019894
------------------------------------------------------------------------------

Summary            : Map file doesn't print memory section if only one is
		     specified
Affected Component : Linker

Description: 
The linker map file is supposed to have a list of configured memory
sections at the top of the file.  When there is only one MEMORY
specified, the linker fails to print it.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00022829
------------------------------------------------------------------------------

Summary            : string functions in RTS contain undefined C code
Affected Component : Runtime Support Libraries (RTS)

Description: 
Many of the string functions for comparing, copying, etc adjust their
string pointer input parameters by subtracting one and then using
pre-decrement fetches to access the characters.  The pointer minus one
is not guaranteed to point to a legal entity (or one unit beyond) and
thus is left undefined by the C standard.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00023488
------------------------------------------------------------------------------

Summary            : Trampoline generation linker not generating appropriate
		     trampolines (or) emitting incorrect warning message
Affected Component : Linker

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00025088
------------------------------------------------------------------------------

Summary            : First symbol name in symbol table should be the file 
                     symbol
Affected Component : C/C++ Compiler (cl)

Description: 
If you compile a file two times, create an xml file using ofd6x, and
review the symbol table; you will find the first symbol to be a numeric
string which is different each time you compile the code.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00026226
------------------------------------------------------------------------------

Summary            : The shell should emit an error message when preprocessor
		     options are mistakenly combined
Affected Component : C/C++ Compiler (cl)

Description: 
The preprocessor options such as -ppd and -ppc may not be combined. 
Yet if you do combine them, the compiler shell does not emit an error
message.  Instead, one of the options is silently ignored.

Also, the documentation should clearly state these options may not be
combined.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00027782
------------------------------------------------------------------------------

Summary            : *l (long double) math functions in rts not declared
		     properly
Affected Component : Runtime Support Libraries (RTS)

Description: 
The roundl, truncl, exp2l, etc functions are declared with double
arguments and double return types instead of long double as is required
by the C standard.

This means a C++ source file cannot use these functions in function
pointers :

extern "C" long double (*fp1)(long double); // declare a function
pointer fp1
extern "C" double (*fp2)(double);
void foo()
{
    fp1 = roundl; // will get a compilation error.
    fp2 = roundl; // will work, but shouldn't!
}

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00028535
------------------------------------------------------------------------------

Summary            : Option '-h' on all newer compiler revisions does not
		     properly show the options help
Affected Component : C/C++ Compiler (cl)

Description: 
The option '-h' on the newer command line tools does not point to the
correct detailed description of the option if the option is listed without
the '-'.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00029070
------------------------------------------------------------------------------

Summary            : Debug information represents different template
		     instantiations with same class name
Affected Component : Linker

Description: 
Different instantiations of the the same template class with different
template parameters are all reported as having the same class name in
the DWARF debug information.  This prevents the debugger from
differentiating between the different class types by name alone.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00029142
------------------------------------------------------------------------------

Summary            : C6x 6.1.x windows build-time increase
Affected Component : C/C++ Compiler (cl)

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00029390
------------------------------------------------------------------------------

Summary            : pprof6x does not process input path names properly
Affected Component : Path Profiler (pprof)

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00030125
------------------------------------------------------------------------------

Summary            : Linker generates confusing error message and fails
Affected Component : C/C++ Compiler (cl)

Description: 
If a linker command file configures MEMORY for a particular address,
and then uses specific placement for an input SECTION at an address
that precedes the configured address, the following messages are issued

"lnk_specAddrMakesDefaultOverlaps.cmd", line 13 warning #10096-D
specified
   address lies outside memory map
error #10264 DEFAULT memory range overlaps existing memory range MEM
error #10010 errors encountered during linking; "z.out" not built

>> Compilation failure

The first warning indicates that the address used for specific
placement is not part of the MEMORY specified in the command file,
which is fine.	The new linker then attempts to create a DEFAULT
section to contain the input that was specifically placed.  This
DEFAULT section is created such that it begins at the address given for
specific placement and extends to the end of memory.  Since MEMORY
includes an output section that begins after the specific placement
address, the creation fails.  This causes the display of the message
involving the DEFAULT memory range, which the user knows nothing about.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00030127
------------------------------------------------------------------------------

Summary            : Code coverage information missing when using -pm option
Affected Component : C/C++ Compiler (cl)

Description: 
When using -pm program level mode optimization, functions are missing
from the .csv file. 

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00030579
------------------------------------------------------------------------------

Summary            : "Customized call" optimization .const entry and function
		     lack .clink directive
Affected Component : Code Generator

Description: 
The "customized call" optimization (call_stub) used for C64x+ when -ms3
is used fails to make the function table and call_stub conditionally
linkable using ".clink".  

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00030829
------------------------------------------------------------------------------

Summary            : lnk6x failed to allocate memory
Affected Component : Linker

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00030869
------------------------------------------------------------------------------

Summary            : ofd6x option --obj_display=sections fails to include
		     program segment table from ELF files
Affected Component : OFD Utility

Description: 
The following command does not result in the segment table, with the
XML tag "program_table" to appear in the XML output.

% ofd6x -x --obj_display=none,sections elf.out 

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00030911
------------------------------------------------------------------------------

Summary            : atan2sp / atan2dp in fastmath67x.h are incorrectly
		     documented
Affected Component : Runtime Support Libraries (RTS)

Description: 
In SPRU100 the atan2 function is shown correctly as atan2sp(y,x) 
but in the actual fastRTS header file (fastmath67x, sprc060) it is
shown as atan2sp(x,y). 

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00031335
------------------------------------------------------------------------------

Summary            : Compiler incorrectly schedules instructions in SPLOOP

Affected Component : C/C++ Compiler (cl)

Description: 
An inner loop with restricted pointers defined entirely within it may 
produce incorrect results, because "restrict" will be used to 
disambiguate the pointers in all cases, when it should only be used to 
disambiguate within a single iteration and not across iterations.

Note: SDSCM00031335 is not fixed in version 6.1.11.  This fix in
6.1.10 has been shown to negatively impact performance in some
cases.  

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00031459
------------------------------------------------------------------------------

Summary            : Application fails to link when using the -m option to 
		     directory that doesn't exist
Affected Component : COFF Linker

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00031800
------------------------------------------------------------------------------

Summary            : Code size increase from 6.0.20 to 6.1.9
		     
Affected Component : C/C++ Compiler (cl)

Workaround: Code size may improve in this specific case using the shell
switch:

--disable:31800

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00032055
------------------------------------------------------------------------------

Summary            : setvbuf does not affect the internal buffering done in
		     fwrite()
Affected Component : Runtime Support Libraries (RTS)

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00032176
------------------------------------------------------------------------------

Summary            : Linker command file does not allow expressions to contain
		     symbols assigned through address operators
Affected Component : COFF Linker

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00032304
------------------------------------------------------------------------------

Summary            : performance degradation in CGT 6.1.10 
Affected Component : Optimizer

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00032726
------------------------------------------------------------------------------

Summary            : CGT 6.1 cycle count is 10x worse than CGT 6.0
Affected Component : Optimizer

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00032755
------------------------------------------------------------------------------

Summary            : Optimize array initialization of C++ class objects with
		     empty user-defined constructors
Affected Component : C/C++ Compiler (cl)

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00032874
------------------------------------------------------------------------------

Summary            : 64x+ Compiler performance degradation (about 5x) from 6.0.8
		     to 6.1.10
Affected Component : C/C++ Compiler (cl)

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00032875
------------------------------------------------------------------------------

Summary            : 64x+ Compiler performance degradation (about 2x) from 6.0.8
		     to 6.1.10
Affected Component : C/C++ Compiler (cl)

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00032881
------------------------------------------------------------------------------

Summary            : 3x cycle degradation in FFT search code from 6.0.18 to
		     6.1.10
Affected Component : C/C++ Compiler (cl)

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00032987
------------------------------------------------------------------------------

Summary            : Performamce drop seen in 6.1.10 compared with 6.0.8 for a
		     two level nested loop
Affected Component : C/C++ Compiler (cl)

Description: 
We observed a performance drop for a two level nested loop. In 6.0.8,
II = 9, for the whole outer loop.  In 6.1.10, the outer loop ii=28.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00033072
------------------------------------------------------------------------------

Summary            : cycle count of -mv6740 often worse than -mv67p
Affected Component : C/C++ Compiler (cl)

Description: 
For the attached test case, compilation for C67x+ creates routine with
53 cycles, whereas as compilation of same code for C674x results in 85
cycles.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00033452
------------------------------------------------------------------------------

Summary            : Optimizer loses "alignedness" of _amem4 intrinsic
Affected Component : Optimizer

Description: 
The optimizer is losing the "alignedness" of an _amem4 intrinsic, by
combining it with a _mem4 intrinsic in order to produce a _memd8
intrinsic.  This is arguably illegal since _amem4 should have the
behavior of a STW/LDW, where the address is truncated if not aligned to
a 4 byte boundary.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00033753
------------------------------------------------------------------------------

Summary            : sprintf - when argument NULL is passed inserted'\0'
		     instead of empty string.
Affected Component : Runtime Support Libraries (RTS)

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00034154
------------------------------------------------------------------------------

Summary            : register allocation failure in sploop'd loop
Affected Component : C/C++ Compiler (cl)

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00034159
------------------------------------------------------------------------------

Summary            : Compiler intermittently emits garbage in Dwarf directive
Affected Component : C/C++ Compiler (cl)

Description: 
Sometimes the compiler emits garbage in a Dwarf directive.  That in
turn results in an assembler error.  

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00034268
------------------------------------------------------------------------------

Summary            : compiler generates wrong address when using STRUCT_ALIGN
		     pragma
Affected Component : C/C++ Compiler (cl)

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00034323
------------------------------------------------------------------------------

Summary            : Referring to CSR after the loop mysteriously causes a loop
		     carried dependency
Affected Component : C/C++ Compiler (cl)

Description: 
Referring to CSR after a loop causes it to have a loop carried
dependency.  If the CSR code is commented out, the loop has no loop
carried dependency, and the resulting code performs much better.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00034656
------------------------------------------------------------------------------

Summary            : A severe performance drop with a bit field structure access
		     in loop
Affected Component : C/C++ Compiler (cl)

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00034822
------------------------------------------------------------------------------

Summary            : Uncalled function with pragma CODE_SECTION will be
		     optimized out by TI CGTools 6.1.X even with pragma 
                     FUNC_EXT_CALLED.
Affected Component : Linker

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00034836
------------------------------------------------------------------------------

Summary            : Linker places initialized data section into an invalid LOAD
		     address when part of a GROUP with uninitialized data sections
Affected Component : Linker

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00035018
------------------------------------------------------------------------------

Summary            : Linker crash when using C++ template classes
Affected Component : Linker

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00035082
------------------------------------------------------------------------------

Summary            : Including math.h inside extern "C" gives errors
Affected Component : Runtime Support Libraries (RTS)

Description: 
math.h is responsible for defining some overloaded functions when in
C++ mode, but it should not do so when included under an extern "C"
specifier.  Overloaded functions are not allowed inside an extern "C"
specifier.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00035166
------------------------------------------------------------------------------

Summary            : Preprocessor output should preserve pragmas
Affected Component : C/C++ Compiler (cl)

Description: 
Preprocessed output should preserve the #pragma or _Pragma operators. 
Otherwise, they are lost, and the code cannot be re-compiled to achieve
the same effect as compiling the original source.


------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00035274
------------------------------------------------------------------------------

Summary            : Misaligned trampoline causes failure
Affected Component : ELF Linker

Description: 
Incorrect trampoline might be causing crash. 

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00035389
------------------------------------------------------------------------------

Summary            : Eliminate remarks when building RTS header files with
		     --issue_remarks (-pdr)
Affected Component : Runtime Support Libraries (RTS)

Description: 
When building code that includes math.h with -pdr, you get remarks
associated with lines in that file.  This probably happens with other
headers as well.  Pragmas can be used to disable these remarks.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00035422
------------------------------------------------------------------------------

Summary            : When building a relocatable executable, linker omits
		     relocation entries from the .debug_info section
Affected Component : COFF Linker

Description: 
When building a relocatable executable (-a -r) linker options, the
linker may omit some relocations from the .debug_info section. This can
inhibit debugging if the file is subsequently relocated.

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00035435
------------------------------------------------------------------------------

Summary            : Compiler generates incorrect code at -o2 optimization level
Affected Component : C/C++ Compiler (cl)

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00035478
------------------------------------------------------------------------------

Summary            : Need compiler workaround for SPLOOP's cross path stall
Affected Component : Code Generator

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00035479
------------------------------------------------------------------------------

Summary            : dis6x takes long time to invoking disassembly code
Affected Component : Disassembler (dis)

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00035503
------------------------------------------------------------------------------

Summary            : Optimizer - Loop is disqulaified "Disqualified loop Did not
		     find schedule"
Affected Component : Assembly Optimizer

------------------------------------------------------------------------------
KNOWN ISSUE  SDSCM00035528
------------------------------------------------------------------------------

Summary            : DWARF Call Frame information does not accurately reflect SP
		     manipulation
Affected Component : COFF Linker
