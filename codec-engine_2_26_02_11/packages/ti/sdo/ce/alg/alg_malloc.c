/* 
 * Copyright (c) 2010, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
/*
 *  ======== alg_malloc.c ========
 *  This module implements an algorithm memory management "policy" in which
 *  no memory is shared among algorithm objects.  Memory is, however
 *  reclaimed when objects are deleted.
 *
 *  preemption      sharing             object deletion
 *  ----------      -------             ---------------
 *  yes(*)          none                yes
 *
 *  Note 1: this module uses run-time support functions malloc() and free()
 *  to allocate and free memory.  Since these functions are *not* reentrant,
 *  either all object creation and deletion must be performed by a single
 *  thread or reentrant versions or these functions must be created.
 */

#include <xdc/std.h>

#include <ti/sdo/ce/osal/SemMP.h>

#include <ti/sdo/ce/osal/Memory.h>

#include <ti/xdais/ialg.h>

#include <stdlib.h>     /* malloc/free declarations */
#include <string.h>     /* memset declaration */

#ifdef __GNUC__
#include <malloc.h> /* memalign declaration is here for Linux */
#endif

#include "alg.h"
#include "_alg.h"
#include <ti/sdo/utils/trace/gt.h>

/*
 * Mask to enable GT tracing
 */
GT_Mask ti_sdo_ce_alg_GTMask;
#define CURTRACE ti_sdo_ce_alg_GTMask


/*
 *  Base ID for semaphores in this module. This is auto-generated by
 *  Settings.xdt.
 */
extern UInt32 ti_sdo_ce_alg_ipcKey;


static Int curInit = 0;     /* module init counter */

/*
 *  ======== ALG_releaseLock ========
 */
Void ALG_releaseLock(Int groupId, IALG_Handle alg)
{
    if ((0 <= groupId) && (groupId < _ALG_NUMGROUPS)) {
        GT_assert(CURTRACE, _ALG_sems[groupId] != NULL);
        SemMP_post(_ALG_sems[groupId]);
    }
}

/*
 *  ======== ALG_acquireLock ========
 */
Void ALG_acquireLock(Int groupId, IALG_Handle alg)
{
    /* acquire lock */
    /* TODO:M what if groupId is out of range?  At least drop some trace? */
    if ((0 <= groupId) && (groupId < _ALG_NUMGROUPS)) {
        GT_assert(CURTRACE, _ALG_sems[groupId] != NULL);
        SemMP_pend(_ALG_sems[groupId], SemMP_FOREVER);
    }
}

/*
 *  ======== ALG_activate ========
 */
Void ALG_activate(Int groupId, ALG_Handle alg)
{
    /* acquire lock */
    /* TODO:M what if groupId is out of range?  At least drop some trace? */
    if ((0 <= groupId) && (groupId < _ALG_NUMGROUPS)) {
        GT_assert(CURTRACE, _ALG_sems[groupId] != NULL);
        SemMP_pend(_ALG_sems[groupId], SemMP_FOREVER);
    }

    /* restore all persistant shared memory */
    /* nothing to do since memory allocation never shares any data */

    /* do app specific initialization of scratch memory */
    if (alg->fxns->algActivate != NULL) {
        alg->fxns->algActivate(alg);
    }
}

/*
 *  ======== ALG_addGroup ========
 */
Bool ALG_addGroup(Int groupId)
{
    Int     key;
    Bool    retVal = TRUE;

    GT_1trace(CURTRACE, GT_ENTER, "ALG_addGroup> Enter. groupId = %d\n",
            groupId);

    if ((groupId < 0) || (groupId >= _ALG_NUMGROUPS)) {
        GT_1trace(CURTRACE, GT_6CLASS, "ALG_addGroup> group %d out of range\n",
                groupId);
        return (FALSE);
    }

    if (_ALG_groupRefCount[groupId] == 0) {
        /* Create a semaphore for this groupId */
        key = (Int)ti_sdo_ce_alg_ipcKey + groupId;
         _ALG_sems[groupId] = SemMP_create(key, 1);

        if (_ALG_sems[groupId] == NULL) {
            GT_1trace(CURTRACE, GT_7CLASS, "ALG_addGroup> Failed to create "
                    "semaphore for groupId %d\n", groupId);
            retVal = FALSE;
        }
    }

    if (retVal) {
        _ALG_groupRefCount[groupId]++;
    }

    GT_1trace(CURTRACE, GT_ENTER, "ALG_addGroup> Exit. status = %d\n", retVal);

    return (retVal);
}


/*
 *  ======== ALG_deactivate ========
 */
Void ALG_deactivate(Int groupId, ALG_Handle alg)
{
    /* do app specific store of persistent data */
    if (alg->fxns->algDeactivate != NULL) {
        alg->fxns->algDeactivate(alg);
    }

    /* save all persistant shared memory */
    /* nothing to do since memory allocation never shares any data */

    /* release lock */
    /* TODO:M what if groupId is out of range?  At least drop some trace? */

    if ((0 <= groupId) && (groupId < _ALG_NUMGROUPS)) {
        GT_assert(CURTRACE, _ALG_sems[groupId] != NULL);
        SemMP_post(_ALG_sems[groupId]);
    }
}

/*
 *  ======== ALG_exit ========
 */
Void ALG_exit(Void)
{
    Int i;

    if (--curInit == 0) {
        /* De-initialize semaphores */
        for (i = 0; i < _ALG_NUMGROUPS; i++) {
            if (_ALG_sems[i]) {
                SemMP_delete(_ALG_sems[i]);
                _ALG_sems[i] = NULL;
            }
        }
    }
}

/*
 *  ======== ALG_init ========
 */
Void ALG_init(Void)
{
    Int i;

    if (curInit++ == 0) {
        GT_init();
        GT_create(&CURTRACE, ALG_GTNAME);
        GT_0trace(CURTRACE, GT_ENTER, "ALG_init> Enter\n");

        /* Initialize semaphores with count 1 */
        for (i = 0; i < _ALG_NUMGROUPS; i++) {
            if (_ALG_groupUsed[i]) {
                _ALG_sems[i] = SemMP_create((Int)ti_sdo_ce_alg_ipcKey + i, 1);
                _ALG_groupRefCount[i] = 1;
            }
            else {
                _ALG_sems[i] = NULL;
            }
        }

        /*
         *  Do not call Global_atexit() here. ALG_exit() will be called
         *  by Algorithm_exit(), which will have been registered with
         *  Global_atexit().
         */
    }
    else {
        GT_0trace(CURTRACE, GT_2CLASS, "ALG_init> Enter\n");
    }

    GT_0trace(CURTRACE, GT_ENTER, "ALG_init> Exit\n");
}


/*
 *  ======== ALG_removeGroup ========
 */
Void ALG_removeGroup(Int groupId)
{
    GT_1trace(CURTRACE, GT_ENTER, "ALG_removeGroup> Enter. groupId = %d\n",
            groupId);

    if ((groupId < 0) || (groupId >= _ALG_NUMGROUPS)) {
        GT_1trace(CURTRACE, GT_6CLASS,
                "ALG_removeGroup> groupId: %d out of range.\n", groupId);
        return;
    }

    if (--_ALG_groupRefCount[groupId] == 0) {
        /* Delete semaphore for this groupId */
        SemMP_delete(_ALG_sems[groupId]);
        _ALG_sems[groupId] = NULL;
    }

    GT_0trace(CURTRACE, GT_ENTER, "ALG_removeGroup> Exit.\n");
}


extern Bool ti_sdo_ce_alg_ALG_useCache;
extern Bool ti_sdo_ce_alg_ALG_useHeap;


/*
 *  ======== _ALG_allocMemory ========
 */
Bool _ALG_allocMemory(IALG_MemRec memTab[], Int n)
{
    GT_2trace(CURTRACE, GT_ENTER, "_ALG_allocMemory> memTab=0x%x, n=%d\n",
            memTab, n);

    return (_ALG_allocMemory2(memTab, n, ALG_USECACHEDMEM_DEFAULT));
}

/*
 *  ======== _ALG_allocMemory2 ========
 */
Bool _ALG_allocMemory2(IALG_MemRec memTab[], Int n, UInt32 useCachedMem)
{
    Int i;
    Memory_AllocParams params;

    GT_3trace(CURTRACE, GT_ENTER, "_ALG_allocMemory2> memTab=0x%x, "
            "n=%d, useCachedMem=%d\n", memTab, n, useCachedMem);

    params = Memory_DEFAULTPARAMS;
    params.type = ti_sdo_ce_alg_ALG_useHeap ? Memory_CONTIGHEAP :
                                                   Memory_CONTIGPOOL;
    switch (useCachedMem) {
        case ALG_USECACHEDMEM_DEFAULT:
            params.flags = ti_sdo_ce_alg_ALG_useCache ? Memory_CACHED :
                                                     Memory_NONCACHED;
            break;

        case ALG_USECACHEDMEM_CACHED:
            params.flags = Memory_CACHED;
            break;

        case ALG_USECACHEDMEM_NONCACHED:
            params.flags = Memory_NONCACHED;
            break;

        default:
            /* invalid useCachedMem, return failure */
            GT_1trace(CURTRACE, GT_7CLASS, "_ALG_allocMemory2> Invalid "
                    "useCachedMem flag (0x%x)\n", useCachedMem);
            return (FALSE);
    }

    for (i = 0; i < n; i++) {
        params.align = memTab[i].alignment;
        memTab[i].base = Memory_alloc(memTab[i].size, &params);

        if (memTab[i].base == NULL) {
            _ALG_freeMemory2(memTab, i, useCachedMem);
            return (FALSE);
        }
        memset(memTab[i].base, 0, memTab[i].size);
    }

    GT_0trace(CURTRACE, GT_ENTER, "_ALG_allocMemory2> Returning (TRUE)\n");
    return (TRUE);
}

/*
 *  ======== _ALG_freeMemory ========
 */
Void _ALG_freeMemory(IALG_MemRec memTab[], Int n)
{
    GT_2trace(CURTRACE, GT_ENTER, "_ALG_freeMemory> memTab=0x%x, n=%d\n",
            memTab, n);
    _ALG_freeMemory2(memTab, n, ALG_USECACHEDMEM_DEFAULT);
}

/*
 *  ======== _ALG_freeMemory2 ========
 */
Void _ALG_freeMemory2(IALG_MemRec memTab[], Int n, UInt32 useCachedMem)
{
    Int i;
    Memory_AllocParams params;

    GT_3trace(CURTRACE, GT_ENTER, "_ALG_freeMemory2> memTab=0x%x, n=%d, "
            "useCachedMem=%d\n", memTab, n, useCachedMem);

    params = Memory_DEFAULTPARAMS;
    params.type = ti_sdo_ce_alg_ALG_useHeap ? Memory_CONTIGHEAP :
        Memory_CONTIGPOOL;

    switch (useCachedMem) {
        case ALG_USECACHEDMEM_DEFAULT:
            params.flags = ti_sdo_ce_alg_ALG_useCache ? Memory_CACHED :
                                                     Memory_NONCACHED;
            break;

        case ALG_USECACHEDMEM_CACHED:
            params.flags = Memory_CACHED;
            break;

        case ALG_USECACHEDMEM_NONCACHED:
            params.flags = Memory_NONCACHED;
            break;

        default:
            /* invalid useCachedMem, return failure */
            GT_1trace(CURTRACE, GT_7CLASS, "_ALG_allocMemory> Invalid "
                    "useCachedMem flag (0x%x)\n", useCachedMem);
            /* return here rather than continue and try to do something bad. */
            return;
    }

    for (i = 0; i < n; i++) {
        if (memTab[i].base != NULL) {
            Memory_free(memTab[i].base, memTab[i].size, &params);
        }
    }
}
/*
 *  @(#) ti.sdo.ce.alg; 1, 0, 1,191; 12-2-2010 21:18:41; /db/atree/library/trees/ce/ce-r11x/src/ xlibrary

 */

